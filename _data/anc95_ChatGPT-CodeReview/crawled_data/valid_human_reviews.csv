PR_URL,Comment_URL,Comment_Author,Original_Commit_id,Commit_id,Diff_hunk,Diff_path,Created_At,Updated_At,Body,Start_Line,Original_Start_Line,Start_Side,Line,Original_Line,Side,Original_Position,Position,Subject_Type,Affiliated_PR_URL,Repository,Merge_Commit_SHA
https://api.github.com/repos/hyperskill/mobile-app/pulls/848,https://api.github.com/repos/hyperskill/mobile-app/pulls/comments/1448448987,ivan-magda,f48cbedc4744221df9d1396e44147a9eb6c274c9,061f88c51fa94cf047ba42f89aa1e3d8121ec6f2,"@@ -103,6 +103,7 @@ kotlin {
         }
 
         val iosMain by creating {
+            dependsOn(commonMain)",shared/build.gradle.kts,2024-01-11 08:03:06+00:00,2024-01-11T08:03:06Z,"Why `androidMain` not depends on `commonMain`? Or this syntax is optional? before everything works as expected.

![](https://resources.jetbrains.com/help/img/kotlin-multiplatform-dev/modules-structure.png)",,,,106.0,106,RIGHT,4,4.0,line,https://api.github.com/repos/hyperskill/mobile-app/pulls/848,hyperskill/mobile-app,8488ba50505c6648068a4ca751f8c271f9d1a79c
https://api.github.com/repos/hyperskill/mobile-app/pulls/887,https://api.github.com/repos/hyperskill/mobile-app/pulls/comments/1483823101,ivan-magda,bcfd6683150801d9890814fbfc3bd6393befcf36,b8dd66bb5a7bc4e026e724683b179a143f27c38b,"@@ -0,0 +1,23 @@
+package org.hyperskill.app.manage_subscription.domain.analytics",shared/src/commonMain/kotlin/org/hyperskill/app/manage_subscription/domain/analytics/ManageSubscriptionHyperskillAnalyticsEvent.kt,2024-02-09 03:21:05+00:00,2024-02-09T03:51:07Z,package name must be `**.analytic`,,,,,1,RIGHT,1,,line,https://api.github.com/repos/hyperskill/mobile-app/pulls/887,hyperskill/mobile-app,397d991ce542d66e302f68a0383eee3e9af59173
https://api.github.com/repos/hyperskill/mobile-app/pulls/887,https://api.github.com/repos/hyperskill/mobile-app/pulls/comments/1483823267,ivan-magda,bcfd6683150801d9890814fbfc3bd6393befcf36,b8dd66bb5a7bc4e026e724683b179a143f27c38b,"@@ -0,0 +1,23 @@
+package org.hyperskill.app.manage_subscription.domain.analytics
+
+import org.hyperskill.app.analytic.domain.model.hyperskill.HyperskillAnalyticAction
+import org.hyperskill.app.analytic.domain.model.hyperskill.HyperskillAnalyticEvent
+import org.hyperskill.app.analytic.domain.model.hyperskill.HyperskillAnalyticRoute
+
+/**
+ * Represents a view analytic event.
+ *
+ * JSON payload:
+ * ```
+ * {
+ *     ""route"": ""/profile/settings/manage-subscription"",
+ *     ""action"": ""view""
+ * }
+ * ```
+ *
+ * @see HyperskillAnalyticEvent
+ */
+object ManageSubscriptionHyperskillAnalyticsEvent : HyperskillAnalyticEvent(",shared/src/commonMain/kotlin/org/hyperskill/app/manage_subscription/domain/analytics/ManageSubscriptionHyperskillAnalyticsEvent.kt,2024-02-09 03:21:36+00:00,2024-02-09T03:51:07Z,"```suggestion
object ManageSubscriptionViewedHyperskillAnalyticEvent : HyperskillAnalyticEvent(
```",,,,,20,RIGHT,20,,line,https://api.github.com/repos/hyperskill/mobile-app/pulls/887,hyperskill/mobile-app,397d991ce542d66e302f68a0383eee3e9af59173
https://api.github.com/repos/hyperskill/mobile-app/pulls/887,https://api.github.com/repos/hyperskill/mobile-app/pulls/comments/1483823735,ivan-magda,bcfd6683150801d9890814fbfc3bd6393befcf36,b8dd66bb5a7bc4e026e724683b179a143f27c38b,"@@ -0,0 +1,23 @@
+package org.hyperskill.app.manage_subscription.injection
+
+import org.hyperskill.app.core.injection.AppGraph
+import org.hyperskill.app.manage_subscription.presentation.ManageSubscriptionFeature.Action
+import org.hyperskill.app.manage_subscription.presentation.ManageSubscriptionFeature.Message
+import org.hyperskill.app.manage_subscription.presentation.ManageSubscriptionFeature.ViewState
+import ru.nobird.app.presentation.redux.feature.Feature
+
+class ManageSubscriptionComponentImpl(",shared/src/commonMain/kotlin/org/hyperskill/app/manage_subscription/injection/ManageSubscriptionComponentImpl.kt,2024-02-09 03:23:07+00:00,2024-02-09T03:51:07Z,"```suggestion
internal class ManageSubscriptionComponentImpl(
```",,,,,9,RIGHT,9,,line,https://api.github.com/repos/hyperskill/mobile-app/pulls/887,hyperskill/mobile-app,397d991ce542d66e302f68a0383eee3e9af59173
https://api.github.com/repos/hyperskill/mobile-app/pulls/887,https://api.github.com/repos/hyperskill/mobile-app/pulls/comments/1483823815,ivan-magda,bcfd6683150801d9890814fbfc3bd6393befcf36,b8dd66bb5a7bc4e026e724683b179a143f27c38b,"@@ -0,0 +1,60 @@
+package org.hyperskill.app.manage_subscription.injection
+
+import co.touchlab.kermit.Logger
+import org.hyperskill.app.analytic.domain.interactor.AnalyticInteractor
+import org.hyperskill.app.core.domain.BuildVariant
+import org.hyperskill.app.core.presentation.ActionDispatcherOptions
+import org.hyperskill.app.core.presentation.transformState
+import org.hyperskill.app.core.view.mapper.ResourceProvider
+import org.hyperskill.app.core.view.mapper.date.SharedDateFormatter
+import org.hyperskill.app.logging.presentation.wrapWithLogger
+import org.hyperskill.app.manage_subscription.presentation.ManageSubscriptionActionDispatcher
+import org.hyperskill.app.manage_subscription.presentation.ManageSubscriptionFeature.Action
+import org.hyperskill.app.manage_subscription.presentation.ManageSubscriptionFeature.Message
+import org.hyperskill.app.manage_subscription.presentation.ManageSubscriptionFeature.State
+import org.hyperskill.app.manage_subscription.presentation.ManageSubscriptionFeature.ViewState
+import org.hyperskill.app.manage_subscription.presentation.ManageSubscriptionReducer
+import org.hyperskill.app.manage_subscription.view.mapper.ManageSubscriptionViewStateMapper
+import org.hyperskill.app.purchases.domain.interactor.PurchaseInteractor
+import org.hyperskill.app.sentry.domain.interactor.SentryInteractor
+import org.hyperskill.app.subscriptions.domain.repository.CurrentSubscriptionStateRepository
+import ru.nobird.app.presentation.redux.dispatcher.wrapWithActionDispatcher
+import ru.nobird.app.presentation.redux.feature.Feature
+import ru.nobird.app.presentation.redux.feature.ReduxFeature
+
+object ManageSubscriptionFeatureBuilder {",shared/src/commonMain/kotlin/org/hyperskill/app/manage_subscription/injection/ManageSubscriptionFeatureBuilder.kt,2024-02-09 03:23:21+00:00,2024-02-09T03:51:07Z,"```suggestion
internal object ManageSubscriptionFeatureBuilder {
```",,,,,25,RIGHT,25,,line,https://api.github.com/repos/hyperskill/mobile-app/pulls/887,hyperskill/mobile-app,397d991ce542d66e302f68a0383eee3e9af59173
https://api.github.com/repos/hyperskill/mobile-app/pulls/887,https://api.github.com/repos/hyperskill/mobile-app/pulls/comments/1483824644,ivan-magda,bcfd6683150801d9890814fbfc3bd6393befcf36,b8dd66bb5a7bc4e026e724683b179a143f27c38b,"@@ -0,0 +1,68 @@
+package org.hyperskill.app.manage_subscription.presentation
+
+import co.touchlab.kermit.Logger
+import kotlinx.coroutines.async
+import kotlinx.coroutines.coroutineScope
+import org.hyperskill.app.analytic.domain.interactor.AnalyticInteractor
+import org.hyperskill.app.core.presentation.ActionDispatcherOptions
+import org.hyperskill.app.manage_subscription.presentation.ManageSubscriptionFeature.Action
+import org.hyperskill.app.manage_subscription.presentation.ManageSubscriptionFeature.InternalAction
+import org.hyperskill.app.manage_subscription.presentation.ManageSubscriptionFeature.InternalMessage
+import org.hyperskill.app.manage_subscription.presentation.ManageSubscriptionFeature.Message
+import org.hyperskill.app.purchases.domain.interactor.PurchaseInteractor
+import org.hyperskill.app.sentry.domain.interactor.SentryInteractor
+import org.hyperskill.app.sentry.domain.model.transaction.HyperskillSentryTransactionBuilder
+import org.hyperskill.app.sentry.domain.withTransaction
+import org.hyperskill.app.subscriptions.domain.repository.CurrentSubscriptionStateRepository
+import ru.nobird.app.presentation.redux.dispatcher.CoroutineActionDispatcher
+
+class ManageSubscriptionActionDispatcher(",shared/src/commonMain/kotlin/org/hyperskill/app/manage_subscription/presentation/ManageSubscriptionActionDispatcher.kt,2024-02-09 03:25:31+00:00,2024-02-09T03:51:07Z,"```suggestion
internal class ManageSubscriptionActionDispatcher(
```",,,,,19,RIGHT,19,,line,https://api.github.com/repos/hyperskill/mobile-app/pulls/887,hyperskill/mobile-app,397d991ce542d66e302f68a0383eee3e9af59173
https://api.github.com/repos/hyperskill/mobile-app/pulls/887,https://api.github.com/repos/hyperskill/mobile-app/pulls/comments/1483824793,ivan-magda,bcfd6683150801d9890814fbfc3bd6393befcf36,b8dd66bb5a7bc4e026e724683b179a143f27c38b,"@@ -0,0 +1,62 @@
+package org.hyperskill.app.manage_subscription.presentation
+
+import org.hyperskill.app.analytic.domain.model.AnalyticEvent
+import org.hyperskill.app.subscriptions.domain.model.Subscription
+
+object ManageSubscriptionFeature {
+    sealed interface State {",shared/src/commonMain/kotlin/org/hyperskill/app/manage_subscription/presentation/ManageSubscriptionFeature.kt,2024-02-09 03:25:49+00:00,2024-02-09T03:51:07Z,Make state internal,,,,,7,RIGHT,7,,line,https://api.github.com/repos/hyperskill/mobile-app/pulls/887,hyperskill/mobile-app,397d991ce542d66e302f68a0383eee3e9af59173
https://api.github.com/repos/hyperskill/mobile-app/pulls/887,https://api.github.com/repos/hyperskill/mobile-app/pulls/comments/1483830900,ivan-magda,bcfd6683150801d9890814fbfc3bd6393befcf36,b8dd66bb5a7bc4e026e724683b179a143f27c38b,"@@ -0,0 +1,60 @@
+package org.hyperskill.app.manage_subscription.presentation
+
+import org.hyperskill.app.manage_subscription.domain.analytics.ManageSubscriptionHyperskillAnalyticsEvent
+import org.hyperskill.app.manage_subscription.presentation.ManageSubscriptionFeature.Action
+import org.hyperskill.app.manage_subscription.presentation.ManageSubscriptionFeature.InternalAction
+import org.hyperskill.app.manage_subscription.presentation.ManageSubscriptionFeature.InternalMessage
+import org.hyperskill.app.manage_subscription.presentation.ManageSubscriptionFeature.Message
+import org.hyperskill.app.manage_subscription.presentation.ManageSubscriptionFeature.State
+import ru.nobird.app.presentation.redux.reducer.StateReducer
+
+private typealias ReducerResult = Pair<State, Set<Action>>
+
+class ManageSubscriptionReducer : StateReducer<State, Message, Action> {
+    override fun reduce(state: State, message: Message): ReducerResult =
+        when (message) {
+            Message.Initialize -> handleInitialize(state)
+            Message.ViewedEventMessage -> handleViewedEventMessage(state)
+            is InternalMessage.FetchSubscriptionSuccess -> handleFetchSubscriptionSuccess(message)
+            InternalMessage.FetchSubscriptionError -> handleFetchSubscriptionError()
+            Message.RetryContentLoading -> fetchSubscription(forceLoadFromNetwork = true)
+            Message.ManageSubscriptionClicked -> handleManageSubscriptionClicked(state)
+        }
+
+    private fun handleInitialize(state: State): ReducerResult =
+        if (state is State.Idle) {
+            fetchSubscription(forceLoadFromNetwork = false)",shared/src/commonMain/kotlin/org/hyperskill/app/manage_subscription/presentation/ManageSubscriptionReducer.kt,2024-02-09 03:42:49+00:00,2024-02-09T03:51:07Z,"In my opinion it's better to fetch subscription remotely, otherwise user can see outdated data when screen presented. So I suggest to remove forceLoadFromNetwork flag and always load from remote data source.",,,,,26,RIGHT,26,,line,https://api.github.com/repos/hyperskill/mobile-app/pulls/887,hyperskill/mobile-app,397d991ce542d66e302f68a0383eee3e9af59173
https://api.github.com/repos/hyperskill/mobile-app/pulls/887,https://api.github.com/repos/hyperskill/mobile-app/pulls/comments/1483831223,ivan-magda,bcfd6683150801d9890814fbfc3bd6393befcf36,b8dd66bb5a7bc4e026e724683b179a143f27c38b,"@@ -0,0 +1,60 @@
+package org.hyperskill.app.manage_subscription.presentation
+
+import org.hyperskill.app.manage_subscription.domain.analytics.ManageSubscriptionHyperskillAnalyticsEvent
+import org.hyperskill.app.manage_subscription.presentation.ManageSubscriptionFeature.Action
+import org.hyperskill.app.manage_subscription.presentation.ManageSubscriptionFeature.InternalAction
+import org.hyperskill.app.manage_subscription.presentation.ManageSubscriptionFeature.InternalMessage
+import org.hyperskill.app.manage_subscription.presentation.ManageSubscriptionFeature.Message
+import org.hyperskill.app.manage_subscription.presentation.ManageSubscriptionFeature.State
+import ru.nobird.app.presentation.redux.reducer.StateReducer
+
+private typealias ReducerResult = Pair<State, Set<Action>>
+
+class ManageSubscriptionReducer : StateReducer<State, Message, Action> {
+    override fun reduce(state: State, message: Message): ReducerResult =
+        when (message) {
+            Message.Initialize -> handleInitialize(state)
+            Message.ViewedEventMessage -> handleViewedEventMessage(state)
+            is InternalMessage.FetchSubscriptionSuccess -> handleFetchSubscriptionSuccess(message)
+            InternalMessage.FetchSubscriptionError -> handleFetchSubscriptionError()
+            Message.RetryContentLoading -> fetchSubscription(forceLoadFromNetwork = true)
+            Message.ManageSubscriptionClicked -> handleManageSubscriptionClicked(state)
+        }
+
+    private fun handleInitialize(state: State): ReducerResult =
+        if (state is State.Idle) {
+            fetchSubscription(forceLoadFromNetwork = false)
+        } else {
+            state to emptySet()
+        }
+
+    private fun handleViewedEventMessage(state: State): ReducerResult =
+        state to setOf(
+            InternalAction.LogAnalyticsEvent(
+                ManageSubscriptionHyperskillAnalyticsEvent
+            )
+        )
+
+    private fun handleFetchSubscriptionSuccess(
+        message: InternalMessage.FetchSubscriptionSuccess
+    ): ReducerResult =
+        State.Content(
+            subscription = message.subscription,
+            manageSubscriptionUrl = message.manageSubscriptionUrl
+        ) to emptySet()
+
+    private fun handleFetchSubscriptionError(): ReducerResult =
+        State.Error to emptySet()
+
+    private fun fetchSubscription(forceLoadFromNetwork: Boolean): ReducerResult =
+        State.Loading to setOf(InternalAction.FetchSubscription(forceLoadFromNetwork))
+
+    private fun handleManageSubscriptionClicked(state: State): ReducerResult =
+        if (state is State.Content && state.manageSubscriptionUrl != null) {
+            state to setOf(
+                Action.ViewAction.OpenUrl(state.manageSubscriptionUrl)",shared/src/commonMain/kotlin/org/hyperskill/app/manage_subscription/presentation/ManageSubscriptionReducer.kt,2024-02-09 03:43:51+00:00,2024-02-09T03:51:07Z,Please log click event ,,,,57.0,55,RIGHT,55,57.0,line,https://api.github.com/repos/hyperskill/mobile-app/pulls/887,hyperskill/mobile-app,397d991ce542d66e302f68a0383eee3e9af59173
https://api.github.com/repos/hyperskill/mobile-app/pulls/887,https://api.github.com/repos/hyperskill/mobile-app/pulls/comments/1483833475,ivan-magda,bcfd6683150801d9890814fbfc3bd6393befcf36,b8dd66bb5a7bc4e026e724683b179a143f27c38b,"@@ -607,4 +607,16 @@
     <string name=""paywall_pending_purchase"">Paid functionality will become available after success payment</string>
     <string name=""paywall_subscription_sync_description"">The app is updating. Please wait a moment</string>
 
+    <!--Manage subscription-->
+    <string name=""manage_subscription_screen_title"">Subscription</string>
+    <string name=""manage_subscription_plan_title"">Your current plan:</string>
+    <string name=""manage_subscription_mobile_only"">Hyperskill Mobile only</string>",shared/src/commonMain/resources/MR/base/strings.xml,2024-02-09 03:49:59+00:00,2024-02-09T03:51:07Z,"I suppose we don't need to hardcode subscription display name, I'm sure that SDK must provide it.

_For example in Google Play / App Store we can update product name (subscription display name) and make new submission without app resubmit, so when user will buy subscription it will see different names in the app and in the system purchase UI._",,,,629.0,613,RIGHT,7,24.0,line,https://api.github.com/repos/hyperskill/mobile-app/pulls/887,hyperskill/mobile-app,397d991ce542d66e302f68a0383eee3e9af59173
https://api.github.com/repos/hyperskill/mobile-app/pulls/887,https://api.github.com/repos/hyperskill/mobile-app/pulls/comments/1484344891,ivan-magda,a2bdb278b72c40ed217d7d55f436cb10919bf49e,b8dd66bb5a7bc4e026e724683b179a143f27c38b,"@@ -0,0 +1,33 @@
+package org.hyperskill.app.manage_subscription.domain.analytic
+
+import org.hyperskill.app.analytic.domain.model.hyperskill.HyperskillAnalyticAction
+import org.hyperskill.app.analytic.domain.model.hyperskill.HyperskillAnalyticEvent
+import org.hyperskill.app.analytic.domain.model.hyperskill.HyperskillAnalyticPart
+import org.hyperskill.app.analytic.domain.model.hyperskill.HyperskillAnalyticRoute
+import org.hyperskill.app.analytic.domain.model.hyperskill.HyperskillAnalyticTarget
+
+/**
+ * Represents a click analytic event of the manage subscription button.
+ *
+ * JSON payload:
+ * ```
+ * {
+ *     ""route"": ""/profile/settings/manage-subscription"",
+ *     ""action"": ""click"",
+ *     ""part"": ""main"",
+ *     ""target"": ""manage_subscription"",
+ *     ""context"":
+ *     {
+ *       ""source"": ""login""
+ *     }",shared/src/commonMain/kotlin/org/hyperskill/app/manage_subscription/domain/analytic/ManageSubscriptionClickedManageHyperskillAnalyticEvent.kt,2024-02-09 13:51:28+00:00,2024-02-09T14:09:29Z,"I suppose this is a typo, event object does't provides context data.",,19.0,RIGHT,,22,RIGHT,22,,line,https://api.github.com/repos/hyperskill/mobile-app/pulls/887,hyperskill/mobile-app,397d991ce542d66e302f68a0383eee3e9af59173
https://api.github.com/repos/hyperskill/mobile-app/pulls/887,https://api.github.com/repos/hyperskill/mobile-app/pulls/comments/1484911238,ivan-magda,551d4c76bdf30930cc90fb602ef585a9288367de,b8dd66bb5a7bc4e026e724683b179a143f27c38b,"@@ -184,6 +185,8 @@ internal class PaywallReducer(
             PaywallTransitionSource.LOGIN ->
                 Action.ViewAction.CompletePaywall
             PaywallTransitionSource.PROFILE_SETTINGS ->
-                Action.ViewAction.NavigateTo.Profile
+                Action.ViewAction.NavigateTo.BackToSettings",shared/src/commonMain/kotlin/org/hyperskill/app/paywall/presentation/PaywallReducer.kt,2024-02-10 00:32:14+00:00,2024-02-10T00:33:08Z,"Maybe `BackToProfileSettings`, like `PaywallTransitionSource.PROFILE_SETTINGS`",,,,,188,RIGHT,15,,line,https://api.github.com/repos/hyperskill/mobile-app/pulls/887,hyperskill/mobile-app,397d991ce542d66e302f68a0383eee3e9af59173
https://api.github.com/repos/hyperskill/mobile-app/pulls/855,https://api.github.com/repos/hyperskill/mobile-app/pulls/comments/1470522136,ivan-magda,4e7a3192a6787325ea375d2f8fc92f20aa85d4a4,145026a562c29e7e8fafc1c9760a5c65290ce49a,"@@ -5,7 +5,6 @@
     <uses-permission android:name=""android.permission.FOREGROUND_SERVICE"" />
     <uses-permission android:name=""android.permission.RECEIVE_BOOT_COMPLETED"" />
     <uses-permission android:name=""android.permission.POST_NOTIFICATIONS"" />
-    <uses-permission android:name=""com.android.vending.BILLING"" />",androidHyperskillApp/src/main/AndroidManifest.xml,2024-01-30 02:40:01+00:00,2024-01-30T03:39:02Z,"Billing permission not required?

At the same time we have billing dependencies:

1. https://github.com/hyperskill/mobile-app/blob/d24d35cad99ec370ee09d31bb104ac9348ae8971/androidHyperskillApp/build.gradle.kts#L41
2. https://github.com/hyperskill/mobile-app/blob/d24d35cad99ec370ee09d31bb104ac9348ae8971/gradle/libs.versions.toml#L85",,,,8.0,8,LEFT,4,4.0,line,https://api.github.com/repos/hyperskill/mobile-app/pulls/855,hyperskill/mobile-app,ea91a66367dda4920700e7757a6546dc75423c74
https://api.github.com/repos/hyperskill/mobile-app/pulls/855,https://api.github.com/repos/hyperskill/mobile-app/pulls/comments/1470525159,ivan-magda,4e7a3192a6787325ea375d2f8fc92f20aa85d4a4,145026a562c29e7e8fafc1c9760a5c65290ce49a,"@@ -17,6 +17,7 @@ coil = '2.2.0'
 lottie = '6.1.0'
 kermit = '2.0.0-RC4'
 androidxBrowser = ""1.5.0""
+revenueCat = ""7.3.5""",gradle/libs.versions.toml,2024-01-30 02:45:21+00:00,2024-01-30T03:39:02Z,the latest release is [7.4.0](https://github.com/RevenueCat/purchases-android/releases/tag/7.4.0),,,,,20,RIGHT,4,,line,https://api.github.com/repos/hyperskill/mobile-app/pulls/855,hyperskill/mobile-app,ea91a66367dda4920700e7757a6546dc75423c74
https://api.github.com/repos/hyperskill/mobile-app/pulls/855,https://api.github.com/repos/hyperskill/mobile-app/pulls/comments/1470527743,ivan-magda,4e7a3192a6787325ea375d2f8fc92f20aa85d4a4,145026a562c29e7e8fafc1c9760a5c65290ce49a,"@@ -67,6 +71,14 @@ import org.hyperskill.app.welcome.injection.WelcomeComponent
 
 abstract class CommonAndroidAppGraphImpl : CommonAndroidAppGraph, BaseAppGraph() {
 
+    override fun buildPurchaseComponent(): PurchaseComponent =
+        PurchaseComponentImpl(
+            AndroidPurchaseManager(
+                application = application,
+                isDebugMode = BuildConfig.DEBUG",shared/src/androidMain/kotlin/org/hyperskill/app/core/injection/CommonAndroidAppGraphImpl.kt,2024-01-30 02:50:17+00:00,2024-01-30T03:39:02Z,`BuildConfig.DEBUG` returns `true` if current build type is debug otherwise `false`?,,,,78.0,78,RIGHT,25,25.0,line,https://api.github.com/repos/hyperskill/mobile-app/pulls/855,hyperskill/mobile-app,ea91a66367dda4920700e7757a6546dc75423c74
https://api.github.com/repos/hyperskill/mobile-app/pulls/855,https://api.github.com/repos/hyperskill/mobile-app/pulls/comments/1470532943,ivan-magda,4e7a3192a6787325ea375d2f8fc92f20aa85d4a4,145026a562c29e7e8fafc1c9760a5c65290ce49a,"@@ -0,0 +1,110 @@
+package org.hyperskill.app.purchases.domain
+
+import android.app.Activity
+import android.app.Application
+import com.revenuecat.purchases.LogLevel
+import com.revenuecat.purchases.PurchaseParams
+import com.revenuecat.purchases.Purchases
+import com.revenuecat.purchases.PurchasesConfiguration
+import com.revenuecat.purchases.PurchasesErrorCode
+import com.revenuecat.purchases.PurchasesException
+import com.revenuecat.purchases.PurchasesTransactionException
+import com.revenuecat.purchases.awaitCustomerInfo
+import com.revenuecat.purchases.awaitGetProducts
+import com.revenuecat.purchases.awaitLogIn
+import com.revenuecat.purchases.awaitLogOut
+import com.revenuecat.purchases.awaitPurchase
+import com.revenuecat.purchases.models.StoreProduct
+import org.hyperskill.app.BuildConfig
+import org.hyperskill.app.purchases.domain.model.AndroidPurchaseParams
+import org.hyperskill.app.purchases.domain.model.PlatformPurchaseParams
+import org.hyperskill.app.purchases.domain.model.PurchaseManager
+import org.hyperskill.app.purchases.domain.model.PurchaseResult
+
+class AndroidPurchaseManager(
+    private val application: Application,
+    private val isDebugMode: Boolean
+) : PurchaseManager {
+    override fun setup() {
+        if (!Purchases.isConfigured) {
+            Purchases.logLevel = if (isDebugMode) LogLevel.DEBUG else LogLevel.INFO",shared/src/androidMain/kotlin/org/hyperskill/app/purchases/domain/AndroidPurchaseManager.kt,2024-01-30 03:00:23+00:00,2024-01-30T03:39:02Z,"I agree that for debugging issues LogLevel.DEBUG in debug builds will be helpful, but I don't understand how we can use logs in release builds, where logs will be logged?

1. https://sdk.revenuecat.com/android/7.4.0/purchases/com.revenuecat.purchases/-purchases/-companion/log-level.html
2. https://sdk.revenuecat.com/android/7.4.0/purchases/com.revenuecat.purchases/-purchases/-companion/log-handler.html

_Debug logs will provide detailed log output in Xcode or LogCat for what is going on behind the scenes and should be the first thing you check if your app is behaving unexpectedly, and also to confirm there aren't any unhandled warnings or errors._",,,,29.0,30,RIGHT,30,29.0,line,https://api.github.com/repos/hyperskill/mobile-app/pulls/855,hyperskill/mobile-app,ea91a66367dda4920700e7757a6546dc75423c74
https://api.github.com/repos/hyperskill/mobile-app/pulls/855,https://api.github.com/repos/hyperskill/mobile-app/pulls/comments/1470544160,ivan-magda,4e7a3192a6787325ea375d2f8fc92f20aa85d4a4,145026a562c29e7e8fafc1c9760a5c65290ce49a,"@@ -0,0 +1,110 @@
+package org.hyperskill.app.purchases.domain
+
+import android.app.Activity
+import android.app.Application
+import com.revenuecat.purchases.LogLevel
+import com.revenuecat.purchases.PurchaseParams
+import com.revenuecat.purchases.Purchases
+import com.revenuecat.purchases.PurchasesConfiguration
+import com.revenuecat.purchases.PurchasesErrorCode
+import com.revenuecat.purchases.PurchasesException
+import com.revenuecat.purchases.PurchasesTransactionException
+import com.revenuecat.purchases.awaitCustomerInfo
+import com.revenuecat.purchases.awaitGetProducts
+import com.revenuecat.purchases.awaitLogIn
+import com.revenuecat.purchases.awaitLogOut
+import com.revenuecat.purchases.awaitPurchase
+import com.revenuecat.purchases.models.StoreProduct
+import org.hyperskill.app.BuildConfig
+import org.hyperskill.app.purchases.domain.model.AndroidPurchaseParams
+import org.hyperskill.app.purchases.domain.model.PlatformPurchaseParams
+import org.hyperskill.app.purchases.domain.model.PurchaseManager
+import org.hyperskill.app.purchases.domain.model.PurchaseResult
+
+class AndroidPurchaseManager(
+    private val application: Application,
+    private val isDebugMode: Boolean
+) : PurchaseManager {
+    override fun setup() {
+        if (!Purchases.isConfigured) {
+            Purchases.logLevel = if (isDebugMode) LogLevel.DEBUG else LogLevel.INFO
+            Purchases.configure(
+                PurchasesConfiguration.Builder(
+                    context = application,
+                    apiKey = BuildConfig.REVENUE_CAT_GOOGLE_API_KEY
+                ).build()
+            )
+        }
+    }
+
+    override suspend fun login(userId: Long): Result<Unit> =
+        kotlin.runCatching {
+            Purchases.sharedInstance.awaitLogIn(userId.toString())
+        }
+
+    override suspend fun logout(): Result<Unit> =
+        runCatching {
+            Purchases.sharedInstance.awaitLogOut()
+        }",shared/src/androidMain/kotlin/org/hyperskill/app/purchases/domain/AndroidPurchaseManager.kt,2024-01-30 03:23:21+00:00,2024-01-30T05:51:58Z,"JFYI according to the docs we will be using a combination of anonymous RevenueCat App User IDs and our own custom App User IDs:

1. https://www.revenuecat.com/docs/user-ids#how-to-only-use-custom-app-user-ids
2. https://www.revenuecat.com/docs/user-ids#login-method-alias-behavior",,40.0,RIGHT,,48,RIGHT,48,,line,https://api.github.com/repos/hyperskill/mobile-app/pulls/855,hyperskill/mobile-app,ea91a66367dda4920700e7757a6546dc75423c74
https://api.github.com/repos/hyperskill/mobile-app/pulls/855,https://api.github.com/repos/hyperskill/mobile-app/pulls/comments/1470549136,ivan-magda,4e7a3192a6787325ea375d2f8fc92f20aa85d4a4,145026a562c29e7e8fafc1c9760a5c65290ce49a,"@@ -0,0 +1,110 @@
+package org.hyperskill.app.purchases.domain
+
+import android.app.Activity
+import android.app.Application
+import com.revenuecat.purchases.LogLevel
+import com.revenuecat.purchases.PurchaseParams
+import com.revenuecat.purchases.Purchases
+import com.revenuecat.purchases.PurchasesConfiguration
+import com.revenuecat.purchases.PurchasesErrorCode
+import com.revenuecat.purchases.PurchasesException
+import com.revenuecat.purchases.PurchasesTransactionException
+import com.revenuecat.purchases.awaitCustomerInfo
+import com.revenuecat.purchases.awaitGetProducts
+import com.revenuecat.purchases.awaitLogIn
+import com.revenuecat.purchases.awaitLogOut
+import com.revenuecat.purchases.awaitPurchase
+import com.revenuecat.purchases.models.StoreProduct
+import org.hyperskill.app.BuildConfig
+import org.hyperskill.app.purchases.domain.model.AndroidPurchaseParams
+import org.hyperskill.app.purchases.domain.model.PlatformPurchaseParams
+import org.hyperskill.app.purchases.domain.model.PurchaseManager
+import org.hyperskill.app.purchases.domain.model.PurchaseResult
+
+class AndroidPurchaseManager(
+    private val application: Application,
+    private val isDebugMode: Boolean
+) : PurchaseManager {
+    override fun setup() {
+        if (!Purchases.isConfigured) {
+            Purchases.logLevel = if (isDebugMode) LogLevel.DEBUG else LogLevel.INFO
+            Purchases.configure(
+                PurchasesConfiguration.Builder(
+                    context = application,
+                    apiKey = BuildConfig.REVENUE_CAT_GOOGLE_API_KEY
+                ).build()
+            )
+        }
+    }
+
+    override suspend fun login(userId: Long): Result<Unit> =
+        kotlin.runCatching {
+            Purchases.sharedInstance.awaitLogIn(userId.toString())
+        }
+
+    override suspend fun logout(): Result<Unit> =
+        runCatching {
+            Purchases.sharedInstance.awaitLogOut()
+        }
+
+    override suspend fun purchase(
+        productId: String,
+        platformPurchaseParams: PlatformPurchaseParams
+    ): Result<PurchaseResult> =",shared/src/androidMain/kotlin/org/hyperskill/app/purchases/domain/AndroidPurchaseManager.kt,2024-01-30 03:32:27+00:00,2024-01-30T05:52:15Z,"`Result<PurchaseResult>` as for me this is strange design that we returns double wrapped return value - first result can be successful or not and the second result the same. Ideally, I would expect just `PurchaseResult`.",,,,47.0,53,RIGHT,53,47.0,line,https://api.github.com/repos/hyperskill/mobile-app/pulls/855,hyperskill/mobile-app,ea91a66367dda4920700e7757a6546dc75423c74
https://api.github.com/repos/hyperskill/mobile-app/pulls/855,https://api.github.com/repos/hyperskill/mobile-app/pulls/comments/1470550832,ivan-magda,4e7a3192a6787325ea375d2f8fc92f20aa85d4a4,145026a562c29e7e8fafc1c9760a5c65290ce49a,"@@ -0,0 +1,39 @@
+package org.hyperskill.app.purchases.domain.interactor
+
+import org.hyperskill.app.purchases.domain.model.PlatformPurchaseParams
+import org.hyperskill.app.purchases.domain.model.PurchaseManager
+import org.hyperskill.app.purchases.domain.model.PurchaseResult
+
+class PurchaseInteractor(
+    private val purchaseManager: PurchaseManager
+) {
+    companion object {
+        private const val MOBILE_ONLY_SUBSCRIPTION_PRODUCT_ID: String =
+            ""premium_mobile""
+    }
+    fun setup() {
+        purchaseManager.setup()
+    }",shared/src/commonMain/kotlin/org/hyperskill/app/purchases/domain/interactor/PurchaseInteractor.kt,2024-01-30 03:36:20+00:00,2024-01-30T03:39:02Z,"```suggestion
    companion object {
        private const val MOBILE_ONLY_SUBSCRIPTION_PRODUCT_ID: String = ""premium_mobile""
    }

    fun setup() {
        purchaseManager.setup()
    }
```",,10.0,RIGHT,,16,RIGHT,16,,line,https://api.github.com/repos/hyperskill/mobile-app/pulls/855,hyperskill/mobile-app,ea91a66367dda4920700e7757a6546dc75423c74
https://api.github.com/repos/hyperskill/mobile-app/pulls/854,https://api.github.com/repos/hyperskill/mobile-app/pulls/comments/1452973992,vladkash,cc8ff42836a4de8780ce001893cb2694cbff8fee,346bdf7ba9e1706611981433deae0a8762cd3606,"@@ -22,6 +22,8 @@ class FreemiumInteractor(
 
     suspend fun isProblemsLimitReached(): Result<Boolean> =",shared/src/commonMain/kotlin/org/hyperskill/app/freemium/domain/interactor/FreemiumInteractor.kt,2024-01-16 06:24:36+00:00,2024-01-16T06:29:47Z,I think that we can use `SubscriptionType.areProblemLimitsEnabled` here instead of check freemium subscription to hide details about what subscriptions have limits in `SubscriptionType`,,,,20.0,23,RIGHT,2,19.0,line,https://api.github.com/repos/hyperskill/mobile-app/pulls/854,hyperskill/mobile-app,5523a06937bb9d63cdbf97725357394d5440e762
https://api.github.com/repos/hyperskill/mobile-app/pulls/854,https://api.github.com/repos/hyperskill/mobile-app/pulls/comments/1452976483,vladkash,cc8ff42836a4de8780ce001893cb2694cbff8fee,346bdf7ba9e1706611981433deae0a8762cd3606,"@@ -4,15 +4,21 @@ import kotlinx.serialization.SerialName
 import kotlinx.serialization.Serializable
 
 @Serializable
-enum class SubscriptionType {
+enum class SubscriptionType(
+    val isProjectSelectionEnabled: Boolean = false,
+    val isProjectInfoAvailable: Boolean = true,",shared/src/commonMain/kotlin/org/hyperskill/app/subscriptions/domain/model/SubscriptionType.kt,2024-01-16 06:28:30+00:00,2024-01-16T06:29:47Z,Why do we have 2 flags for projects? In what real cases we have different values? I guess users can either have or not projects in app,8.0,8.0,RIGHT,9.0,9,RIGHT,7,7.0,line,https://api.github.com/repos/hyperskill/mobile-app/pulls/854,hyperskill/mobile-app,5523a06937bb9d63cdbf97725357394d5440e762
https://api.github.com/repos/hyperskill/mobile-app/pulls/854,https://api.github.com/repos/hyperskill/mobile-app/pulls/comments/1453350936,XanderZhu,346bdf7ba9e1706611981433deae0a8762cd3606,346bdf7ba9e1706611981433deae0a8762cd3606,"@@ -135,15 +134,12 @@ internal class TrackSelectionDetailsReducer : StateReducer<State, Message, Actio
         if (state.contentState !is ContentState.Content) {
             return false
         }
-        return when (state.contentState.subscriptionType) {
-            SubscriptionType.PREMIUM,
-            SubscriptionType.PERSONAL,
-            SubscriptionType.TRIAL -> {
-                val trackRelatedProjects =
-                    state.trackWithProgress.track.getAllProjects(state.contentState.profile.isBeta)
-                trackRelatedProjects.isNotEmpty()
-            }
-            else -> false",shared/src/commonMain/kotlin/org/hyperskill/app/track_selection/details/presentation/TrackSelectionDetailsReducer.kt,2024-01-16 12:20:30+00:00,2024-01-16T12:20:59Z,"@vladkash 
See this old condition for more details",138.0,138.0,LEFT,146.0,146,LEFT,19,19.0,line,https://api.github.com/repos/hyperskill/mobile-app/pulls/854,hyperskill/mobile-app,5523a06937bb9d63cdbf97725357394d5440e762
https://api.github.com/repos/hyperskill/mobile-app/pulls/889,https://api.github.com/repos/hyperskill/mobile-app/pulls/comments/1484357964,XanderZhu,b58f0366c7c5edfa7128566c6356a2618ae19d61,a669f226d403f4bd96d82eefefb8bb860c582095,"@@ -0,0 +1,45 @@
+package org.hyperskill.app.request_review.modal.presentation
+
+import org.hyperskill.app.analytic.domain.model.AnalyticEvent
+
+object RequestReviewModalFeature {
+    internal sealed interface State {
+        object Awaiting : State
+        object Negative : State
+        object Positive : State
+    }
+
+    data class ViewState(
+        val title: String,
+        val description: String?,
+        val positiveButtonText: String,
+        val negativeButtonText: String
+    )",shared/src/commonMain/kotlin/org/hyperskill/app/request_review/modal/presentation/RequestReviewModalFeature.kt,2024-02-09 14:00:41+00:00,2024-02-09T14:19:21Z,"Why do we need description, positiveButtonText and negativeButtonText in the viewState? These data are static, they are not changed. In my opinion, it is redundant and, we can just directly use string resources on the ui side.",12.0,12.0,RIGHT,17.0,17,RIGHT,17,17.0,line,https://api.github.com/repos/hyperskill/mobile-app/pulls/889,hyperskill/mobile-app,f9572f40e5aac64567cfeab05e50bf0eb63c6660
https://api.github.com/repos/hyperskill/mobile-app/pulls/886,https://api.github.com/repos/hyperskill/mobile-app/pulls/comments/1483848444,ivan-magda,9bfd200a95e2532dbd445f95cb3ebe3791caba60,1e77f3ee802b445eb7fbfbb90174b626f9b53799,"@@ -111,5 +111,5 @@ interface CommonAndroidAppGraph : AppGraph {
 
     fun buildPlatformPaywallComponent(paywallTransitionSource: PaywallTransitionSource): PlatformPaywallComponent
 
-    fun buildManageSubscriptionPlatformComponent(): PlatformManageSubscriptionComponent
+    fun buildManagePlatformSubscriptionComponent(): PlatformManageSubscriptionComponent",shared/src/androidMain/kotlin/org/hyperskill/app/core/injection/CommonAndroidAppGraph.kt,2024-02-09 04:30:54+00:00,2024-02-09T04:32:39Z,buildPlatformManageSubscriptionComponent,,,,,114,RIGHT,5,,line,https://api.github.com/repos/hyperskill/mobile-app/pulls/886,hyperskill/mobile-app,a2bdb278b72c40ed217d7d55f436cb10919bf49e
https://api.github.com/repos/hyperskill/mobile-app/pulls/886,https://api.github.com/repos/hyperskill/mobile-app/pulls/comments/1483849051,ivan-magda,9bfd200a95e2532dbd445f95cb3ebe3791caba60,1e77f3ee802b445eb7fbfbb90174b626f9b53799,"@@ -593,11 +593,13 @@
     <string name=""earned_badge_modal_title"">Wow! You\'ve reached level %d</string>
     <string name=""earned_badge_modal_description"">You\'ve earned the %s badge by reaching level %d! Amazing job!</string>
 
+    <!--Mobile-only-->
+    <string name=""mobile_only_option_1"">Access to all tracks</string>",shared/src/commonMain/resources/MR/base/strings.xml,2024-02-09 04:32:20+00:00,2024-02-09T09:05:58Z,`mobile_only_subscription_feature_1` and so on...,,,,,597,RIGHT,5,,line,https://api.github.com/repos/hyperskill/mobile-app/pulls/886,hyperskill/mobile-app,a2bdb278b72c40ed217d7d55f436cb10919bf49e
https://api.github.com/repos/hyperskill/mobile-app/pulls/868,https://api.github.com/repos/hyperskill/mobile-app/pulls/comments/1475464461,ivan-magda,dadb6663f914f099f0a56af607c05491e1fc925b,7ffd80ae722c1572148d666dc24a51e57975dd61,"@@ -111,6 +111,8 @@ enum class HyperskillAnalyticTarget(val targetName: String) {
     CONFIRM(""confirm""),
     GO_TO_FIRST_PROBLEM(""go_to_first_problem""),
     INTERVIEW_PREPARATION_COMPLETED_MODAL(""interview_preparation_completed_modal""),
+    ACTIVE_SUBSCRIPTION_DETAILS(""active_subscription_details""),
+    SUBSCRIPTION_SUGGESTION_DETAILS(""subscription_suggestion_details""),",shared/src/commonMain/kotlin/org/hyperskill/app/analytic/domain/model/hyperskill/HyperskillAnalyticTarget.kt,2024-02-02 03:02:12+00:00,2024-02-02T04:14:31Z,"`SUBSCRIPTION_SUGGESTION_DETAILS` what does it means, when mobile only subscription is not purchased and on click paywall screen will be presented?",114.0,114.0,RIGHT,115.0,115,RIGHT,5,5.0,line,https://api.github.com/repos/hyperskill/mobile-app/pulls/868,hyperskill/mobile-app,9d5d49008a7367014ad566cf1b307a2bc0d85e65
https://api.github.com/repos/hyperskill/mobile-app/pulls/868,https://api.github.com/repos/hyperskill/mobile-app/pulls/comments/1475465859,ivan-magda,dadb6663f914f099f0a56af607c05491e1fc925b,7ffd80ae722c1572148d666dc24a51e57975dd61,"@@ -0,0 +1,28 @@
+package org.hyperskill.app.profile_settings.domain.analytic.subscription
+
+import org.hyperskill.app.analytic.domain.model.hyperskill.HyperskillAnalyticAction
+import org.hyperskill.app.analytic.domain.model.hyperskill.HyperskillAnalyticEvent
+import org.hyperskill.app.analytic.domain.model.hyperskill.HyperskillAnalyticPart
+import org.hyperskill.app.analytic.domain.model.hyperskill.HyperskillAnalyticRoute
+import org.hyperskill.app.analytic.domain.model.hyperskill.HyperskillAnalyticTarget
+
+/**
+ * Represents click on the active subscription details.
+ *
+ * JSON payload:
+ * ```
+ * {
+ *     ""route"": ""/profile/settings"",
+ *     ""action"": ""click"",
+ *     ""part"": ""main"",
+ *     ""target"": ""active_subscription_details""
+ * }
+ * ```
+ * @see HyperskillAnalyticEvent
+ */
+object ActiveSubscriptionDetailsClickedHyperskillAnalyticEvent : HyperskillAnalyticEvent(",shared/src/commonMain/kotlin/org/hyperskill/app/profile_settings/domain/analytic/subscription/ActiveSubscriptionDetailsClickedHyperskillAnalyticEvent.kt,2024-02-02 03:04:06+00:00,2024-02-02T04:14:31Z,Instead of creating `ActiveSubscriptionDetailsClickedHyperskillAnalyticEvent` and `SubscriptionSuggestionDetailsClickedHyperskillAnalyticEvent` analytic events you can reuse `ProfileSettingsClickedHyperskillAnalyticEvent` with corresponding `target`,,,,,23,RIGHT,23,,line,https://api.github.com/repos/hyperskill/mobile-app/pulls/868,hyperskill/mobile-app,9d5d49008a7367014ad566cf1b307a2bc0d85e65
https://api.github.com/repos/hyperskill/mobile-app/pulls/868,https://api.github.com/repos/hyperskill/mobile-app/pulls/comments/1475471902,ivan-magda,dadb6663f914f099f0a56af607c05491e1fc925b,7ffd80ae722c1572148d666dc24a51e57975dd61,"@@ -149,5 +159,39 @@ class ProfileSettingsReducer : StateReducer<State, Message, Action> {
                     null
                 }
             }
+            is Message.SubscriptionDetailsClicked ->
+                handleSubscriptionDetailsClicked(state)
         } ?: (state to emptySet())
-}
\ No newline at end of file
+
+    private fun handleSubscriptionDetailsClicked(
+        state: State
+    ): ReducerResult =
+        state.updateContent { content ->
+            content to when (content.subscription?.type) {
+                SubscriptionType.MOBILE_ONLY ->
+                    setOf(
+                        Action.LogAnalyticEvent(
+                            ActiveSubscriptionDetailsClickedHyperskillAnalyticEvent
+                        ),
+                        Action.ViewAction.NavigateTo.SubscriptionManagement
+                    )
+                SubscriptionType.FREEMIUM ->
+                    setOf(
+                        Action.LogAnalyticEvent(
+                            SubscriptionSuggestionDetailsClickedHyperskillAnalyticEvent
+                        ),
+                        Action.ViewAction.NavigateTo.Paywall(
+                            PaywallTransitionSource.PROFILE_SETTINGS
+                        )
+                    )
+                else -> emptySet()
+            }
+        }
+}
+
+private fun State.updateContent(block: (content: State.Content) -> ReducerResult): ReducerResult =
+    if (this is State.Content) {
+        block(this)
+    } else {
+        this to emptySet()
+    }",shared/src/commonMain/kotlin/org/hyperskill/app/profile_settings/presentation/ProfileSettingsReducer.kt,2024-02-02 03:14:50+00:00,2024-02-02T04:14:31Z,"I don't see benefits of using this extension. In my opinion if statement looks more readable:
```kotlin
private fun handleSubscriptionDetailsClicked(
    state: State
): ReducerResult =
    if (state is State.Content) {
        state to when (state.subscription?.type) {
            SubscriptionType.MOBILE_ONLY ->
                setOf(
                    Action.LogAnalyticEvent(
                        ActiveSubscriptionDetailsClickedHyperskillAnalyticEvent
                    ),
                    Action.ViewAction.NavigateTo.SubscriptionManagement
                )
            SubscriptionType.FREEMIUM ->
                setOf(
                    Action.LogAnalyticEvent(
                        SubscriptionSuggestionDetailsClickedHyperskillAnalyticEvent
                    ),
                    Action.ViewAction.NavigateTo.Paywall(
                        PaywallTransitionSource.PROFILE_SETTINGS
                    )
                )
            else -> emptySet()
        }
    } else {
        state to emptySet()
    }
```",,192.0,RIGHT,,197,RIGHT,84,,line,https://api.github.com/repos/hyperskill/mobile-app/pulls/868,hyperskill/mobile-app,9d5d49008a7367014ad566cf1b307a2bc0d85e65
https://api.github.com/repos/hyperskill/mobile-app/pulls/868,https://api.github.com/repos/hyperskill/mobile-app/pulls/comments/1475474668,ivan-magda,dadb6663f914f099f0a56af607c05491e1fc925b,7ffd80ae722c1572148d666dc24a51e57975dd61,"@@ -26,14 +32,19 @@ class ProfileSettingsActionDispatcher(
     private val platform: Platform,
     private val userAgentInfo: UserAgentInfo,
     private val resourceProvider: ResourceProvider,
-    private val urlPathProcessor: UrlPathProcessor
+    private val urlPathProcessor: UrlPathProcessor,
+    private val currentSubscriptionStateRepository: CurrentSubscriptionStateRepository,
+    private val purchaseInteractor: PurchaseInteractor,
+    private val logger: Logger
 ) : CoroutineActionDispatcher<Action, Message>(config.createConfig()) {
+
+    private val arePurchasesAvailable: Boolean
+        get() = platform.platformType == PlatformType.ANDROID
+
     override suspend fun doSuspendableAction(action: Action) {
         when (action) {
-            is Action.FetchProfileSettings -> {
-                val profileSettings = profileSettingsInteractor.getProfileSettings()
-                onNewMessage(Message.ProfileSettingsSuccess(profileSettings))
-            }
+            is Action.FetchProfileSettings ->
+                handleFetchProfileSettings(arePurchasesAvailable, ::onNewMessage)",shared/src/commonMain/kotlin/org/hyperskill/app/profile_settings/presentation/ProfileSettingsActionDispatcher.kt,2024-02-02 03:20:04+00:00,2024-02-02T04:14:31Z,"Now we are loading some data remotely, so let's add a Sentry performance tracking transaction",,,,51.0,47,RIGHT,45,49.0,line,https://api.github.com/repos/hyperskill/mobile-app/pulls/868,hyperskill/mobile-app,9d5d49008a7367014ad566cf1b307a2bc0d85e65
https://api.github.com/repos/hyperskill/mobile-app/pulls/868,https://api.github.com/repos/hyperskill/mobile-app/pulls/comments/1475496215,ivan-magda,dadb6663f914f099f0a56af607c05491e1fc925b,7ffd80ae722c1572148d666dc24a51e57975dd61,"@@ -0,0 +1,46 @@
+package org.hyperskill.app.profile_settings.view
+
+import org.hyperskill.app.SharedResources
+import org.hyperskill.app.core.view.mapper.ResourceProvider
+import org.hyperskill.app.profile_settings.presentation.ProfileSettingsFeature
+import org.hyperskill.app.subscriptions.domain.model.SubscriptionType
+
+class ProfileSettingsViewStateMapper(
+    private val resourceProvider: ResourceProvider
+) {
+    fun map(state: ProfileSettingsFeature.State.Content): ProfileSettingsViewState =
+        ProfileSettingsViewState(
+            profileSettings = state.profileSettings,
+            isLoadingMagicLink = state.isLoadingMagicLink,
+            subscriptionState = if (isSubscriptionVisible(state)) {
+                when (state.subscription?.type) {
+                    SubscriptionType.MOBILE_ONLY ->
+                        ProfileSettingsViewState.SubscriptionState(
+                            resourceProvider.getString(SharedResources.strings.settings_subscription_mobile_only)
+                        )
+                    SubscriptionType.FREEMIUM -> {
+                        state.mobileOnlyFormattedPrice?.let {
+                            ProfileSettingsViewState.SubscriptionState(
+                                resourceProvider.getString(
+                                    SharedResources.strings.settings_subscription_mobile_only_suggestion,
+                                    state.mobileOnlyFormattedPrice
+                                )
+                            )
+                        }
+                    }
+                    else -> null
+                }
+            } else {
+                null
+            }
+        )
+
+    private fun isSubscriptionVisible(state: ProfileSettingsFeature.State.Content): Boolean =",shared/src/commonMain/kotlin/org/hyperskill/app/profile_settings/view/ProfileSettingsViewStateMapper.kt,2024-02-02 04:04:12+00:00,2024-02-02T04:14:31Z,As far as I understand currently we don't have subscription error state handling in the UI - on error subscription section won't be visible. I suggest to mention this to the design team and maybe we will improve this in the future updates.,,,,38.0,38,RIGHT,38,38.0,line,https://api.github.com/repos/hyperskill/mobile-app/pulls/868,hyperskill/mobile-app,9d5d49008a7367014ad566cf1b307a2bc0d85e65
https://api.github.com/repos/hyperskill/mobile-app/pulls/868,https://api.github.com/repos/hyperskill/mobile-app/pulls/comments/1475504437,ivan-magda,dadb6663f914f099f0a56af607c05491e1fc925b,7ffd80ae722c1572148d666dc24a51e57975dd61,"@@ -18,7 +20,9 @@ class PaywallViewStateMapper(
                     buyButtonText = resourceProvider.getString(
                         SharedResources.strings.paywall_mobile_only_buy_btn,
                         state.formattedPrice
-                    )
+                    ),
+                    isToolbarVisible = state.paywallTransitionSource != LOGIN,",shared/src/commonMain/kotlin/org/hyperskill/app/paywall/view/PaywallViewStateMapper.kt,2024-02-02 04:13:16+00:00,2024-02-02T04:22:09Z,"I think that this is strange that toolbar is only visible when `State.Content`, visibility should be configured on initial presentation or on any state.

For example when `State.Error` - on iOS navigation bar must be visible (with back button) so that user has ability to navigate back in the hierarchy.

JFYI: iOS will ignore `isToolbarVisible` property, because on iOS that means that should Paywall module be embedded in the navigation controller or not before presentation (before rendering).",,,,,24,RIGHT,15,,line,https://api.github.com/repos/hyperskill/mobile-app/pulls/868,hyperskill/mobile-app,9d5d49008a7367014ad566cf1b307a2bc0d85e65
https://api.github.com/repos/hyperskill/mobile-app/pulls/876,https://api.github.com/repos/hyperskill/mobile-app/pulls/comments/1479508676,ivan-magda,185dd3d9db08d86483226f910a08c622c0e96ef3,bf8c07c1cd74784f9f5a046c1cd99cbc3de4ed35,"@@ -181,4 +182,5 @@ interface AppGraph {
     fun buildInterviewPreparationWidgetComponent(): InterviewPreparationWidgetComponent
     fun buildInterviewPreparationOnboardingComponent(): InterviewPreparationOnboardingComponent
     fun buildPaywallComponent(paywallTransitionSource: PaywallTransitionSource): PaywallComponent
+    fun buildSubscripotionsDataComponent(): SubscripitonsDataComponent",shared/src/commonMain/kotlin/org/hyperskill/app/core/injection/AppGraph.kt,2024-02-06 10:00:22+00:00,2024-02-06T11:24:24Z,"Typo:
1. buildSubscriptionsDataComponent()
2. SubscriptionsDataComponent",,,,,185,RIGHT,12,,line,https://api.github.com/repos/hyperskill/mobile-app/pulls/876,hyperskill/mobile-app,28fdc9ac62da0bc97bfc77700b7a4eec61ae1737
https://api.github.com/repos/hyperskill/mobile-app/pulls/876,https://api.github.com/repos/hyperskill/mobile-app/pulls/comments/1479513180,ivan-magda,185dd3d9db08d86483226f910a08c622c0e96ef3,bf8c07c1cd74784f9f5a046c1cd99cbc3de4ed35,"@@ -0,0 +1,12 @@
+package org.hyperskill.app.subscriptions.data.repository
+
+import org.hyperskill.app.subscriptions.domain.model.Subscription
+import org.hyperskill.app.subscriptions.domain.repository.SubscriptionsRepository
+import org.hyperskill.app.subscriptions.remote.SubscriptionsRemoteDataSourceImpl
+
+class SubscriptionsRepositoryImpl(
+    private val subscriptionsRemoteDataSourceImpl: SubscriptionsRemoteDataSourceImpl",shared/src/commonMain/kotlin/org/hyperskill/app/subscriptions/data/repository/SubscriptionsRepositoryImpl.kt,2024-02-06 10:03:48+00:00,2024-02-06T11:24:24Z,Should be `subscriptionsRemoteDataSource: SubscriptionsRemoteDataSource`,,,,,8,RIGHT,8,,line,https://api.github.com/repos/hyperskill/mobile-app/pulls/876,hyperskill/mobile-app,28fdc9ac62da0bc97bfc77700b7a4eec61ae1737
https://api.github.com/repos/hyperskill/mobile-app/pulls/876,https://api.github.com/repos/hyperskill/mobile-app/pulls/comments/1479528524,ivan-magda,185dd3d9db08d86483226f910a08c622c0e96ef3,bf8c07c1cd74784f9f5a046c1cd99cbc3de4ed35,"@@ -1,32 +1,43 @@
 package org.hyperskill.app.paywall.presentation
 
+import dev.icerock.moko.resources.StringResource
+import org.hyperskill.app.SharedResources
 import org.hyperskill.app.analytic.domain.model.AnalyticEvent
+import org.hyperskill.app.purchases.domain.model.PlatformPurchaseParams
+import org.hyperskill.app.purchases.domain.model.PurchaseResult
+import org.hyperskill.app.subscriptions.domain.model.Subscription
+import org.hyperskill.app.subscriptions.domain.model.SubscriptionType
 
 object PaywallFeature {
 
     sealed interface State {",shared/src/commonMain/kotlin/org/hyperskill/app/paywall/presentation/PaywallFeature.kt,2024-02-06 10:15:48+00:00,2024-02-06T11:24:24Z,Make `State` internal,,,,,13,RIGHT,13,,line,https://api.github.com/repos/hyperskill/mobile-app/pulls/876,hyperskill/mobile-app,28fdc9ac62da0bc97bfc77700b7a4eec61ae1737
https://api.github.com/repos/hyperskill/mobile-app/pulls/876,https://api.github.com/repos/hyperskill/mobile-app/pulls/comments/1479556773,ivan-magda,185dd3d9db08d86483226f910a08c622c0e96ef3,bf8c07c1cd74784f9f5a046c1cd99cbc3de4ed35,"@@ -36,19 +46,67 @@ class PaywallActionDispatcher(
                     if (price != null) {
                         InternalMessage.FetchMobileOnlyPriceSuccess(price)
                     } else {
-                        logger.e {
-                            ""Receive null instead of formatter mobile-only subscription price""
-                        }
+                        logger.e { ""Receive null instead of formatted mobile-only subscription price"" }
                         InternalMessage.FetchMobileOnlyPriceError
                     }
                 },
                 onFailure = {
-                    logger.e(it) {
-                        ""Error during mobile-only subscription price fetching""
-                    }
+                    logger.e(it) { ""Error during mobile-only subscription price fetching"" }
                     InternalMessage.FetchMobileOnlyPriceError
                 }
             )
             .let(onNewMessage)
     }
+
+    private suspend fun handleStartMobileOnlySubscriptionPurchase(
+        action: InternalAction.StartMobileOnlySubscriptionPurchase,
+        onNewMessage: (Message) -> Unit
+    ) {
+        purchaseInteractor
+            .purchaseMobileOnlySubscription(action.purchaseParams)
+            .fold(
+                onSuccess = { purchaseResult ->
+                    if (purchaseResult is PurchaseResult.Error) {
+                        logger.e { getPurchaseErrorMessage(purchaseResult) }
+                    }
+                    InternalMessage.MobileOnlySubscriptionPurchaseSuccess(purchaseResult)
+                },
+                onFailure = {
+                    logger.e(it) { ""Subscription purchase failed!"" }
+                    InternalMessage.MobileOnlySubscriptionPurchaseError
+                }
+            )
+            .let(onNewMessage)
+    }
+
+    private fun getPurchaseErrorMessage(error: PurchaseResult.Error): String =
+        ""Subscription purchase failed!\n${error.message}\n${error.underlyingErrorMessage}""
+
+    private suspend fun handleSyncSubscription(
+        onNewMessage: (Message) -> Unit
+    ) {
+        subscriptionsRepository
+            .syncSubscription()
+            .fold(
+                onSuccess = InternalMessage::SubscriptionSyncSuccess,
+                onFailure = {
+                    logger.e(it) { ""Failed to sync subscription"" }
+                    InternalMessage.SubscriptionSyncError
+                }
+            )
+            .let(onNewMessage)
+    }
+
+    /*ktlint-disable*/",shared/src/commonMain/kotlin/org/hyperskill/app/paywall/presentation/PaywallActionDispatcher.kt,2024-02-06 10:37:29+00:00,2024-02-06T11:24:24Z,"I think yo can delete `/*ktlint-disable*/`, local execution `./gradlew ktlintCheck` passed successfully ",,,,,100,RIGHT,97,,line,https://api.github.com/repos/hyperskill/mobile-app/pulls/876,hyperskill/mobile-app,28fdc9ac62da0bc97bfc77700b7a4eec61ae1737
https://api.github.com/repos/hyperskill/mobile-app/pulls/852,https://api.github.com/repos/hyperskill/mobile-app/pulls/comments/1503531781,ivan-magda,c772da6c31bf357ae2eb5d123074278651ae6ad0,939610643f21f4215406a905d863c4aa06989712,"@@ -114,12 +114,16 @@ internal class HomeActionDispatcher(
                     .getOrThrow()
                 val problemOfDayStateResult = async { getProblemOfDayState(currentProfile.dailyStep) }
                 val repetitionsStateResult = async { getRepetitionsState() }
-                val isFreemiumEnabledResult = async { freemiumInteractor.isFreemiumEnabled() }
+                val areProblemsLimited = async {
+                    currentSubscriptionStateRepository
+                        .getState()
+                        .map { it.type.areHintsLimited }",shared/src/commonMain/kotlin/org/hyperskill/app/home/presentation/HomeActionDispatcher.kt,2024-02-27 01:50:55+00:00,2024-02-27T01:50:56Z,"```suggestion
                        .map { it.type.areProblemsLimited }
```",,,,,120,RIGHT,33,,line,https://api.github.com/repos/hyperskill/mobile-app/pulls/852,hyperskill/mobile-app,75552cf5c53d33f9525985b31bca2d845193d68e
https://api.github.com/repos/hyperskill/mobile-app/pulls/852,https://api.github.com/repos/hyperskill/mobile-app/pulls/comments/1505454970,ivan-magda,60267b435d9831d23f20f0330f3385829bfdd59b,939610643f21f4215406a905d863c4aa06989712,"@@ -50,75 +63,111 @@ internal class AppActionDispatcher(
                 onNewMessage(Message.UserDeauthorized(it.reason))
             }
             .launchIn(actionScope)
+
+        if (isSubscriptionPurchaseEnabled) {
+            currentSubscriptionStateRepository
+                .changes
+                .map { it.type }
+                .distinctUntilChanged()
+                .onEach { subscriptionType ->
+                    onNewMessage(AppFeature.InternalMessage.SubscriptionTypeChanged(subscriptionType))
+                }
+                .launchIn(actionScope)
+        }
     }
 
     override suspend fun doSuspendableAction(action: Action) {
         when (action) {
-            is Action.DetermineUserAccountStatus -> {
-                val isAuthorized = authInteractor.isAuthorized()
-                    .getOrDefault(false)
-
-                val transaction = HyperskillSentryTransactionBuilder.buildAppScreenRemoteDataLoading(isAuthorized)
-                sentryInteractor.startTransaction(transaction)
-
-                sentryInteractor.addBreadcrumb(HyperskillSentryBreadcrumbBuilder.buildAppDetermineUserAccountStatus())
-
-                // TODO: Move this logic to reducer
-                val profileResult: Result<Profile> = if (isAuthorized) {
-                    currentProfileStateRepository
-                        .getStateWithSource(forceUpdate = false)
-                        .fold(
-                            onSuccess = { (profile, usedDataSourceType) ->
-                                /**
-                                 * ALTAPPS-693:
-                                 * If cached user is new, we need to fetch profile from remote to check if track selected
-                                 */
-                                if (profile.isNewUser && usedDataSourceType == DataSourceType.CACHE) {
-                                    currentProfileStateRepository.getState(forceUpdate = true)
-                                } else {
-                                    Result.success(profile)
-                                }
-                            },
-                            onFailure = { currentProfileStateRepository.getState(forceUpdate = true) }
-                        )
-                } else {
-                    currentProfileStateRepository.getState(forceUpdate = true)
-                }
-
-                profileResult
-                    .fold(
-                        onSuccess = { profile ->
-                            sentryInteractor.addBreadcrumb(
-                                HyperskillSentryBreadcrumbBuilder.buildAppDetermineUserAccountStatusSuccess()
-                            )
-                            sentryInteractor.finishTransaction(transaction)
-                            onNewMessage(Message.UserAccountStatus(profile, action.pushNotificationData))
-                        },
-                        onFailure = { exception ->
-                            sentryInteractor.addBreadcrumb(
-                                HyperskillSentryBreadcrumbBuilder.buildAppDetermineUserAccountStatusError(exception)
-                            )
-                            sentryInteractor.finishTransaction(transaction, exception)
-                            onNewMessage(Message.UserAccountStatusError)
-                        }
-                    )
-            }
+            is Action.FetchAppStartupConfig ->
+                handleFetchAppStartupConfig(action, ::onNewMessage)
             is Action.IdentifyUserInSentry ->
                 sentryInteractor.setUsedId(action.userId)
             is Action.ClearUserInSentry ->
                 sentryInteractor.clearCurrentUser()
             is Action.UpdateDailyLearningNotificationTime ->
                 handleUpdateDailyLearningNotificationTime()
-            is Action.SendPushNotificationsToken -> {
+            is Action.SendPushNotificationsToken ->
                 pushNotificationsInteractor.renewFCMToken()
-            }
-            is Action.LogAppLaunchFirstTimeAnalyticEventIfNeeded -> {
+            is Action.IdentifyUserInPurchaseSdk ->
+                handleIdentifyUserInPurchaseSdk(action.userId)
+            is Action.LogAppLaunchFirstTimeAnalyticEventIfNeeded ->
                 appInteractor.logAppLaunchFirstTimeAnalyticEventIfNeeded()
-            }
+            is AppFeature.InternalAction.FetchSubscription ->
+                handleFetchSubscription(::onNewMessage)
             else -> {}
         }
     }
 
+    private suspend fun handleFetchAppStartupConfig(
+        action: Action.FetchAppStartupConfig,
+        onNewMessage: (Message) -> Unit
+    ) {
+        val isAuthorized = authInteractor.isAuthorized()
+            .getOrDefault(false)
+
+        sentryInteractor.withTransaction(
+            transaction = HyperskillSentryTransactionBuilder.buildAppScreenRemoteDataLoading(isAuthorized),
+            onError = { e ->
+                sentryInteractor.addBreadcrumb(
+                    HyperskillSentryBreadcrumbBuilder.buildAppDetermineUserAccountStatusError(e)
+                )
+                Message.FetchAppStartupConfigError
+            }
+        ) {
+            coroutineScope {
+                sentryInteractor.addBreadcrumb(HyperskillSentryBreadcrumbBuilder.buildAppDetermineUserAccountStatus())
+
+                val profileDeferred = async { fetchProfile(isAuthorized) }
+                val subscriptionDeferred = async { fetchSubscription(isAuthorized) }
+
+                sentryInteractor.addBreadcrumb(
+                    HyperskillSentryBreadcrumbBuilder.buildAppDetermineUserAccountStatusSuccess()
+                )",shared/src/commonMain/kotlin/org/hyperskill/app/main/presentation/AppActionDispatcher.kt,2024-02-28 07:08:17+00:00,2024-02-28T07:08:18Z,This breadcrumb should be added after we awaited `profileDeferred` and `subscriptionDeferred`,130.0,123.0,RIGHT,132.0,125,RIGHT,153,171.0,line,https://api.github.com/repos/hyperskill/mobile-app/pulls/852,hyperskill/mobile-app,75552cf5c53d33f9525985b31bca2d845193d68e
https://api.github.com/repos/hyperskill/mobile-app/pulls/852,https://api.github.com/repos/hyperskill/mobile-app/pulls/comments/1505488247,ivan-magda,8abd72fa5f7bf7746cb0bf46b0a4b4c505c53bed,939610643f21f4215406a905d863c4aa06989712,"@@ -84,15 +96,36 @@ internal class AppReducer(
                 state to reduceNotificationClickHandlingMessage(message.message)
             is Message.WelcomeOnboardingMessage ->
                 reduceWelcomeOnboardingMessage(state, message.message)
+            is InternalMessage.SubscriptionTypeChanged ->
+                handleSubscriptionTypeChanged(state, message)
         } ?: (state to emptySet())
 
-    private fun handleUserAccountStatus(
+    private fun handleFetchAppStartupConfigSuccess(
         state: State,
-        message: Message.UserAccountStatus
+        message: Message.FetchAppStartupConfigSuccess
     ): ReducerResult =
         if (state is State.Loading) {
             val isAuthorized = !message.profile.isGuest
 
+            val (streakRecoveryState, streakRecoveryActions) =
+                if (isAuthorized && message.notificationData == null) {
+                    reduceStreakRecoveryMessage(
+                        StreakRecoveryFeature.State(),
+                        StreakRecoveryFeature.Message.Initialize
+                    )
+                } else {
+                    StreakRecoveryFeature.State() to emptySet()
+                }
+
+            val readyState = State.Ready(
+                isAuthorized = isAuthorized,
+                isMobileLeaderboardsEnabled = message.profile.features.isMobileLeaderboardsEnabled,
+                streakRecoveryState = streakRecoveryState,
+                appShowsCount = 0,",shared/src/commonMain/kotlin/org/hyperskill/app/main/presentation/AppReducer.kt,2024-02-28 07:41:12+00:00,2024-02-28T07:41:12Z,"```suggestion
                appShowsCount = 0, // This is a hack to show paywall on the first app start
```",,,,,124,RIGHT,110,,line,https://api.github.com/repos/hyperskill/mobile-app/pulls/852,hyperskill/mobile-app,75552cf5c53d33f9525985b31bca2d845193d68e
https://api.github.com/repos/hyperskill/mobile-app/pulls/888,https://api.github.com/repos/hyperskill/mobile-app/pulls/comments/1483859108,ivan-magda,b45cae7067fb467277485d8111361e44ba29f83a,b9e1b4782cc2301026cf37ad33ecb0633d6f1690,"@@ -421,9 +421,11 @@
     <!--Topics widget-->
     <string name=""topics_widget_learn_next_badge"">Learn next</string>
 
-    <!--  Problems limit reached modal  -->
+    <!--Problems limit reached modal-->
     <string name=""problems_limit_reached_modal_title"">You\'ve reached your daily limit</string>
     <string name=""problems_limit_reached_modal_description"">You\'ve solved %d problems today. Great job! Tomorrow new problems will be available to you.</string>
+    <string name=""problems_limit_reached_modal_unlock_unlimited_problems_description"">You\'ve solved %d problems today. Great job! Unlock unlimited problems with Mobile only plan</string>",shared/src/commonMain/resources/MR/base/strings.xml,2024-02-09 04:56:19+00:00,2024-02-09T05:00:10Z,"```suggestion
    <string name=""problems_limit_reached_modal_unlock_unlimited_problems_description"">You\'ve solved %d problems today. Great job! Unlock unlimited problems with Mobile only plan.</string>
```",,,,,427,RIGHT,8,,line,https://api.github.com/repos/hyperskill/mobile-app/pulls/888,hyperskill/mobile-app,e8910814a28e62ea4e588eb466fdc3921ad02be5
https://api.github.com/repos/hyperskill/mobile-app/pulls/888,https://api.github.com/repos/hyperskill/mobile-app/pulls/comments/1483859776,ivan-magda,b45cae7067fb467277485d8111361e44ba29f83a,b9e1b4782cc2301026cf37ad33ecb0633d6f1690,"@@ -421,9 +421,11 @@
     <!--Topics widget-->
     <string name=""topics_widget_learn_next_badge"">Learn next</string>
 
-    <!--  Problems limit reached modal  -->
+    <!--Problems limit reached modal-->
     <string name=""problems_limit_reached_modal_title"">You\'ve reached your daily limit</string>
     <string name=""problems_limit_reached_modal_description"">You\'ve solved %d problems today. Great job! Tomorrow new problems will be available to you.</string>
+    <string name=""problems_limit_reached_modal_unlock_unlimited_problems_description"">You\'ve solved %d problems today. Great job! Unlock unlimited problems with Mobile only plan</string>
+    <string name=""problems_limit_reached_buy_subscription_button"">Unlock unlimited problems</string>",shared/src/commonMain/resources/MR/base/strings.xml,2024-02-09 04:57:44+00:00,2024-02-09T05:00:10Z,"```suggestion
    <string name=""problems_limit_reached_modal_buy_subscription_button"">Unlock unlimited problems</string>
```",,,,,428,RIGHT,9,,line,https://api.github.com/repos/hyperskill/mobile-app/pulls/888,hyperskill/mobile-app,e8910814a28e62ea4e588eb466fdc3921ad02be5
https://api.github.com/repos/hyperskill/mobile-app/pulls/859,https://api.github.com/repos/hyperskill/mobile-app/pulls/comments/1470583016,ivan-magda,d14452099b49e359da5994cd5e1ae32eb18ba82c,6dd6707cf7ac88eba3b0264bb9208e6f6bdae10e,"@@ -278,6 +278,9 @@ extension AppViewController: AppViewControllerProtocol {
                     }
 
                     return tabBarController
+                case .paywall:
+                    #warning(""TODO: ALTAPPS-1118"")",iosHyperskillApp/iosHyperskillApp/Sources/Modules/App/ViewControllers/AppViewController.swift,2024-01-30 04:41:49+00:00,2024-01-30T05:30:28Z,"```suggestion
                    #warning(""TODO: ALTAPPS-1116"")
```",,,,,282,RIGHT,5,,line,https://api.github.com/repos/hyperskill/mobile-app/pulls/859,hyperskill/mobile-app,1e406b9f9b8776bb7cdd39ac80d8cf05fd09d77f
https://api.github.com/repos/hyperskill/mobile-app/pulls/859,https://api.github.com/repos/hyperskill/mobile-app/pulls/comments/1470585276,ivan-magda,d14452099b49e359da5994cd5e1ae32eb18ba82c,6dd6707cf7ac88eba3b0264bb9208e6f6bdae10e,"@@ -158,7 +157,7 @@ internal class AppReducer(
             )
             val (onboardingState, onboardingActions) = reduceWelcomeOnboardingMessage(
                 WelcomeOnboardingFeature.State(),
-                WelcomeOnboardingFeature.InternalMessage.OnboardingFlowRequested(
+                WelcomeOnboardingFeature.Message.OnboardingFlowRequested(",shared/src/commonMain/kotlin/org/hyperskill/app/main/presentation/AppReducer.kt,2024-01-30 04:46:23+00:00,2024-01-30T05:30:28Z,What is the reason to make this message public visible?,,,,160.0,160,RIGHT,13,13.0,line,https://api.github.com/repos/hyperskill/mobile-app/pulls/859,hyperskill/mobile-app,1e406b9f9b8776bb7cdd39ac80d8cf05fd09d77f
https://api.github.com/repos/hyperskill/mobile-app/pulls/859,https://api.github.com/repos/hyperskill/mobile-app/pulls/comments/1470608910,ivan-magda,d14452099b49e359da5994cd5e1ae32eb18ba82c,6dd6707cf7ac88eba3b0264bb9208e6f6bdae10e,"@@ -255,15 +254,10 @@ internal class AppReducer(
         finishAction: WelcomeOnboardingFeature.Action.OnboardingFlowFinished
     ): Set<Action> =
         setOf(
-            when (val reason = finishAction.reason) {",shared/src/commonMain/kotlin/org/hyperskill/app/main/presentation/AppReducer.kt,2024-01-30 05:28:24+00:00,2024-01-30T05:30:28Z,"JFYI I understand that the code works as expected (like before), but in my opinion _finish reason_ previously simplified readability and understanding of the code",,,,258.0,258,LEFT,21,21.0,line,https://api.github.com/repos/hyperskill/mobile-app/pulls/859,hyperskill/mobile-app,1e406b9f9b8776bb7cdd39ac80d8cf05fd09d77f
https://api.github.com/repos/hyperskill/mobile-app/pulls/859,https://api.github.com/repos/hyperskill/mobile-app/pulls/comments/1472306946,ivan-magda,f2299291731f05b2bf2637c5c39a4d88655bd780,6dd6707cf7ac88eba3b0264bb9208e6f6bdae10e,"@@ -15,15 +16,26 @@ import org.hyperskill.app.analytic.domain.model.hyperskill.HyperskillAnalyticTar
  *     ""route"": ""/paywall"",
  *     ""action"": ""click"",
  *     ""part"": ""main"",
- *     ""target"": ""buy_subscription""
+ *     ""target"": ""buy_subscription"",
+ *     ""context"":
+ *     {
+ *       ""source"": ""login""
+ *     }
  * }
  * ```
  *
  * @see HyperskillAnalyticEvent
  */
-object PaywallClickedBuySubscriptionHyperskillAnalyticEvent : HyperskillAnalyticEvent(
+class PaywallClickedBuySubscriptionHyperskillAnalyticEvent(
+    private val paywallTransitionSource: PaywallTransitionSource
+) : HyperskillAnalyticEvent(
     HyperskillAnalyticRoute.Paywall,
     HyperskillAnalyticAction.CLICK,
     HyperskillAnalyticPart.MAIN,
     HyperskillAnalyticTarget.BUY_SUBSCRIPTION
-)
\ No newline at end of file
+) {
+    override val params: Map<String, Any>
+        get() = super.params + mapOf(
+            PaywallAnalyticKeys.PAYWALL_TRANSITION_SOURCE to paywallTransitionSource.analyticName
+        )",shared/src/commonMain/kotlin/org/hyperskill/app/paywall/domain/analytic/PaywallClickedBuySubscriptionHyperskillAnalyticEvent.kt,2024-01-31 05:00:46+00:00,2024-01-31T05:10:05Z,"To put value to the `context` you need to use a different syntax:
```kotlin
override val params: Map<String, Any>
    get() = super.params +
        mapOf(
            PARAM_CONTEXT to mapOf(
                PaywallAnalyticKeys.PAYWALL_TRANSITION_SOURCE to paywallTransitionSource.analyticName
            )
        )
```",,37.0,RIGHT,,40,RIGHT,37,,line,https://api.github.com/repos/hyperskill/mobile-app/pulls/859,hyperskill/mobile-app,1e406b9f9b8776bb7cdd39ac80d8cf05fd09d77f
https://api.github.com/repos/hyperskill/mobile-app/pulls/860,https://api.github.com/repos/hyperskill/mobile-app/pulls/comments/1470623243,ivan-magda,76b4d17f1851fb500a07521416dbeb4c18ca4444,8a511e7e454ed8e5314af746c2e8582a342ccece,"@@ -588,4 +588,13 @@
     <!-- Earned badge modal -->
     <string name=""earned_badge_modal_title"">Wow! You\'ve reached level %d</string>
     <string name=""earned_badge_modal_description"">You\'ve earned the %s badge by reaching level %d! Amazing job!</string>
+
+    <!--Paywall-->
+    <string name=""paywall_mobile_only_title"">Solve unlimited problems with Mobile only plan</string>
+    <string name=""paywall_mobile_only_option_1"">Access to all tracks</string>
+    <string name=""paywall_mobile_only_option_2"">Unlimited problems per day in the app</string>
+    <string name=""paywall_mobile_only_option_3"">1 hint per problem</string>
+    <string name=""paywall_mobile_only_buy_btn"">Subscribe for $12.00/month</string>",shared/src/commonMain/resources/MR/base/strings.xml,2024-01-30 05:50:29+00:00,2024-01-30T05:50:37Z,Please see [question](https://vyahhi.myjetbrains.com/youtrack/issue/ALTAPPS-1115/Shared-Android-Implement-a-Paywall-screen-after-sign-in-sign-up#focus=Comments-74-278754.0-0) about formatting,,,,,597,RIGHT,10,,line,https://api.github.com/repos/hyperskill/mobile-app/pulls/860,hyperskill/mobile-app,50d6264c667d839e0ddf26beae592012b27ebbc2
https://api.github.com/repos/UnUniFi/chain/pulls/507,https://api.github.com/repos/UnUniFi/chain/pulls/comments/1178552353,jununifi,e462428d72d9a106a57b131dbf0fcbb3663620ed,e462428d72d9a106a57b131dbf0fcbb3663620ed,"@@ -16,6 +16,7 @@ func (suite *KeeperTestSuite) TestOpenPerpetualFuturesPosition() {
 		QuoteDenom: ""uusdc"",
 	}
 
+	// TODO: add failure case due to the lack of the available asset in the pool",x/derivatives/keeper/perpetual_futures_test.go,2023-04-27 02:03:37+00:00,2023-04-27T02:03:37Z,Can you implement all TODOs on this PR?,,,,19.0,19,RIGHT,4,4.0,line,https://api.github.com/repos/UnUniFi/chain/pulls/507,UnUniFi/chain,3704eb562b954caab26a6dff285c2fe021255719
https://api.github.com/repos/UnUniFi/chain/pulls/507,https://api.github.com/repos/UnUniFi/chain/pulls/comments/1178552526,jununifi,e462428d72d9a106a57b131dbf0fcbb3663620ed,e462428d72d9a106a57b131dbf0fcbb3663620ed,"@@ -192,14 +196,223 @@ func TestPosition_IsValid(t *testing.T) {
 					t.Errorf(""expected %v, got %v"", tc.exp, err)
 				}
 			} else {
-				if err != nil {
+				if err == nil {
 					t.Errorf(""expected %v, got %v"", tc.exp, err)
 				}
 			}
 		})
 	}
 }
 
+// TODO: impl TestRemaingMarginInMetrics",x/derivatives/types/positions_test.go,2023-04-27 02:03:56+00:00,2023-04-27T02:03:56Z,Could remove this since it's implemented,,,,207.0,207,RIGHT,30,30.0,line,https://api.github.com/repos/UnUniFi/chain/pulls/507,UnUniFi/chain,3704eb562b954caab26a6dff285c2fe021255719
https://api.github.com/repos/UnUniFi/chain/pulls/532,https://api.github.com/repos/UnUniFi/chain/pulls/comments/1213191480,kimurayu45z,33bf412d5b337ad76db386d3f028941c8ecc5ce7,5198259ce97345f1ae9f7b58976599c72c23cd10,"@@ -187,21 +170,13 @@ message QueryPerpetualFuturesMarketResponse {
   string metrics_quote_ticker = 2 [
     (gogoproto.moretags)  = ""yaml:\""metrics_quote_ticker\""""
   ];
-  string volume_24hours = 3 [
-    (gogoproto.moretags)  = ""yaml:\""volume_24hours\"""",
-    (gogoproto.customtype) = ""github.com/cosmos/cosmos-sdk/types.Dec""
-  ];
-  string fees_24hours = 4 [
-    (gogoproto.moretags)  = ""yaml:\""fees_24hours\"""",
-    (gogoproto.customtype) = ""github.com/cosmos/cosmos-sdk/types.Dec""
-  ];
-  string long_positions = 5 [
+  string long_positions = 3 [
     (gogoproto.moretags)  = ""yaml:\""long_positions\"""",
-    (gogoproto.customtype) = ""github.com/cosmos/cosmos-sdk/types.Dec""
+    (gogoproto.customtype) = ""github.com/cosmos/cosmos-sdk/types.Int""
   ];
-  string short_positions = 6 [
+  string short_positions = 4 [
     (gogoproto.moretags)  = ""yaml:\""short_positions\"""",
-    (gogoproto.customtype) = ""github.com/cosmos/cosmos-sdk/types.Dec""
+    (gogoproto.customtype) = ""github.com/cosmos/cosmos-sdk/types.Int""",proto/derivatives/query.proto,2023-06-01 13:51:52+00:00,2023-06-01T13:51:56Z,is this value million timed value?,,,,,179,RIGHT,66,,line,https://api.github.com/repos/UnUniFi/chain/pulls/532,UnUniFi/chain,b98ea66ce0689be592caade8693b0d1cb8283220
https://api.github.com/repos/UnUniFi/chain/pulls/565,https://api.github.com/repos/UnUniFi/chain/pulls/comments/1212711975,kimurayu45z,5cc83e50207addb7ced90290b40136425fc770f4,c54b34159a4180547b1dabab780d29c3f85d32b9,"@@ -0,0 +1,60 @@
+# v2.0 to v2.1 Upgrade Guide
+
+## Purpose of this upgrade
+
+This proposal aims to do upgrade to UnUniFi `v2.1.0`.
+This upgrade will enable everyone to deploy cosmwasm contract & update [ibc-go v7.0.1](https://github.com/cosmos/ibc-go/releases/tag/v7.0.1) to fix for the [huckleberry security advisory](https://forum.cosmos.network/t/ibc-security-advisory-huckleberry/10731).
+
+## Brief guide
+
+### Time
+
+The upgrade height is `5630000`.
+About June 4, 2023, 7:30 AM UTC.
+
+## Go Requirement
+
+You will need to be running go1.19 for this, same as the previsou version. You can check with this command:",networks/ununifi-beta/upgrades/v2.1.0/guide.md,2023-06-01 07:29:28+00:00,2023-06-01T07:29:29Z,previous,,,,,17,RIGHT,17,,line,https://api.github.com/repos/UnUniFi/chain/pulls/565,UnUniFi/chain,69068cb88894b2b31d21a583fe8ec553534e7622
https://api.github.com/repos/UnUniFi/chain/pulls/565,https://api.github.com/repos/UnUniFi/chain/pulls/comments/1212712299,kimurayu45z,5cc83e50207addb7ced90290b40136425fc770f4,c54b34159a4180547b1dabab780d29c3f85d32b9,"@@ -0,0 +1,60 @@
+# v2.0 to v2.1 Upgrade Guide
+
+## Purpose of this upgrade
+
+This proposal aims to do upgrade to UnUniFi `v2.1.0`.
+This upgrade will enable everyone to deploy cosmwasm contract & update [ibc-go v7.0.1](https://github.com/cosmos/ibc-go/releases/tag/v7.0.1) to fix for the [huckleberry security advisory](https://forum.cosmos.network/t/ibc-security-advisory-huckleberry/10731).
+
+## Brief guide
+
+### Time
+
+The upgrade height is `5630000`.
+About June 4, 2023, 7:30 AM UTC.
+
+## Go Requirement
+
+You will need to be running go1.19 for this, same as the previsou version. You can check with this command:
+
+```shell
+go version
+```
+
+## Setup
+
+If the cosmovisor's `DAEMON_ALLOW_DOWNLOAD_BINARIES` variable is set `true`, no need to do the following steps, it will be downloaded automatically.
+But, if `$DAEMON_HOME/cosmovisor/upgrades/v2/bin` already exists, the cosmovisor uses it.
+
+If you use cosmovisor which we highly recommend, create the required folder, make the build, and copy the daemon over to that folder with the appropriate name.
+
+```shell
+# Download
+mkdir -p $DAEMON_HOME/cosmovisor/upgrades/v2_1/bin
+wget https://github.com/UnUniFi/chain/releases/download/v2.1.0/ununifid?checksum=md5:870390f317f30995ea0b4457df05c53b -O $DAEMON_HOME/cosmovisor/upgrades/v2_1/bin/ununifid
+```
+
+or
+
+```shell
+# Build
+mkdir -p $DAEMON_HOME/cosmovisor/upgrades/v2_1/bin
+cd $HOME/<your-ununifi-repo>
+git pull
+git checkout v2.1.0
+make build -B
+## to make sure the build status
+# ./build/ununifid version
+cp ./build/ununifid $DAEMON_HOME/cosmovisor/upgrades/v2_1/bin
+```
+
+NOTE: Don't forget check the file owner of v2 binary.
+
+```shell
+chmod 755 $DAEMON_HOME/cosmovisor/upgrades/v2_1/bin/ununifid
+```
+
+And you don't have to reboot cosmovisor when to do upgrade. So, after locating the binary into the appropriate place, you don't need to anything.",networks/ununifi-beta/upgrades/v2.1.0/guide.md,2023-06-01 07:29:47+00:00,2023-06-01T07:29:48Z,need to do anything,,,,,56,RIGHT,56,,line,https://api.github.com/repos/UnUniFi/chain/pulls/565,UnUniFi/chain,69068cb88894b2b31d21a583fe8ec553534e7622
https://api.github.com/repos/UnUniFi/chain/pulls/527,https://api.github.com/repos/UnUniFi/chain/pulls/comments/1201638910,mkXultra,b44718eb2b99618bbf309f3a6a83a885a2fc356f,ee99903b92853d1628e14ee7c52b3eda29678e43,"@@ -120,23 +128,46 @@ import (
 	""github.com/spf13/cast""
 
 	v1_beta3 ""github.com/UnUniFi/chain/app/upgrades/v1-beta.3""
-	// ""github.com/UnUniFi/chain/x/derivatives""
-	// epochsmodule ""github.com/UnUniFi/chain/x/epochs""
-	// ""github.com/UnUniFi/chain/x/nftmint""
 	// ""github.com/UnUniFi/chain/deprecated/yieldfarm""
+	epochsmodule ""github.com/UnUniFi/chain/x/epochs""
+	epochsmodulekeeper ""github.com/UnUniFi/chain/x/epochs/keeper""
+	epochsmoduletypes ""github.com/UnUniFi/chain/x/epochs/types""
+	icacallbacksmodule ""github.com/UnUniFi/chain/x/icacallbacks""
+	icacallbacksmodulekeeper ""github.com/UnUniFi/chain/x/icacallbacks/keeper""
+	icacallbacksmoduletypes ""github.com/UnUniFi/chain/x/icacallbacks/types""
+	""github.com/UnUniFi/chain/x/interchainquery""
+	interchainquerykeeper ""github.com/UnUniFi/chain/x/interchainquery/keeper""
+	interchainquerytypes ""github.com/UnUniFi/chain/x/interchainquery/types""
+	""github.com/UnUniFi/chain/x/pricefeed""
+	pricefeedkeeper ""github.com/UnUniFi/chain/x/pricefeed/keeper""
+	pricefeedtypes ""github.com/UnUniFi/chain/x/pricefeed/types""
+	recordsmodule ""github.com/UnUniFi/chain/x/records""
+	recordsmodulekeeper ""github.com/UnUniFi/chain/x/records/keeper""
+	recordsmoduletypes ""github.com/UnUniFi/chain/x/records/types""
+	stakeibcmodule ""github.com/UnUniFi/chain/x/stakeibc""
+	stakeibcmodulekeeper ""github.com/UnUniFi/chain/x/stakeibc/keeper""
+	stakeibcmoduletypes ""github.com/UnUniFi/chain/x/stakeibc/types""
+	yieldaggregator ""github.com/UnUniFi/chain/x/yield-aggregator""
+	yieldaggregatorkeeper ""github.com/UnUniFi/chain/x/yield-aggregator/keeper""
+	yieldaggregatortypes ""github.com/UnUniFi/chain/x/yield-aggregator/types""
+
+	// ""github.com/UnUniFi/chain/x/yieldfarm""
+	// yieldfarmkeeper ""github.com/UnUniFi/chain/x/yieldfarm/keeper""
+	// yieldfarmtypes ""github.com/UnUniFi/chain/x/yieldfarm/types""",app/app.go,2023-05-23 07:01:06+00:00,2023-05-23T07:02:17Z,"plz delete it.
it's not exists.",,154.0,RIGHT,,156,RIGHT,59,,line,https://api.github.com/repos/UnUniFi/chain/pulls/527,UnUniFi/chain,f12e887d86edb919a8879c1bdfff832b6ab354cb
https://api.github.com/repos/UnUniFi/chain/pulls/480,https://api.github.com/repos/UnUniFi/chain/pulls/comments/1161562115,kimurayu45z,6d5696bfbf4d2dedc7be09b686b68e2555098703,73cb6903abdad3e2ce26f5222a5a2d47bd93240d,"@@ -98,7 +98,10 @@ message PerpetualFuturesNetPositionOfMarket {
     (gogoproto.moretags) = ""yaml:\""market\"""",
     (gogoproto.nullable) = false
   ];
-  string position_size_in_micro = 2 [
+  PositionType position_type = 2 [
+    (gogoproto.moretags) = ""yaml:\""position_type\""""
+  ];
+  string position_size_in_denom_unit = 3 [",proto/derivatives/perpetual_futures.proto,2023-04-10 09:00:55+00:00,2023-04-10T09:00:56Z,Is it difficult to make this `PositionSize` as `sdk.Dec`?,,,,,104,RIGHT,8,,line,https://api.github.com/repos/UnUniFi/chain/pulls/480,UnUniFi/chain,363fbc3c01e9ec219591f9a1e7e503ca06943b3b
https://api.github.com/repos/UnUniFi/chain/pulls/444,https://api.github.com/repos/UnUniFi/chain/pulls/comments/1141737589,kimurayu45z,0a4192020df103feec08a79fff32fed19331fcb6,1cb0bdc9559180a853d18febb853881ddd17204f,"@@ -15,16 +15,38 @@ type PositionInstance interface {
 
 type Positions []Position
 
-func (m Position) Validate() error {
-	if m.RemainingMargin.Amount.IsZero() {
-		return fmt.Errorf(""remaining margin cannot be zero"")
+func (m Position) IsValid() error {
+	if !m.IsValidMarginAsset() {
+		return fmt.Errorf(""margin asset is not valid"")
 	}
-	if m.RemainingMargin.Amount.IsNegative() {
-		return fmt.Errorf(""remaining margin cannot be negative"")
+
+	// check the least requirement for the margin
+	if !m.RemainingMargin.Amount.IsPositive() {
+		return fmt.Errorf(""remaining margin must be positive"")
+	}
+
+	pfPosition, err := NewPerpetualFuturesPositionFromPosition(m)
+	if err != nil {
+		return err
+	}
+
+	if !pfPosition.IsValidPositionSize() {
+		return fmt.Errorf(""position size is not valid"")
 	}
+
 	return nil
 }
 
+func (m Position) IsValidMarginAsset() bool {
+	return !(m.Market.BaseDenom != m.RemainingMargin.Denom && m.Market.QuoteDenom != m.RemainingMargin.Denom)",x/derivatives/types/positions.go,2023-03-20 07:53:34+00:00,2023-03-20T07:53:34Z,"Oh plz wait.
@mkXultra Is this ok?",,,,,41,RIGHT,32,,line,https://api.github.com/repos/UnUniFi/chain/pulls/444,UnUniFi/chain,2d87a963484f1091461a257b0b93dba956474541
https://api.github.com/repos/UnUniFi/chain/pulls/523,https://api.github.com/repos/UnUniFi/chain/pulls/comments/1190874350,Senna46,16cbaf4c04f3b0396e003bdb63eee4e05637e17a,e5db4777e7b8f7fe055db1d356c474e0d9b70978,"@@ -253,7 +252,7 @@ func (k Keeper) ReportLiquidationNeededPerpetualFuturesPosition(ctx sdk.Context,
 		return nil
 	}
 
-	return errors.New(""no liquidation needed"")",x/derivatives/keeper/perpetual_futures.go,2023-05-11 09:10:24+00:00,2023-05-11T09:10:25Z,"If it is not subject to ReportLiquidation, it should end the process, not an error",,,,256.0,256,LEFT,12,12.0,line,https://api.github.com/repos/UnUniFi/chain/pulls/523,UnUniFi/chain,ce1ccbbde8fe3937bf2d5ccd70ee822c26084b33
https://api.github.com/repos/VladislavPetyukevich/GulagGazRoom/pulls/147,https://api.github.com/repos/VladislavPetyukevich/GulagGazRoom/pulls/comments/1160479496,blowin,3dc26ef5815f559f2f03340e7417ec995a64805e,3293e427cb0bb01cca8b56c77d5825cc36d9010f,"@@ -188,5 +187,7 @@ public Task<IPagedList<T>> GetPageDetailedAsync(int pageNumber, int pageSize, Ca
             .ToPagedListAsync(pageNumber, pageSize, cancellationToken);
     }
 
-    protected abstract IQueryable<T> ApplyIncludes(DbSet<T> set);
+    protected virtual IQueryable<T> ApplyIncludes(DbSet<T> set) => set;
+
+    protected virtual IQueryable<T> DecorateSet(DbSet<T> set) => set;",Backend/Interview.Infrastructure/Database/EfRepository.cs,2023-04-07 06:48:17+00:00,2023-04-07T06:49:24Z,ApplyNonDetail,,,,,192,RIGHT,110,,line,https://api.github.com/repos/VladislavPetyukevich/GulagGazRoom/pulls/147,VladislavPetyukevich/GulagGazRoom,3b785c4170db549138e123d715c30acfa7470969
https://api.github.com/repos/UnUniFi/chain/pulls/536,https://api.github.com/repos/UnUniFi/chain/pulls/comments/1196201771,jununifi,41d76efe51d980819d0a8f0a2928a3407205f924,c9fb944622e8e7055551b7f54c48982c374d3778,"@@ -187,7 +187,7 @@ require (
 replace (
 	// patch bech32 decoding to enable larger string lengths
 	github.com/btcsuite/btcutil => github.com/kava-labs/btcutil v0.0.0-20200522184203-886d33430f06
-	github.com/cosmos/cosmos-sdk => github.com/ununifi/cosmos-sdk v0.47.1
+	github.com/cosmos/cosmos-sdk => github.com/ununifi/cosmos-sdk v0.47.1-bank-rc2",go.mod,2023-05-17 09:20:07+00:00,2023-05-17T09:20:07Z,"Why does it require custom bank? I see following commit on modified sdk
https://github.com/UnUniFi/cosmos-sdk/commit/62acccf557cc0577560999442fe7232a18f0707b#diff-9d2eab3427e6248af17c3913110878659d8128d050b8476e609ae7c0e95b702dR30

I think this configuration can be modified on app.go without using custom cosmos-sdk.",,,,190.0,190,RIGHT,5,274.0,line,https://api.github.com/repos/UnUniFi/chain/pulls/536,UnUniFi/chain,1c6f570022b6909d6a4e8c4e5fd34bbbb5ed4224
https://api.github.com/repos/UnUniFi/chain/pulls/536,https://api.github.com/repos/UnUniFi/chain/pulls/comments/1196204723,jununifi,bd3760437ff873fe6ad796596734c683d25d6204,c9fb944622e8e7055551b7f54c48982c374d3778,"@@ -1395,12 +1405,39 @@ func initParamsKeeper(appCodec codec.BinaryCodec, legacyAmino *codec.LegacyAmino
 	return paramsKeeper
 }
 
+func (app *App) setupUpgradeStoreLoaders() {
+	upgradeInfo, err := app.UpgradeKeeper.ReadUpgradeInfoFromDisk()
+	if err != nil {
+		panic(fmt.Sprintf(""failed to read upgrade info from disk %s"", err))
+	}
+
+	if app.UpgradeKeeper.IsSkipHeight(upgradeInfo.Height) {
+		return
+	}
+
+	for _, upgrade := range Upgrades {
+		if upgradeInfo.Name == upgrade.UpgradeName {
+			app.SetStoreLoader(upgradetypes.UpgradeStoreLoader(upgradeInfo.Height, &upgrade.StoreUpgrades))
+		}
+	}
+
+}
+
 func (app *App) setupUpgradeHandlers() {
-	app.UpgradeKeeper.SetUpgradeHandler(
-		v1_beta3.UpgradeName,
-		v1_beta3.CreateUpgradeHandler(
-			app.mm,
-			app.configurator,
-			app.AccountKeeper,
-			app.BankKeeper))
+	for _, upgrade := range Upgrades {
+		app.UpgradeKeeper.SetUpgradeHandler(
+			upgrade.UpgradeName,
+			upgrade.CreateUpgradeHandler(
+				app.mm,
+				app.configurator,
+				app.BaseApp,
+				&app.AppKeepers,
+			),
+		)
+	}
+}
+
+func (app *App) setupAppkeeper() {
+	app.AppKeepers.AccountKeeper = &app.AccountKeeper
+	app.AppKeepers.BankKeeper = &app.BankKeeper",app/app.go,2023-05-17 09:22:30+00:00,2023-05-17T09:22:31Z,I am not sure why it is doing update for AccountKeeper and BankKeeper only here - what about the others?,,,,1438.0,1442,RIGHT,100,1602.0,line,https://api.github.com/repos/UnUniFi/chain/pulls/536,UnUniFi/chain,1c6f570022b6909d6a4e8c4e5fd34bbbb5ed4224
https://api.github.com/repos/UnUniFi/chain/pulls/536,https://api.github.com/repos/UnUniFi/chain/pulls/comments/1196205986,jununifi,bd3760437ff873fe6ad796596734c683d25d6204,c9fb944622e8e7055551b7f54c48982c374d3778,"@@ -0,0 +1,41 @@
+package keepers
+
+import (
+	authkeeper ""github.com/cosmos/cosmos-sdk/x/auth/keeper""
+	authzkeeper ""github.com/cosmos/cosmos-sdk/x/authz/keeper""
+	bankkeeper ""github.com/cosmos/cosmos-sdk/x/bank/keeper""
+	capabilitykeeper ""github.com/cosmos/cosmos-sdk/x/capability/keeper""
+	crisiskeeper ""github.com/cosmos/cosmos-sdk/x/crisis/keeper""
+	distrkeeper ""github.com/cosmos/cosmos-sdk/x/distribution/keeper""
+	paramskeeper ""github.com/cosmos/cosmos-sdk/x/params/keeper""
+	stakingkeeper ""github.com/cosmos/cosmos-sdk/x/staking/keeper""
+	upgradekeeper ""github.com/cosmos/cosmos-sdk/x/upgrade/keeper""
+)
+
+type AppKeepers struct {
+	// keepers, by order of initialization
+	// ""Special"" keepers
+	ParamsKeeper     *paramskeeper.Keeper
+	CapabilityKeeper *capabilitykeeper.Keeper
+	CrisisKeeper     *crisiskeeper.Keeper
+	UpgradeKeeper    *upgradekeeper.Keeper
+
+	// make scoped keepers public for test purposes
+	ScopedIBCKeeper      capabilitykeeper.ScopedKeeper
+	ScopedICAHostKeeper  capabilitykeeper.ScopedKeeper
+	ScopedTransferKeeper capabilitykeeper.ScopedKeeper
+	ScopedWasmKeeper     capabilitykeeper.ScopedKeeper
+	ScopedICQKeeper      capabilitykeeper.ScopedKeeper
+
+	// ""Normal"" keepers
+	AccountKeeper *authkeeper.AccountKeeper
+	BankKeeper    *bankkeeper.BaseKeeper
+	AuthzKeeper   *authzkeeper.Keeper
+	StakingKeeper *stakingkeeper.Keeper
+	DistrKeeper   *distrkeeper.Keeper
+
+	// // keys to access the substores
+	// keys    map[string]*sdk.KVStoreKey
+	// tkeys   map[string]*sdk.TransientStoreKey
+	// memKeys map[string]*sdk.MemoryStoreKey",app/keepers/keepers.go,2023-05-17 09:23:37+00:00,2023-05-17T09:23:37Z,Could this commented code removed?,,,,,40,RIGHT,40,,line,https://api.github.com/repos/UnUniFi/chain/pulls/536,UnUniFi/chain,1c6f570022b6909d6a4e8c4e5fd34bbbb5ed4224
https://api.github.com/repos/UnUniFi/chain/pulls/536,https://api.github.com/repos/UnUniFi/chain/pulls/comments/1196208035,jununifi,bd3760437ff873fe6ad796596734c683d25d6204,c9fb944622e8e7055551b7f54c48982c374d3778,"@@ -366,6 +372,7 @@ type App struct {
 	// simulation manager
 	sm           *module.SimulationManager
 	configurator module.Configurator
+	keepers.AppKeepers",app/app.go,2023-05-17 09:24:54+00:00,2023-05-17T09:24:55Z,"I believe we will need to not keep two keeper objects one on AppKeepers and the other under app directly.
We can only keep AppKeepers only.",,,,383.0,375,RIGHT,34,426.0,line,https://api.github.com/repos/UnUniFi/chain/pulls/536,UnUniFi/chain,1c6f570022b6909d6a4e8c4e5fd34bbbb5ed4224
https://api.github.com/repos/UnUniFi/chain/pulls/536,https://api.github.com/repos/UnUniFi/chain/pulls/comments/1196211844,jununifi,144f63dcc4f2aed48f14102a060e2033ede8deda,c9fb944622e8e7055551b7f54c48982c374d3778,"@@ -15,9 +29,59 @@ func CreateUpgradeHandler(mm *module.Manager,
 	configurator module.Configurator,
 	_ upgrades.BaseAppParamManager,
 	keepers *keepers.AppKeepers) upgradetypes.UpgradeHandler {
+	for _, subspace := range keepers.ParamsKeeper.GetSubspaces() {
+		subspace := subspace
+
+		// ctx.Logger().Info(fmt.Sprintf(""subspace.Name:%s"", subspace.Name()))
+		// ctx.Logger().Info(fmt.Sprintf(""i:%d"", i))
+		var keyTable paramstypes.KeyTable
+		switch subspace.Name() {
+		case authtypes.ModuleName:
+			keyTable = authtypes.ParamKeyTable() //nolint:staticcheck
+		case banktypes.ModuleName:
+			keyTable = banktypes.ParamKeyTable() //nolint:staticcheck
+		case stakingtypes.ModuleName:
+			keyTable = stakingtypes.ParamKeyTable() //nolint:staticcheck
+		case minttypes.ModuleName:
+			keyTable = minttypes.ParamKeyTable() //nolint:staticcheck
+		case distrtypes.ModuleName:
+			keyTable = distrtypes.ParamKeyTable() //nolint:staticcheck
+		case slashingtypes.ModuleName:
+			keyTable = slashingtypes.ParamKeyTable() //nolint:staticcheck
+		case govtypes.ModuleName:
+			keyTable = govv1.ParamKeyTable() //nolint:staticcheck
+		case crisistypes.ModuleName:
+			keyTable = crisistypes.ParamKeyTable() //nolint:staticcheck
+		case wasmtypes.ModuleName:
+			keyTable = wasmtypes.ParamKeyTable() //nolint:staticcheck
+		}
+
+		if !subspace.HasKeyTable() {
+			subspace.WithKeyTable(keyTable)
+		}",app/upgrades/v2/upgrades.go,2023-05-17 09:28:02+00:00,2023-05-17T09:28:03Z,"I haven't seen similar upgrade codebase before, will need to check if it's working fine on actual upgrade process.",,,,61.0,61,RIGHT,58,61.0,line,https://api.github.com/repos/UnUniFi/chain/pulls/536,UnUniFi/chain,1c6f570022b6909d6a4e8c4e5fd34bbbb5ed4224
https://api.github.com/repos/UnUniFi/web-apps/pulls/423,https://api.github.com/repos/UnUniFi/web-apps/pulls/comments/1152000515,kimurayu45z,b35a453890a608af1c1548d0139bbc7faf7dd878,b8742a4ef4522a013dd92d3bb5d3876cd4c55aa6,"@@ -64,25 +67,52 @@ <h2 class=""card-title break-all"">Bidding Status</h2>
 <div class=""card lg:card-side bg-base-100 shadow-xl mb-8"">
   <div class=""card-body"">
     <h2 class=""card-title break-all"">Lend Tokens</h2>
-    <form #formRef=""ngForm"" (submit)=""onSubmit()"">
+    <div class=""form-control"">
+      <label class=""cursor-pointer label"">
+        <span class=""label-text"">Advanced Search</span>
+        <input
+          type=""checkbox""
+          class=""toggle toggle-primary""
+          name=""openSearch""
+          [(ngModel)]=""isOpenedSearch""",projects/portal/src/app/views/nft-pawnshop/lenders/lenders.component.html,2023-03-29 14:05:42+00:00,2023-03-29T14:05:42Z,"open search is not good word I think.
how about
""isNotFiltered""
",,,,,77,RIGHT,39,,line,https://api.github.com/repos/UnUniFi/web-apps/pulls/423,UnUniFi/web-apps,d96a6fd4517bc9230ca1df8dc257a1b8c8698af9
https://api.github.com/repos/UnUniFi/web-apps/pulls/442,https://api.github.com/repos/UnUniFi/web-apps/pulls/comments/1154426722,kimurayu45z,2c920c766d5cebfd6b6f22be7cc4c8a27d89c6e6,bbb5d4191b16d5b05856ddcbd8f16eb8e2f5a9c1,"@@ -56,57 +59,66 @@ <h2 class=""mb-0"">Delegations</h2>
 </ng-container>
 <ng-template #existUnbonding>
   <h2 class=""mb-0"">OnGoing Unbonding</h2>
-  <mat-card class=""mb-4"">
-    <mat-list>
-      <mat-list-item>
-        <span class=""w-6/12 break-all truncate pl-8 pr-8"">Validator</span>
-        <span class=""w-4/12 break-all truncate text-center"">Date</span>
-        <span class=""w-2/12 break-all truncate text-right pl-2"">Amount</span>
-        <mat-divider></mat-divider>
-      </mat-list-item>
-    </mat-list>
-    <mat-nav-list>
-      <ng-container *ngFor=""let unbondingDelegation of unbondingDelegations; last as last"">
-        <ng-container *ngFor=""let validator of delegatedValidators"">
-          <mat-list-item
-            *ngIf=""unbondingDelegation?.unbond?.validator_address === validator?.operator_address""
-            (click)=""onClickValidator(validator!)""
-          >
-            <mat-icon
-              matListIcon
-              [ngStyle]=""{
-                color: getColorCode(unbondingDelegation?.unbond?.validator_address ?? '')
-              }""
+  <div class=""overflow-x-auto mb-8"">
+    <table class=""table w-full"">
+      <!-- head -->
+      <thead>
+        <tr>
+          <th></th>
+          <td>Validator</td>
+          <td>Date</td>
+          <td>Amount</td>
+        </tr>
+      </thead>
+      <tbody>
+        <ng-container *ngFor=""let unbondingDelegation of unbondingDelegations"">
+          <ng-container *ngFor=""let validator of delegatedValidators"">
+            <tr
+              class=""hover cursor-pointer""
+              *ngIf=""unbondingDelegation?.unbond?.validator_address === validator?.operator_address""
+              (click)=""onClickValidator(validator!)""
             >
-              circle
-            </mat-icon>
-            <span class=""w-6/12 break-all text-sm sm:text-base""
-              >{{ validator?.description?.moniker }}
-            </span>
-            <span class=""w-4/12 break-all text-sm sm:text-base text-right pr-2""
-              >{{
-              unbondingDelegation?.unbond?.entries?.[0]?.completion_time | date : 'yyyy-MM-dd a hh:mm:ss z'}}
-            </span>
-            <span class=""w-2/12 break-all text-sm sm:text-base text-right pr-2"">{{
-              unbondingDelegation?.unbond?.entries?.[0]?.balance }}</span>
-          </mat-list-item>
+              <th>
+                <mat-icon
+                  matListIcon
+                  [ngStyle]=""{
+                    color: getColorCode(unbondingDelegation?.unbond?.validator_address ?? '')
+                  }""
+                >
+                  circle
+                </mat-icon>
+              </th>
+              <td>{{ validator?.description?.moniker }}</td>
+              <td>
+                {{ unbondingDelegation?.unbond?.entries?.[0]?.completion_time | date : 'yyyy-MM-dd a hh:mm:ss z'}}
+              </td>
+              <td>
+                {{ unbondingDelegation?.unbond?.entries?.[0]?.balance ?? '0' | coinAmount }}
+              </td>
+            </tr>
+          </ng-container>
         </ng-container>
-        <mat-divider *ngIf=""!last"" [inset]=""true""></mat-divider>
-      </ng-container>
-    </mat-nav-list>
-  </mat-card>
-</ng-template>
-<ng-template #emptyUnbonding>
-  <p>There is no unbonding delegations.</p>
+      </tbody>
+    </table>
+  </div>
 </ng-template>
+<ng-template #emptyUnbonding></ng-template>
 
 <div class=""flex flex-row items-end mb-2"">",projects/portal/src/app/views/delegate/validators/validators.component.html,2023-03-31 12:39:42+00:00,2023-03-31T12:40:00Z,"shouldn't be items-end, and mb-2 and mb of h2 should b eliminated in design principle",,,,,107,RIGHT,173,,line,https://api.github.com/repos/UnUniFi/web-apps/pulls/442,UnUniFi/web-apps,7cc9860fcf38acf40a480d2b14437c322a8d6bcd
https://api.github.com/repos/QuickSwap/interface-v2/pulls/754,https://api.github.com/repos/QuickSwap/interface-v2/pulls/comments/1169679191,sameepsi,39e862ae5ba120784fdb889f131b2771ab4b7170,6207ceca3c47f31bd116e60c98f67897acf968af,"@@ -124,58 +110,32 @@ function Updaters() {
 const queryClient = new QueryClient();
 
 const App: React.FC = () => {
-  const { chainId: web3ChainId } = useWeb3React<Web3Provider>();
-  const localChainIdStr = localStorage.getItem('quickswap_chainId');
-  const localChainId = localChainIdStr
-    ? (Number(localChainIdStr) as ChainId)
-    : undefined;
-  const chainId = web3ChainId ?? localChainId;",src/App.tsx,2023-04-18 08:26:53+00:00,2023-04-18T08:38:05Z,Why have you removed the multichain handling?,,,,132.0,132,LEFT,36,36.0,line,https://api.github.com/repos/QuickSwap/interface-v2/pulls/754,QuickSwap/interface-v2,254f2c5822d2d2c5704062f42ef79798bf201154
https://api.github.com/repos/QuickSwap/interface-v2/pulls/754,https://api.github.com/repos/QuickSwap/interface-v2/pulls/comments/1169684455,sameepsi,39e862ae5ba120784fdb889f131b2771ab4b7170,6207ceca3c47f31bd116e60c98f67897acf968af,"@@ -10,22 +8,11 @@ const StatusIcon: React.FC = () => {
   const { t } = useTranslation();
   const { connector } = useActiveWeb3React();
   const icon = getWalletKeys(connector).map(
-    (k) => SUPPORTED_WALLETS[k].iconName,",src/components/AccountDetails/StatusIcon.tsx,2023-04-18 08:29:56+00:00,2023-04-18T08:38:05Z,Why have you removed supported wallets?,,,,13.0,13,LEFT,12,12.0,line,https://api.github.com/repos/QuickSwap/interface-v2/pulls/754,QuickSwap/interface-v2,254f2c5822d2d2c5704062f42ef79798bf201154
https://api.github.com/repos/QuickSwap/interface-v2/pulls/1156,https://api.github.com/repos/QuickSwap/interface-v2/pulls/comments/1445699817,sameepsi,248e410d19492151bd5410b3e3ae1ce8af1c1995,66fca16db524cb747fdb87aac7d30069573c1490,"@@ -0,0 +1,56 @@
+import { Box, Button, CircularProgress } from '@material-ui/core';",src/pages/SwapPage/BuySellWidget/DraginDipatchAdvertisement.tsx,2024-01-09 07:06:03+00:00,2024-01-09T07:06:47Z,Please fix the name of this file,,,,,1,RIGHT,1,,line,https://api.github.com/repos/QuickSwap/interface-v2/pulls/1156,QuickSwap/interface-v2,bfbf06dacd1d2b8b8b5aed55e464c336b5641dba
https://api.github.com/repos/QuickSwap/interface-v2/pulls/1156,https://api.github.com/repos/QuickSwap/interface-v2/pulls/comments/1448383208,sameepsi,5e19266532118fd4fb074cc5a687bb8411473b57,66fca16db524cb747fdb87aac7d30069573c1490,"@@ -0,0 +1,56 @@
+import { Box, Button, CircularProgress } from '@material-ui/core';",src/pages/SwapPage/BuySellWidget/DragonDipatchAdvertisement.tsx,2024-01-11 07:10:52+00:00,2024-01-11T07:10:52Z,fix the name of this file,,,,,1,RIGHT,1,,line,https://api.github.com/repos/QuickSwap/interface-v2/pulls/1156,QuickSwap/interface-v2,bfbf06dacd1d2b8b8b5aed55e464c336b5641dba
https://api.github.com/repos/QuickSwap/interface-v2/pulls/1274,https://api.github.com/repos/QuickSwap/interface-v2/pulls/comments/1530108455,ayushbuidl,0af48a08d331d1d608cd5ef321cd6e3b95cabf58,8370818a92e1c312c875c5c76546cdb2033ad45c,"@@ -51,6 +52,22 @@ export const Leverage = ({ perpToken, orderQuantity }) => {
     side: 'BUY',
     order_symbol: perpToken,
   });
+  console.log(state.status);
+  useEffect(() => {
+    if (!library || !quickSwapAccount) return;
+    account.setAddress(quickSwapAccount, {
+      provider: window.ethereum,",src/pages/PerpsPage/Leverage.tsx,2024-03-19 10:31:59+00:00,2024-03-19T10:31:59Z,provider should be library.provider,,,,,59,RIGHT,45,,line,https://api.github.com/repos/QuickSwap/interface-v2/pulls/1274,QuickSwap/interface-v2,12366b4ab73cea00b62c25af88c436b6cd7b10d3
https://api.github.com/repos/QuickSwap/interface-v2/pulls/1504,https://api.github.com/repos/QuickSwap/interface-v2/pulls/comments/1723023426,sameepsi,d2c0a5ef57dc153a4ec110127636bbb5a2aaa709,2475c5e8959b31058b298d13d9791ceab031a672,"@@ -65,7 +70,7 @@
     ""available"": false
   },
   ""hydra"": {
-    ""available"": false
+    ""available"": true",src/config/layerx.json,2024-08-20 09:43:54+00:00,2024-08-20T09:43:54Z,@brianshattuck why this is changed from false to true?,,,,,73,RIGHT,24,,line,https://api.github.com/repos/QuickSwap/interface-v2/pulls/1504,QuickSwap/interface-v2,83c269b439febb5297d9f29688695434245996a4
https://api.github.com/repos/QuickSwap/interface-v2/pulls/1504,https://api.github.com/repos/QuickSwap/interface-v2/pulls/comments/1723023739,sameepsi,d2c0a5ef57dc153a4ec110127636bbb5a2aaa709,2475c5e8959b31058b298d13d9791ceab031a672,"@@ -86,7 +91,7 @@
     ""available"": false
   },
   ""steer"": {
-    ""available"": true
+    ""available"": false",src/config/layerx.json,2024-08-20 09:44:08+00:00,2024-08-20T09:44:08Z,@brianshattuck why this has been done?,,,,,94,RIGHT,33,,line,https://api.github.com/repos/QuickSwap/interface-v2/pulls/1504,QuickSwap/interface-v2,83c269b439febb5297d9f29688695434245996a4
https://api.github.com/repos/QuickSwap/interface-v2/pulls/1504,https://api.github.com/repos/QuickSwap/interface-v2/pulls/comments/1723026159,sameepsi,d2c0a5ef57dc153a4ec110127636bbb5a2aaa709,2475c5e8959b31058b298d13d9791ceab031a672,"@@ -1732,3 +1775,34 @@ export class ExtendedEther extends V3Currency {
     );
   }
 }
+
+export const wrappedTokenAddresses = {
+  1: '0xC02aaa39b223FE8D0A0e5C4F27eAD9083C756Cc2', // Ethereum Mainnet (WETH)
+  3: '0xc778417E063141139Fce010982780140Aa0cD5Ab', // Ropsten Testnet (WETH)
+  4: '0xc778417E063141139Fce010982780140Aa0cD5Ab', // Rinkeby Testnet (WETH)
+  5: '0xc778417E063141139Fce010982780140Aa0cD5Ab', // Goerli Testnet (WETH)
+  42: '0xd0A1E359811322d97991E03f863a0C30C2cF029C', // Kovan Testnet (WETH)
+  56: '0xBB4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c', // Binance Smart Chain Mainnet (WBNB)
+  97: '0xae13d989dac2f0debff460ac112a837c89baa7cd', // Binance Smart Chain Testnet (WBNB)
+  137: '0x0d500b1d8e8ef31e21c99d1db9a6444d3adf1270', // Polygon Mainnet (WMATIC)
+  80001: '0x9c3c9283d3e44854697cd22d3faa240cfb032889', // Mumbai Testnet (WMATIC)
+  43114: '0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7', // Avalanche Mainnet (WAVAX)
+  1101: '0xa2036f0538221a77A3937F1379699f44945018d0', // Polygon zkEVM Mainnet (WETH)",src/constants/v3/addresses.ts,2024-08-20 09:45:54+00:00,2024-08-20T09:52:44Z,@brianshattuck this is not WETH but MATIC on zkevm,,,,,1790,RIGHT,66,,line,https://api.github.com/repos/QuickSwap/interface-v2/pulls/1504,QuickSwap/interface-v2,83c269b439febb5297d9f29688695434245996a4
https://api.github.com/repos/QuickSwap/interface-v2/pulls/1504,https://api.github.com/repos/QuickSwap/interface-v2/pulls/comments/1723027573,sameepsi,d2c0a5ef57dc153a4ec110127636bbb5a2aaa709,2475c5e8959b31058b298d13d9791ceab031a672,"@@ -1732,3 +1775,34 @@ export class ExtendedEther extends V3Currency {
     );
   }
 }
+
+export const wrappedTokenAddresses = {
+  1: '0xC02aaa39b223FE8D0A0e5C4F27eAD9083C756Cc2', // Ethereum Mainnet (WETH)
+  3: '0xc778417E063141139Fce010982780140Aa0cD5Ab', // Ropsten Testnet (WETH)
+  4: '0xc778417E063141139Fce010982780140Aa0cD5Ab', // Rinkeby Testnet (WETH)
+  5: '0xc778417E063141139Fce010982780140Aa0cD5Ab', // Goerli Testnet (WETH)
+  42: '0xd0A1E359811322d97991E03f863a0C30C2cF029C', // Kovan Testnet (WETH)
+  56: '0xBB4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c', // Binance Smart Chain Mainnet (WBNB)
+  97: '0xae13d989dac2f0debff460ac112a837c89baa7cd', // Binance Smart Chain Testnet (WBNB)
+  137: '0x0d500b1d8e8ef31e21c99d1db9a6444d3adf1270', // Polygon Mainnet (WMATIC)
+  80001: '0x9c3c9283d3e44854697cd22d3faa240cfb032889', // Mumbai Testnet (WMATIC)
+  43114: '0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7', // Avalanche Mainnet (WAVAX)
+  1101: '0xa2036f0538221a77A3937F1379699f44945018d0', // Polygon zkEVM Mainnet (WETH)
+  344: '0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7', // Manta Pacific L2 Rollup (WETH)",src/constants/v3/addresses.ts,2024-08-20 09:46:56+00:00,2024-08-20T09:52:44Z,@brianshattuck this is not weth on manta,,,,,1791,RIGHT,67,,line,https://api.github.com/repos/QuickSwap/interface-v2/pulls/1504,QuickSwap/interface-v2,83c269b439febb5297d9f29688695434245996a4
https://api.github.com/repos/QuickSwap/interface-v2/pulls/1504,https://api.github.com/repos/QuickSwap/interface-v2/pulls/comments/1723028741,sameepsi,d2c0a5ef57dc153a4ec110127636bbb5a2aaa709,2475c5e8959b31058b298d13d9791ceab031a672,"@@ -1732,3 +1775,34 @@ export class ExtendedEther extends V3Currency {
     );
   }
 }
+
+export const wrappedTokenAddresses = {
+  1: '0xC02aaa39b223FE8D0A0e5C4F27eAD9083C756Cc2', // Ethereum Mainnet (WETH)
+  3: '0xc778417E063141139Fce010982780140Aa0cD5Ab', // Ropsten Testnet (WETH)
+  4: '0xc778417E063141139Fce010982780140Aa0cD5Ab', // Rinkeby Testnet (WETH)
+  5: '0xc778417E063141139Fce010982780140Aa0cD5Ab', // Goerli Testnet (WETH)
+  42: '0xd0A1E359811322d97991E03f863a0C30C2cF029C', // Kovan Testnet (WETH)
+  56: '0xBB4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c', // Binance Smart Chain Mainnet (WBNB)
+  97: '0xae13d989dac2f0debff460ac112a837c89baa7cd', // Binance Smart Chain Testnet (WBNB)
+  137: '0x0d500b1d8e8ef31e21c99d1db9a6444d3adf1270', // Polygon Mainnet (WMATIC)
+  80001: '0x9c3c9283d3e44854697cd22d3faa240cfb032889', // Mumbai Testnet (WMATIC)
+  43114: '0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7', // Avalanche Mainnet (WAVAX)
+  1101: '0xa2036f0538221a77A3937F1379699f44945018d0', // Polygon zkEVM Mainnet (WETH)
+  344: '0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7', // Manta Pacific L2 Rollup (WETH)
+  132: '0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7', // Immutable zkEVM Mainnet (WETH)",src/constants/v3/addresses.ts,2024-08-20 09:47:48+00:00,2024-08-20T09:52:44Z,This is wrong as well,,,,,1792,RIGHT,68,,line,https://api.github.com/repos/QuickSwap/interface-v2/pulls/1504,QuickSwap/interface-v2,83c269b439febb5297d9f29688695434245996a4
https://api.github.com/repos/QuickSwap/interface-v2/pulls/1504,https://api.github.com/repos/QuickSwap/interface-v2/pulls/comments/1723029217,sameepsi,d2c0a5ef57dc153a4ec110127636bbb5a2aaa709,2475c5e8959b31058b298d13d9791ceab031a672,"@@ -1732,3 +1775,34 @@ export class ExtendedEther extends V3Currency {
     );
   }
 }
+
+export const wrappedTokenAddresses = {
+  1: '0xC02aaa39b223FE8D0A0e5C4F27eAD9083C756Cc2', // Ethereum Mainnet (WETH)
+  3: '0xc778417E063141139Fce010982780140Aa0cD5Ab', // Ropsten Testnet (WETH)
+  4: '0xc778417E063141139Fce010982780140Aa0cD5Ab', // Rinkeby Testnet (WETH)
+  5: '0xc778417E063141139Fce010982780140Aa0cD5Ab', // Goerli Testnet (WETH)
+  42: '0xd0A1E359811322d97991E03f863a0C30C2cF029C', // Kovan Testnet (WETH)
+  56: '0xBB4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c', // Binance Smart Chain Mainnet (WBNB)
+  97: '0xae13d989dac2f0debff460ac112a837c89baa7cd', // Binance Smart Chain Testnet (WBNB)
+  137: '0x0d500b1d8e8ef31e21c99d1db9a6444d3adf1270', // Polygon Mainnet (WMATIC)
+  80001: '0x9c3c9283d3e44854697cd22d3faa240cfb032889', // Mumbai Testnet (WMATIC)
+  43114: '0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7', // Avalanche Mainnet (WAVAX)
+  1101: '0xa2036f0538221a77A3937F1379699f44945018d0', // Polygon zkEVM Mainnet (WETH)
+  344: '0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7', // Manta Pacific L2 Rollup (WETH)
+  132: '0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7', // Immutable zkEVM Mainnet (WETH)
+  592: '0x9fB83c0635De2E815fd1c21b3a292277540C2e8d', // Astar zkEVM (WASTR)",src/constants/v3/addresses.ts,2024-08-20 09:48:10+00:00,2024-08-20T09:52:44Z,This is wrong as well,,,,,1793,RIGHT,69,,line,https://api.github.com/repos/QuickSwap/interface-v2/pulls/1504,QuickSwap/interface-v2,83c269b439febb5297d9f29688695434245996a4
https://api.github.com/repos/QuickSwap/interface-v2/pulls/1504,https://api.github.com/repos/QuickSwap/interface-v2/pulls/comments/1723029736,sameepsi,d2c0a5ef57dc153a4ec110127636bbb5a2aaa709,2475c5e8959b31058b298d13d9791ceab031a672,"@@ -1732,3 +1775,34 @@ export class ExtendedEther extends V3Currency {
     );
   }
 }
+
+export const wrappedTokenAddresses = {
+  1: '0xC02aaa39b223FE8D0A0e5C4F27eAD9083C756Cc2', // Ethereum Mainnet (WETH)
+  3: '0xc778417E063141139Fce010982780140Aa0cD5Ab', // Ropsten Testnet (WETH)
+  4: '0xc778417E063141139Fce010982780140Aa0cD5Ab', // Rinkeby Testnet (WETH)
+  5: '0xc778417E063141139Fce010982780140Aa0cD5Ab', // Goerli Testnet (WETH)
+  42: '0xd0A1E359811322d97991E03f863a0C30C2cF029C', // Kovan Testnet (WETH)
+  56: '0xBB4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c', // Binance Smart Chain Mainnet (WBNB)
+  97: '0xae13d989dac2f0debff460ac112a837c89baa7cd', // Binance Smart Chain Testnet (WBNB)
+  137: '0x0d500b1d8e8ef31e21c99d1db9a6444d3adf1270', // Polygon Mainnet (WMATIC)
+  80001: '0x9c3c9283d3e44854697cd22d3faa240cfb032889', // Mumbai Testnet (WMATIC)
+  43114: '0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7', // Avalanche Mainnet (WAVAX)
+  1101: '0xa2036f0538221a77A3937F1379699f44945018d0', // Polygon zkEVM Mainnet (WETH)
+  344: '0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7', // Manta Pacific L2 Rollup (WETH)
+  132: '0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7', // Immutable zkEVM Mainnet (WETH)
+  592: '0x9fB83c0635De2E815fd1c21b3a292277540C2e8d', // Astar zkEVM (WASTR)
+  2000: '0x5c21a9226A2E5cd2c30bDB3A5D53E1c2325Ff55a', // DogeChain (wDOGE)",src/constants/v3/addresses.ts,2024-08-20 09:48:33+00:00,2024-08-20T09:52:44Z,This is wrong as well,,,,,1794,RIGHT,70,,line,https://api.github.com/repos/QuickSwap/interface-v2/pulls/1504,QuickSwap/interface-v2,83c269b439febb5297d9f29688695434245996a4
https://api.github.com/repos/QuickSwap/interface-v2/pulls/1504,https://api.github.com/repos/QuickSwap/interface-v2/pulls/comments/1723030686,sameepsi,d2c0a5ef57dc153a4ec110127636bbb5a2aaa709,2475c5e8959b31058b298d13d9791ceab031a672,"@@ -1732,3 +1775,34 @@ export class ExtendedEther extends V3Currency {
     );
   }
 }
+
+export const wrappedTokenAddresses = {
+  1: '0xC02aaa39b223FE8D0A0e5C4F27eAD9083C756Cc2', // Ethereum Mainnet (WETH)
+  3: '0xc778417E063141139Fce010982780140Aa0cD5Ab', // Ropsten Testnet (WETH)
+  4: '0xc778417E063141139Fce010982780140Aa0cD5Ab', // Rinkeby Testnet (WETH)
+  5: '0xc778417E063141139Fce010982780140Aa0cD5Ab', // Goerli Testnet (WETH)
+  42: '0xd0A1E359811322d97991E03f863a0C30C2cF029C', // Kovan Testnet (WETH)
+  56: '0xBB4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c', // Binance Smart Chain Mainnet (WBNB)
+  97: '0xae13d989dac2f0debff460ac112a837c89baa7cd', // Binance Smart Chain Testnet (WBNB)
+  137: '0x0d500b1d8e8ef31e21c99d1db9a6444d3adf1270', // Polygon Mainnet (WMATIC)
+  80001: '0x9c3c9283d3e44854697cd22d3faa240cfb032889', // Mumbai Testnet (WMATIC)
+  43114: '0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7', // Avalanche Mainnet (WAVAX)
+  1101: '0xa2036f0538221a77A3937F1379699f44945018d0', // Polygon zkEVM Mainnet (WETH)
+  344: '0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7', // Manta Pacific L2 Rollup (WETH)
+  132: '0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7', // Immutable zkEVM Mainnet (WETH)
+  592: '0x9fB83c0635De2E815fd1c21b3a292277540C2e8d', // Astar zkEVM (WASTR)
+  2000: '0x5c21a9226A2E5cd2c30bDB3A5D53E1c2325Ff55a', // DogeChain (wDOGE)
+  2010: '0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7', // X Layer (WETH)",src/constants/v3/addresses.ts,2024-08-20 09:49:11+00:00,2024-08-20T09:52:44Z,i am assuming this is wrong as well,,,,,1795,RIGHT,71,,line,https://api.github.com/repos/QuickSwap/interface-v2/pulls/1504,QuickSwap/interface-v2,83c269b439febb5297d9f29688695434245996a4
https://api.github.com/repos/QuickSwap/interface-v2/pulls/1504,https://api.github.com/repos/QuickSwap/interface-v2/pulls/comments/1723030861,sameepsi,d2c0a5ef57dc153a4ec110127636bbb5a2aaa709,2475c5e8959b31058b298d13d9791ceab031a672,"@@ -1732,3 +1775,34 @@ export class ExtendedEther extends V3Currency {
     );
   }
 }
+
+export const wrappedTokenAddresses = {
+  1: '0xC02aaa39b223FE8D0A0e5C4F27eAD9083C756Cc2', // Ethereum Mainnet (WETH)
+  3: '0xc778417E063141139Fce010982780140Aa0cD5Ab', // Ropsten Testnet (WETH)
+  4: '0xc778417E063141139Fce010982780140Aa0cD5Ab', // Rinkeby Testnet (WETH)
+  5: '0xc778417E063141139Fce010982780140Aa0cD5Ab', // Goerli Testnet (WETH)
+  42: '0xd0A1E359811322d97991E03f863a0C30C2cF029C', // Kovan Testnet (WETH)
+  56: '0xBB4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c', // Binance Smart Chain Mainnet (WBNB)
+  97: '0xae13d989dac2f0debff460ac112a837c89baa7cd', // Binance Smart Chain Testnet (WBNB)
+  137: '0x0d500b1d8e8ef31e21c99d1db9a6444d3adf1270', // Polygon Mainnet (WMATIC)
+  80001: '0x9c3c9283d3e44854697cd22d3faa240cfb032889', // Mumbai Testnet (WMATIC)
+  43114: '0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7', // Avalanche Mainnet (WAVAX)
+  1101: '0xa2036f0538221a77A3937F1379699f44945018d0', // Polygon zkEVM Mainnet (WETH)
+  344: '0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7', // Manta Pacific L2 Rollup (WETH)
+  132: '0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7', // Immutable zkEVM Mainnet (WETH)
+  592: '0x9fB83c0635De2E815fd1c21b3a292277540C2e8d', // Astar zkEVM (WASTR)
+  2000: '0x5c21a9226A2E5cd2c30bDB3A5D53E1c2325Ff55a', // DogeChain (wDOGE)
+  2010: '0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7', // X Layer (WETH)
+  2222: '0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee', // Kava - Kinetix (WKAVA)",src/constants/v3/addresses.ts,2024-08-20 09:49:19+00:00,2024-08-20T09:52:44Z,this is wrong as well,,,,,1796,RIGHT,72,,line,https://api.github.com/repos/QuickSwap/interface-v2/pulls/1504,QuickSwap/interface-v2,83c269b439febb5297d9f29688695434245996a4
https://api.github.com/repos/QuickSwap/interface-v2/pulls/742,https://api.github.com/repos/QuickSwap/interface-v2/pulls/comments/1161594299,sameepsi,15c38bbb35855cfc8e0482b3df470b2fb19ce634,56be4372b041167ef725ae120ad9c9a5e8e015b4,"@@ -5,7 +5,9 @@ import zkmainnet from './zkmainnet.json';
 import { ChainId } from '@uniswap/sdk';
 const configs: any = {
   [ChainId.MATIC]: polygon,
+  [ChainId.MUMBAI]: polygon,",src/config/index.ts,2023-04-10 09:52:41+00:00,2023-04-10T17:05:53Z,what is this?,,,,,8,RIGHT,4,,line,https://api.github.com/repos/QuickSwap/interface-v2/pulls/742,QuickSwap/interface-v2,0a29cb26327b5659801d0d05881152807408fff0
https://api.github.com/repos/QuickSwap/interface-v2/pulls/742,https://api.github.com/repos/QuickSwap/interface-v2/pulls/comments/1161594674,sameepsi,15c38bbb35855cfc8e0482b3df470b2fb19ce634,56be4372b041167ef725ae120ad9c9a5e8e015b4,"@@ -5,7 +5,9 @@ import zkmainnet from './zkmainnet.json';
 import { ChainId } from '@uniswap/sdk';
 const configs: any = {
   [ChainId.MATIC]: polygon,
+  [ChainId.MUMBAI]: polygon,
   [ChainId.DOGECHAIN]: dogechain,
+  [ChainId.DOEGCHAIN_TESTNET]: dogechain,",src/config/index.ts,2023-04-10 09:53:23+00:00,2023-04-10T17:05:53Z,same here,,,,,10,RIGHT,6,,line,https://api.github.com/repos/QuickSwap/interface-v2/pulls/742,QuickSwap/interface-v2,0a29cb26327b5659801d0d05881152807408fff0
https://api.github.com/repos/QuickSwap/interface-v2/pulls/742,https://api.github.com/repos/QuickSwap/interface-v2/pulls/comments/1161594787,sameepsi,15c38bbb35855cfc8e0482b3df470b2fb19ce634,56be4372b041167ef725ae120ad9c9a5e8e015b4,"@@ -5,7 +5,9 @@ import zkmainnet from './zkmainnet.json';
 import { ChainId } from '@uniswap/sdk';
 const configs: any = {
   [ChainId.MATIC]: polygon,
+  [ChainId.MUMBAI]: polygon,
   [ChainId.DOGECHAIN]: dogechain,
+  [ChainId.DOEGCHAIN_TESTNET]: dogechain,
   [ChainId.ZKTESTNET]: zktestnet,",src/config/index.ts,2023-04-10 09:53:35+00:00,2023-04-10T17:05:53Z,same here,,,,,11,RIGHT,7,,line,https://api.github.com/repos/QuickSwap/interface-v2/pulls/742,QuickSwap/interface-v2,0a29cb26327b5659801d0d05881152807408fff0
https://api.github.com/repos/QuickSwap/interface-v2/pulls/798,https://api.github.com/repos/QuickSwap/interface-v2/pulls/comments/1188376053,sameepsi,699e03aa920964b9a20f3af9a5be2f7646d61fdb,ff3bdc0acf59a608fe81b484898960ffe30a8732,"@@ -29,10 +29,10 @@
     ""@uniswap/liquidity-staker"": ""^1.0.2"",
     ""@uniswap/merkle-distributor"": ""1.0.1"",
     ""@uniswap/sdk"": ""npm:quickswap-sdk@3.0.20"",
+    ""@uniswap/sdk-core"": ""^3.2.2"",
     ""@uniswap/token-lists"": ""npm:quickswap-token-lists@1.0.1"",
     ""@uniswap/v2-core"": ""1.0.0"",
     ""@uniswap/v2-periphery"": ""^1.1.0-beta.0"",
-    ""@uniswap/v3-sdk"": ""^3.9.0"",",package.json,2023-05-09 09:27:03+00:00,2023-05-12T06:26:37Z,Why did you remove this?,,,,35.0,35,LEFT,8,8.0,line,https://api.github.com/repos/QuickSwap/interface-v2/pulls/798,QuickSwap/interface-v2,3a854bec2ebd84162ad6fe1be7b4fbc567dd0682
https://api.github.com/repos/QuickSwap/interface-v2/pulls/798,https://api.github.com/repos/QuickSwap/interface-v2/pulls/comments/1188376365,sameepsi,699e03aa920964b9a20f3af9a5be2f7646d61fdb,ff3bdc0acf59a608fe81b484898960ffe30a8732,"@@ -29,10 +29,10 @@
     ""@uniswap/liquidity-staker"": ""^1.0.2"",
     ""@uniswap/merkle-distributor"": ""1.0.1"",
     ""@uniswap/sdk"": ""npm:quickswap-sdk@3.0.20"",
+    ""@uniswap/sdk-core"": ""^3.2.2"",",package.json,2023-05-09 09:27:19+00:00,2023-05-12T06:26:37Z,Why its added as part of venly integration?,,,,32.0,32,RIGHT,4,4.0,line,https://api.github.com/repos/QuickSwap/interface-v2/pulls/798,QuickSwap/interface-v2,3a854bec2ebd84162ad6fe1be7b4fbc567dd0682
https://api.github.com/repos/QuickSwap/interface-v2/pulls/798,https://api.github.com/repos/QuickSwap/interface-v2/pulls/comments/1188376978,sameepsi,699e03aa920964b9a20f3af9a5be2f7646d61fdb,ff3bdc0acf59a608fe81b484898960ffe30a8732,"@@ -8,7 +7,7 @@ import { Connector } from '@web3-react/types';
 import { WalletConnectPopup } from './WalletConnect';
 // import { UAuthConnector } from '@uauth/web3-react';
 // import { FortmaticConnector } from './Fortmatic';
-// import { ArkaneConnector } from './Arkane';",src/connectors/index.ts,2023-05-09 09:27:51+00:00,2023-05-12T06:26:37Z,Please remove all comments,,,,11.0,11,LEFT,9,11.0,line,https://api.github.com/repos/QuickSwap/interface-v2/pulls/798,QuickSwap/interface-v2,3a854bec2ebd84162ad6fe1be7b4fbc567dd0682
https://api.github.com/repos/QuickSwap/interface-v2/pulls/798,https://api.github.com/repos/QuickSwap/interface-v2/pulls/comments/1188377222,sameepsi,699e03aa920964b9a20f3af9a5be2f7646d61fdb,ff3bdc0acf59a608fe81b484898960ffe30a8732,"@@ -264,38 +264,34 @@ export const zengoConnectConnection: Connection = {
   mobile: true,
 };
 
-// mainnet only",src/connectors/index.ts,2023-05-09 09:28:01+00:00,2023-05-12T06:26:37Z,remove all comments,,,,267.0,267,LEFT,26,33.0,line,https://api.github.com/repos/QuickSwap/interface-v2/pulls/798,QuickSwap/interface-v2,3a854bec2ebd84162ad6fe1be7b4fbc567dd0682
https://api.github.com/repos/QuickSwap/interface-v2/pulls/798,https://api.github.com/repos/QuickSwap/interface-v2/pulls/comments/1188377629,sameepsi,699e03aa920964b9a20f3af9a5be2f7646d61fdb,ff3bdc0acf59a608fe81b484898960ffe30a8732,"@@ -11,7 +11,6 @@ import invariant from 'tiny-invariant';
 import { Trade } from './trade';
 import { PermitOptions, SelfPermit } from './selfPermit';
 import { MethodParameters, toHex } from './utils/calldata';
-// import { abi } from '@uniswap/v3-periphery/artifacts/contracts/SwapRouter.sol/SwapRouter.json'",src/lib/src/swapRouter.ts,2023-05-09 09:28:22+00:00,2023-05-12T06:26:37Z,remove it,,,,14.0,14,LEFT,4,4.0,line,https://api.github.com/repos/QuickSwap/interface-v2/pulls/798,QuickSwap/interface-v2,3a854bec2ebd84162ad6fe1be7b4fbc567dd0682
https://api.github.com/repos/pokt-network/pocket/pulls/637,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1153374492,deblasis,760ee2fc07805a071d3dbb6f3aa67b06e0b34e30,104fb2983f607997a60bec0c7034ff2f0bb19ede,"@@ -113,3 +114,20 @@ func (view *sortedPeersView) sortAddrs(startAddr crypto.Address) {
 	}
 	view.sortedAddrs = append(view.sortedAddrs[i:len(view.sortedAddrs)], view.sortedAddrs[0:i]...)
 }
+
+// getAddrIndex returns the sortedAddrs index at which the given address is stored
+// or at which to insert it if not present.
+func (view *sortedPeersView) getAddrIndex(addr crypto.Address) int {
+	wrapIdx := sort.Search(len(view.sortedAddrs), func(visitIdx int) bool {
+		return view.sortedAddrs[visitIdx] < view.sortedAddrs[0]
+	})
+
+	frontAddrs := view.sortedAddrs[:wrapIdx]
+	backAddrs := view.sortedAddrs[wrapIdx:]
+	i := sort.SearchStrings(frontAddrs, addr.String())
+	if i == 0 {",p2p/types/peers_view.go,2023-03-30 14:44:18+00:00,2023-03-30T14:44:20Z,"Here I would add a simple comment explaining the ""why"" of this.
At a glance, I am a bit confused because I remember that `SearchString` returns `len(a)` when something is not found and that's, generally speaking, the most common check that's done after searching for a needle in a haystack.

Wdyt?",,,,144.0,128,RIGHT,47,73.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/637,pokt-network/pocket,c58ea5e678d536d228f6758f028767d071ffc481
https://api.github.com/repos/pokt-network/pocket/pulls/637,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1153397224,deblasis,760ee2fc07805a071d3dbb6f3aa67b06e0b34e30,104fb2983f607997a60bec0c7034ff2f0bb19ede,"@@ -1,9 +1,123 @@
 package types
 
 import (
+	""strings""
 	""testing""
+
+	""github.com/stretchr/testify/require""
+
+	cryptoPocket ""github.com/pokt-network/pocket/shared/crypto""
 )
 
+func TestSortedPeersView_Add_Remove(t *testing.T) {
+	testCases := []struct {
+		name          string
+		selfAddr      string
+		addAddrs      string
+		removeAddrs   string
+		expectedAddrs string
+	}{
+		{
+			""highest self address"",
+			""A"",
+			""BC"",
+			"""",
+			""ABC"",
+		},",p2p/types/peers_view_test.go,2023-03-30 14:59:00+00:00,2023-03-30T14:59:03Z,"I understand that cool people don't use VSCode but other editors that show a ""hint"" about the name of the variables from the context. :)

That said, I don't have a strong opinion, feel free to ignore completely but I would consider making the test cases definitions more verbose, I bothered writing this just because all the arguments are strings. This way I don't have to scroll and read what is argument at index 2 if that makes sense.

Something like this (and below): 

```suggestion
		{
			name:          ""highest self address"",
			selfAddr:      ""A"",
			addAddrs:      ""BC"",
			removeAddrs:   """",
			expectedAddrs: ""ABC"",
		},
```

If it sounds overkill, I get it. Ignore.
",,20.0,RIGHT,,26,RIGHT,26,,line,https://api.github.com/repos/pokt-network/pocket/pulls/637,pokt-network/pocket,c58ea5e678d536d228f6758f028767d071ffc481
https://api.github.com/repos/pokt-network/pocket/pulls/637,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1160206002,Olshansk,760ee2fc07805a071d3dbb6f3aa67b06e0b34e30,104fb2983f607997a60bec0c7034ff2f0bb19ede,"@@ -98,9 +99,9 @@ func (view *sortedPeersView) init(startAddr crypto.Address, pstore Peerstore) *s
 	return view
 }
 
-// sortAddrs sorts addresses in `sortedAddrs` lexicographically but then `startAddr`
-// is moved to be first in the list. This makes RainTree propagation easier to
-// compute and interpret.
+// sortAddrs sorts addresses in `sortedAddrs` lexicographically then shifts
+// `startAddr` to the first index, moving any preceding values to the end
+// of the list; effectively preserving the order by ""wrapping around"".",p2p/types/peers_view.go,2023-04-06 20:10:05+00:00,2023-04-06T22:31:55Z,"Add an example:

sorted peers: [a b c d e f g]
highlight start: [a b c d *e* f g]
shift: [e f g a b c d]",,,,106.0,104,RIGHT,28,40.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/637,pokt-network/pocket,c58ea5e678d536d228f6758f028767d071ffc481
https://api.github.com/repos/pokt-network/pocket/pulls/637,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1160307598,Olshansk,760ee2fc07805a071d3dbb6f3aa67b06e0b34e30,104fb2983f607997a60bec0c7034ff2f0bb19ede,"@@ -113,3 +114,20 @@ func (view *sortedPeersView) sortAddrs(startAddr crypto.Address) {
 	}
 	view.sortedAddrs = append(view.sortedAddrs[i:len(view.sortedAddrs)], view.sortedAddrs[0:i]...)
 }
+
+// getAddrIndex returns the sortedAddrs index at which the given address is stored
+// or at which to insert it if not present.
+func (view *sortedPeersView) getAddrIndex(addr crypto.Address) int {
+	wrapIdx := sort.Search(len(view.sortedAddrs), func(visitIdx int) bool {",p2p/types/peers_view.go,2023-04-06 22:28:39+00:00,2023-04-06T22:31:55Z,Can you add a comment of what this sort.Search does?,,,,134.0,121,RIGHT,40,63.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/637,pokt-network/pocket,c58ea5e678d536d228f6758f028767d071ffc481
https://api.github.com/repos/pokt-network/pocket/pulls/637,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1160308261,Olshansk,760ee2fc07805a071d3dbb6f3aa67b06e0b34e30,104fb2983f607997a60bec0c7034ff2f0bb19ede,"@@ -1,9 +1,123 @@
 package types
 
 import (
+	""strings""
 	""testing""
+
+	""github.com/stretchr/testify/require""
+
+	cryptoPocket ""github.com/pokt-network/pocket/shared/crypto""
 )
 
+func TestSortedPeersView_Add_Remove(t *testing.T) {
+	testCases := []struct {
+		name          string
+		selfAddr      string
+		addAddrs      string
+		removeAddrs   string
+		expectedAddrs string
+	}{
+		{
+			""highest self address"",",p2p/types/peers_view_test.go,2023-04-06 22:30:14+00:00,2023-04-06T22:31:55Z,Should this be `lowest` (and the next one `highest`)?,,,,,21,RIGHT,21,,line,https://api.github.com/repos/pokt-network/pocket/pulls/637,pokt-network/pocket,c58ea5e678d536d228f6758f028767d071ffc481
https://api.github.com/repos/pokt-network/pocket/pulls/637,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1167263010,Olshansk,d01d4f75c816aa39c76794e924301b922b96f5eb,104fb2983f607997a60bec0c7034ff2f0bb19ede,"@@ -105,6 +103,62 @@ func TestSortedPeersView_Remove(t *testing.T) {
 	t.Skip(""TECHDEBT(#554): test that this method works as expected when target peer/addr is not in the list!"")
 }
 
+func TestSortedPeersView(t *testing.T) {
+	testCases := []struct {
+		name              string
+		selfAddr          string
+		initialAddrs      string
+		expectedSortOrder string
+	}{
+		{
+			name:              ""lowest self address"",
+			selfAddr:          ""A"",
+			initialAddrs:      ""BDCEA"",
+			expectedSortOrder: ""ABCDE"",
+		},
+		{
+			name:              ""highest self address"",
+			selfAddr:          ""E"",
+			initialAddrs:      ""BDCEA"",
+			expectedSortOrder: ""EABCD"",
+		},
+		{
+			name:              ""middle self address"",
+			selfAddr:          ""C"",
+			initialAddrs:      ""BDCEA"",
+			expectedSortOrder: ""CDEAB"",
+		},
+	}
+	for _, testCase := range testCases {
+		t.Run(testCase.name, func(t *testing.T) {
+			selfAddr := cryptoPocket.Address(testCase.selfAddr)
+
+			pstore := make(PeerAddrMap)
+			var initialPeers []Peer",p2p/types/peers_view_test.go,2023-04-14 20:48:34+00:00,2023-04-14T20:59:39Z,"Confirming that this works?

<img width=""702"" alt=""Screenshot 2023-04-14 at 1 48 19 PM"" src=""https://user-images.githubusercontent.com/1892194/232151797-3b55e473-4427-4e2f-bfe3-cf5640f0b020.png"">
",,,,137.0,137,RIGHT,98,137.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/637,pokt-network/pocket,c58ea5e678d536d228f6758f028767d071ffc481
https://api.github.com/repos/pokt-network/pocket/pulls/622,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1160035218,Olshansk,45cfd2bf399fe10c8ddab2655b8384c9b429b9f8,c0a96add056e9fdff4fdbeb3cf456355c5520b65,"@@ -533,3 +533,7 @@ check_cross_module_imports: ## Lists cross-module imports
 .PHONY: send_local_tx
 send_local_tx: ## A hardcoded send tx to make LocalNet debugging easier
 	go run -tags=debug app/client/*.go Account Send --non_interactive 00104055c00bed7c983a48aac7dc6335d7c607a7 00204737d2a165ebe4be3a7d5b0af905b0ea91d8 1000
+
+.PHONY: query_node_params
+query_node_params: ## A hardcoded NodeParams query to make LocalNet debugging easier
+	go run app/client/main.go System NodeParams",Makefile,2023-04-06 16:44:50+00:00,2023-04-06T23:32:31Z,"Let's add a `Query` subcommand for this.

![Screenshot 2023-04-06 at 9 44 06 AM](https://user-images.githubusercontent.com/1892194/230443116-f486dca2-646e-4385-8739-cdd83a3a809c.png)
",,,,,539,RIGHT,7,,line,https://api.github.com/repos/pokt-network/pocket/pulls/622,pokt-network/pocket,6b9b2db0f25b5fb605c1cb6d454b47708ff4eacd
https://api.github.com/repos/pokt-network/pocket/pulls/622,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1160035410,Olshansk,45cfd2bf399fe10c8ddab2655b8384c9b429b9f8,c0a96add056e9fdff4fdbeb3cf456355c5520b65,"@@ -74,6 +76,33 @@ func systemCommands() []*cobra.Command {
 				return rpcResponseCodeUnhealthy(statusCode, response.Body)
 			},
 		},
+		{
+			Use:     ""NodeParams"",",app/client/cli/system.go,2023-04-06 16:45:02+00:00,2023-04-06T23:32:31Z,"We should either do `AllGovParams` or `AllChainParams`. I'm learning towards the latter

Ditto all related code / functions.",,,,,80,RIGHT,14,,line,https://api.github.com/repos/pokt-network/pocket/pulls/622,pokt-network/pocket,6b9b2db0f25b5fb605c1cb6d454b47708ff4eacd
https://api.github.com/repos/pokt-network/pocket/pulls/622,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1160151700,Olshansk,010c045d060cf8114d09066846c1f7d1fe5f7318,c0a96add056e9fdff4fdbeb3cf456355c5520b65,"@@ -74,6 +76,33 @@ func systemCommands() []*cobra.Command {
 				return rpcResponseCodeUnhealthy(statusCode, response.Body)
 			},
 		},
+		{
+			Use:     ""NodeParams"",
+			Short:   ""Get current values of all node parameters"",
+			Long:    ""Queries the node RPC to obtain the current values of all the governance parameters"",
+			Aliases: []string{""nodeparams""},
+			RunE: func(cmd *cobra.Command, args []string) error {
+				client, err := rpc.NewClientWithResponses(remoteCLIURL)
+				if err != nil {
+					return err
+				}
+				response, err := client.GetV1QueryNodeParams(cmd.Context())
+				if err != nil {
+					return unableToConnectToRpc(err)
+				}
+				statusCode := response.StatusCode
+				body, err := io.ReadAll(response.Body)
+				if err != nil {
+					logger.Global.Error().Err(err).Msg(""Error reading response body"")
+					return err
+				}
+				if statusCode == http.StatusOK {
+					fmt.Println(string(body))
+					return nil",app/client/cli/system.go,2023-04-06 18:58:23+00:00,2023-04-06T23:32:31Z,"So we're not actually returning anything?

In v0, we can do this: `curl --location -X 'POST' -H 'Content-Type: application/json' ""${POCKET_ENDPOINT}/v1/query/allParams"" | jq` and parse it with jq. Ideally it's what we'd be doing here too.",,,,,101,RIGHT,35,,line,https://api.github.com/repos/pokt-network/pocket/pulls/622,pokt-network/pocket,6b9b2db0f25b5fb605c1cb6d454b47708ff4eacd
https://api.github.com/repos/pokt-network/pocket/pulls/622,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1160156418,Olshansk,010c045d060cf8114d09066846c1f7d1fe5f7318,c0a96add056e9fdff4fdbeb3cf456355c5520b65,"@@ -189,5 +189,26 @@ func TestGetSetToggleByteArrayFlag(t *testing.T) {
 
 	require.Equal(t, newOwner, owner)
 	require.Equal(t, true, enabled)
+}
+
+func TestGetAllParams(t *testing.T) {
+	db := NewTestPostgresContext(t, 0)
 
+	err := db.InitGenesisParams(test_artifacts.DefaultParams())
+	require.NoError(t, err)
+
+	appMaxChain, err := db.GetStringParam(AppMaxChainsParamName, 0)",persistence/test/gov_test.go,2023-04-06 19:04:30+00:00,2023-04-06T23:32:31Z,What if you assign all the param names to an array and have a loop to validate it? It'll be a one line change as we add more.,,,,,200,RIGHT,30,,line,https://api.github.com/repos/pokt-network/pocket/pulls/622,pokt-network/pocket,6b9b2db0f25b5fb605c1cb6d454b47708ff4eacd
https://api.github.com/repos/pokt-network/pocket/pulls/622,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1160156948,Olshansk,010c045d060cf8114d09066846c1f7d1fe5f7318,c0a96add056e9fdff4fdbeb3cf456355c5520b65,"@@ -189,5 +189,26 @@ func TestGetSetToggleByteArrayFlag(t *testing.T) {
 
 	require.Equal(t, newOwner, owner)
 	require.Equal(t, true, enabled)
+}
+
+func TestGetAllParams(t *testing.T) {",persistence/test/gov_test.go,2023-04-06 19:05:09+00:00,2023-04-06T23:32:31Z,"If we have an array with all the parameters, can we actually test `AllParams`? Seems you called it `utils.GovParamMetadataKey`",,,,196.0,194,RIGHT,24,34.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/622,pokt-network/pocket,6b9b2db0f25b5fb605c1cb6d454b47708ff4eacd
https://api.github.com/repos/pokt-network/pocket/pulls/622,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1160159414,Olshansk,010c045d060cf8114d09066846c1f7d1fe5f7318,c0a96add056e9fdff4fdbeb3cf456355c5520b65,"@@ -50,6 +51,35 @@ func (s *rpcServer) GetV1ConsensusState(ctx echo.Context) error {
 	})
 }
 
+func (s *rpcServer) GetV1QueryNodeParams(ctx echo.Context) error {",rpc/handlers.go,2023-04-06 19:08:11+00:00,2023-04-06T23:32:31Z,"Let's rename to `QueryAllParams` or `QueryGovParams` (per my previous comment).

Also, can you leave a `CONSIDERATION: consider removing v1 prefixes in the rpc module`. I'm not 100% sure we need it.",,,,,54,RIGHT,12,,line,https://api.github.com/repos/pokt-network/pocket/pulls/622,pokt-network/pocket,6b9b2db0f25b5fb605c1cb6d454b47708ff4eacd
https://api.github.com/repos/pokt-network/pocket/pulls/622,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1160163345,Olshansk,010c045d060cf8114d09066846c1f7d1fe5f7318,c0a96add056e9fdff4fdbeb3cf456355c5520b65,"@@ -50,6 +51,35 @@ func (s *rpcServer) GetV1ConsensusState(ctx echo.Context) error {
 	})
 }
 
+func (s *rpcServer) GetV1QueryNodeParams(ctx echo.Context) error {
+	currHeight := s.GetBus().GetConsensusModule().CurrentHeight()
+	persistenceRC, err := s.GetBus().GetPersistenceModule().NewReadContext(int64(currHeight))",rpc/handlers.go,2023-04-06 19:13:31+00:00,2023-04-06T23:32:31Z,s/persistenceRC/readCtx,,,,,56,RIGHT,14,,line,https://api.github.com/repos/pokt-network/pocket/pulls/622,pokt-network/pocket,6b9b2db0f25b5fb605c1cb6d454b47708ff4eacd
https://api.github.com/repos/pokt-network/pocket/pulls/622,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1160164787,Olshansk,010c045d060cf8114d09066846c1f7d1fe5f7318,c0a96add056e9fdff4fdbeb3cf456355c5520b65,"@@ -50,6 +51,35 @@ func (s *rpcServer) GetV1ConsensusState(ctx echo.Context) error {
 	})
 }
 
+func (s *rpcServer) GetV1QueryNodeParams(ctx echo.Context) error {
+	currHeight := s.GetBus().GetConsensusModule().CurrentHeight()
+	persistenceRC, err := s.GetBus().GetPersistenceModule().NewReadContext(int64(currHeight))
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+	paramValueMap, err := persistenceRC.GetAllParams()
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+	parameterKeyValues := make([]*paramValue, 0)
+	keys := make([]string, 0)
+	for key := range paramValueMap {
+		keys = append(keys, key)
+	}
+	sort.Strings(keys)",rpc/handlers.go,2023-04-06 19:15:27+00:00,2023-04-06T23:32:31Z,"TAtry sorting at the DB level, it'll be 100x faster and remove some of the code you have here.",,,,,69,RIGHT,27,,line,https://api.github.com/repos/pokt-network/pocket/pulls/622,pokt-network/pocket,6b9b2db0f25b5fb605c1cb6d454b47708ff4eacd
https://api.github.com/repos/pokt-network/pocket/pulls/622,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1160293589,Olshansk,010c045d060cf8114d09066846c1f7d1fe5f7318,c0a96add056e9fdff4fdbeb3cf456355c5520b65,"@@ -215,11 +189,41 @@ func (p *PostgresContext) getFlagsUpdated(height int64) ([]*coreTypes.Flag, erro
 	return flagSlice, nil
 }
 
+// GetAllParams returns a map of the current latest updated values for all parameters
+// and their values in the form map[parameterName] = parameterValue
+func (p *PostgresContext) GetAllParams() (map[string]string, error) {
+	ctx, tx := p.getCtxAndTx()
+	// Get all the parameters in their most recently updated form
+	rows, err := tx.Query(ctx, p.getLatestParamsOrFlagsQuery(types.ParamsTableName))
+	if err != nil {
+		return nil, err
+	}
+	defer rows.Close()
+	paramValueMap := make(map[string]string)
+	for rows.Next() {
+		var paramName, paramValue string
+		if err := rows.Scan(&paramName, &paramValue); err != nil {
+			return nil, err
+		}
+		paramValueMap[paramName] = paramValue
+	}
+	return paramValueMap, nil
+}
+
 func (p *PostgresContext) getParamsOrFlagsUpdateAtHeightQuery(tableName string, height int64) string {
 	fields := ""name,value""
 	if tableName == types.FlagsTableName {
 		fields += "",enabled""
 	}
 	// Build correct query to get all Params/Flags at certain height ordered by their name values
-	return fmt.Sprintf(`SELECT %s FROM %s WHERE height=%d ORDER BY name ASC`, fields, tableName, height)
+	return fmt.Sprintf(""SELECT %s FROM %s WHERE height=%d ORDER BY name ASC"", fields, tableName, height)",persistence/gov.go,2023-04-06 22:04:28+00:00,2023-04-06T23:32:31Z,"If we're sorting by name here, why do we also need to sort in code earlier?",,,,219.0,219,RIGHT,112,112.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/622,pokt-network/pocket,6b9b2db0f25b5fb605c1cb6d454b47708ff4eacd
https://api.github.com/repos/pokt-network/pocket/pulls/622,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1160294627,Olshansk,010c045d060cf8114d09066846c1f7d1fe5f7318,c0a96add056e9fdff4fdbeb3cf456355c5520b65,"@@ -33,498 +129,71 @@ func (u *baseUtilityUnitOfWork) updateParam(paramName string, value any) typesUt
 	return typesUtil.ErrUnknownParam(paramName)
 }
 
-func (u *baseUtilityUnitOfWork) getParameter(paramName string) (any, error) {",utility/unit_of_work/gov.go,2023-04-06 22:06:41+00:00,2023-04-06T23:32:31Z,Fucking amazing,,,,36.0,36,LEFT,113,126.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/622,pokt-network/pocket,6b9b2db0f25b5fb605c1cb6d454b47708ff4eacd
https://api.github.com/repos/pokt-network/pocket/pulls/622,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1160295772,Olshansk,010c045d060cf8114d09066846c1f7d1fe5f7318,c0a96add056e9fdff4fdbeb3cf456355c5520b65,"@@ -3,12 +3,108 @@ package unit_of_work
 import (
 	""math/big""
 
+	""github.com/pokt-network/pocket/persistence""
 	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
 	""github.com/pokt-network/pocket/shared/utils""
 	typesUtil ""github.com/pokt-network/pocket/utility/types""
 	""google.golang.org/protobuf/types/known/wrapperspb""
 )
 
+func init() {
+	GovParams = generateParamConfigs()
+}
+
+var (
+	GovParams map[string]int
+)
+
+const (
+	BIGINT int = iota
+	INT
+	INT64
+	BYTES
+	STRING
+)
+
+func generateParamConfigs() map[string]int {
+	return map[string]int{
+		typesUtil.AppMinimumStakeParamName:                 BIGINT,
+		typesUtil.AppMaxChainsParamName:                    INT,
+		typesUtil.AppSessionTokensMultiplierParamName:      INT,
+		typesUtil.AppUnstakingBlocksParamName:              INT64,
+		typesUtil.AppMinimumPauseBlocksParamName:           INT,
+		typesUtil.AppMaxPauseBlocksParamName:               INT,
+		typesUtil.BlocksPerSessionParamName:                INT,
+		typesUtil.ServicerMinimumStakeParamName:            BIGINT,
+		typesUtil.ServicerMaxChainsParamName:               INT,
+		typesUtil.ServicerUnstakingBlocksParamName:         INT64,
+		typesUtil.ServicerMinimumPauseBlocksParamName:      INT,
+		typesUtil.ServicerMaxPauseBlocksParamName:          INT,
+		typesUtil.ServicersPerSessionParamName:             INT,
+		typesUtil.ValidatorMinimumStakeParamName:           BIGINT,
+		typesUtil.ValidatorUnstakingBlocksParamName:        INT64,
+		typesUtil.ValidatorMinimumPauseBlocksParamName:     INT,
+		typesUtil.ValidatorMaxPausedBlocksParamName:        INT,
+		typesUtil.ProposerPercentageOfFeesParamName:        INT,
+		typesUtil.ValidatorMaximumMissedBlocksParamName:    INT,
+		typesUtil.ValidatorMaxEvidenceAgeInBlocksParamName: INT,
+		typesUtil.DoubleSignBurnPercentageParamName:        INT,
+		typesUtil.MissedBlocksBurnPercentageParamName:      INT,
+		typesUtil.FishermanMinimumStakeParamName:           BIGINT,
+		typesUtil.FishermanMaxChainsParamName:              INT,
+		typesUtil.FishermanUnstakingBlocksParamName:        INT64,
+		typesUtil.FishermanMinimumPauseBlocksParamName:     INT,
+		typesUtil.FishermanMaxPauseBlocksParamName:         INT,
+		typesUtil.MessageDoubleSignFee:                     BIGINT,
+		typesUtil.MessageSendFee:                           BIGINT,
+		typesUtil.MessageStakeFishermanFee:                 BIGINT,
+		typesUtil.MessageEditStakeFishermanFee:             BIGINT,
+		typesUtil.MessageUnpauseFishermanFee:               BIGINT,
+		typesUtil.MessageFishermanPauseServicerFee:         BIGINT,
+		typesUtil.MessageTestScoreFee:                      BIGINT,
+		typesUtil.MessageProveTestScoreFee:                 BIGINT,
+		typesUtil.MessageStakeAppFee:                       BIGINT,
+		typesUtil.MessageEditStakeAppFee:                   BIGINT,
+		typesUtil.MessageUnstakeAppFee:                     BIGINT,
+		typesUtil.MessagePauseAppFee:                       BIGINT,
+		typesUtil.MessageUnpauseAppFee:                     BIGINT,
+		typesUtil.MessageStakeValidatorFee:                 BIGINT,
+		typesUtil.MessageEditStakeValidatorFee:             BIGINT,
+		typesUtil.MessageUnstakeValidatorFee:               BIGINT,
+		typesUtil.MessagePauseValidatorFee:                 BIGINT,
+		typesUtil.MessageUnpauseValidatorFee:               BIGINT,
+		typesUtil.MessageStakeServicerFee:                  BIGINT,
+		typesUtil.MessageEditStakeServicerFee:              BIGINT,
+		typesUtil.MessageUnstakeServicerFee:                BIGINT,
+		typesUtil.MessagePauseServicerFee:                  BIGINT,
+		typesUtil.MessageUnpauseServicerFee:                BIGINT,
+		typesUtil.MessageChangeParameterFee:                BIGINT,
+	}
+}
+
+func getGovParam[T *big.Int | int | int64 | []byte | string](u *baseUtilityUnitOfWork, paramName string) (i T, err typesUtil.Error) {",utility/unit_of_work/gov.go,2023-04-06 22:08:47+00:00,2023-04-06T23:32:31Z,"Thoughts on making this a receiver of uow so you don't have to pass it in?
```suggestion
func (uow *baseUtilityUnitOfWork) getGovParam[T *big.Int | int | int64 | []byte | string](paramName string) (i T, err typesUtil.Error) {
```",,,,,85,RIGHT,83,,line,https://api.github.com/repos/pokt-network/pocket/pulls/622,pokt-network/pocket,6b9b2db0f25b5fb605c1cb6d454b47708ff4eacd
https://api.github.com/repos/pokt-network/pocket/pulls/622,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1160301264,Olshansk,010c045d060cf8114d09066846c1f7d1fe5f7318,c0a96add056e9fdff4fdbeb3cf456355c5520b65,"@@ -13,498 +16,64 @@ import (
 	""google.golang.org/protobuf/types/known/wrapperspb""
 )
 
-// TODO : After we change the interface to pass param name, simply use reflection to
-//  iterate over all the params and test them. Suggestion: [Google's go-cmp] (https://github.com/google/go-cmp)
-
 func DefaultTestingParams(_ *testing.T) *genesis.Params {
 	return test_artifacts.DefaultParams()
 }
 
-func TestUtilityUnitOfWork_GetAppMaxChains(t *testing.T) {
-	uow := newTestingUtilityUnitOfWork(t, 0)
-	defaultParams := DefaultTestingParams(t)
-	maxChains, err := uow.getAppMaxChains()
-	require.NoError(t, err)
-	require.Equal(t, int(defaultParams.GetAppMaxChains()), maxChains)
-}
-
-func TestUtilityUnitOfWork_GetAppMaxPausedBlocks(t *testing.T) {
-	uow := newTestingUtilityUnitOfWork(t, 0)
-	defaultParams := DefaultTestingParams(t)
-	gotParam, err := uow.getAppMaxPausedBlocks()
-	require.NoError(t, err)
-	require.Equal(t, int(defaultParams.GetAppMaxPauseBlocks()), gotParam)
-}
-
-func TestUtilityUnitOfWork_GetAppMinimumPauseBlocks(t *testing.T) {
-	uow := newTestingUtilityUnitOfWork(t, 0)
-	defaultParams := DefaultTestingParams(t)
-	defaultParam := int(defaultParams.GetAppMinimumPauseBlocks())
-	gotParam, err := uow.getAppMinimumPauseBlocks()
-	require.NoError(t, err)
-	require.Equal(t, defaultParam, gotParam)
-}
-
-func TestUtilityUnitOfWork_GetAppMinimumStake(t *testing.T) {
-	uow := newTestingUtilityUnitOfWork(t, 0)
-	defaultParams := DefaultTestingParams(t)
-	defaultParam := defaultParams.GetAppMinimumStake()
-	gotParam, err := uow.getAppMinimumStake()
-	require.NoError(t, err)
-	require.Equal(t, defaultParam, utils.BigIntToString(gotParam))
-}
-
-func TestUtilityUnitOfWork_GetAppUnstakingBlocks(t *testing.T) {
-	uow := newTestingUtilityUnitOfWork(t, 0)
-	defaultParams := DefaultTestingParams(t)
-	defaultParam := int64(defaultParams.GetAppUnstakingBlocks())
-	gotParam, err := uow.getAppUnstakingBlocks()
-	require.NoError(t, err)
-	require.Equal(t, defaultParam, gotParam)
-}
-
-func TestUtilityUnitOfWork_GetBlocksPerSession(t *testing.T) {
-	uow := newTestingUtilityUnitOfWork(t, 0)
-	defaultParams := DefaultTestingParams(t)
-	defaultParam := int(defaultParams.GetBlocksPerSession())
-	gotParam, err := uow.getParameter(typesUtil.BlocksPerSessionParamName)
-	require.NoError(t, err)
-	require.Equal(t, defaultParam, gotParam)
-}
-
-func TestUtilityUnitOfWork_GetDoubleSignBurnPercentage(t *testing.T) {
-	uow := newTestingUtilityUnitOfWork(t, 0)
-	defaultParams := DefaultTestingParams(t)
-	defaultParam := int(defaultParams.GetDoubleSignBurnPercentage())
-	gotParam, err := uow.getDoubleSignBurnPercentage()
-	require.NoError(t, err)
-	require.Equal(t, defaultParam, gotParam)
-}
-
-func TestUtilityUnitOfWork_GetDoubleSignFeeOwner(t *testing.T) {
-	uow := newTestingUtilityUnitOfWork(t, 0)
-	defaultParams := DefaultTestingParams(t)
-	defaultParam := defaultParams.GetMessageDoubleSignFeeOwner()
-	gotParam, err := uow.getDoubleSignFeeOwner()
-	require.NoError(t, err)
-
-	defaultParamTx, er := hex.DecodeString(defaultParam)
-	require.NoError(t, er)
-
-	require.Equal(t, defaultParamTx, gotParam)
-}
-
-func TestUtilityUnitOfWork_GetFishermanMaxChains(t *testing.T) {
-	uow := newTestingUtilityUnitOfWork(t, 0)
-	defaultParams := DefaultTestingParams(t)
-	defaultParam := int(defaultParams.GetFishermanMaxChains())
-	gotParam, err := uow.getFishermanMaxChains()
-	require.NoError(t, err)
-	require.Equal(t, defaultParam, gotParam)
-}
-
-func TestUtilityUnitOfWork_GetFishermanMaxPausedBlocks(t *testing.T) {
-	uow := newTestingUtilityUnitOfWork(t, 0)
-	defaultParams := DefaultTestingParams(t)
-	defaultParam := int(defaultParams.GetFishermanMaxPauseBlocks())
-	gotParam, err := uow.getFishermanMaxPausedBlocks()
-	require.NoError(t, err)
-	require.Equal(t, defaultParam, gotParam)
-}
-
-func TestUtilityUnitOfWork_GetFishermanMinimumPauseBlocks(t *testing.T) {
-	uow := newTestingUtilityUnitOfWork(t, 0)
-	defaultParams := DefaultTestingParams(t)
-	defaultParam := int(defaultParams.GetFishermanMinimumPauseBlocks())
-	gotParam, err := uow.getFishermanMinimumPauseBlocks()
-	require.NoError(t, err)
-	require.Equal(t, defaultParam, gotParam)
-}
-
-func TestUtilityUnitOfWork_GetFishermanMinimumStake(t *testing.T) {
-	uow := newTestingUtilityUnitOfWork(t, 0)
-	defaultParams := DefaultTestingParams(t)
-	defaultParam := defaultParams.GetFishermanMinimumStake()
-	gotParam, err := uow.getFishermanMinimumStake()
-	require.NoError(t, err)
-	require.Equal(t, defaultParam, utils.BigIntToString(gotParam))
-}
-
-func TestUtilityUnitOfWork_GetFishermanUnstakingBlocks(t *testing.T) {
-	uow := newTestingUtilityUnitOfWork(t, 0)
-	defaultParams := DefaultTestingParams(t)
-	defaultParam := int64(defaultParams.GetFishermanUnstakingBlocks())
-	gotParam, err := uow.getFishermanUnstakingBlocks()
-	require.NoError(t, err)
-	require.Equal(t, defaultParam, gotParam)
-}
-
-func TestUtilityUnitOfWork_GetMaxEvidenceAgeInBlocks(t *testing.T) {
-	uow := newTestingUtilityUnitOfWork(t, 0)
-	defaultParams := DefaultTestingParams(t)
-	defaultParam := int(defaultParams.GetValidatorMaxEvidenceAgeInBlocks())
-	gotParam, err := uow.getMaxEvidenceAgeInBlocks()
-	require.NoError(t, err)
-	require.Equal(t, defaultParam, gotParam)
-}
-
-func TestUtilityUnitOfWork_GetMessageChangeParameterFee(t *testing.T) {
-	uow := newTestingUtilityUnitOfWork(t, 0)
-	defaultParams := DefaultTestingParams(t)
-	defaultParam := defaultParams.GetMessageChangeParameterFee()
-	gotParam, err := uow.getMessageChangeParameterFee()
-	require.NoError(t, err)
-	require.Equal(t, defaultParam, utils.BigIntToString(gotParam))
-}
-
-func TestUtilityUnitOfWork_GetMessageDoubleSignFee(t *testing.T) {
-	uow := newTestingUtilityUnitOfWork(t, 0)
-	defaultParams := DefaultTestingParams(t)
-	defaultParam := defaultParams.GetMessageDoubleSignFee()
-	gotParam, err := uow.getMessageDoubleSignFee()
-	require.NoError(t, err)
-	require.Equal(t, defaultParam, utils.BigIntToString(gotParam))
-}
-
-func TestUtilityUnitOfWork_GetMessageEditStakeAppFee(t *testing.T) {
-	uow := newTestingUtilityUnitOfWork(t, 0)
-	defaultParams := DefaultTestingParams(t)
-	defaultParam := defaultParams.GetMessageEditStakeAppFee()
-	gotParam, err := uow.getMessageEditStakeAppFee()
-	require.NoError(t, err)
-	require.Equal(t, defaultParam, utils.BigIntToString(gotParam))
-}
-
-func TestUtilityUnitOfWork_GetMessageEditStakeFishermanFee(t *testing.T) {
-	uow := newTestingUtilityUnitOfWork(t, 0)
-	defaultParams := DefaultTestingParams(t)
-	defaultParam := defaultParams.GetMessageEditStakeFishermanFee()
-	gotParam, err := uow.getMessageEditStakeFishermanFee()
-	require.NoError(t, err)
-	require.Equal(t, defaultParam, utils.BigIntToString(gotParam))
-}
-
-func TestUtilityUnitOfWork_GetMessageEditStakeServicerFee(t *testing.T) {
-	uow := newTestingUtilityUnitOfWork(t, 0)
-	defaultParams := DefaultTestingParams(t)
-	defaultParam := defaultParams.GetMessageEditStakeServicerFee()
-	gotParam, err := uow.getMessageEditStakeServicerFee()
-	require.NoError(t, err)
-	require.Equal(t, defaultParam, utils.BigIntToString(gotParam))
-}
-
-func TestUtilityUnitOfWork_GetMessageEditStakeValidatorFee(t *testing.T) {
-	uow := newTestingUtilityUnitOfWork(t, 0)
-	defaultParams := DefaultTestingParams(t)
-	defaultParam := defaultParams.GetMessageEditStakeValidatorFee()
-	gotParam, err := uow.getMessageEditStakeValidatorFee()
-	require.NoError(t, err)
-	require.Equal(t, defaultParam, utils.BigIntToString(gotParam))
-}
-
-func TestUtilityUnitOfWork_GetMessageFishermanPauseServicerFee(t *testing.T) {
-	uow := newTestingUtilityUnitOfWork(t, 0)
-	defaultParams := DefaultTestingParams(t)
-	defaultParam := defaultParams.GetMessageFishermanPauseServicerFee()
-	gotParam, err := uow.getMessageFishermanPauseServicerFee()
-	require.NoError(t, err)
-	require.Equal(t, defaultParam, utils.BigIntToString(gotParam))
-}
-
-func TestUtilityUnitOfWork_GetMessagePauseAppFee(t *testing.T) {
-	uow := newTestingUtilityUnitOfWork(t, 0)
-	defaultParams := DefaultTestingParams(t)
-	defaultParam := defaultParams.GetMessagePauseAppFee()
-	gotParam, err := uow.getMessagePauseAppFee()
-	require.NoError(t, err)
-	require.Equal(t, defaultParam, utils.BigIntToString(gotParam))
-}
-
-func TestUtilityUnitOfWork_GetMessagePauseFishermanFee(t *testing.T) {
-	uow := newTestingUtilityUnitOfWork(t, 0)
-	defaultParams := DefaultTestingParams(t)
-	defaultParam := defaultParams.GetMessagePauseFishermanFee()
-	gotParam, err := uow.getMessagePauseFishermanFee()
-	require.NoError(t, err)
-	require.Equal(t, defaultParam, utils.BigIntToString(gotParam))
-}
-
-func TestUtilityUnitOfWork_GetMessagePauseServicerFee(t *testing.T) {
-	uow := newTestingUtilityUnitOfWork(t, 0)
-	defaultParams := DefaultTestingParams(t)
-	defaultParam := defaultParams.GetMessagePauseServicerFee()
-	gotParam, err := uow.getMessagePauseServicerFee()
-	require.NoError(t, err)
-	require.Equal(t, defaultParam, utils.BigIntToString(gotParam))
-}
-
-func TestUtilityUnitOfWork_GetMessagePauseValidatorFee(t *testing.T) {
-	uow := newTestingUtilityUnitOfWork(t, 0)
-	defaultParams := DefaultTestingParams(t)
-	defaultParam := defaultParams.GetMessagePauseValidatorFee()
-	gotParam, err := uow.getMessagePauseValidatorFee()
-	require.NoError(t, err)
-	require.Equal(t, defaultParam, utils.BigIntToString(gotParam))
-}
-
-func TestUtilityUnitOfWork_GetMessageProveTestScoreFee(t *testing.T) {
-	uow := newTestingUtilityUnitOfWork(t, 0)
-	defaultParams := DefaultTestingParams(t)
-	defaultParam := defaultParams.GetMessageProveTestScoreFee()
-	gotParam, err := uow.getMessageProveTestScoreFee()
-	require.NoError(t, err)
-	require.Equal(t, defaultParam, utils.BigIntToString(gotParam))
-}
-
-func TestUtilityUnitOfWork_GetMessageSendFee(t *testing.T) {
-	uow := newTestingUtilityUnitOfWork(t, 0)
-	defaultParams := DefaultTestingParams(t)
-	defaultParam := defaultParams.GetMessageSendFee()
-	gotParam, err := uow.getMessageSendFee()
-	require.NoError(t, err)
-	require.Equal(t, defaultParam, utils.BigIntToString(gotParam))
-}
-
-func TestUtilityUnitOfWork_GetMessageStakeAppFee(t *testing.T) {
-	uow := newTestingUtilityUnitOfWork(t, 0)
-	defaultParams := DefaultTestingParams(t)
-	defaultParam := defaultParams.GetMessageStakeAppFee()
-	gotParam, err := uow.getMessageStakeAppFee()
-	require.NoError(t, err)
-	require.Equal(t, defaultParam, utils.BigIntToString(gotParam))
-}
-
-func TestUtilityUnitOfWork_GetMessageStakeFishermanFee(t *testing.T) {
-	uow := newTestingUtilityUnitOfWork(t, 0)
-	defaultParams := DefaultTestingParams(t)
-	defaultParam := defaultParams.GetMessageStakeFishermanFee()
-	gotParam, err := uow.getMessageStakeFishermanFee()
-	require.NoError(t, err)
-	require.Equal(t, defaultParam, utils.BigIntToString(gotParam))
-}
-
-func TestUtilityUnitOfWork_GetMessageStakeServicerFee(t *testing.T) {
-	uow := newTestingUtilityUnitOfWork(t, 0)
-	defaultParams := DefaultTestingParams(t)
-	defaultParam := defaultParams.GetMessageStakeServicerFee()
-	gotParam, err := uow.getMessageStakeServicerFee()
-	require.NoError(t, err)
-	require.Equal(t, defaultParam, utils.BigIntToString(gotParam))
-}
-
-func TestUtilityUnitOfWork_GetMessageStakeValidatorFee(t *testing.T) {
-	uow := newTestingUtilityUnitOfWork(t, 0)
-	defaultParams := DefaultTestingParams(t)
-	defaultParam := defaultParams.GetMessageStakeValidatorFee()
-	gotParam, err := uow.getMessageStakeValidatorFee()
-	require.NoError(t, err)
-	require.Equal(t, defaultParam, utils.BigIntToString(gotParam))
-}
-
-func TestUtilityUnitOfWork_GetMessageTestScoreFee(t *testing.T) {
-	uow := newTestingUtilityUnitOfWork(t, 0)
-	defaultParams := DefaultTestingParams(t)
-	defaultParam := defaultParams.GetMessageTestScoreFee()
-	gotParam, err := uow.getMessageTestScoreFee()
-	require.NoError(t, err)
-	require.Equal(t, defaultParam, utils.BigIntToString(gotParam))
-}
-
-func TestUtilityUnitOfWork_GetMessageUnpauseAppFee(t *testing.T) {
-	uow := newTestingUtilityUnitOfWork(t, 0)
-	defaultParams := DefaultTestingParams(t)
-	defaultParam := defaultParams.GetMessageUnpauseAppFee()
-	gotParam, err := uow.getMessageUnpauseAppFee()
-	require.NoError(t, err)
-	require.Equal(t, defaultParam, utils.BigIntToString(gotParam))
-}
-
-func TestUtilityUnitOfWork_GetMessageUnpauseFishermanFee(t *testing.T) {
-	uow := newTestingUtilityUnitOfWork(t, 0)
-	defaultParams := DefaultTestingParams(t)
-	defaultParam := defaultParams.GetMessageUnpauseFishermanFee()
-	gotParam, err := uow.getMessageUnpauseFishermanFee()
-	require.NoError(t, err)
-	require.Equal(t, defaultParam, utils.BigIntToString(gotParam))
-}
-
-func TestUtilityUnitOfWork_GetMessageUnpauseServicerFee(t *testing.T) {
-	uow := newTestingUtilityUnitOfWork(t, 0)
-	defaultParams := DefaultTestingParams(t)
-	defaultParam := defaultParams.GetMessageUnpauseServicerFee()
-	gotParam, err := uow.getMessageUnpauseServicerFee()
-	require.NoError(t, err)
-	require.Equal(t, defaultParam, utils.BigIntToString(gotParam))
-}
-
-func TestUtilityUnitOfWork_GetMessageUnpauseValidatorFee(t *testing.T) {
-	uow := newTestingUtilityUnitOfWork(t, 0)
-	defaultParams := DefaultTestingParams(t)
-	defaultParam := defaultParams.GetMessageUnpauseValidatorFee()
-	gotParam, err := uow.getMessageUnpauseValidatorFee()
-	require.NoError(t, err)
-	require.Equal(t, defaultParam, utils.BigIntToString(gotParam))
-}
-
-func TestUtilityUnitOfWork_GetMessageUnstakeAppFee(t *testing.T) {
-	uow := newTestingUtilityUnitOfWork(t, 0)
-	defaultParams := DefaultTestingParams(t)
-	defaultParam := defaultParams.GetMessageUnstakeAppFee()
-	gotParam, err := uow.getMessageUnstakeAppFee()
-	require.NoError(t, err)
-	require.Equal(t, defaultParam, utils.BigIntToString(gotParam))
-}
-
-func TestUtilityUnitOfWork_GetMessageUnstakeFishermanFee(t *testing.T) {
-	uow := newTestingUtilityUnitOfWork(t, 0)
-	defaultParams := DefaultTestingParams(t)
-	defaultParam := defaultParams.GetMessageUnstakeFishermanFee()
-	gotParam, err := uow.getMessageUnstakeFishermanFee()
-	require.NoError(t, err)
-	require.Equal(t, defaultParam, utils.BigIntToString(gotParam))
-}
-
-func TestUtilityUnitOfWork_GetMessageUnstakeServicerFee(t *testing.T) {
-	uow := newTestingUtilityUnitOfWork(t, 0)
-	defaultParams := DefaultTestingParams(t)
-	defaultParam := defaultParams.GetMessageUnstakeServicerFee()
-	gotParam, err := uow.getMessageUnstakeServicerFee()
-	require.NoError(t, err)
-	require.Equal(t, defaultParam, utils.BigIntToString(gotParam))
-}
-
-func TestUtilityUnitOfWork_GetMessageUnstakeValidatorFee(t *testing.T) {
-	uow := newTestingUtilityUnitOfWork(t, 0)
-	defaultParams := DefaultTestingParams(t)
-	defaultParam := defaultParams.GetMessageUnstakeValidatorFee()
-	gotParam, err := uow.getMessageUnstakeValidatorFee()
-	require.NoError(t, err)
-	require.Equal(t, defaultParam, utils.BigIntToString(gotParam))
-}
-
-func TestUtilityUnitOfWork_GetMissedBlocksBurnPercentage(t *testing.T) {
-	uow := newTestingUtilityUnitOfWork(t, 0)
-	defaultParams := DefaultTestingParams(t)
-	defaultParam := int(defaultParams.GetMissedBlocksBurnPercentage())
-	gotParam, err := uow.getMissedBlocksBurnPercentage()
-	require.NoError(t, err)
-	require.Equal(t, defaultParam, gotParam)
-}
-
-func TestUtilityUnitOfWork_GetProposerPercentageOfFees(t *testing.T) {
-	uow := newTestingUtilityUnitOfWork(t, 0)
-	defaultParams := DefaultTestingParams(t)
-	defaultParam := int(defaultParams.GetProposerPercentageOfFees())
-	gotParam, err := uow.getProposerPercentageOfFees()
-	require.NoError(t, err)
-	require.Equal(t, defaultParam, gotParam)
-}
-
-func TestUtilityUnitOfWork_GetServicerMaxChains(t *testing.T) {
-	uow := newTestingUtilityUnitOfWork(t, 0)
-	defaultParams := DefaultTestingParams(t)
-	defaultParam := int(defaultParams.GetServicerMaxChains())
-	gotParam, err := uow.getServicerMaxChains()
-	require.NoError(t, err)
-	require.Equal(t, defaultParam, gotParam)
-}
-
-func TestUtilityUnitOfWork_GetServicerMaxPausedBlocks(t *testing.T) {
-	uow := newTestingUtilityUnitOfWork(t, 0)
-	defaultParams := DefaultTestingParams(t)
-	defaultParam := int(defaultParams.GetServicerMaxPauseBlocks())
-	gotParam, err := uow.getServicerMaxPausedBlocks()
-	require.NoError(t, err)
-	require.Equal(t, defaultParam, gotParam)
-}
-
-func TestUtilityUnitOfWork_GetServicerMinimumPauseBlocks(t *testing.T) {
-	uow := newTestingUtilityUnitOfWork(t, 0)
-	defaultParams := DefaultTestingParams(t)
-	defaultParam := int(defaultParams.GetServicerMinimumPauseBlocks())
-	gotParam, err := uow.getServicerMinimumPauseBlocks()
-	require.NoError(t, err)
-	require.Equal(t, defaultParam, gotParam)
-}
-
-func TestUtilityUnitOfWork_GetServicerMinimumStake(t *testing.T) {
-	uow := newTestingUtilityUnitOfWork(t, 0)
-	defaultParams := DefaultTestingParams(t)
-	defaultParam := defaultParams.GetServicerMinimumStake()
-	gotParam, err := uow.getServicerMinimumStake()
-	require.NoError(t, err)
-	require.Equal(t, defaultParam, utils.BigIntToString(gotParam))
-}
-
-func TestUtilityUnitOfWork_GetServicerUnstakingBlocks(t *testing.T) {
-	uow := newTestingUtilityUnitOfWork(t, 0)
-	defaultParams := DefaultTestingParams(t)
-	defaultParam := int64(defaultParams.GetServicerUnstakingBlocks())
-	gotParam, err := uow.getServicerUnstakingBlocks()
-	require.NoError(t, err)
-	require.Equal(t, defaultParam, gotParam)
-}
-
-func TestUtilityUnitOfWork_GetSessionTokensMultiplier(t *testing.T) {
-	uow := newTestingUtilityUnitOfWork(t, 0)
-	defaultParams := DefaultTestingParams(t)
-	defaultParam := int(defaultParams.GetAppSessionTokensMultiplier())
-	gotParam, err := uow.getAppSessionTokensMultiplier()
-	require.NoError(t, err)
-	require.Equal(t, defaultParam, gotParam)
-}
-
-func TestUtilityUnitOfWork_GetValidatorMaxMissedBlocks(t *testing.T) {
-	uow := newTestingUtilityUnitOfWork(t, 0)
-	defaultParams := DefaultTestingParams(t)
-	defaultParam := int(defaultParams.GetValidatorMaximumMissedBlocks())
-	gotParam, err := uow.getValidatorMaxMissedBlocks()
-	require.NoError(t, err)
-	require.Equal(t, defaultParam, gotParam)
-}
-
-func TestUtilityUnitOfWork_GetValidatorMaxPausedBlocks(t *testing.T) {
-	uow := newTestingUtilityUnitOfWork(t, 0)
-	defaultParams := DefaultTestingParams(t)
-	defaultParam := int(defaultParams.GetValidatorMaxPauseBlocks())
-	gotParam, err := uow.getValidatorMaxPausedBlocks()
-	require.NoError(t, err)
-	require.Equal(t, defaultParam, gotParam)
-}
-
-func TestUtilityUnitOfWork_GetValidatorMinimumPauseBlocks(t *testing.T) {
-	uow := newTestingUtilityUnitOfWork(t, 0)
-	defaultParams := DefaultTestingParams(t)
-	defaultParam := int(defaultParams.GetValidatorMinimumPauseBlocks())
-	gotParam, err := uow.getValidatorMinimumPauseBlocks()
-	require.NoError(t, err)
-	require.Equal(t, defaultParam, gotParam)
-}
-
-func TestUtilityUnitOfWork_GetValidatorMinimumStake(t *testing.T) {
-	uow := newTestingUtilityUnitOfWork(t, 0)
-	defaultParams := DefaultTestingParams(t)
-	defaultParam := defaultParams.GetValidatorMinimumStake()
-	gotParam, err := uow.getValidatorMinimumStake()
-	require.NoError(t, err)
-	require.Equal(t, defaultParam, utils.BigIntToString(gotParam))
-}
-
-func TestUtilityUnitOfWork_GetValidatorUnstakingBlocks(t *testing.T) {
-	uow := newTestingUtilityUnitOfWork(t, 0)
-	defaultParams := DefaultTestingParams(t)
-	defaultParam := int64(defaultParams.GetValidatorUnstakingBlocks())
-	gotParam, err := uow.getValidatorUnstakingBlocks()
-	require.NoError(t, err)
-	require.Equal(t, defaultParam, gotParam)
+func TestUtilityUnitOfWork_GetGovParams(t *testing.T) {
+	uow := newTestingUtilityUnitOfWork(t, 0)
+	defaultParams := DefaultTestingParams(t)
+	for _, paramName := range utils.GovParamMetadataKeys {
+		if strings.Contains(paramName, ""_owner"") {
+			continue
+		}
+		defaultParam := reflect.ValueOf(defaultParams).MethodByName(""Get"" + utils.GovParamMetadataMap[paramName].PropertyName).Call([]reflect.Value{})[0].Interface()",utility/unit_of_work/gov_test.go,2023-04-06 22:17:30+00:00,2023-04-06T23:32:31Z,Is this the `defaultParamValue`?,,,,,30,RIGHT,505,,line,https://api.github.com/repos/pokt-network/pocket/pulls/622,pokt-network/pocket,6b9b2db0f25b5fb605c1cb6d454b47708ff4eacd
https://api.github.com/repos/pokt-network/pocket/pulls/622,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1160316336,Olshansk,010c045d060cf8114d09066846c1f7d1fe5f7318,c0a96add056e9fdff4fdbeb3cf456355c5520b65,"@@ -0,0 +1,75 @@
+package utils
+
+import (
+	""reflect""
+	""strings""
+
+	""github.com/pokt-network/pocket/runtime/genesis""
+)
+
+// init initializes a map that contains the metadata extracted from `gov.proto`.
+// Since protobuf files do not change at runtime, it seems efficient to do it here.
+func init() {
+	GovParamMetadataMap = parseGovProto()
+}
+
+var (
+	GovParamMetadataMap  map[string]GovParamMetadata
+	GovParamMetadataKeys []string
+)
+
+type GovParamMetadata struct {
+	PropertyName string
+	ParamName    string
+	ParamOwner   string
+	PoktType     string
+	GoType       string
+}
+
+// parseGovProto parses genesis.Params{} (generated from gov.proto) in order to extract metadata about its fields.
+//
+// The metadata comes in the form of struct tags that we attached to gov.proto and also from the tags that protoc injects automatically.
+// Since currently we need to specify a mapping between the fields and a custom enum in the database (and potentially other things as well in the future),
+// instead of having to maintain multiple maps, which would lead to having to maintain multiple sources of truth, we centralized the declaration of the fields
+// and related metadata into the protobuf file.
+//
+// WARNING: reflections in prod
+func parseGovProto() (govParamMetadataMap map[string]GovParamMetadata) {
+	govParamMetadataMap = make(map[string]GovParamMetadata)
+	fields := reflect.VisibleFields(reflect.TypeOf(genesis.Params{}))
+	for _, field := range fields {
+		if !field.IsExported() {
+			continue
+		}
+		poktTag := field.Tag.Get(""pokt"")
+		protoTag := field.Tag.Get(""protobuf"")
+		poktValType := extractStructTag(poktTag, ""val_type="")
+		poktOwner := extractStructTag(poktTag, ""owner="")
+		golangType := field.Type.Name() // Get string version of field's Golang type
+		protoName := extractStructTag(protoTag, ""name="")",shared/utils/gov_utils.go,2023-04-06 22:47:53+00:00,2023-04-06T23:32:31Z,Does this exist?,,,,47.0,49,RIGHT,49,47.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/622,pokt-network/pocket,6b9b2db0f25b5fb605c1cb6d454b47708ff4eacd
https://api.github.com/repos/pokt-network/pocket/pulls/622,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1160316590,Olshansk,010c045d060cf8114d09066846c1f7d1fe5f7318,c0a96add056e9fdff4fdbeb3cf456355c5520b65,"@@ -0,0 +1,75 @@
+package utils
+
+import (
+	""reflect""
+	""strings""
+
+	""github.com/pokt-network/pocket/runtime/genesis""
+)
+
+// init initializes a map that contains the metadata extracted from `gov.proto`.
+// Since protobuf files do not change at runtime, it seems efficient to do it here.
+func init() {
+	GovParamMetadataMap = parseGovProto()
+}
+
+var (
+	GovParamMetadataMap  map[string]GovParamMetadata
+	GovParamMetadataKeys []string
+)
+
+type GovParamMetadata struct {
+	PropertyName string
+	ParamName    string",shared/utils/gov_utils.go,2023-04-06 22:48:31+00:00,2023-04-06T23:32:31Z,"It's unclear to me what the difference between `Property` and `Param`. Are we using both?

Doesn't seem like `name=`  is used any which makes me think we can remove `ParamName`",,22.0,RIGHT,,23,RIGHT,23,,line,https://api.github.com/repos/pokt-network/pocket/pulls/622,pokt-network/pocket,6b9b2db0f25b5fb605c1cb6d454b47708ff4eacd
https://api.github.com/repos/pokt-network/pocket/pulls/622,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1160317269,Olshansk,010c045d060cf8114d09066846c1f7d1fe5f7318,c0a96add056e9fdff4fdbeb3cf456355c5520b65,"@@ -0,0 +1,75 @@
+package utils
+
+import (
+	""reflect""
+	""strings""
+
+	""github.com/pokt-network/pocket/runtime/genesis""
+)
+
+// init initializes a map that contains the metadata extracted from `gov.proto`.
+// Since protobuf files do not change at runtime, it seems efficient to do it here.
+func init() {
+	GovParamMetadataMap = parseGovProto()
+}
+
+var (
+	GovParamMetadataMap  map[string]GovParamMetadata
+	GovParamMetadataKeys []string
+)
+
+type GovParamMetadata struct {
+	PropertyName string
+	ParamName    string
+	ParamOwner   string
+	PoktType     string
+	GoType       string
+}
+
+// parseGovProto parses genesis.Params{} (generated from gov.proto) in order to extract metadata about its fields.
+//
+// The metadata comes in the form of struct tags that we attached to gov.proto and also from the tags that protoc injects automatically.
+// Since currently we need to specify a mapping between the fields and a custom enum in the database (and potentially other things as well in the future),
+// instead of having to maintain multiple maps, which would lead to having to maintain multiple sources of truth, we centralized the declaration of the fields
+// and related metadata into the protobuf file.
+//
+// WARNING: reflections in prod
+func parseGovProto() (govParamMetadataMap map[string]GovParamMetadata) {
+	govParamMetadataMap = make(map[string]GovParamMetadata)
+	fields := reflect.VisibleFields(reflect.TypeOf(genesis.Params{}))
+	for _, field := range fields {
+		if !field.IsExported() {
+			continue
+		}
+		poktTag := field.Tag.Get(""pokt"")
+		protoTag := field.Tag.Get(""protobuf"")
+		poktValType := extractStructTag(poktTag, ""val_type="")
+		poktOwner := extractStructTag(poktTag, ""owner="")
+		golangType := field.Type.Name() // Get string version of field's Golang type
+		protoName := extractStructTag(protoTag, ""name="")
+		govParamMetadataMap[protoName] = GovParamMetadata{
+			PropertyName: field.Name,
+			ParamName:    protoName,
+			ParamOwner:   poktOwner,
+			PoktType:     poktValType,
+			GoType:       golangType,
+		}
+		GovParamMetadataKeys = append(GovParamMetadataKeys, protoName)
+	}
+	return govParamMetadataMap
+}
+
+func extractStructTag(structTag, key string) string {
+	for len(structTag) > 0 {
+		i := strings.IndexByte(structTag, ',')
+		if i < 0 { // not found
+			i = len(structTag)
+		}
+		s := structTag[:i]
+		if strings.HasPrefix(s, key) {
+			return s[len(key):]
+		}
+		structTag = strings.TrimPrefix(structTag[i:], "","")
+	}
+	return """"",shared/utils/gov_utils.go,2023-04-06 22:49:55+00:00,2023-04-06T23:32:31Z,"```suggestion
	return """" // key not found
```",,,,,74,RIGHT,74,,line,https://api.github.com/repos/pokt-network/pocket/pulls/622,pokt-network/pocket,6b9b2db0f25b5fb605c1cb6d454b47708ff4eacd
https://api.github.com/repos/pokt-network/pocket/pulls/622,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1160332077,Olshansk,010c045d060cf8114d09066846c1f7d1fe5f7318,c0a96add056e9fdff4fdbeb3cf456355c5520b65,"@@ -3,12 +3,108 @@ package unit_of_work
 import (
 	""math/big""
 
+	""github.com/pokt-network/pocket/persistence""
 	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
 	""github.com/pokt-network/pocket/shared/utils""
 	typesUtil ""github.com/pokt-network/pocket/utility/types""
 	""google.golang.org/protobuf/types/known/wrapperspb""
 )
 
+func init() {
+	GovParams = generateParamConfigs()
+}
+
+var (
+	GovParams map[string]int
+)
+
+const (
+	BIGINT int = iota
+	INT
+	INT64
+	BYTES
+	STRING
+)
+
+func generateParamConfigs() map[string]int {",utility/unit_of_work/gov.go,2023-04-06 23:28:09+00:00,2023-04-06T23:32:31Z,"I know this is overly explicit, but I feel like do you think this helps? `prepareGovParamParamTypesMap`",,,,,29,RIGHT,27,,line,https://api.github.com/repos/pokt-network/pocket/pulls/622,pokt-network/pocket,6b9b2db0f25b5fb605c1cb6d454b47708ff4eacd
https://api.github.com/repos/pokt-network/pocket/pulls/622,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1160332196,Olshansk,010c045d060cf8114d09066846c1f7d1fe5f7318,c0a96add056e9fdff4fdbeb3cf456355c5520b65,"@@ -3,12 +3,108 @@ package unit_of_work
 import (
 	""math/big""
 
+	""github.com/pokt-network/pocket/persistence""
 	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
 	""github.com/pokt-network/pocket/shared/utils""
 	typesUtil ""github.com/pokt-network/pocket/utility/types""
 	""google.golang.org/protobuf/types/known/wrapperspb""
 )
 
+func init() {
+	GovParams = generateParamConfigs()
+}
+
+var (
+	GovParams map[string]int",utility/unit_of_work/gov.go,2023-04-06 23:28:34+00:00,2023-04-06T23:32:31Z,"1. Confirming that this needs to be exposed?
2. Maybe `GovParamTypes`?",,,,,18,RIGHT,16,,line,https://api.github.com/repos/pokt-network/pocket/pulls/622,pokt-network/pocket,6b9b2db0f25b5fb605c1cb6d454b47708ff4eacd
https://api.github.com/repos/pokt-network/pocket/pulls/622,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1160332826,Olshansk,010c045d060cf8114d09066846c1f7d1fe5f7318,c0a96add056e9fdff4fdbeb3cf456355c5520b65,"@@ -0,0 +1,75 @@
+package utils
+
+import (
+	""reflect""
+	""strings""
+
+	""github.com/pokt-network/pocket/runtime/genesis""
+)
+
+// init initializes a map that contains the metadata extracted from `gov.proto`.
+// Since protobuf files do not change at runtime, it seems efficient to do it here.
+func init() {
+	GovParamMetadataMap = parseGovProto()",shared/utils/gov_utils.go,2023-04-06 23:30:24+00:00,2023-04-06T23:32:31Z,"Can we verify that `GovParams` (the map you have hardcoded elsewhere) corresponds to `gov.proto`?

I basically want a compile check to make sure we don't edit one file and forget to update the source code.",,,,13.0,13,RIGHT,13,13.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/622,pokt-network/pocket,6b9b2db0f25b5fb605c1cb6d454b47708ff4eacd
https://api.github.com/repos/pokt-network/pocket/pulls/622,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1160892511,Olshansk,2158a38a6ff9529a405a23c55366e37d403afa5b,c0a96add056e9fdff4fdbeb3cf456355c5520b65,"@@ -538,6 +538,6 @@ check_cross_module_imports: ## Lists cross-module imports
 send_local_tx: ## A hardcoded send tx to make LocalNet debugging easier
 	go run -tags=debug app/client/*.go Account Send --non_interactive 00104055c00bed7c983a48aac7dc6335d7c607a7 00204737d2a165ebe4be3a7d5b0af905b0ea91d8 1000
 
-.PHONY: query_node_params
-query_node_params: ## A hardcoded NodeParams query to make LocalNet debugging easier
-	go run app/client/main.go System NodeParams
+.PHONY: query_chain_params
+query_chain_params: ## A hardcoded NodeParams query to make LocalNet debugging easier",Makefile,2023-04-07 18:49:14+00:00,2023-04-07T19:21:21Z,"```suggestion
query_chain_params: ## A hardcoded ChainParams query to make LocalNet debugging easier
```",,,,,542,RIGHT,8,,line,https://api.github.com/repos/pokt-network/pocket/pulls/622,pokt-network/pocket,6b9b2db0f25b5fb605c1cb6d454b47708ff4eacd
https://api.github.com/repos/pokt-network/pocket/pulls/622,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1160892861,Olshansk,2158a38a6ff9529a405a23c55366e37d403afa5b,c0a96add056e9fdff4fdbeb3cf456355c5520b65,"@@ -0,0 +1,62 @@
+package cli
+
+import (
+	""fmt""
+	""io""
+	""net/http""
+
+	""github.com/pokt-network/pocket/logger""
+	""github.com/pokt-network/pocket/rpc""
+	""github.com/spf13/cobra""
+)
+
+func init() {
+	queryCmd := NewQueryCommand()
+	rootCmd.AddCommand(queryCmd)
+}
+
+func NewQueryCommand() *cobra.Command {
+	cmd := &cobra.Command{
+		Use:     ""Query"",
+		Short:   ""Commands related to querying the RPC server of the node"",",app/client/cli/query.go,2023-04-07 18:50:01+00:00,2023-04-07T19:21:21Z,"```suggestion
		Short:   ""Commands related to querying on-chain data via the node's RPC server"",
```",,,,,21,RIGHT,21,,line,https://api.github.com/repos/pokt-network/pocket/pulls/622,pokt-network/pocket,6b9b2db0f25b5fb605c1cb6d454b47708ff4eacd
https://api.github.com/repos/pokt-network/pocket/pulls/622,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1160909361,Olshansk,2158a38a6ff9529a405a23c55366e37d403afa5b,c0a96add056e9fdff4fdbeb3cf456355c5520b65,"@@ -3,12 +3,108 @@ package unit_of_work
 import (
 	""math/big""
 
+	""github.com/pokt-network/pocket/persistence""
 	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
 	""github.com/pokt-network/pocket/shared/utils""
 	typesUtil ""github.com/pokt-network/pocket/utility/types""
 	""google.golang.org/protobuf/types/known/wrapperspb""
 )
 
+func init() {
+	govParamTypes = prepareGovParamParamTypesMap()
+}
+
+var (
+	govParamTypes map[string]int
+)
+
+const (
+	BIGINT int = iota
+	INT
+	INT64
+	BYTES
+	STRING
+)
+
+func prepareGovParamParamTypesMap() map[string]int {",utility/unit_of_work/gov.go,2023-04-07 19:13:33+00:00,2023-04-07T19:21:21Z,"Regarding this comment: https://github.com/pokt-network/pocket/pull/622/files/010c045d060cf8114d09066846c1f7d1fe5f7318..2158a38a6ff9529a405a23c55366e37d403afa5b#r1160332826

If we update `genesis.proto`, there's nothing currently that forces us to update `prepareGovParamParamTypesMap` as well.

Source of truth: `genesis.proto`
Derived source of truth based on above: `GovParamMetadataMap`
Alternate source of truth: `prepareGovParamParamTypesMap`

In the forloop, we currently ignore missing ids: `switch id := govParamTypes[paramName]; id {`

tl;dr I basically want a fatal error if the ID doesn't exist.",,,,39.0,29,RIGHT,27,38.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/622,pokt-network/pocket,6b9b2db0f25b5fb605c1cb6d454b47708ff4eacd
https://api.github.com/repos/UnUniFi/web-apps/pulls/416,https://api.github.com/repos/UnUniFi/web-apps/pulls/comments/1152007990,kimurayu45z,62ffc83ec968f1b8b0e1cbbe3cd2c1a31f9b71d6,ffb914c71024b4c32b2df76ddbecae4ce60fb6aa,"@@ -0,0 +1,20 @@
+import { Component, OnInit } from '@angular/core';
+
+@Component({
+  selector: 'view-app-tool',
+  templateUrl: './app-tool.component.html',
+  styleUrls: ['./app-tool.component.css'],
+})
+export class AppToolComponent implements OnInit {
+  apps: { name: string; link: string; icon: string }[];
+
+  constructor() {
+    this.apps = [
+      { name: 'Utilities', link: '/', icon: 'account_balance_wallet' },",projects/portal/src/app/views/tools/app-tool/app-tool.component.ts,2023-03-29 14:11:04+00:00,2023-03-29T14:13:43Z,"`assistant` is better for icon

https://fonts.google.com/icons?selected=Material+Symbols+Outlined:assistant:FILL@0;wght@400;GRAD@0;opsz@48",,,,,13,RIGHT,13,,line,https://api.github.com/repos/UnUniFi/web-apps/pulls/416,UnUniFi/web-apps,6ab236b61b7a38af75f7bf67895fdfa69b9b08cb
https://api.github.com/repos/UnUniFi/web-apps/pulls/416,https://api.github.com/repos/UnUniFi/web-apps/pulls/comments/1152013836,kimurayu45z,62ffc83ec968f1b8b0e1cbbe3cd2c1a31f9b71d6,ffb914c71024b4c32b2df76ddbecae4ce60fb6aa,"@@ -0,0 +1,20 @@
+import { Component, OnInit } from '@angular/core';
+
+@Component({
+  selector: 'view-app-tool',
+  templateUrl: './app-tool.component.html',
+  styleUrls: ['./app-tool.component.css'],
+})
+export class AppToolComponent implements OnInit {
+  apps: { name: string; link: string; icon: string }[];
+
+  constructor() {
+    this.apps = [
+      { name: 'Utilities', link: '/', icon: 'account_balance_wallet' },
+      { name: 'NFT Backed Loan', link: '/nft-backed-loan', icon: 'photo_library' },",projects/portal/src/app/views/tools/app-tool/app-tool.component.ts,2023-03-29 14:13:34+00:00,2023-03-29T14:13:43Z,"`loyalty` is better for icon I think
https://fonts.google.com/icons?selected=Material+Symbols+Outlined:loyalty:FILL@0;wght@400;GRAD@0;opsz@48

NFT is not only for JPEG",,,,,14,RIGHT,14,,line,https://api.github.com/repos/UnUniFi/web-apps/pulls/416,UnUniFi/web-apps,6ab236b61b7a38af75f7bf67895fdfa69b9b08cb
https://api.github.com/repos/pokt-network/pocket/pulls/643,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1153107489,bryanchriswhite,cef1ba21eeb797972ab393f2d05aad988db1bbd7,2b3cfd815f591dbbcadc7d57988b31a7029ef220,"@@ -1,6 +1,6 @@
 package peerstore_provider
 
-//go:generate mockgen -source=$GOFILE -destination=../../types/mocks/peerstore_provider_mock.go -package=mock_types github.com/pokt-network/pocket/p2p/types PeerstoreProvider
+//go:generate mockgen -destination=../../types/mocks/peerstore_provider_mock.go -package=mock_types github.com/pokt-network/pocket/p2p/providers/peerstore_provider PeerstoreProvider",p2p/providers/peerstore_provider/peerstore_provider.go,2023-03-30 11:17:34+00:00,2023-03-30T11:17:34Z,"### Rational behind 89548d999ab1ce30cfc6df5d9be425ef95cc780e

@reviewer `mockgen` source mode seems to have trouble with embedded interfaces:

![image](https://user-images.githubusercontent.com/600733/228819163-accbffbe-aaaa-43a1-8ed6-bc75752026e4.png)

(see: https://github.com/golang/mock/issues/10)",,,,3.0,3,RIGHT,4,4.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/643,pokt-network/pocket,c573472deb9c059ed4aed638907a8b38e9010c4f
https://api.github.com/repos/pokt-network/pocket/pulls/652,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1159051193,dylanlott,f092dcd17501dfcb1376f815c09a480a63b1f6d2,d17a865ebf9f07c92e868d1dbe71619b49326411,"@@ -12,48 +12,67 @@ import (
 	typesUtil ""github.com/pokt-network/pocket/utility/types""
 )
 
-func (u *baseUtilityUnitOfWork) beginBlock(previousBlockByzantineValidators [][]byte) typesUtil.Error {
-	if err := u.handleByzantineValidators(previousBlockByzantineValidators); err != nil {
+func (uow *baseUtilityUnitOfWork) beginBlock() typesUtil.Error {",utility/unit_of_work/block.go,2023-04-05 21:41:55+00:00,2023-04-05T23:43:03Z,"u -> uow is a good name change, much clearer through these functions what it is, imo 👍",,,,19.0,15,RIGHT,6,10.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/652,pokt-network/pocket,c9f18a38f7eaa521dc9be5e477fe860fea301fe8
https://api.github.com/repos/pokt-network/pocket/pulls/652,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1160211155,Olshansk,f092dcd17501dfcb1376f815c09a480a63b1f6d2,d17a865ebf9f07c92e868d1dbe71619b49326411,"@@ -12,48 +12,67 @@ import (
 	typesUtil ""github.com/pokt-network/pocket/utility/types""
 )
 
-func (u *baseUtilityUnitOfWork) beginBlock(previousBlockByzantineValidators [][]byte) typesUtil.Error {
-	if err := u.handleByzantineValidators(previousBlockByzantineValidators); err != nil {
+func (uow *baseUtilityUnitOfWork) beginBlock() typesUtil.Error {
+	log := uow.logger.With().Fields(map[string]interface{}{",utility/unit_of_work/block.go,2023-04-06 20:14:34+00:00,2023-04-06T20:34:09Z,I ❤️  this pattern,,,,20.0,16,RIGHT,7,11.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/652,pokt-network/pocket,c9f18a38f7eaa521dc9be5e477fe860fea301fe8
https://api.github.com/repos/pokt-network/pocket/pulls/652,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1160213967,Olshansk,f092dcd17501dfcb1376f815c09a480a63b1f6d2,d17a865ebf9f07c92e868d1dbe71619b49326411,"@@ -12,48 +12,67 @@ import (
 	typesUtil ""github.com/pokt-network/pocket/utility/types""
 )
 
-func (u *baseUtilityUnitOfWork) beginBlock(previousBlockByzantineValidators [][]byte) typesUtil.Error {
-	if err := u.handleByzantineValidators(previousBlockByzantineValidators); err != nil {
+func (uow *baseUtilityUnitOfWork) beginBlock() typesUtil.Error {
+	log := uow.logger.With().Fields(map[string]interface{}{
+		""source"": ""beginBlock"",
+	}).Logger()
+
+	log.Debug().Bool(""TODO"", true).Msg(""determining prevBlockByzantineValidators"")",utility/unit_of_work/block.go,2023-04-06 20:15:31+00:00,2023-04-06T20:34:09Z,Should we put this log in the helper function?,,,,24.0,20,RIGHT,11,15.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/652,pokt-network/pocket,c9f18a38f7eaa521dc9be5e477fe860fea301fe8
https://api.github.com/repos/pokt-network/pocket/pulls/652,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1160223053,Olshansk,f092dcd17501dfcb1376f815c09a480a63b1f6d2,d17a865ebf9f07c92e868d1dbe71619b49326411,"@@ -26,32 +29,58 @@ func NewLeaderUOW(height int64, readContext modules.PersistenceReadContext, rwPe
 	}
 }
 
-func (uow *leaderUtilityUnitOfWork) CreateAndApplyProposalBlock(proposer []byte, maxTxBytes uint64) (stateHash string, txs [][]byte, err error) {
-	prevBlockByzantineVals, err := uow.prevBlockByzantineValidators()
-	if err != nil {
+func (uow *leaderUtilityUnitOfWork) CreateProposalBlock(proposer []byte, maxTxBytes uint64) (stateHash string, txs [][]byte, err error) {
+	log := uow.logger.With().Fields(map[string]interface{}{
+		""proposer"":   hex.EncodeToString(proposer),
+		""maxTxBytes"": maxTxBytes,
+		""source"":     ""CreateProposalBlock"",
+	}).Logger()
+	log.Debug().Msg(""calling beginBlock"")
+	// begin block lifecycle phase
+	if err := uow.beginBlock(); err != nil {
 		return """", nil, err
 	}
 
-	// begin block lifecycle phase
-	if err := uow.beginBlock(prevBlockByzantineVals); err != nil {
+	log.Debug().Msg(""reaping the mempool"")
+	txMempool := uow.GetBus().GetUtilityModule().GetMempool()
+	if txs, err = uow.reapMempool(txMempool, maxTxBytes); err != nil {
+		return """", nil, err
+	}
+
+	// end block lifecycle phase
+	log.Debug().Msg(""calling endBlock"")
+	if err := uow.endBlock(proposer); err != nil {
 		return """", nil, err
 	}
+
+	log.Debug().Msg(""computing state hash"")
+	// TODO(@deblasis): this should be from a ReadContext (the ephemeral/staging one)",utility/unit_of_work/uow_leader.go,2023-04-06 20:19:38+00:00,2023-04-06T20:34:09Z,"We need to get the state hash from the modified context (i.e. the one we're writing to), so I believe this is correct and we can remove the TODO",,,,,57,RIGHT,46,,line,https://api.github.com/repos/pokt-network/pocket/pulls/652,pokt-network/pocket,c9f18a38f7eaa521dc9be5e477fe860fea301fe8
https://api.github.com/repos/pokt-network/pocket/pulls/652,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1160224303,Olshansk,f092dcd17501dfcb1376f815c09a480a63b1f6d2,d17a865ebf9f07c92e868d1dbe71619b49326411,"@@ -26,32 +29,58 @@ func NewLeaderUOW(height int64, readContext modules.PersistenceReadContext, rwPe
 	}
 }
 
-func (uow *leaderUtilityUnitOfWork) CreateAndApplyProposalBlock(proposer []byte, maxTxBytes uint64) (stateHash string, txs [][]byte, err error) {
-	prevBlockByzantineVals, err := uow.prevBlockByzantineValidators()
-	if err != nil {
+func (uow *leaderUtilityUnitOfWork) CreateProposalBlock(proposer []byte, maxTxBytes uint64) (stateHash string, txs [][]byte, err error) {
+	log := uow.logger.With().Fields(map[string]interface{}{
+		""proposer"":   hex.EncodeToString(proposer),
+		""maxTxBytes"": maxTxBytes,
+		""source"":     ""CreateProposalBlock"",
+	}).Logger()
+	log.Debug().Msg(""calling beginBlock"")
+	// begin block lifecycle phase
+	if err := uow.beginBlock(); err != nil {
 		return """", nil, err
 	}
 
-	// begin block lifecycle phase
-	if err := uow.beginBlock(prevBlockByzantineVals); err != nil {
+	log.Debug().Msg(""reaping the mempool"")
+	txMempool := uow.GetBus().GetUtilityModule().GetMempool()
+	if txs, err = uow.reapMempool(txMempool, maxTxBytes); err != nil {
+		return """", nil, err
+	}
+
+	// end block lifecycle phase
+	log.Debug().Msg(""calling endBlock"")
+	if err := uow.endBlock(proposer); err != nil {
 		return """", nil, err
 	}
+
+	log.Debug().Msg(""computing state hash"")
+	// TODO(@deblasis): this should be from a ReadContext (the ephemeral/staging one)
+	// Compute & return the new state hash
+	stateHash, err = uow.persistenceRWContext.ComputeStateHash()
+	if err != nil {
+		log.Fatal().Err(err).Msg(""Updating the app hash failed. TODO: Look into roll-backing the entire commit..."")
+	}
+	log.Info().Str(""state_hash"", stateHash).Msgf(""Finished successfully"")",utility/unit_of_work/uow_leader.go,2023-04-06 20:21:31+00:00,2023-04-06T20:34:10Z,"```suggestion
	log.Info().Str(""state_hash"", stateHash).Msg(""Finished successfully"")
```",,,,,63,RIGHT,52,,line,https://api.github.com/repos/pokt-network/pocket/pulls/652,pokt-network/pocket,c9f18a38f7eaa521dc9be5e477fe860fea301fe8
https://api.github.com/repos/pokt-network/pocket/pulls/652,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1160225068,Olshansk,f092dcd17501dfcb1376f815c09a480a63b1f6d2,d17a865ebf9f07c92e868d1dbe71619b49326411,"@@ -44,147 +45,43 @@ func (uow *baseUtilityUnitOfWork) SetProposalBlock(blockHash string, proposerAdd
 	return nil
 }
 
-// CreateAndApplyProposalBlock implements the exposed functionality of the shared UtilityUnitOfWork interface.
-func (u *baseUtilityUnitOfWork) CreateAndApplyProposalBlock(proposer []byte, maxTransactionBytes int) (stateHash string, txs [][]byte, err error) {
-	prevBlockByzantineVals, err := u.prevBlockByzantineValidators()
-	if err != nil {
-		return """", nil, err
-	}
-
-	// begin block lifecycle phase
-	if err := u.beginBlock(prevBlockByzantineVals); err != nil {
-		return """", nil, err
-	}
-	txs = make([][]byte, 0)
-	txsTotalBz := 0
-	txIdx := 0
-
-	mempool := u.GetBus().GetUtilityModule().GetMempool()
-	for !mempool.IsEmpty() {
-		// NB: In order for transactions to have entered the mempool, `HandleTransaction` must have
-		// been called which handles basic checks & validation.
-		txBz, err := mempool.PopTx()
-		if err != nil {
-			return """", nil, err
-		}
-
-		tx, err := coreTypes.TxFromBytes(txBz)
-		if err != nil {
-			return """", nil, err
-		}
-
-		txBzSize := len(txBz)
-		txsTotalBz += txBzSize
-
-		// Exceeding maximum transaction bytes to be added in this block
-		if txsTotalBz >= maxTransactionBytes {
-			// Add back popped tx to be applied in a future block
-			if err := mempool.AddTx(txBz); err != nil {
-				return """", nil, err
-			}
-			break // we've reached our max
-		}
-
-		txResult, err := u.hydrateTxResult(tx, txIdx)
-		if err != nil {
-			u.logger.Err(err).Msg(""Error in ApplyTransaction"")
-			// TODO(#327): Properly implement 'unhappy path' for save points
-			if err := u.revertLastSavePoint(); err != nil {
-				return """", nil, err
-			}
-			txsTotalBz -= txBzSize
-			continue
-		}
-
-		// Index the transaction
-		if err := u.persistenceRWContext.IndexTransaction(txResult); err != nil {
-			u.logger.Fatal().Err(err).Msgf(""TODO(#327): The transaction can by hydrated but not indexed. Crash the process for now: %v\n"", err)
-		}
-
-		txs = append(txs, txBz)
-		txIdx++
-	}
-
-	if err := u.endBlock(proposer); err != nil {
-		return """", nil, err
-	}
-
-	// TODO(@deblasis): this should be from a ReadContext (the ephemeral/staging one)
-	// Compute & return the new state hash
-	stateHash, err = u.persistenceRWContext.ComputeStateHash()
-	if err != nil {
-		u.logger.Fatal().Err(err).Msg(""Updating the app hash failed. TODO: Look into roll-backing the entire commit..."")
-	}
-	u.logger.Info().Str(""state_hash"", stateHash).Msgf(""CreateAndApplyProposalBlock finished successfully"")
-
-	return stateHash, txs, err
-}
-
 // CLEANUP: code re-use ApplyBlock() for CreateAndApplyBlock()",utility/unit_of_work/module.go,2023-04-06 20:22:40+00:00,2023-04-06T20:34:10Z,Can we remove this?,,,,,48,RIGHT,88,,line,https://api.github.com/repos/pokt-network/pocket/pulls/652,pokt-network/pocket,c9f18a38f7eaa521dc9be5e477fe860fea301fe8
https://api.github.com/repos/pokt-network/pocket/pulls/652,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1160225451,Olshansk,f092dcd17501dfcb1376f815c09a480a63b1f6d2,d17a865ebf9f07c92e868d1dbe71619b49326411,"@@ -44,147 +45,43 @@ func (uow *baseUtilityUnitOfWork) SetProposalBlock(blockHash string, proposerAdd
 	return nil
 }
 
-// CreateAndApplyProposalBlock implements the exposed functionality of the shared UtilityUnitOfWork interface.
-func (u *baseUtilityUnitOfWork) CreateAndApplyProposalBlock(proposer []byte, maxTransactionBytes int) (stateHash string, txs [][]byte, err error) {
-	prevBlockByzantineVals, err := u.prevBlockByzantineValidators()
-	if err != nil {
-		return """", nil, err
-	}
-
-	// begin block lifecycle phase
-	if err := u.beginBlock(prevBlockByzantineVals); err != nil {
-		return """", nil, err
-	}
-	txs = make([][]byte, 0)
-	txsTotalBz := 0
-	txIdx := 0
-
-	mempool := u.GetBus().GetUtilityModule().GetMempool()
-	for !mempool.IsEmpty() {
-		// NB: In order for transactions to have entered the mempool, `HandleTransaction` must have
-		// been called which handles basic checks & validation.
-		txBz, err := mempool.PopTx()
-		if err != nil {
-			return """", nil, err
-		}
-
-		tx, err := coreTypes.TxFromBytes(txBz)
-		if err != nil {
-			return """", nil, err
-		}
-
-		txBzSize := len(txBz)
-		txsTotalBz += txBzSize
-
-		// Exceeding maximum transaction bytes to be added in this block
-		if txsTotalBz >= maxTransactionBytes {
-			// Add back popped tx to be applied in a future block
-			if err := mempool.AddTx(txBz); err != nil {
-				return """", nil, err
-			}
-			break // we've reached our max
-		}
-
-		txResult, err := u.hydrateTxResult(tx, txIdx)
-		if err != nil {
-			u.logger.Err(err).Msg(""Error in ApplyTransaction"")
-			// TODO(#327): Properly implement 'unhappy path' for save points
-			if err := u.revertLastSavePoint(); err != nil {
-				return """", nil, err
-			}
-			txsTotalBz -= txBzSize
-			continue
-		}
-
-		// Index the transaction
-		if err := u.persistenceRWContext.IndexTransaction(txResult); err != nil {
-			u.logger.Fatal().Err(err).Msgf(""TODO(#327): The transaction can by hydrated but not indexed. Crash the process for now: %v\n"", err)
-		}
-
-		txs = append(txs, txBz)
-		txIdx++
-	}
-
-	if err := u.endBlock(proposer); err != nil {
-		return """", nil, err
-	}
-
-	// TODO(@deblasis): this should be from a ReadContext (the ephemeral/staging one)
-	// Compute & return the new state hash
-	stateHash, err = u.persistenceRWContext.ComputeStateHash()
-	if err != nil {
-		u.logger.Fatal().Err(err).Msg(""Updating the app hash failed. TODO: Look into roll-backing the entire commit..."")
-	}
-	u.logger.Info().Str(""state_hash"", stateHash).Msgf(""CreateAndApplyProposalBlock finished successfully"")
-
-	return stateHash, txs, err
-}
-
 // CLEANUP: code re-use ApplyBlock() for CreateAndApplyBlock()
-func (u *baseUtilityUnitOfWork) ApplyBlock() (stateHash string, txs [][]byte, err error) {
-	lastByzantineValidators, err := u.prevBlockByzantineValidators()
-	if err != nil {
-		return """", nil, err
+func (uow *baseUtilityUnitOfWork) ApplyBlock() (stateHash string, txs [][]byte, err error) {
+	log := uow.logger.With().Fields(map[string]interface{}{
+		""source"": ""ApplyBlock"",
+	}).Logger()
+
+	log.Debug().Msg(""checking if proposal block has been set"")
+	if !uow.isProposalBlockSet() {
+		return """", nil, utilTypes.ErrProposalBlockNotSet()
 	}
 
 	// begin block lifecycle phase
-	if err := u.beginBlock(lastByzantineValidators); err != nil {
+	log.Debug().Msg(""calling beginBlock"")
+	if err := uow.beginBlock(); err != nil {
 		return """", nil, err
 	}
 
-	mempool := u.GetBus().GetUtilityModule().GetMempool()
-
-	// deliver txs lifecycle phase
-	for index, txProtoBytes := range u.proposalBlockTxs {
-		tx, err := coreTypes.TxFromBytes(txProtoBytes)
-		if err != nil {
-			return """", nil, err
-		}
-		if err := tx.ValidateBasic(); err != nil {
-			return """", nil, err
-		}
-		// TODO(#346): Currently, the pattern is allowing nil err with an error transaction...
-		//             Should we terminate applyBlock immediately if there's an invalid transaction?
-		//             Or wait until the entire lifecycle is over to evaluate an 'invalid' block
-
-		// Validate and apply the transaction to the Postgres database
-		txResult, err := u.hydrateTxResult(tx, index)
-		if err != nil {
-			return """", nil, err
-		}
-
-		txHash, err := tx.Hash()
-		if err != nil {
-			return """", nil, err
-		}
-
-		// TODO: Need to properly add transactions back on rollbacks
-		if mempool.Contains(txHash) {
-			if err := mempool.RemoveTx(txProtoBytes); err != nil {
-				return """", nil, err
-			}
-			u.logger.Info().Str(""tx_hash"", txHash).Msg(""Applying tx that WAS in the local mempool"")
-		} else {
-			u.logger.Info().Str(""tx_hash"", txHash).Msg(""Applying tx that WAS NOT in the local mempool"")
-		}
-
-		if err := u.persistenceRWContext.IndexTransaction(txResult); err != nil {
-			u.logger.Fatal().Err(err).Msgf(""TODO(#327): We can apply the transaction but not index it. Crash the process for now: %v\n"", err)
-		}
+	log.Debug().Msg(""processing transactions from proposal block"")
+	txMempool := uow.GetBus().GetUtilityModule().GetMempool()
+	if err := uow.processTransactionsFromProposalBlock(txMempool, uow.proposalBlockTxs); err != nil {
+		return """", nil, err
 	}
 
 	// end block lifecycle phase
-	if err := u.endBlock(u.proposalProposerAddr); err != nil {
+	log.Debug().Msg(""calling endBlock"")
+	if err := uow.endBlock(uow.proposalProposerAddr); err != nil {
 		return """", nil, err
 	}
 	// TODO(@deblasis): this should be from a ReadContext (the ephemeral/staging one)",utility/unit_of_work/module.go,2023-04-06 20:23:15+00:00,2023-04-06T20:34:10Z,See my other comment. I believe we can remove this TODO,,,,,76,RIGHT,161,,line,https://api.github.com/repos/pokt-network/pocket/pulls/652,pokt-network/pocket,c9f18a38f7eaa521dc9be5e477fe860fea301fe8
https://api.github.com/repos/pokt-network/pocket/pulls/652,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1160226849,Olshansk,f092dcd17501dfcb1376f815c09a480a63b1f6d2,d17a865ebf9f07c92e868d1dbe71619b49326411,"@@ -216,3 +113,46 @@ func (uow *baseUtilityUnitOfWork) Release() error {
 
 	return nil
 }
+
+func (uow *baseUtilityUnitOfWork) isProposalBlockSet() bool {
+	return uow.proposalStateHash != """" && uow.proposalProposerAddr != nil
+}
+
+// processTransactionsFromProposalBlock processes the transactions from the proposal block.
+// It also removes the transactions from the mempool if they are already present.
+func (uow *baseUtilityUnitOfWork) processTransactionsFromProposalBlock(txMempool mempool.TXMempool, txsBytes [][]byte) (err error) {",utility/unit_of_work/module.go,2023-04-06 20:25:14+00:00,2023-04-06T20:34:10Z,"```suggestion
func (uow *baseUtilityUnitOfWork) processTransactionsFromProposalBlock(txMempool mempool.TXMempool) error {
```

Get the txs from the `uow` to avoid discrepancies ",,,,,123,RIGHT,187,,line,https://api.github.com/repos/pokt-network/pocket/pulls/652,pokt-network/pocket,c9f18a38f7eaa521dc9be5e477fe860fea301fe8
https://api.github.com/repos/pokt-network/pocket/pulls/652,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1160227465,Olshansk,f092dcd17501dfcb1376f815c09a480a63b1f6d2,d17a865ebf9f07c92e868d1dbe71619b49326411,"@@ -216,3 +113,46 @@ func (uow *baseUtilityUnitOfWork) Release() error {
 
 	return nil
 }
+
+func (uow *baseUtilityUnitOfWork) isProposalBlockSet() bool {
+	return uow.proposalStateHash != """" && uow.proposalProposerAddr != nil
+}
+
+// processTransactionsFromProposalBlock processes the transactions from the proposal block.
+// It also removes the transactions from the mempool if they are already present.",utility/unit_of_work/module.go,2023-04-06 20:26:06+00:00,2023-04-06T20:34:10Z,"```suggestion
// It also removes the transactions from the mempool if they are also present.
```",,,,,122,RIGHT,186,,line,https://api.github.com/repos/pokt-network/pocket/pulls/652,pokt-network/pocket,c9f18a38f7eaa521dc9be5e477fe860fea301fe8
https://api.github.com/repos/pokt-network/pocket/pulls/652,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1160228496,Olshansk,f092dcd17501dfcb1376f815c09a480a63b1f6d2,d17a865ebf9f07c92e868d1dbe71619b49326411,"@@ -71,10 +70,9 @@ type UtilityUnitOfWork interface {
 type LeaderUtilityUnitOfWork interface {
 	UtilityUnitOfWork
 
-	// CreateAndApplyProposalBlock reaps the mempool for txs to be proposed in a new block, and
+	// CreateProposalBlock reaps the mempool for txs to be proposed in a new block, and
 	// applies them to this context after validation.",shared/modules/utility_module.go,2023-04-06 20:27:31+00:00,2023-04-06T20:34:10Z,"```suggestion
	// CreateProposalBlock reaps the mempool for txs to be proposed in a new block.
```",,73.0,RIGHT,,74,RIGHT,23,,line,https://api.github.com/repos/pokt-network/pocket/pulls/652,pokt-network/pocket,c9f18a38f7eaa521dc9be5e477fe860fea301fe8
https://api.github.com/repos/pokt-network/pocket/pulls/652,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1160231836,Olshansk,f092dcd17501dfcb1376f815c09a480a63b1f6d2,d17a865ebf9f07c92e868d1dbe71619b49326411,"@@ -44,147 +45,43 @@ func (uow *baseUtilityUnitOfWork) SetProposalBlock(blockHash string, proposerAdd
 	return nil
 }
 
-// CreateAndApplyProposalBlock implements the exposed functionality of the shared UtilityUnitOfWork interface.
-func (u *baseUtilityUnitOfWork) CreateAndApplyProposalBlock(proposer []byte, maxTransactionBytes int) (stateHash string, txs [][]byte, err error) {
-	prevBlockByzantineVals, err := u.prevBlockByzantineValidators()
-	if err != nil {
-		return """", nil, err
-	}
-
-	// begin block lifecycle phase
-	if err := u.beginBlock(prevBlockByzantineVals); err != nil {
-		return """", nil, err
-	}
-	txs = make([][]byte, 0)
-	txsTotalBz := 0
-	txIdx := 0
-
-	mempool := u.GetBus().GetUtilityModule().GetMempool()
-	for !mempool.IsEmpty() {
-		// NB: In order for transactions to have entered the mempool, `HandleTransaction` must have
-		// been called which handles basic checks & validation.
-		txBz, err := mempool.PopTx()
-		if err != nil {
-			return """", nil, err
-		}
-
-		tx, err := coreTypes.TxFromBytes(txBz)
-		if err != nil {
-			return """", nil, err
-		}
-
-		txBzSize := len(txBz)
-		txsTotalBz += txBzSize
-
-		// Exceeding maximum transaction bytes to be added in this block
-		if txsTotalBz >= maxTransactionBytes {
-			// Add back popped tx to be applied in a future block
-			if err := mempool.AddTx(txBz); err != nil {
-				return """", nil, err
-			}
-			break // we've reached our max
-		}
-
-		txResult, err := u.hydrateTxResult(tx, txIdx)
-		if err != nil {
-			u.logger.Err(err).Msg(""Error in ApplyTransaction"")
-			// TODO(#327): Properly implement 'unhappy path' for save points
-			if err := u.revertLastSavePoint(); err != nil {
-				return """", nil, err
-			}
-			txsTotalBz -= txBzSize
-			continue
-		}
-
-		// Index the transaction
-		if err := u.persistenceRWContext.IndexTransaction(txResult); err != nil {
-			u.logger.Fatal().Err(err).Msgf(""TODO(#327): The transaction can by hydrated but not indexed. Crash the process for now: %v\n"", err)
-		}
-
-		txs = append(txs, txBz)
-		txIdx++
-	}
-
-	if err := u.endBlock(proposer); err != nil {
-		return """", nil, err
-	}
-
-	// TODO(@deblasis): this should be from a ReadContext (the ephemeral/staging one)
-	// Compute & return the new state hash
-	stateHash, err = u.persistenceRWContext.ComputeStateHash()
-	if err != nil {
-		u.logger.Fatal().Err(err).Msg(""Updating the app hash failed. TODO: Look into roll-backing the entire commit..."")
-	}
-	u.logger.Info().Str(""state_hash"", stateHash).Msgf(""CreateAndApplyProposalBlock finished successfully"")
-
-	return stateHash, txs, err
-}
-
 // CLEANUP: code re-use ApplyBlock() for CreateAndApplyBlock()
-func (u *baseUtilityUnitOfWork) ApplyBlock() (stateHash string, txs [][]byte, err error) {
-	lastByzantineValidators, err := u.prevBlockByzantineValidators()
-	if err != nil {
-		return """", nil, err
+func (uow *baseUtilityUnitOfWork) ApplyBlock() (stateHash string, txs [][]byte, err error) {",utility/unit_of_work/module.go,2023-04-06 20:31:10+00:00,2023-04-06T20:34:10Z,I think we can remove everything other than `err` from the return value,,,,,49,RIGHT,93,,line,https://api.github.com/repos/pokt-network/pocket/pulls/652,pokt-network/pocket,c9f18a38f7eaa521dc9be5e477fe860fea301fe8
https://api.github.com/repos/pokt-network/pocket/pulls/652,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1160232780,Olshansk,f092dcd17501dfcb1376f815c09a480a63b1f6d2,d17a865ebf9f07c92e868d1dbe71619b49326411,"@@ -216,3 +113,46 @@ func (uow *baseUtilityUnitOfWork) Release() error {
 
 	return nil
 }
+
+func (uow *baseUtilityUnitOfWork) isProposalBlockSet() bool {
+	return uow.proposalStateHash != """" && uow.proposalProposerAddr != nil",utility/unit_of_work/module.go,2023-04-06 20:31:32+00:00,2023-04-06T20:34:10Z,And check that `uow.proposalBlockTxs` is not empty,,,,136.0,118,RIGHT,182,216.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/652,pokt-network/pocket,c9f18a38f7eaa521dc9be5e477fe860fea301fe8
https://api.github.com/repos/pokt-network/pocket/pulls/652,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1160233872,Olshansk,f092dcd17501dfcb1376f815c09a480a63b1f6d2,d17a865ebf9f07c92e868d1dbe71619b49326411,"@@ -44,147 +45,43 @@ func (uow *baseUtilityUnitOfWork) SetProposalBlock(blockHash string, proposerAdd
 	return nil
 }
 
-// CreateAndApplyProposalBlock implements the exposed functionality of the shared UtilityUnitOfWork interface.
-func (u *baseUtilityUnitOfWork) CreateAndApplyProposalBlock(proposer []byte, maxTransactionBytes int) (stateHash string, txs [][]byte, err error) {
-	prevBlockByzantineVals, err := u.prevBlockByzantineValidators()
-	if err != nil {
-		return """", nil, err
-	}
-
-	// begin block lifecycle phase
-	if err := u.beginBlock(prevBlockByzantineVals); err != nil {
-		return """", nil, err
-	}
-	txs = make([][]byte, 0)
-	txsTotalBz := 0
-	txIdx := 0
-
-	mempool := u.GetBus().GetUtilityModule().GetMempool()
-	for !mempool.IsEmpty() {
-		// NB: In order for transactions to have entered the mempool, `HandleTransaction` must have
-		// been called which handles basic checks & validation.
-		txBz, err := mempool.PopTx()
-		if err != nil {
-			return """", nil, err
-		}
-
-		tx, err := coreTypes.TxFromBytes(txBz)
-		if err != nil {
-			return """", nil, err
-		}
-
-		txBzSize := len(txBz)
-		txsTotalBz += txBzSize
-
-		// Exceeding maximum transaction bytes to be added in this block
-		if txsTotalBz >= maxTransactionBytes {
-			// Add back popped tx to be applied in a future block
-			if err := mempool.AddTx(txBz); err != nil {
-				return """", nil, err
-			}
-			break // we've reached our max
-		}
-
-		txResult, err := u.hydrateTxResult(tx, txIdx)
-		if err != nil {
-			u.logger.Err(err).Msg(""Error in ApplyTransaction"")
-			// TODO(#327): Properly implement 'unhappy path' for save points
-			if err := u.revertLastSavePoint(); err != nil {
-				return """", nil, err
-			}
-			txsTotalBz -= txBzSize
-			continue
-		}
-
-		// Index the transaction
-		if err := u.persistenceRWContext.IndexTransaction(txResult); err != nil {
-			u.logger.Fatal().Err(err).Msgf(""TODO(#327): The transaction can by hydrated but not indexed. Crash the process for now: %v\n"", err)
-		}
-
-		txs = append(txs, txBz)
-		txIdx++
-	}
-
-	if err := u.endBlock(proposer); err != nil {
-		return """", nil, err
-	}
-
-	// TODO(@deblasis): this should be from a ReadContext (the ephemeral/staging one)
-	// Compute & return the new state hash
-	stateHash, err = u.persistenceRWContext.ComputeStateHash()
-	if err != nil {
-		u.logger.Fatal().Err(err).Msg(""Updating the app hash failed. TODO: Look into roll-backing the entire commit..."")
-	}
-	u.logger.Info().Str(""state_hash"", stateHash).Msgf(""CreateAndApplyProposalBlock finished successfully"")
-
-	return stateHash, txs, err
-}
-
 // CLEANUP: code re-use ApplyBlock() for CreateAndApplyBlock()
-func (u *baseUtilityUnitOfWork) ApplyBlock() (stateHash string, txs [][]byte, err error) {
-	lastByzantineValidators, err := u.prevBlockByzantineValidators()
-	if err != nil {
-		return """", nil, err
+func (uow *baseUtilityUnitOfWork) ApplyBlock() (stateHash string, txs [][]byte, err error) {
+	log := uow.logger.With().Fields(map[string]interface{}{
+		""source"": ""ApplyBlock"",
+	}).Logger()
+
+	log.Debug().Msg(""checking if proposal block has been set"")
+	if !uow.isProposalBlockSet() {
+		return """", nil, utilTypes.ErrProposalBlockNotSet()
 	}
 
 	// begin block lifecycle phase
-	if err := u.beginBlock(lastByzantineValidators); err != nil {
+	log.Debug().Msg(""calling beginBlock"")
+	if err := uow.beginBlock(); err != nil {
 		return """", nil, err
 	}
 
-	mempool := u.GetBus().GetUtilityModule().GetMempool()
-
-	// deliver txs lifecycle phase
-	for index, txProtoBytes := range u.proposalBlockTxs {
-		tx, err := coreTypes.TxFromBytes(txProtoBytes)
-		if err != nil {
-			return """", nil, err
-		}
-		if err := tx.ValidateBasic(); err != nil {
-			return """", nil, err
-		}
-		// TODO(#346): Currently, the pattern is allowing nil err with an error transaction...
-		//             Should we terminate applyBlock immediately if there's an invalid transaction?
-		//             Or wait until the entire lifecycle is over to evaluate an 'invalid' block
-
-		// Validate and apply the transaction to the Postgres database
-		txResult, err := u.hydrateTxResult(tx, index)
-		if err != nil {
-			return """", nil, err
-		}
-
-		txHash, err := tx.Hash()
-		if err != nil {
-			return """", nil, err
-		}
-
-		// TODO: Need to properly add transactions back on rollbacks
-		if mempool.Contains(txHash) {
-			if err := mempool.RemoveTx(txProtoBytes); err != nil {
-				return """", nil, err
-			}
-			u.logger.Info().Str(""tx_hash"", txHash).Msg(""Applying tx that WAS in the local mempool"")
-		} else {
-			u.logger.Info().Str(""tx_hash"", txHash).Msg(""Applying tx that WAS NOT in the local mempool"")
-		}
-
-		if err := u.persistenceRWContext.IndexTransaction(txResult); err != nil {
-			u.logger.Fatal().Err(err).Msgf(""TODO(#327): We can apply the transaction but not index it. Crash the process for now: %v\n"", err)
-		}
+	log.Debug().Msg(""processing transactions from proposal block"")
+	txMempool := uow.GetBus().GetUtilityModule().GetMempool()
+	if err := uow.processTransactionsFromProposalBlock(txMempool, uow.proposalBlockTxs); err != nil {
+		return """", nil, err
 	}
 
 	// end block lifecycle phase
-	if err := u.endBlock(u.proposalProposerAddr); err != nil {
+	log.Debug().Msg(""calling endBlock"")
+	if err := uow.endBlock(uow.proposalProposerAddr); err != nil {
 		return """", nil, err
 	}
 	// TODO(@deblasis): this should be from a ReadContext (the ephemeral/staging one)
 	// return the app hash (consensus module will get the validator set directly)
-	stateHash, err = u.persistenceRWContext.ComputeStateHash()
+	log.Debug().Msg(""computing state hash"")
+	stateHash, err = uow.persistenceRWContext.ComputeStateHash()",utility/unit_of_work/module.go,2023-04-06 20:31:55+00:00,2023-04-06T20:34:10Z,We need to validate that the computed state hash != `uow.proposalStateHash`,,,,,79,RIGHT,165,,line,https://api.github.com/repos/pokt-network/pocket/pulls/652,pokt-network/pocket,c9f18a38f7eaa521dc9be5e477fe860fea301fe8
https://api.github.com/repos/pokt-network/pocket/pulls/652,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1160235085,Olshansk,f092dcd17501dfcb1376f815c09a480a63b1f6d2,d17a865ebf9f07c92e868d1dbe71619b49326411,"@@ -42,7 +42,7 @@ type UnstakingActor interface {
 
 // CONSIDERATION: Consider removing `Utility` from `UtilityUnitOfWork` altogether
 
-// TECHDEBT(@deblasis): `CreateAndApplyProposalBlock` and `ApplyBlock` should be be refactored into a
+// TECHDEBT(@deblasis): `CreateProposalBlock` and `ApplyBlock` should be be refactored into a",shared/modules/utility_module.go,2023-04-06 20:33:08+00:00,2023-04-06T20:34:10Z,Confirming this still a TODO for a followup?,,,,,45,RIGHT,5,,line,https://api.github.com/repos/pokt-network/pocket/pulls/652,pokt-network/pocket,c9f18a38f7eaa521dc9be5e477fe860fea301fe8
https://api.github.com/repos/pokt-network/pocket/pulls/652,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1160338399,Olshansk,abbe4e667045a4f498cf7fbfb8ab30548c8f7f8f,d17a865ebf9f07c92e868d1dbe71619b49326411,"@@ -45,46 +49,58 @@ func (uow *baseUtilityUnitOfWork) SetProposalBlock(blockHash string, proposerAdd
 	return nil
 }
 
-// CLEANUP: code re-use ApplyBlock() for CreateAndApplyBlock()
-func (uow *baseUtilityUnitOfWork) ApplyBlock() (stateHash string, txs [][]byte, err error) {
+func (uow *baseUtilityUnitOfWork) ApplyBlock() error {
 	log := uow.logger.With().Fields(map[string]interface{}{
 		""source"": ""ApplyBlock"",
 	}).Logger()
 
 	log.Debug().Msg(""checking if proposal block has been set"")
 	if !uow.isProposalBlockSet() {
-		return """", nil, utilTypes.ErrProposalBlockNotSet()
+		return utilTypes.ErrProposalBlockNotSet()
 	}
 
 	// begin block lifecycle phase
 	log.Debug().Msg(""calling beginBlock"")
 	if err := uow.beginBlock(); err != nil {
-		return """", nil, err
+		return err
 	}
 
 	log.Debug().Msg(""processing transactions from proposal block"")
 	txMempool := uow.GetBus().GetUtilityModule().GetMempool()
-	if err := uow.processTransactionsFromProposalBlock(txMempool, uow.proposalBlockTxs); err != nil {
-		return """", nil, err
+	if err := uow.processTransactionsFromProposalBlock(txMempool); err != nil {
+		return err
 	}
 
 	// end block lifecycle phase
 	log.Debug().Msg(""calling endBlock"")
 	if err := uow.endBlock(uow.proposalProposerAddr); err != nil {
-		return """", nil, err
+		return err
 	}
-	// TODO(@deblasis): this should be from a ReadContext (the ephemeral/staging one)
 	// return the app hash (consensus module will get the validator set directly)
 	log.Debug().Msg(""computing state hash"")
-	stateHash, err = uow.persistenceRWContext.ComputeStateHash()
+	stateHash, err := uow.persistenceRWContext.ComputeStateHash()
 	if err != nil {
-		log.Fatal().Err(err).Msg(""Updating the app hash failed. TODO: Look into roll-backing the entire commit..."")
-		return """", nil, utilTypes.ErrAppHash(err)
+		log.Fatal().Err(err).Bool(""TODO"", true).Msg(""Updating the app hash failed. TODO: Look into roll-backing the entire commit..."")
+		return utilTypes.ErrAppHash(err)
 	}
+
+	// IMPROVE: this acts as a feature flag to allow tests to ignore the check if needed, ideally the tests should have a way to determine",utility/unit_of_work/module.go,2023-04-06 23:46:13+00:00,2023-04-06T23:47:07Z,"```suggestion
	// IMPROVE(#655): this acts as a feature flag to allow tests to ignore the check if needed, ideally the tests should have a way to determine
```",,,,,87,RIGHT,68,,line,https://api.github.com/repos/pokt-network/pocket/pulls/652,pokt-network/pocket,c9f18a38f7eaa521dc9be5e477fe860fea301fe8
https://api.github.com/repos/pokt-network/pocket/pulls/654,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1160082272,dylanlott,132785e1113fa71021c05b6a605b278e6188d716,d2caa53c8a1d0817a8d77ab81b4ea0c61d5ac1df,"@@ -76,10 +76,10 @@ type PersistenceWriteContext interface {
 	IndexTransaction(txResult TxResult) error
 
 	// Pool Operations
-	AddPoolAmount(name string, amount string) error
-	SubtractPoolAmount(name string, amount string) error
-	SetPoolAmount(name string, amount string) error
-	InsertPool(name string, amount string) error
+	AddPoolAmount(address []byte, amount string) error
+	SubtractPoolAmount(address []byte, amount string) error
+	SetPoolAmount(address []byte, amount string) error
+	InsertPool(address []byte, amount string) error",shared/modules/persistence_module.go,2023-04-06 17:36:15+00:00,2023-04-06T17:39:03Z,`[]byte` is definitely an improvement here 👍,79.0,79.0,RIGHT,82.0,82,RIGHT,11,11.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/654,pokt-network/pocket,726619b318537caaa69bd184e2c0c6cef0b09dc1
https://api.github.com/repos/pokt-network/pocket/pulls/654,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1160258274,Olshansk,132785e1113fa71021c05b6a605b278e6188d716,d2caa53c8a1d0817a8d77ab81b4ea0c61d5ac1df,"@@ -84,28 +87,33 @@ func TestUtilityUnitOfWork_AddPoolAmount(t *testing.T) {
 
 func TestUtilityUnitOfWork_InsertPool(t *testing.T) {
 	uow := newTestingUtilityUnitOfWork(t, 0)
-	testPoolName := ""TEST_POOL""
+
+	_, _, poolAddr := keygen.GetInstance().Next()",utility/unit_of_work/account_test.go,2023-04-06 21:05:15+00:00,2023-04-06T21:16:47Z,"Man, whoever designed this interface was thinking ahead",,,,91.0,91,RIGHT,33,33.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/654,pokt-network/pocket,726619b318537caaa69bd184e2c0c6cef0b09dc1
https://api.github.com/repos/pokt-network/pocket/pulls/654,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1160262076,Olshansk,132785e1113fa71021c05b6a605b278e6188d716,d2caa53c8a1d0817a8d77ab81b4ea0c61d5ac1df,"@@ -1,18 +1,35 @@
 package types",shared/core/types/pools.go,2023-04-06 21:11:07+00:00,2023-04-06T21:16:47Z,Was doing something related in v0 this week: https://github.com/pokt-network/pocket-core/pull/1540/files,,,,1.0,1,RIGHT,1,1.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/654,pokt-network/pocket,726619b318537caaa69bd184e2c0c6cef0b09dc1
https://api.github.com/repos/pokt-network/pocket/pulls/654,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1160263044,Olshansk,132785e1113fa71021c05b6a605b278e6188d716,d2caa53c8a1d0817a8d77ab81b4ea0c61d5ac1df,"@@ -0,0 +1,67 @@
+package types
+
+import (
+	""bytes""
+	""encoding/hex""
+	""errors""
+	""strings""
+	""testing""
+
+	""github.com/stretchr/testify/require""
+)
+
+func TestPools_Address(t *testing.T) {
+	tests := []struct {
+		name string
+		pn   Pools
+	}{
+		// initializing tests with the custom/edge cases
+		{""unspecified"", Pools_POOLS_UNSPECIFIED},
+		{""invalid"", Pools(100)},
+	}
+
+	// adding all the real world cases programmatically in order to catch any changes to the enum
+	// that must be reflected into the hardcoded values
+	for _, pool := range Pools_value {
+		tests = append(tests, struct {
+			name string
+			pn   Pools
+		}{
+			name: Pools(pool).FriendlyName(),
+			pn:   Pools(pool),
+		})
+	}
+
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			name := tt.pn.FriendlyName()
+			want, err := convertFriendlyNameToHexBytes(name)
+			require.NoError(t, err)
+
+			if got := tt.pn.Address(); !bytes.Equal(got, want) {
+				t.Errorf(""Pools.Address() = %v, want %v"", string(got), string(want))
+			}
+		})
+	}
+}
+
+// convertFriendlyNameToHexBytes is the function used to opinionatedly convert a pool name into a valid address",shared/core/types/pools_test.go,2023-04-06 21:12:48+00:00,2023-04-06T21:16:47Z,"Thoughts on doing the same thing as v0? https://github.com/pokt-network/pocket-core/blob/a109dfc03a13eec06413bf1eb7d17fe093f96842/x/auth/types/account.go#L320

Leaving a TODO is fine a well - up to you.",,,,48.0,48,RIGHT,48,48.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/654,pokt-network/pocket,726619b318537caaa69bd184e2c0c6cef0b09dc1
https://api.github.com/repos/pokt-network/pocket/pulls/654,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1160264106,Olshansk,132785e1113fa71021c05b6a605b278e6188d716,d2caa53c8a1d0817a8d77ab81b4ea0c61d5ac1df,"@@ -355,15 +369,19 @@ func TestGetAllPools(t *testing.T) {
 	db := NewTestPostgresContext(t, 0)
 
 	updatePool := func(db *persistence.PostgresContext, pool *coreTypes.Account) error {
-		return db.AddPoolAmount(pool.GetAddress(), ""10"")
+		addrBz, err := hex.DecodeString(pool.Address)
+		require.NoError(t, err)
+		return db.AddPoolAmount(addrBz, ""10"")
 	}
 
-	getAllActorsTest(t, db, db.GetAllPools, createAndInsertNewPool, updatePool, 7)
+	// -1 because we don't count the ""unspecified"" pool (Pools_POOLS_UNSPECIFIED)
+	initialCount := len(coreTypes.Pools_value) - 1
+	getAllActorsTest(t, db, db.GetAllPools, createAndInsertNewPool, updatePool, initialCount)
 }
 
 func TestPoolsUpdatedAtHeight(t *testing.T) {
 	db := NewTestPostgresContext(t, 0)
-	numPoolsInTestGenesis := 7
+	numPoolsInTestGenesis := len(coreTypes.Pools_value) - 1 // -1 because we don't count the ""unspecified"" pool (Pools_POOLS_UNSPECIFIED",persistence/test/account_test.go,2023-04-06 21:14:23+00:00,2023-04-06T21:16:47Z,"```suggestion
	numPoolsInTestGenesis := len(coreTypes.Pools_value) - 1 // -1 because we don't count the ""unspecified"" pool (Pools_POOLS_UNSPECIFIED)
```",,,,,384,RIGHT,161,,line,https://api.github.com/repos/pokt-network/pocket/pulls/654,pokt-network/pocket,726619b318537caaa69bd184e2c0c6cef0b09dc1
https://api.github.com/repos/pokt-network/pocket/pulls/663,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1162144913,Olshansk,f1ee42b7a6f42ff0361b8ceff1bd5901c906d38c,f1ee42b7a6f42ff0361b8ceff1bd5901c906d38c,"@@ -1,229 +0,0 @@
-# Pocket 1.0 E2E Testing Framework",e2e/docs/E2E_FRAMEWORK.md,2023-04-10 22:42:28+00:00,2023-04-10T22:42:32Z,This deleted the entire document without adding a new one.,,,,1.0,1,LEFT,1,1.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/663,pokt-network/pocket,43320c70cb5306506e1ffaadc26bc879b023e6e6
https://api.github.com/repos/pokt-network/pocket/pulls/664,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1178748683,bryanchriswhite,abee27ff6c7a335f06a22356e692d4377aa6f5d2,0b028e117325716ce02fda4d52a6be9a9dfd5e92,"@@ -69,61 +70,87 @@ func init() {
 	rpcHost = runtime.GetEnv(""RPC_HOST"", validator1Endpoint)
 }
 
+// NewDebugSubCommands builds out the list of debug subcommands by matching the
+// handleSelect dispatch to the appropriate command.
+// * To add a debug subcommand, you must add it to the `items` array and then
+// write a function handler to match for it in `handleSelect`.
+func NewDebugSubCommands() []*cobra.Command {
+	commands := make([]*cobra.Command, len(items))
+	for idx, promptItem := range items {
+		commands[idx] = &cobra.Command{
+			Use: promptItem,
+			PersistentPreRun: func(cmd *cobra.Command, args []string) {
+				persistentPreRun(cmd, args)
+			},
+			Run: func(cmd *cobra.Command, args []string) {
+				handleSelect(cmd, cmd.Use)
+			},
+			ValidArgs: items,
+		}
+	}
+	return commands
+}
+
+// NewDebugCommand returns the cobra CLI for the Debug command.
 func NewDebugCommand() *cobra.Command {
 	return &cobra.Command{
 		Use:   ""debug"",
 		Short: ""Debug utility for rapid development"",
-		Args:  cobra.ExactArgs(0),
+		Args:  cobra.MaximumNArgs(0),
 		PersistentPreRun: func(cmd *cobra.Command, args []string) {
-
-			// TECHDEBT: this is to keep backwards compatibility with localnet
-			configPath = runtime.GetEnv(""CONFIG_PATH"", ""build/config/config1.json"")
-
-			runtimeMgr := runtime.NewManagerFromFiles(
-				configPath, genesisPath,
-				runtime.WithClientDebugMode(),
-				runtime.WithRandomPK(),
-			)
-
-			bus := runtimeMgr.GetBus()
-			modulesRegistry := bus.GetModulesRegistry()
-
-			rpcURL := fmt.Sprintf(""http://%s:%s"", rpcHost, defaults.DefaultRPCPort)
-
-			addressBookProvider := rpcABP.NewRPCPeerstoreProvider(
-				rpcABP.WithP2PConfig(
-					runtimeMgr.GetConfig().P2P,
-				),
-				rpcABP.WithCustomRPCURL(rpcURL),
-			)
-			modulesRegistry.RegisterModule(addressBookProvider)
-
-			currentHeightProvider := rpcCHP.NewRPCCurrentHeightProvider(
-				rpcCHP.WithCustomRPCURL(rpcURL),
-			)
-			modulesRegistry.RegisterModule(currentHeightProvider)
-
-			setValueInCLIContext(cmd, busCLICtxKey, bus)
-
-			mod, err := p2p.Create(bus)
-			if err != nil {
-				logger.Global.Fatal().Err(err).Msg(""Failed to create p2p module"")
-			}
-
-			var ok bool
-			p2pMod, ok = mod.(modules.P2PModule)
-			if !ok {
-				logger.Global.Fatal().Msgf(""unexpected P2P module type: %T"", mod)
-			}
-
-			if err := p2pMod.Start(); err != nil {
-				logger.Global.Fatal().Err(err).Msg(""Failed to start p2p module"")
-			}
+			persistentPreRun(cmd, args)
 		},
 		RunE: runDebug,
 	}
 }
 
+// persistentPreRun is called by both debug and debug sub-commands before runs
+func persistentPreRun(cmd *cobra.Command, _ []string) {
+	// TECHDEBT: this is to keep backwards compatibility with localnet
+	configPath = runtime.GetEnv(""CONFIG_PATH"", ""build/config/config1.json"")
+
+	runtimeMgr := runtime.NewManagerFromFiles(
+		configPath, genesisPath,
+		runtime.WithClientDebugMode(),
+		runtime.WithRandomPK(),
+	)
+
+	bus := runtimeMgr.GetBus()
+	modulesRegistry := bus.GetModulesRegistry()
+
+	rpcURL := fmt.Sprintf(""http://%s:%s"", rpcHost, defaults.DefaultRPCPort)
+",app/client/cli/debug.go,2023-04-27 07:40:54+00:00,2023-04-27T07:40:55Z,"Wdyt about refactoring everything below into a few functions?:

```golang
func setupPeerstoreProvider(runtimeMgr runtime.Manager, rpcURL string) { ... }
func setupCurrentHeightProvider(runtimeMgr runtime.Manager, rpcURL string) { ... }
func setupAndStartP2PModule(bus runtime.Bus) { ... }
```",,,,126.0,126,RIGHT,110,114.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/664,pokt-network/pocket,2d5e6bcd1ec538d465de4090184140a148e4a7e6
https://api.github.com/repos/pokt-network/pocket/pulls/664,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1178748736,bryanchriswhite,abee27ff6c7a335f06a22356e692d4377aa6f5d2,0b028e117325716ce02fda4d52a6be9a9dfd5e92,"@@ -69,61 +70,87 @@ func init() {
 	rpcHost = runtime.GetEnv(""RPC_HOST"", validator1Endpoint)
 }
 
+// NewDebugSubCommands builds out the list of debug subcommands by matching the
+// handleSelect dispatch to the appropriate command.
+// * To add a debug subcommand, you must add it to the `items` array and then
+// write a function handler to match for it in `handleSelect`.
+func NewDebugSubCommands() []*cobra.Command {
+	commands := make([]*cobra.Command, len(items))
+	for idx, promptItem := range items {
+		commands[idx] = &cobra.Command{
+			Use: promptItem,
+			PersistentPreRun: func(cmd *cobra.Command, args []string) {
+				persistentPreRun(cmd, args)
+			},
+			Run: func(cmd *cobra.Command, args []string) {
+				handleSelect(cmd, cmd.Use)
+			},
+			ValidArgs: items,
+		}
+	}
+	return commands
+}
+
+// NewDebugCommand returns the cobra CLI for the Debug command.
 func NewDebugCommand() *cobra.Command {
 	return &cobra.Command{
 		Use:   ""debug"",
 		Short: ""Debug utility for rapid development"",
-		Args:  cobra.ExactArgs(0),
+		Args:  cobra.MaximumNArgs(0),
 		PersistentPreRun: func(cmd *cobra.Command, args []string) {
-
-			// TECHDEBT: this is to keep backwards compatibility with localnet
-			configPath = runtime.GetEnv(""CONFIG_PATH"", ""build/config/config1.json"")
-
-			runtimeMgr := runtime.NewManagerFromFiles(
-				configPath, genesisPath,
-				runtime.WithClientDebugMode(),
-				runtime.WithRandomPK(),
-			)
-
-			bus := runtimeMgr.GetBus()
-			modulesRegistry := bus.GetModulesRegistry()
-
-			rpcURL := fmt.Sprintf(""http://%s:%s"", rpcHost, defaults.DefaultRPCPort)
-
-			addressBookProvider := rpcABP.NewRPCPeerstoreProvider(
-				rpcABP.WithP2PConfig(
-					runtimeMgr.GetConfig().P2P,
-				),
-				rpcABP.WithCustomRPCURL(rpcURL),
-			)
-			modulesRegistry.RegisterModule(addressBookProvider)
-
-			currentHeightProvider := rpcCHP.NewRPCCurrentHeightProvider(
-				rpcCHP.WithCustomRPCURL(rpcURL),
-			)
-			modulesRegistry.RegisterModule(currentHeightProvider)
-
-			setValueInCLIContext(cmd, busCLICtxKey, bus)
-
-			mod, err := p2p.Create(bus)
-			if err != nil {
-				logger.Global.Fatal().Err(err).Msg(""Failed to create p2p module"")
-			}
-
-			var ok bool
-			p2pMod, ok = mod.(modules.P2PModule)
-			if !ok {
-				logger.Global.Fatal().Msgf(""unexpected P2P module type: %T"", mod)
-			}
-
-			if err := p2pMod.Start(); err != nil {
-				logger.Global.Fatal().Err(err).Msg(""Failed to start p2p module"")
-			}
+			persistentPreRun(cmd, args)
 		},
 		RunE: runDebug,
 	}
 }
 
+// persistentPreRun is called by both debug and debug sub-commands before runs
+func persistentPreRun(cmd *cobra.Command, _ []string) {
+	// TECHDEBT: this is to keep backwards compatibility with localnet
+	configPath = runtime.GetEnv(""CONFIG_PATH"", ""build/config/config1.json"")
+
+	runtimeMgr := runtime.NewManagerFromFiles(
+		configPath, genesisPath,
+		runtime.WithClientDebugMode(),
+		runtime.WithRandomPK(),
+	)
+
+	bus := runtimeMgr.GetBus()
+	modulesRegistry := bus.GetModulesRegistry()
+
+	rpcURL := fmt.Sprintf(""http://%s:%s"", rpcHost, defaults.DefaultRPCPort)
+
+	addressBookProvider := rpcABP.NewRPCPeerstoreProvider(
+		rpcABP.WithP2PConfig(
+			runtimeMgr.GetConfig().P2P,
+		),",app/client/cli/debug.go,2023-04-27 07:40:57+00:00,2023-04-27T07:40:58Z,nit: I think this would fit fine on one line and would be more readable.,,124.0,RIGHT,,126,RIGHT,114,,line,https://api.github.com/repos/pokt-network/pocket/pulls/664,pokt-network/pocket,2d5e6bcd1ec538d465de4090184140a148e4a7e6
https://api.github.com/repos/pokt-network/pocket/pulls/664,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1178748766,bryanchriswhite,abee27ff6c7a335f06a22356e692d4377aa6f5d2,0b028e117325716ce02fda4d52a6be9a9dfd5e92,"@@ -69,61 +70,87 @@ func init() {
 	rpcHost = runtime.GetEnv(""RPC_HOST"", validator1Endpoint)
 }
 
+// NewDebugSubCommands builds out the list of debug subcommands by matching the
+// handleSelect dispatch to the appropriate command.
+// * To add a debug subcommand, you must add it to the `items` array and then
+// write a function handler to match for it in `handleSelect`.
+func NewDebugSubCommands() []*cobra.Command {
+	commands := make([]*cobra.Command, len(items))
+	for idx, promptItem := range items {
+		commands[idx] = &cobra.Command{
+			Use: promptItem,
+			PersistentPreRun: func(cmd *cobra.Command, args []string) {
+				persistentPreRun(cmd, args)
+			},
+			Run: func(cmd *cobra.Command, args []string) {
+				handleSelect(cmd, cmd.Use)
+			},
+			ValidArgs: items,
+		}
+	}
+	return commands
+}
+
+// NewDebugCommand returns the cobra CLI for the Debug command.
 func NewDebugCommand() *cobra.Command {
 	return &cobra.Command{
 		Use:   ""debug"",
 		Short: ""Debug utility for rapid development"",
-		Args:  cobra.ExactArgs(0),
+		Args:  cobra.MaximumNArgs(0),
 		PersistentPreRun: func(cmd *cobra.Command, args []string) {
-
-			// TECHDEBT: this is to keep backwards compatibility with localnet
-			configPath = runtime.GetEnv(""CONFIG_PATH"", ""build/config/config1.json"")
-
-			runtimeMgr := runtime.NewManagerFromFiles(
-				configPath, genesisPath,
-				runtime.WithClientDebugMode(),
-				runtime.WithRandomPK(),
-			)
-
-			bus := runtimeMgr.GetBus()
-			modulesRegistry := bus.GetModulesRegistry()
-
-			rpcURL := fmt.Sprintf(""http://%s:%s"", rpcHost, defaults.DefaultRPCPort)
-
-			addressBookProvider := rpcABP.NewRPCPeerstoreProvider(
-				rpcABP.WithP2PConfig(
-					runtimeMgr.GetConfig().P2P,
-				),
-				rpcABP.WithCustomRPCURL(rpcURL),
-			)
-			modulesRegistry.RegisterModule(addressBookProvider)
-
-			currentHeightProvider := rpcCHP.NewRPCCurrentHeightProvider(
-				rpcCHP.WithCustomRPCURL(rpcURL),
-			)
-			modulesRegistry.RegisterModule(currentHeightProvider)
-
-			setValueInCLIContext(cmd, busCLICtxKey, bus)
-
-			mod, err := p2p.Create(bus)
-			if err != nil {
-				logger.Global.Fatal().Err(err).Msg(""Failed to create p2p module"")
-			}
-
-			var ok bool
-			p2pMod, ok = mod.(modules.P2PModule)
-			if !ok {
-				logger.Global.Fatal().Msgf(""unexpected P2P module type: %T"", mod)
-			}
-
-			if err := p2pMod.Start(); err != nil {
-				logger.Global.Fatal().Err(err).Msg(""Failed to start p2p module"")
-			}
+			persistentPreRun(cmd, args)
 		},
 		RunE: runDebug,
 	}
 }
 
+// persistentPreRun is called by both debug and debug sub-commands before runs
+func persistentPreRun(cmd *cobra.Command, _ []string) {
+	// TECHDEBT: this is to keep backwards compatibility with localnet
+	configPath = runtime.GetEnv(""CONFIG_PATH"", ""build/config/config1.json"")
+
+	runtimeMgr := runtime.NewManagerFromFiles(
+		configPath, genesisPath,
+		runtime.WithClientDebugMode(),
+		runtime.WithRandomPK(),
+	)
+
+	bus := runtimeMgr.GetBus()
+	modulesRegistry := bus.GetModulesRegistry()
+
+	rpcURL := fmt.Sprintf(""http://%s:%s"", rpcHost, defaults.DefaultRPCPort)
+
+	addressBookProvider := rpcABP.NewRPCPeerstoreProvider(
+		rpcABP.WithP2PConfig(
+			runtimeMgr.GetConfig().P2P,
+		),
+		rpcABP.WithCustomRPCURL(rpcURL),
+	)
+	modulesRegistry.RegisterModule(addressBookProvider)
+
+	currentHeightProvider := rpcCHP.NewRPCCurrentHeightProvider(
+		rpcCHP.WithCustomRPCURL(rpcURL),
+	)
+	modulesRegistry.RegisterModule(currentHeightProvider)
+
+	setValueInCLIContext(cmd, busCLICtxKey, bus)",app/client/cli/debug.go,2023-04-27 07:41:00+00:00,2023-04-27T07:41:00Z,Let's move this to come (more or less) right after `bus` declaration/assignment,,,,,136,RIGHT,124,,line,https://api.github.com/repos/pokt-network/pocket/pulls/664,pokt-network/pocket,2d5e6bcd1ec538d465de4090184140a148e4a7e6
https://api.github.com/repos/pokt-network/pocket/pulls/664,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1178788980,bryanchriswhite,abee27ff6c7a335f06a22356e692d4377aa6f5d2,0b028e117325716ce02fda4d52a6be9a9dfd5e92,"@@ -34,4 +34,44 @@ Command tree available [here](./commands/client.md)
 └── main.go                  # entrypoint
 ```
 
+## Debug Subcommands
+
+The debug command is terminal utility and set of sub-commands for rapid development and debugging of Pocket validators.
+If `debug` is run with no arguments, it drops the user into an interactive prompt session where they can trigger multiple debug message transmissions from the client binary.
+
+```bash
+$> client debug
+[...]
+Use the arrow keys to navigate: ↓ ↑ → ←
+? Select an action:
+  ▸ PrintNodeState (broadcast)
+    TriggerNextView (broadcast)
+    TogglePacemakerMode (broadcast)
+    ResetToGenesis (broadcast)
+    ShowLatestBlockInStore (anycast)
+    MetadataRequest (broadcast)
+    BlockRequest (broadcast)
+
+```
+
+If it's run with an argument it selects the message type that matches that argument.
+The accepted command structure and available sub-commands are shown below.
+
+```bash
+Usage:
+  client debug [flags]      <-- drops you into a debug command prompt
+  client debug [command]    <-- accepts sub commands 
+
+Available Commands:
+  BlockRequest
+  MetadataRequest
+  PrintNodeState
+  ResetToGenesis
+  ShowLatestBlockInStore
+  TogglePacemakerMode
+  TriggerNextView",app/client/doc/README.md,2023-04-27 08:18:15+00:00,2023-04-27T12:50:05Z,"I appreciate the straightforward approach to mapping the existing interactive menu out to CLI sub-commands. However, I think there are some UX implications that we should consider:

1. Am I correct in assuming that these will be case sensitive?
2. The interactive menu is hierarchically flat  and uses multiple words in the entries to communicate their context. This is in contrast to a conventional CLI which I would expect to nest sub-commands hierarchically such that the context is provided by the hierarchy (e.g. `wasmd query account <address>` instead of `wasmd QueryAccount <address>`)

Wdyt about renaming and/or restructuring the sub-commands to simplify the names and express a more conventional UX (e.g. when compared to cosmos-sdk based CLIs)?

Example alternative subcommand names/hierarchy (respective ordering):
```
query block [id; default: latest]
query metadata  (or just `meta`)
consensus print
consensus reset
? (I'm not familiar with this command)
consensus pacemaker [on|off; default: toggle]
consensus next [n steps]
```

I acknowledge that this is probably out of scope for this PR and would be more than happy to see a new issue and a comment referencing it for the time being.",66.0,66.0,RIGHT,72.0,72,RIGHT,39,39.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/664,pokt-network/pocket,2d5e6bcd1ec538d465de4090184140a148e4a7e6
https://api.github.com/repos/pokt-network/pocket/pulls/664,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1180817659,bryanchriswhite,abee27ff6c7a335f06a22356e692d4377aa6f5d2,0b028e117325716ce02fda4d52a6be9a9dfd5e92,"@@ -69,61 +70,87 @@ func init() {
 	rpcHost = runtime.GetEnv(""RPC_HOST"", validator1Endpoint)
 }
 
+// NewDebugSubCommands builds out the list of debug subcommands by matching the
+// handleSelect dispatch to the appropriate command.
+// * To add a debug subcommand, you must add it to the `items` array and then
+// write a function handler to match for it in `handleSelect`.
+func NewDebugSubCommands() []*cobra.Command {
+	commands := make([]*cobra.Command, len(items))
+	for idx, promptItem := range items {
+		commands[idx] = &cobra.Command{
+			Use: promptItem,
+			PersistentPreRun: func(cmd *cobra.Command, args []string) {
+				persistentPreRun(cmd, args)
+			},
+			Run: func(cmd *cobra.Command, args []string) {
+				handleSelect(cmd, cmd.Use)
+			},
+			ValidArgs: items,
+		}
+	}
+	return commands
+}
+
+// NewDebugCommand returns the cobra CLI for the Debug command.
 func NewDebugCommand() *cobra.Command {
 	return &cobra.Command{
 		Use:   ""debug"",
 		Short: ""Debug utility for rapid development"",
-		Args:  cobra.ExactArgs(0),
+		Args:  cobra.MaximumNArgs(0),
 		PersistentPreRun: func(cmd *cobra.Command, args []string) {
-
-			// TECHDEBT: this is to keep backwards compatibility with localnet
-			configPath = runtime.GetEnv(""CONFIG_PATH"", ""build/config/config1.json"")
-
-			runtimeMgr := runtime.NewManagerFromFiles(
-				configPath, genesisPath,
-				runtime.WithClientDebugMode(),
-				runtime.WithRandomPK(),
-			)
-
-			bus := runtimeMgr.GetBus()
-			modulesRegistry := bus.GetModulesRegistry()
-
-			rpcURL := fmt.Sprintf(""http://%s:%s"", rpcHost, defaults.DefaultRPCPort)
-
-			addressBookProvider := rpcABP.NewRPCPeerstoreProvider(
-				rpcABP.WithP2PConfig(
-					runtimeMgr.GetConfig().P2P,
-				),
-				rpcABP.WithCustomRPCURL(rpcURL),
-			)
-			modulesRegistry.RegisterModule(addressBookProvider)
-
-			currentHeightProvider := rpcCHP.NewRPCCurrentHeightProvider(
-				rpcCHP.WithCustomRPCURL(rpcURL),
-			)
-			modulesRegistry.RegisterModule(currentHeightProvider)
-
-			setValueInCLIContext(cmd, busCLICtxKey, bus)
-
-			mod, err := p2p.Create(bus)
-			if err != nil {
-				logger.Global.Fatal().Err(err).Msg(""Failed to create p2p module"")
-			}
-
-			var ok bool
-			p2pMod, ok = mod.(modules.P2PModule)
-			if !ok {
-				logger.Global.Fatal().Msgf(""unexpected P2P module type: %T"", mod)
-			}
-
-			if err := p2pMod.Start(); err != nil {
-				logger.Global.Fatal().Err(err).Msg(""Failed to start p2p module"")
-			}
+			persistentPreRun(cmd, args)
 		},
 		RunE: runDebug,
 	}
 }
 
+// persistentPreRun is called by both debug and debug sub-commands before runs
+func persistentPreRun(cmd *cobra.Command, _ []string) {
+	// TECHDEBT: this is to keep backwards compatibility with localnet
+	configPath = runtime.GetEnv(""CONFIG_PATH"", ""build/config/config1.json"")
+
+	runtimeMgr := runtime.NewManagerFromFiles(
+		configPath, genesisPath,
+		runtime.WithClientDebugMode(),
+		runtime.WithRandomPK(),
+	)
+
+	bus := runtimeMgr.GetBus()
+	modulesRegistry := bus.GetModulesRegistry()
+
+	rpcURL := fmt.Sprintf(""http://%s:%s"", rpcHost, defaults.DefaultRPCPort)
+
+	addressBookProvider := rpcABP.NewRPCPeerstoreProvider(",app/client/cli/debug.go,2023-04-28 21:02:39+00:00,2023-04-28T21:02:39Z,"```suggestion
	pstoreProvider := rpcABP.NewRPCPeerstoreProvider(
```",,,,,123,RIGHT,111,,line,https://api.github.com/repos/pokt-network/pocket/pulls/664,pokt-network/pocket,2d5e6bcd1ec538d465de4090184140a148e4a7e6
https://api.github.com/repos/pokt-network/pocket/pulls/659,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1162124701,Olshansk,6a35868ee75f6c99df368e65221af283178b1cb6,a8e78c8e7a4c1dbf419216c2c2a269ee18081702,"@@ -43,89 +43,24 @@ func TestPacemakerTimeoutIncreasesRound(t *testing.T) {
 
 	// Advance time by an amount shorter than the pacemaker timeout
 	advanceTime(t, clockMock, 10*time.Millisecond)
-
-	// Verify consensus started - NewRound messages have an N^2 complexity.
-	numExpectedMsgs := numValidators * numValidators
-	_, err := WaitForNetworkConsensusEvents(t, clockMock, eventsChannel, consensus.NewRound, consensus.Propose, numExpectedMsgs, consensusMessageTimeoutMsec, true)
-	require.NoError(t, err)
-
-	for pocketId, pocketNode := range pocketNodes {
-		assertNodeConsensusView(t, pocketId,
-			typesCons.ConsensusNodeState{
-				Height: 1,
-				Step:   uint8(consensus.NewRound),
-				Round:  0,
-			},
-			GetConsensusNodeState(pocketNode))
-	}
+	height := uint64(1)
+	step := uint8(consensus.NewRound)
+	round := uint8(0)
+	_ = waitForNewRound(t, clockMock, eventsChannel, pocketNodes, height, step, round, numValidators, consensusMessageTimeout, true)",consensus/e2e_tests/pacemaker_test.go,2023-04-10 22:04:28+00:00,2023-04-10T22:41:21Z,"```suggestion
       // Wait for the round=0 to fail
	_ = waitForNewRound(t, clockMock, eventsChannel, pocketNodes, height, step, round, numValidators, consensusMessageTimeout, true)
```",,,,,49,RIGHT,49,,line,https://api.github.com/repos/pokt-network/pocket/pulls/659,pokt-network/pocket,82d931822979d5286c0cd811cf3f7f31ebb5897b
https://api.github.com/repos/pokt-network/pocket/pulls/659,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1162125095,Olshansk,6a35868ee75f6c99df368e65221af283178b1cb6,a8e78c8e7a4c1dbf419216c2c2a269ee18081702,"@@ -43,89 +43,24 @@ func TestPacemakerTimeoutIncreasesRound(t *testing.T) {
 
 	// Advance time by an amount shorter than the pacemaker timeout
 	advanceTime(t, clockMock, 10*time.Millisecond)
-
-	// Verify consensus started - NewRound messages have an N^2 complexity.
-	numExpectedMsgs := numValidators * numValidators
-	_, err := WaitForNetworkConsensusEvents(t, clockMock, eventsChannel, consensus.NewRound, consensus.Propose, numExpectedMsgs, consensusMessageTimeoutMsec, true)
-	require.NoError(t, err)
-
-	for pocketId, pocketNode := range pocketNodes {
-		assertNodeConsensusView(t, pocketId,
-			typesCons.ConsensusNodeState{
-				Height: 1,
-				Step:   uint8(consensus.NewRound),
-				Round:  0,
-			},
-			GetConsensusNodeState(pocketNode))
-	}
+	height := uint64(1)
+	step := uint8(consensus.NewRound)
+	round := uint8(0)
+	_ = waitForNewRound(t, clockMock, eventsChannel, pocketNodes, height, step, round, numValidators, consensusMessageTimeout, true)
 
 	// Force the pacemaker to time out
 	forcePacemakerTimeout(t, clockMock, paceMakerTimeout)
-
-	// Verify that a new round started at the same height
-	_, err = WaitForNetworkConsensusEvents(t, clockMock, eventsChannel, consensus.NewRound, consensus.Propose, numExpectedMsgs, consensusMessageTimeoutMsec, true)
-	require.NoError(t, err)
-	for pocketId, pocketNode := range pocketNodes {
-		assertNodeConsensusView(t, pocketId,
-			typesCons.ConsensusNodeState{
-				Height: 1,
-				Step:   uint8(consensus.NewRound),
-				Round:  1,
-			},
-			GetConsensusNodeState(pocketNode))
-	}
+	_ = waitForNewRound(t, clockMock, eventsChannel, pocketNodes, height, step, round+1, numValidators, consensusMessageTimeout, true)",consensus/e2e_tests/pacemaker_test.go,2023-04-10 22:05:14+00:00,2023-04-10T22:41:21Z,"Try to pretend this is your first day at work. What comments would help you understand what's going on? 

Now, always have this mindset.

```suggestion
       // Wait for the round=1 to fail
	_ = waitForNewRound(t, clockMock, eventsChannel, pocketNodes, height, step, round+1, numValidators, consensusMessageTimeout, true)
```",,,,,53,RIGHT,66,,line,https://api.github.com/repos/pokt-network/pocket/pulls/659,pokt-network/pocket,82d931822979d5286c0cd811cf3f7f31ebb5897b
https://api.github.com/repos/pokt-network/pocket/pulls/659,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1162125218,Olshansk,6a35868ee75f6c99df368e65221af283178b1cb6,a8e78c8e7a4c1dbf419216c2c2a269ee18081702,"@@ -43,89 +43,24 @@ func TestPacemakerTimeoutIncreasesRound(t *testing.T) {
 
 	// Advance time by an amount shorter than the pacemaker timeout
 	advanceTime(t, clockMock, 10*time.Millisecond)
-
-	// Verify consensus started - NewRound messages have an N^2 complexity.
-	numExpectedMsgs := numValidators * numValidators
-	_, err := WaitForNetworkConsensusEvents(t, clockMock, eventsChannel, consensus.NewRound, consensus.Propose, numExpectedMsgs, consensusMessageTimeoutMsec, true)
-	require.NoError(t, err)
-
-	for pocketId, pocketNode := range pocketNodes {
-		assertNodeConsensusView(t, pocketId,
-			typesCons.ConsensusNodeState{
-				Height: 1,
-				Step:   uint8(consensus.NewRound),
-				Round:  0,
-			},
-			GetConsensusNodeState(pocketNode))
-	}
+	height := uint64(1)
+	step := uint8(consensus.NewRound)
+	round := uint8(0)
+	_ = waitForNewRound(t, clockMock, eventsChannel, pocketNodes, height, step, round, numValidators, consensusMessageTimeout, true)
 
 	// Force the pacemaker to time out
 	forcePacemakerTimeout(t, clockMock, paceMakerTimeout)
-
-	// Verify that a new round started at the same height
-	_, err = WaitForNetworkConsensusEvents(t, clockMock, eventsChannel, consensus.NewRound, consensus.Propose, numExpectedMsgs, consensusMessageTimeoutMsec, true)
-	require.NoError(t, err)
-	for pocketId, pocketNode := range pocketNodes {
-		assertNodeConsensusView(t, pocketId,
-			typesCons.ConsensusNodeState{
-				Height: 1,
-				Step:   uint8(consensus.NewRound),
-				Round:  1,
-			},
-			GetConsensusNodeState(pocketNode))
-	}
+	_ = waitForNewRound(t, clockMock, eventsChannel, pocketNodes, height, step, round+1, numValidators, consensusMessageTimeout, true)
 
 	forcePacemakerTimeout(t, clockMock, paceMakerTimeout)
-
-	// Check that a new round starts at the same height
-	_, err = WaitForNetworkConsensusEvents(t, clockMock, eventsChannel, consensus.NewRound, consensus.Propose, numExpectedMsgs, consensusMessageTimeoutMsec, true)
-	require.NoError(t, err)
-	for pocketId, pocketNode := range pocketNodes {
-		assertNodeConsensusView(t, pocketId,
-			typesCons.ConsensusNodeState{
-				Height: 1,
-				Step:   uint8(consensus.NewRound),
-				Round:  2,
-			},
-			GetConsensusNodeState(pocketNode))
-	}
+	_ = waitForNewRound(t, clockMock, eventsChannel, pocketNodes, height, step, round+2, numValidators, consensusMessageTimeout, true)",consensus/e2e_tests/pacemaker_test.go,2023-04-10 22:05:29+00:00,2023-04-10T22:41:21Z,"```suggestion
       // Wait for the round=2 to fail    
	_ = waitForNewRound(t, clockMock, eventsChannel, pocketNodes, height, step, round+2, numValidators, consensusMessageTimeout, true)
```",,,,,56,RIGHT,82,,line,https://api.github.com/repos/pokt-network/pocket/pulls/659,pokt-network/pocket,82d931822979d5286c0cd811cf3f7f31ebb5897b
https://api.github.com/repos/pokt-network/pocket/pulls/659,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1162125555,Olshansk,6a35868ee75f6c99df368e65221af283178b1cb6,a8e78c8e7a4c1dbf419216c2c2a269ee18081702,"@@ -43,89 +43,24 @@ func TestPacemakerTimeoutIncreasesRound(t *testing.T) {
 
 	// Advance time by an amount shorter than the pacemaker timeout
 	advanceTime(t, clockMock, 10*time.Millisecond)
-
-	// Verify consensus started - NewRound messages have an N^2 complexity.
-	numExpectedMsgs := numValidators * numValidators
-	_, err := WaitForNetworkConsensusEvents(t, clockMock, eventsChannel, consensus.NewRound, consensus.Propose, numExpectedMsgs, consensusMessageTimeoutMsec, true)
-	require.NoError(t, err)
-
-	for pocketId, pocketNode := range pocketNodes {
-		assertNodeConsensusView(t, pocketId,
-			typesCons.ConsensusNodeState{
-				Height: 1,
-				Step:   uint8(consensus.NewRound),
-				Round:  0,
-			},
-			GetConsensusNodeState(pocketNode))
-	}
+	height := uint64(1)
+	step := uint8(consensus.NewRound)
+	round := uint8(0)
+	_ = waitForNewRound(t, clockMock, eventsChannel, pocketNodes, height, step, round, numValidators, consensusMessageTimeout, true)
 
 	// Force the pacemaker to time out
 	forcePacemakerTimeout(t, clockMock, paceMakerTimeout)
-
-	// Verify that a new round started at the same height
-	_, err = WaitForNetworkConsensusEvents(t, clockMock, eventsChannel, consensus.NewRound, consensus.Propose, numExpectedMsgs, consensusMessageTimeoutMsec, true)
-	require.NoError(t, err)
-	for pocketId, pocketNode := range pocketNodes {
-		assertNodeConsensusView(t, pocketId,
-			typesCons.ConsensusNodeState{
-				Height: 1,
-				Step:   uint8(consensus.NewRound),
-				Round:  1,
-			},
-			GetConsensusNodeState(pocketNode))
-	}
+	_ = waitForNewRound(t, clockMock, eventsChannel, pocketNodes, height, step, round+1, numValidators, consensusMessageTimeout, true)
 
 	forcePacemakerTimeout(t, clockMock, paceMakerTimeout)
-
-	// Check that a new round starts at the same height
-	_, err = WaitForNetworkConsensusEvents(t, clockMock, eventsChannel, consensus.NewRound, consensus.Propose, numExpectedMsgs, consensusMessageTimeoutMsec, true)
-	require.NoError(t, err)
-	for pocketId, pocketNode := range pocketNodes {
-		assertNodeConsensusView(t, pocketId,
-			typesCons.ConsensusNodeState{
-				Height: 1,
-				Step:   uint8(consensus.NewRound),
-				Round:  2,
-			},
-			GetConsensusNodeState(pocketNode))
-	}
+	_ = waitForNewRound(t, clockMock, eventsChannel, pocketNodes, height, step, round+2, numValidators, consensusMessageTimeout, true)
 
 	forcePacemakerTimeout(t, clockMock, paceMakerTimeout)
+	newRoundMessages := waitForNewRound(t, clockMock, eventsChannel, pocketNodes, height, step, round+3, numValidators, consensusMessageTimeout, true)",consensus/e2e_tests/pacemaker_test.go,2023-04-10 22:06:11+00:00,2023-04-10T22:41:21Z,"```suggestion
       // Wait for the round=3 to succeed
	newRoundMessages := waitForNewRound(t, clockMock, eventsChannel, pocketNodes, height, step, round+3, numValidators, consensusMessageTimeout, true)
```",,,,,59,RIGHT,85,,line,https://api.github.com/repos/pokt-network/pocket/pulls/659,pokt-network/pocket,82d931822979d5286c0cd811cf3f7f31ebb5897b
https://api.github.com/repos/pokt-network/pocket/pulls/659,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1162126578,Olshansk,6a35868ee75f6c99df368e65221af283178b1cb6,a8e78c8e7a4c1dbf419216c2c2a269ee18081702,"@@ -43,89 +43,24 @@ func TestPacemakerTimeoutIncreasesRound(t *testing.T) {
 
 	// Advance time by an amount shorter than the pacemaker timeout
 	advanceTime(t, clockMock, 10*time.Millisecond)
-
-	// Verify consensus started - NewRound messages have an N^2 complexity.
-	numExpectedMsgs := numValidators * numValidators
-	_, err := WaitForNetworkConsensusEvents(t, clockMock, eventsChannel, consensus.NewRound, consensus.Propose, numExpectedMsgs, consensusMessageTimeoutMsec, true)
-	require.NoError(t, err)
-
-	for pocketId, pocketNode := range pocketNodes {
-		assertNodeConsensusView(t, pocketId,
-			typesCons.ConsensusNodeState{
-				Height: 1,
-				Step:   uint8(consensus.NewRound),
-				Round:  0,
-			},
-			GetConsensusNodeState(pocketNode))
-	}
+	height := uint64(1)
+	step := uint8(consensus.NewRound)
+	round := uint8(0)",consensus/e2e_tests/pacemaker_test.go,2023-04-10 22:08:10+00:00,2023-04-10T22:41:21Z,"Remove these 3 variables and make it explicit in the code.

If I look at

```
_ = waitForNewRound(t, clockMock, eventsChannel, pocketNodes, height, step, round+1, numValidators, consensusMessageTimeout, true)
```

I don't know what `height`, `step`, `round` are.

If I look at

```
_ = waitForNewRound(t, clockMock, eventsChannel, pocketNodes, 1, NewRound,1, numValidators, consensusMessageTimeout, true)
```

It becomes really obvious.

There's no ""rule"" for this. Just pretend you don't know anything and try to figure out what makes it easier to understad.",,46.0,RIGHT,,48,RIGHT,48,,line,https://api.github.com/repos/pokt-network/pocket/pulls/659,pokt-network/pocket,82d931822979d5286c0cd811cf3f7f31ebb5897b
https://api.github.com/repos/pokt-network/pocket/pulls/659,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1162127782,Olshansk,6a35868ee75f6c99df368e65221af283178b1cb6,a8e78c8e7a4c1dbf419216c2c2a269ee18081702,"@@ -274,31 +261,20 @@ func TestStateSync_UnsyncedPeerSyncs_Success(t *testing.T) {
 		require.Equal(t, typesCons.NodeId(0), nodeState.LeaderId)
 	}
 
-	unsyncedNode.GetBus().GetConsensusModule().SetAggregatedStateSyncMetadata(uint64(1), testHeight, string(leaderPK.Address()))
-
+	unsyncedNode.GetBus().GetConsensusModule().PushStateSyncMetadataResponse(uint64(1), testHeight)
 	for _, message := range newRoundMessages {
 		P2PBroadcast(t, pocketNodes, message)
 	}
 	advanceTime(t, clockMock, 10*time.Millisecond)
 
-	// 2. Propose
-	numExpectedMsgs := numberOfValidators
+	numExpectedMsgs := numValidators",consensus/e2e_tests/state_sync_test.go,2023-04-10 22:10:27+00:00,2023-04-10T22:41:21Z,I think we can remove this variable,,,,,270,RIGHT,128,,line,https://api.github.com/repos/pokt-network/pocket/pulls/659,pokt-network/pocket,82d931822979d5286c0cd811cf3f7f31ebb5897b
https://api.github.com/repos/pokt-network/pocket/pulls/659,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1162127866,Olshansk,6a35868ee75f6c99df368e65221af283178b1cb6,a8e78c8e7a4c1dbf419216c2c2a269ee18081702,"@@ -274,31 +261,20 @@ func TestStateSync_UnsyncedPeerSyncs_Success(t *testing.T) {
 		require.Equal(t, typesCons.NodeId(0), nodeState.LeaderId)
 	}
 
-	unsyncedNode.GetBus().GetConsensusModule().SetAggregatedStateSyncMetadata(uint64(1), testHeight, string(leaderPK.Address()))
-
+	unsyncedNode.GetBus().GetConsensusModule().PushStateSyncMetadataResponse(uint64(1), testHeight)
 	for _, message := range newRoundMessages {
 		P2PBroadcast(t, pocketNodes, message)
 	}
 	advanceTime(t, clockMock, 10*time.Millisecond)
 
-	// 2. Propose",consensus/e2e_tests/state_sync_test.go,2023-04-10 22:10:39+00:00,2023-04-10T22:41:21Z,Why did you remove this useful comment?,,,,284.0,284,LEFT,126,157.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/659,pokt-network/pocket,82d931822979d5286c0cd811cf3f7f31ebb5897b
https://api.github.com/repos/pokt-network/pocket/pulls/659,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1162128062,Olshansk,6a35868ee75f6c99df368e65221af283178b1cb6,a8e78c8e7a4c1dbf419216c2c2a269ee18081702,"@@ -274,31 +261,20 @@ func TestStateSync_UnsyncedPeerSyncs_Success(t *testing.T) {
 		require.Equal(t, typesCons.NodeId(0), nodeState.LeaderId)
 	}
 
-	unsyncedNode.GetBus().GetConsensusModule().SetAggregatedStateSyncMetadata(uint64(1), testHeight, string(leaderPK.Address()))
-
+	unsyncedNode.GetBus().GetConsensusModule().PushStateSyncMetadataResponse(uint64(1), testHeight)
 	for _, message := range newRoundMessages {
 		P2PBroadcast(t, pocketNodes, message)
 	}
 	advanceTime(t, clockMock, 10*time.Millisecond)
 
-	// 2. Propose
-	numExpectedMsgs := numberOfValidators
+	numExpectedMsgs := numValidators
 	_, err = WaitForNetworkConsensusEvents(t, clockMock, eventsChannel, consensus.Prepare, consensus.Propose, numExpectedMsgs, 500, true)
 	require.NoError(t, err)
 
-	advanceTime(t, clockMock, 10*time.Millisecond)
-	for nodeId, pocketNode := range pocketNodes {
-		nodeState := GetConsensusNodeState(pocketNode)
-		fmt.Printf(""Node state, node id: %d, height: %d, round: %d, step: %d, leaderId: %d \n"", nodeId, nodeState.Height, nodeState.Round, nodeState.Step, nodeState.LeaderId)
-		assertNodeConsensusView(t, nodeId,
-			typesCons.ConsensusNodeState{
-				Height: testHeight,
-				Step:   uint8(consensus.Prepare),
-				Round:  uint8(currentRound),
-			},
-			nodeState)
-		require.Equal(t, leaderId, nodeState.LeaderId)
-	}
+	// TODO (#352) This function will be updated once state sync implementation is complete
+	waitForNodeToSync(t, clockMock, eventsChannel, unsyncedNode, pocketNodes, testHeight)",consensus/e2e_tests/state_sync_test.go,2023-04-10 22:11:01+00:00,2023-04-10T22:41:21Z,Can you make it return an error?,,,,,275,RIGHT,146,,line,https://api.github.com/repos/pokt-network/pocket/pulls/659,pokt-network/pocket,82d931822979d5286c0cd811cf3f7f31ebb5897b
https://api.github.com/repos/pokt-network/pocket/pulls/659,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1162128238,Olshansk,6a35868ee75f6c99df368e65221af283178b1cb6,a8e78c8e7a4c1dbf419216c2c2a269ee18081702,"@@ -274,31 +261,20 @@ func TestStateSync_UnsyncedPeerSyncs_Success(t *testing.T) {
 		require.Equal(t, typesCons.NodeId(0), nodeState.LeaderId)
 	}
 
-	unsyncedNode.GetBus().GetConsensusModule().SetAggregatedStateSyncMetadata(uint64(1), testHeight, string(leaderPK.Address()))
-
+	unsyncedNode.GetBus().GetConsensusModule().PushStateSyncMetadataResponse(uint64(1), testHeight)
 	for _, message := range newRoundMessages {
 		P2PBroadcast(t, pocketNodes, message)
 	}
 	advanceTime(t, clockMock, 10*time.Millisecond)
 
-	// 2. Propose
-	numExpectedMsgs := numberOfValidators
+	numExpectedMsgs := numValidators
 	_, err = WaitForNetworkConsensusEvents(t, clockMock, eventsChannel, consensus.Prepare, consensus.Propose, numExpectedMsgs, 500, true)
 	require.NoError(t, err)
 
-	advanceTime(t, clockMock, 10*time.Millisecond)
-	for nodeId, pocketNode := range pocketNodes {
-		nodeState := GetConsensusNodeState(pocketNode)
-		fmt.Printf(""Node state, node id: %d, height: %d, round: %d, step: %d, leaderId: %d \n"", nodeId, nodeState.Height, nodeState.Round, nodeState.Step, nodeState.LeaderId)
-		assertNodeConsensusView(t, nodeId,
-			typesCons.ConsensusNodeState{
-				Height: testHeight,
-				Step:   uint8(consensus.Prepare),
-				Round:  uint8(currentRound),
-			},
-			nodeState)
-		require.Equal(t, leaderId, nodeState.LeaderId)
-	}
+	// TODO (#352) This function will be updated once state sync implementation is complete",consensus/e2e_tests/state_sync_test.go,2023-04-10 22:11:19+00:00,2023-04-10T22:41:21Z,"Let's follow the same pattern everywhere

```suggestion
	// TODO(#352): This function will be updated once state sync implementation is complete
```",,,,,274,RIGHT,145,,line,https://api.github.com/repos/pokt-network/pocket/pulls/659,pokt-network/pocket,82d931822979d5286c0cd811cf3f7f31ebb5897b
https://api.github.com/repos/pokt-network/pocket/pulls/659,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1162128331,Olshansk,6a35868ee75f6c99df368e65221af283178b1cb6,a8e78c8e7a4c1dbf419216c2c2a269ee18081702,"@@ -274,31 +261,20 @@ func TestStateSync_UnsyncedPeerSyncs_Success(t *testing.T) {
 		require.Equal(t, typesCons.NodeId(0), nodeState.LeaderId)
 	}
 
-	unsyncedNode.GetBus().GetConsensusModule().SetAggregatedStateSyncMetadata(uint64(1), testHeight, string(leaderPK.Address()))
-
+	unsyncedNode.GetBus().GetConsensusModule().PushStateSyncMetadataResponse(uint64(1), testHeight)
 	for _, message := range newRoundMessages {
 		P2PBroadcast(t, pocketNodes, message)
 	}
 	advanceTime(t, clockMock, 10*time.Millisecond)
 
-	// 2. Propose
-	numExpectedMsgs := numberOfValidators
+	numExpectedMsgs := numValidators
 	_, err = WaitForNetworkConsensusEvents(t, clockMock, eventsChannel, consensus.Prepare, consensus.Propose, numExpectedMsgs, 500, true)
 	require.NoError(t, err)
 
-	advanceTime(t, clockMock, 10*time.Millisecond)
-	for nodeId, pocketNode := range pocketNodes {
-		nodeState := GetConsensusNodeState(pocketNode)
-		fmt.Printf(""Node state, node id: %d, height: %d, round: %d, step: %d, leaderId: %d \n"", nodeId, nodeState.Height, nodeState.Round, nodeState.Step, nodeState.LeaderId)
-		assertNodeConsensusView(t, nodeId,
-			typesCons.ConsensusNodeState{
-				Height: testHeight,
-				Step:   uint8(consensus.Prepare),
-				Round:  uint8(currentRound),
-			},
-			nodeState)
-		require.Equal(t, leaderId, nodeState.LeaderId)
-	}
+	// TODO (#352) This function will be updated once state sync implementation is complete
+	waitForNodeToSync(t, clockMock, eventsChannel, unsyncedNode, pocketNodes, testHeight)
+
+	// TODO (#352) Add height check once state sync implmentation is complete",consensus/e2e_tests/state_sync_test.go,2023-04-10 22:11:31+00:00,2023-04-10T22:41:21Z,"Let's follow the same pattern everywhere

```suggestion
	// TODO(#352): Add height check once state sync implmentation is complete
```",,,,,277,RIGHT,148,,line,https://api.github.com/repos/pokt-network/pocket/pulls/659,pokt-network/pocket,82d931822979d5286c0cd811cf3f7f31ebb5897b
https://api.github.com/repos/pokt-network/pocket/pulls/659,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1162128811,Olshansk,6a35868ee75f6c99df368e65221af283178b1cb6,a8e78c8e7a4c1dbf419216c2c2a269ee18081702,"@@ -153,12 +155,19 @@ func GenerateBuses(t *testing.T, runtimeMgrs []*runtime.Manager) (buses []module
 }
 
 // CLEANUP: Reduce package scope visibility in the consensus test module
-func StartAllTestPocketNodes(t *testing.T, pocketNodes IdToNodeMapping) {
+func StartAllTestPocketNodes(t *testing.T, pocketNodes IdToNodeMapping) error {
 	for _, pocketNode := range pocketNodes {
 		go startNode(t, pocketNode)
 		startEvent := pocketNode.GetBus().GetBusEvent()
 		require.Equal(t, startEvent.GetContentType(), messaging.NodeStartedEventType)
+		if err := pocketNode.GetBus().GetStateMachineModule().SendEvent(coreTypes.StateMachineEvent_Start); err != nil {",consensus/e2e_tests/utils_test.go,2023-04-10 22:12:27+00:00,2023-04-10T22:41:21Z,You can create a local `stateMachine := pocketNode.GetBus().GetStateMachineModule()` so this is easier to read,,,,,163,RIGHT,58,,line,https://api.github.com/repos/pokt-network/pocket/pulls/659,pokt-network/pocket,82d931822979d5286c0cd811cf3f7f31ebb5897b
https://api.github.com/repos/pokt-network/pocket/pulls/659,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1162129017,Olshansk,6a35868ee75f6c99df368e65221af283178b1cb6,a8e78c8e7a4c1dbf419216c2c2a269ee18081702,"@@ -414,6 +423,7 @@ func baseP2PMock(t *testing.T, eventsChannel modules.EventsChannel) *mockModules
 			eventsChannel <- e
 		}).
 		AnyTimes()
+	// CONSIDER: Adding a check to not to send message to itself",consensus/e2e_tests/utils_test.go,2023-04-10 22:12:53+00:00,2023-04-10T22:41:21Z,"Look in our `Makefile` to see what our kewyrods are

```suggestion
	// CONSIDERATION: Adding a check to not to send message to itself
```",,,,,426,RIGHT,73,,line,https://api.github.com/repos/pokt-network/pocket/pulls/659,pokt-network/pocket,82d931822979d5286c0cd811cf3f7f31ebb5897b
https://api.github.com/repos/pokt-network/pocket/pulls/659,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1162130241,Olshansk,6a35868ee75f6c99df368e65221af283178b1cb6,a8e78c8e7a4c1dbf419216c2c2a269ee18081702,"@@ -91,10 +88,11 @@ type ConsensusDebugModule interface {
 
 	SetUtilityUnitOfWork(UtilityUnitOfWork)
 
-	// SetAggregatedStateSyncMetadata is used to set peer's aggregated metadata in testing scenarios to simulate periodic metadata synchronization. It is not intended to be used outside of testing.
-	SetAggregatedStateSyncMetadata(minHeight, maxHeight uint64, peerAddress string)
-	GetAggregatedStateSyncMetadataMaxHeight() (minHeight uint64)
+	// PushStateSyncMetadataResponse is used to simulate metadata received metadata in testing scenarios. It is not intended to be used outside of testing.
+	PushStateSyncMetadataResponse(minHeight, maxHeight uint64)
 
 	// REFACTOR: This should accept typesCons.HotstuffStep and return typesCons.NodeId.
 	GetLeaderForView(height, round uint64, step uint8) (leaderId uint64)
+
+	GetValidatorsAtHeight(height uint64) ([]*types.Actor, error)",shared/modules/consensus_module.go,2023-04-10 22:15:00+00:00,2023-04-10T22:41:21Z,"This is not a good design decision. If you look at the implementation of `GetValidatorsAtHeight`, this is all we're doing:

```go
func (m *consensusModule) GetValidatorsAtHeight(height uint64) ([]*coreTypes.Actor, error) {
	readCtx, err := m.GetBus().GetPersistenceModule().NewReadContext(int64(height))
	if err != nil {
		return nil, err
	}
	defer readCtx.Release()
	return readCtx.GetAllValidators(int64(height))
}
```

In short, it's a proxy into the persistence module.

Ask yourself:
1. Who is responsible for knowing the vaalidators at a specific height?
2. Are the validators a part of the state?
3. Is the state a part of persistence?
4. Is the consensus module an orchestator of the state a a view into the state?

In short, you should be able to remove this completely and have a local helper if you need it.

If you need to mock it, mock the persistence module. That's the point of dependency injection.",,,,,97,RIGHT,23,,line,https://api.github.com/repos/pokt-network/pocket/pulls/659,pokt-network/pocket,82d931822979d5286c0cd811cf3f7f31ebb5897b
https://api.github.com/repos/pokt-network/pocket/pulls/659,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1162130628,Olshansk,6a35868ee75f6c99df368e65221af283178b1cb6,a8e78c8e7a4c1dbf419216c2c2a269ee18081702,"@@ -91,10 +88,11 @@ type ConsensusDebugModule interface {
 
 	SetUtilityUnitOfWork(UtilityUnitOfWork)
 
-	// SetAggregatedStateSyncMetadata is used to set peer's aggregated metadata in testing scenarios to simulate periodic metadata synchronization. It is not intended to be used outside of testing.
-	SetAggregatedStateSyncMetadata(minHeight, maxHeight uint64, peerAddress string)
-	GetAggregatedStateSyncMetadataMaxHeight() (minHeight uint64)
+	// PushStateSyncMetadataResponse is used to simulate metadata received metadata in testing scenarios. It is not intended to be used outside of testing.
+	PushStateSyncMetadataResponse(minHeight, maxHeight uint64)",shared/modules/consensus_module.go,2023-04-10 22:15:45+00:00,2023-04-10T22:41:21Z,"We have a structure for metadata responses (i.e. the protobuf).

You should be pushing those instead.",,,,,92,RIGHT,18,,line,https://api.github.com/repos/pokt-network/pocket/pulls/659,pokt-network/pocket,82d931822979d5286c0cd811cf3f7f31ebb5897b
https://api.github.com/repos/pokt-network/pocket/pulls/659,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1162130898,Olshansk,6a35868ee75f6c99df368e65221af283178b1cb6,a8e78c8e7a4c1dbf419216c2c2a269ee18081702,"@@ -37,20 +37,23 @@ func (m *consensusModule) handleStateSyncMessage(stateSyncMessage *typesCons.Sta
 	switch stateSyncMessage.Message.(type) {
 	case *typesCons.StateSyncMessage_MetadataReq:
 		m.logger.Info().Str(""proto_type"", ""MetadataRequest"").Msg(""Handling StateSyncMessage MetadataReq"")
-		if !m.stateSync.IsServerModEnabled() {
+		if !m.serverMode {
 			return fmt.Errorf(""server module is not enabled"")
 		}
 		return m.stateSync.HandleStateSyncMetadataRequest(stateSyncMessage.GetMetadataReq())
 	case *typesCons.StateSyncMessage_MetadataRes:
-		return m.stateSync.HandleStateSyncMetadataResponse(stateSyncMessage.GetMetadataRes())
+		m.metadataReceived <- stateSyncMessage.GetMetadataRes()
+		return nil
 	case *typesCons.StateSyncMessage_GetBlockReq:
 		m.logger.Info().Str(""proto_type"", ""GetBlockRequest"").Msg(""Handling StateSyncMessage MetadataReq"")
-		if !m.stateSync.IsServerModEnabled() {
+		if !m.serverMode {
 			return fmt.Errorf(""server module is not enabled"")
 		}
 		return m.stateSync.HandleGetBlockRequest(stateSyncMessage.GetGetBlockReq())
 	case *typesCons.StateSyncMessage_GetBlockRes:
-		return m.stateSync.HandleGetBlockResponse(stateSyncMessage.GetGetBlockRes())
+		fmt.Println(""Received block: "", stateSyncMessage.GetGetBlockRes().Block)",consensus/state_sync_handler.go,2023-04-10 22:16:16+00:00,2023-04-10T22:41:21Z,Why are you using `fmt.Println` when we have a proper logging system?,,,,,54,RIGHT,22,,line,https://api.github.com/repos/pokt-network/pocket/pulls/659,pokt-network/pocket,82d931822979d5286c0cd811cf3f7f31ebb5897b
https://api.github.com/repos/pokt-network/pocket/pulls/659,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1162131459,Olshansk,6a35868ee75f6c99df368e65221af283178b1cb6,a8e78c8e7a4c1dbf419216c2c2a269ee18081702,"@@ -37,20 +37,23 @@ func (m *consensusModule) handleStateSyncMessage(stateSyncMessage *typesCons.Sta
 	switch stateSyncMessage.Message.(type) {
 	case *typesCons.StateSyncMessage_MetadataReq:
 		m.logger.Info().Str(""proto_type"", ""MetadataRequest"").Msg(""Handling StateSyncMessage MetadataReq"")
-		if !m.stateSync.IsServerModEnabled() {
+		if !m.serverMode {
 			return fmt.Errorf(""server module is not enabled"")
 		}
 		return m.stateSync.HandleStateSyncMetadataRequest(stateSyncMessage.GetMetadataReq())
 	case *typesCons.StateSyncMessage_MetadataRes:
-		return m.stateSync.HandleStateSyncMetadataResponse(stateSyncMessage.GetMetadataRes())
+		m.metadataReceived <- stateSyncMessage.GetMetadataRes()
+		return nil
 	case *typesCons.StateSyncMessage_GetBlockReq:
 		m.logger.Info().Str(""proto_type"", ""GetBlockRequest"").Msg(""Handling StateSyncMessage MetadataReq"")
-		if !m.stateSync.IsServerModEnabled() {
+		if !m.serverMode {
 			return fmt.Errorf(""server module is not enabled"")
 		}
 		return m.stateSync.HandleGetBlockRequest(stateSyncMessage.GetGetBlockReq())
 	case *typesCons.StateSyncMessage_GetBlockRes:
-		return m.stateSync.HandleGetBlockResponse(stateSyncMessage.GetGetBlockRes())
+		fmt.Println(""Received block: "", stateSyncMessage.GetGetBlockRes().Block)
+		m.blocksReceived <- stateSyncMessage.GetGetBlockRes().Block",consensus/state_sync_handler.go,2023-04-10 22:17:27+00:00,2023-04-10T22:41:21Z,"In `metadataReceived`, you store response protobufs. In `blockReceived`, you store the data inside the block.

This is inconsistent. Doesn't matter what you do, but be consistent.

I think you should store the whole response in both, and let the actual logic decide what to do with it.",,,,,55,RIGHT,23,,line,https://api.github.com/repos/pokt-network/pocket/pulls/659,pokt-network/pocket,82d931822979d5286c0cd811cf3f7f31ebb5897b
https://api.github.com/repos/pokt-network/pocket/pulls/659,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1162131893,Olshansk,6a35868ee75f6c99df368e65221af283178b1cb6,a8e78c8e7a4c1dbf419216c2c2a269ee18081702,"@@ -64,9 +64,7 @@ func (m *stateSync) HandleGetBlockRequest(blockReq *typesCons.GetBlockRequest) e
 	serverNodePeerAddress := consensusMod.GetNodeAddress()
 	clientPeerAddress := blockReq.PeerAddress
 
-	m.logger.Info().Fields(m.logHelper(clientPeerAddress)).Msgf(""Received StateSync GetBlockRequest: %s"", blockReq)
-
-	// current height is the height of the block that is being processed, so we need to subtract 1 for the last finalized block
+	m.logger.Info().Fields(m.StateSyncLogHelper(clientPeerAddress)).Msgf(""Received StateSync GetBlockRequest: %s"", blockReq)",consensus/state_sync/server.go,2023-04-10 22:18:10+00:00,2023-04-10T22:41:21Z,"Are you 100% sure that using `%s` for the BlockRequest is helpful?

I'm fine with leaving it as is, as long as you were actually using it in debugging.",,,,,67,RIGHT,25,,line,https://api.github.com/repos/pokt-network/pocket/pulls/659,pokt-network/pocket,82d931822979d5286c0cd811cf3f7f31ebb5897b
https://api.github.com/repos/pokt-network/pocket/pulls/659,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1162132253,Olshansk,6a35868ee75f6c99df368e65221af283178b1cb6,a8e78c8e7a4c1dbf419216c2c2a269ee18081702,"@@ -6,32 +6,25 @@ import (
 	""google.golang.org/protobuf/types/known/anypb""
 )
 
-func (m *stateSync) SendStateSyncMessage(stateSyncMsg *typesCons.StateSyncMessage, peerAddress cryptoPocket.Address, height uint64) error {
-	anyMsg, err := anypb.New(stateSyncMsg)
+// SendStateSyncMessage sends a state sync message after converting to any proto, to the given peer
+func (m *stateSync) SendStateSyncMessage(msg *typesCons.StateSyncMessage, dst cryptoPocket.Address, height uint64) error {
+	anyMsg, err := anypb.New(msg)
 	if err != nil {
 		return err
 	}
-
-	m.logger.Info().Fields(m.logHelper(peerAddress.ToString())).Msg(""Sending StateSync Message"")
-	return m.sendToPeer(anyMsg, peerAddress)
-}
-
-// Helper function for messages to the peers
-func (m *stateSync) sendToPeer(msg *anypb.Any, peerAddress cryptoPocket.Address) error {
-	if err := m.GetBus().GetP2PModule().Send(peerAddress, msg); err != nil {
-		m.logger.Error().Msgf(typesCons.ErrSendMessage.Error(), err)
+	if err := m.GetBus().GetP2PModule().Send(dst, anyMsg); err != nil {
+		m.logger.Error().Err(err).Msg(typesCons.ErrSendMessage.Error())
 		return err
 	}
 	return nil
 }
 
-func (m *stateSync) logHelper(receiverPeerAddress string) map[string]any {
+func (m *stateSync) StateSyncLogHelper(receiverPeerAddress string) map[string]any {",consensus/state_sync/helpers.go,2023-04-10 22:18:49+00:00,2023-04-10T22:41:21Z,"A helper (that's not in the shared repo) should NEVER be publically exposed. If it is, it means we're doing something wrong.",,,,,22,RIGHT,29,,line,https://api.github.com/repos/pokt-network/pocket/pulls/659,pokt-network/pocket,82d931822979d5286c0cd811cf3f7f31ebb5897b
https://api.github.com/repos/pokt-network/pocket/pulls/659,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1162132615,Olshansk,6a35868ee75f6c99df368e65221af283178b1cb6,a8e78c8e7a4c1dbf419216c2c2a269ee18081702,"@@ -272,7 +272,7 @@ func (m *consensusModule) setLogPrefix(logPrefix string) {
 	})
 }
 
-func (m *consensusModule) getValidatorsAtHeight(height uint64) ([]*coreTypes.Actor, error) {
+func (m *consensusModule) GetValidatorsAtHeight(height uint64) ([]*coreTypes.Actor, error) {",consensus/helpers.go,2023-04-10 22:19:27+00:00,2023-04-10T22:41:22Z,I left a more detailed comment below. This should not be publically exposed.,,,,,275,RIGHT,79,,line,https://api.github.com/repos/pokt-network/pocket/pulls/659,pokt-network/pocket,82d931822979d5286c0cd811cf3f7f31ebb5897b
https://api.github.com/repos/pokt-network/pocket/pulls/659,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1162133053,Olshansk,6a35868ee75f6c99df368e65221af283178b1cb6,a8e78c8e7a4c1dbf419216c2c2a269ee18081702,"@@ -83,9 +82,9 @@ func (m *consensusModule) HandleUnsynced(msg *messaging.StateMachineTransitionEv
 // HandleSyncMode handles FSM event Consensus_IsSyncing, and SyncMode is the destination state.
 // In Sync mode node (validator or non-validator) starts syncing with the rest of the network.
 func (m *consensusModule) HandleSyncMode(msg *messaging.StateMachineTransitionEvent) error {
-	m.logger.Debug().Msg(""Node is in Sync Mode, start syncing..."")
+	m.logger.Debug().Msg(""Node is in Sync Mode, starting syncing..."")",consensus/fsm_handler.go,2023-04-10 22:20:19+00:00,2023-04-10T22:41:22Z,"```suggestion
	m.logger.Debug().Msg(""Node is in Sync Mode, starting to sync..."")
```",,,,,85,RIGHT,24,,line,https://api.github.com/repos/pokt-network/pocket/pulls/659,pokt-network/pocket,82d931822979d5286c0cd811cf3f7f31ebb5897b
https://api.github.com/repos/pokt-network/pocket/pulls/659,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1162133590,Olshansk,6a35868ee75f6c99df368e65221af283178b1cb6,a8e78c8e7a4c1dbf419216c2c2a269ee18081702,"@@ -64,12 +65,19 @@ type consensusModule struct {
 	paceMaker         pacemaker.Pacemaker
 	leaderElectionMod leader_election.LeaderElectionModule
 
-	logger    *modules.Logger
-	logPrefix string
+	logger *modules.Logger
 
 	stateSync state_sync.StateSyncModule
 
 	hotstuffMempool map[typesCons.HotstuffStep]*hotstuffFIFOMempool
+
+	// block responses received from peers are collected in this channel
+	blocksReceived chan *coreTypes.Block",consensus/module.go,2023-04-10 22:21:29+00:00,2023-04-10T22:41:22Z,"I left a more detail comment about it below, but this should be block responses, not `blocks` directly.",,,,,75,RIGHT,21,,line,https://api.github.com/repos/pokt-network/pocket/pulls/659,pokt-network/pocket,82d931822979d5286c0cd811cf3f7f31ebb5897b
https://api.github.com/repos/pokt-network/pocket/pulls/659,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1162133684,Olshansk,6a35868ee75f6c99df368e65221af283178b1cb6,a8e78c8e7a4c1dbf419216c2c2a269ee18081702,"@@ -64,12 +65,19 @@ type consensusModule struct {
 	paceMaker         pacemaker.Pacemaker
 	leaderElectionMod leader_election.LeaderElectionModule
 
-	logger    *modules.Logger
-	logPrefix string
+	logger *modules.Logger
 
 	stateSync state_sync.StateSyncModule
 
 	hotstuffMempool map[typesCons.HotstuffStep]*hotstuffFIFOMempool
+
+	// block responses received from peers are collected in this channel
+	blocksReceived chan *coreTypes.Block
+
+	// metadata responses received from peers are collected in this channel
+	metadataReceived chan *types.StateSyncMetadataResponse
+
+	serverMode bool",consensus/module.go,2023-04-10 22:21:42+00:00,2023-04-10T22:41:22Z,serverModeEnabled?,,,,,80,RIGHT,26,,line,https://api.github.com/repos/pokt-network/pocket/pulls/659,pokt-network/pocket,82d931822979d5286c0cd811cf3f7f31ebb5897b
https://api.github.com/repos/pokt-network/pocket/pulls/659,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1162133898,Olshansk,6a35868ee75f6c99df368e65221af283178b1cb6,a8e78c8e7a4c1dbf419216c2c2a269ee18081702,"@@ -124,9 +132,9 @@ func (*consensusModule) Create(bus modules.Bus, options ...modules.ModuleOption)
 	consensusCfg := runtimeMgr.GetConfig().Consensus
 
 	if consensusCfg.ServerModeEnabled {",consensus/module.go,2023-04-10 22:22:03+00:00,2023-04-10T22:41:22Z,Why don't we just do `m.serverMode = consensusCfg.ServerModeEnabled`?,,,,,134,RIGHT,33,,line,https://api.github.com/repos/pokt-network/pocket/pulls/659,pokt-network/pocket,82d931822979d5286c0cd811cf3f7f31ebb5897b
https://api.github.com/repos/pokt-network/pocket/pulls/659,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1162134203,Olshansk,6a35868ee75f6c99df368e65221af283178b1cb6,a8e78c8e7a4c1dbf419216c2c2a269ee18081702,"@@ -154,6 +162,9 @@ func (*consensusModule) Create(bus modules.Bus, options ...modules.ModuleOption)
 	m.nodeId = valAddrToIdMap[address]
 	m.nodeAddress = address
 
+	m.metadataReceived = make(chan *types.StateSyncMetadataResponse, 1000)",consensus/module.go,2023-04-10 22:22:34+00:00,2023-04-10T22:41:22Z,Move `1000` into a local constant and leave a TODO that we should be it configurable,,,,,165,RIGHT,56,,line,https://api.github.com/repos/pokt-network/pocket/pulls/659,pokt-network/pocket,82d931822979d5286c0cd811cf3f7f31ebb5897b
https://api.github.com/repos/pokt-network/pocket/pulls/659,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1162135094,Olshansk,6a35868ee75f6c99df368e65221af283178b1cb6,a8e78c8e7a4c1dbf419216c2c2a269ee18081702,"@@ -112,78 +83,6 @@ func (m *stateSync) GetModuleName() string {
 	return stateSyncModuleName
 }
 
-func (m *stateSync) IsServerModEnabled() bool {
-	return m.serverMode
-}
-
 func (m *stateSync) SetLogPrefix(logPrefix string) {",consensus/state_sync/module.go,2023-04-10 22:24:18+00:00,2023-04-10T22:41:22Z,"I did a `cmd shift f` on your branch and got this:

<img width=""312"" alt=""Screenshot 2023-04-10 at 3 23 45 PM"" src=""https://user-images.githubusercontent.com/1892194/231010397-5465c418-78fb-4c7d-b06b-a993004914bc.png"">

1. Is this being used anywhere?
2. If not, remove the function and the local variable",,,,,86,RIGHT,111,,line,https://api.github.com/repos/pokt-network/pocket/pulls/659,pokt-network/pocket,82d931822979d5286c0cd811cf3f7f31ebb5897b
https://api.github.com/repos/pokt-network/pocket/pulls/659,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1162135730,Olshansk,6a35868ee75f6c99df368e65221af283178b1cb6,a8e78c8e7a4c1dbf419216c2c2a269ee18081702,"@@ -16,50 +15,22 @@ const (
 type StateSyncModule interface {
 	modules.Module
 	StateSyncServerModule
-	DebugStateSync
-
-	// This functions are used for managing the Server mode of the node, which is handled independently from the FSM.
-	IsServerModEnabled() bool
-	EnableServerMode() error
-	DisableServerMode() error
-
-	// This functions contains the business logic on handling Block and Metadata responses.
-	HandleStateSyncMetadataResponse(*typesCons.StateSyncMetadataResponse) error
-	HandleGetBlockResponse(*typesCons.GetBlockResponse) error
 
 	SendStateSyncMessage(msg *typesCons.StateSyncMessage, nodeAddress cryptoPocket.Address, height uint64) error
-
-	// Getter functions for the aggregated metadata and the metadata buffer, used by consensus module.
-	GetAggregatedMetadata() *typesCons.StateSyncMetadataResponse
-
-	// Starts syncing the node with the network by requesting blocks.
-	StartSyncing() error
-}
-
-// This interface should be only used for debugging purposes and tests.
-type DebugStateSync interface {
-	SetAggregatedMetadata(*typesCons.StateSyncMetadataResponse)
+	StateSyncLogHelper(receiverPeerAddress string) map[string]any",consensus/state_sync/module.go,2023-04-10 22:25:07+00:00,2023-04-10T22:41:22Z,"A log helper should not be exposed publically. 

Have you ever seen a production interface in the standard go library called ""logHelper""?",,,,,20,RIGHT,39,,line,https://api.github.com/repos/pokt-network/pocket/pulls/659,pokt-network/pocket,82d931822979d5286c0cd811cf3f7f31ebb5897b
https://api.github.com/repos/pokt-network/pocket/pulls/659,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1162136348,Olshansk,6a35868ee75f6c99df368e65221af283178b1cb6,a8e78c8e7a4c1dbf419216c2c2a269ee18081702,"@@ -80,3 +67,11 @@ func (m *consensusModule) GetLeaderForView(height, round uint64, step uint8) uin
 	}
 	return uint64(leaderId)
 }
+
+func (m *consensusModule) PushStateSyncMetadataResponse(minHeight, maxHeight uint64) {
+	m.metadataReceived <- &typesCons.StateSyncMetadataResponse{
+		PeerAddress: """",",consensus/module_consensus_debugging.go,2023-04-10 22:26:20+00:00,2023-04-10T22:41:22Z,"This should accept the whole response as input, not jus part of the data.

Think: `What will we need in the future, and is this what I need or is it a hack? How much more effort is it to do it properly? If the effort is really small, let's do it properly`",,,,,73,RIGHT,27,,line,https://api.github.com/repos/pokt-network/pocket/pulls/659,pokt-network/pocket,82d931822979d5286c0cd811cf3f7f31ebb5897b
https://api.github.com/repos/pokt-network/pocket/pulls/659,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1162136737,Olshansk,6a35868ee75f6c99df368e65221af283178b1cb6,a8e78c8e7a4c1dbf419216c2c2a269ee18081702,"@@ -82,7 +82,7 @@ func (m *consensusModule) IsPrepareQCNil() bool {
 func (m *consensusModule) GetPrepareQC() (*anypb.Any, error) {
 	anyProto, err := anypb.New(m.prepareQC)
 	if err != nil {
-		return nil, fmt.Errorf(""Failed to convert paceMaker message to proto: %s"", err)",consensus/module_consensus_pacemaker.go,2023-04-10 22:27:00+00:00,2023-04-10T22:41:22Z,"Use `%w` instead of `%s` for errors.

See https://stackoverflow.com/questions/61283248/format-errors-in-go-s-v-or-w#:~:text=Should%20I%20use%20%25s%20or,but%20there%20are%20no%20guarantees.",,,,85.0,85,LEFT,4,4.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/659,pokt-network/pocket,82d931822979d5286c0cd811cf3f7f31ebb5897b
https://api.github.com/repos/pokt-network/pocket/pulls/659,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1162137443,Olshansk,6a35868ee75f6c99df368e65221af283178b1cb6,a8e78c8e7a4c1dbf419216c2c2a269ee18081702,"@@ -6,32 +6,25 @@ import (
 	""google.golang.org/protobuf/types/known/anypb""
 )
 
-func (m *stateSync) SendStateSyncMessage(stateSyncMsg *typesCons.StateSyncMessage, peerAddress cryptoPocket.Address, height uint64) error {
-	anyMsg, err := anypb.New(stateSyncMsg)
+// SendStateSyncMessage sends a state sync message after converting to any proto, to the given peer
+func (m *stateSync) SendStateSyncMessage(msg *typesCons.StateSyncMessage, dst cryptoPocket.Address, height uint64) error {",consensus/state_sync/helpers.go,2023-04-10 22:28:25+00:00,2023-04-10T22:41:22Z,Does the helper need to be publically exposed?,,,,,10,RIGHT,7,,line,https://api.github.com/repos/pokt-network/pocket/pulls/659,pokt-network/pocket,82d931822979d5286c0cd811cf3f7f31ebb5897b
https://api.github.com/repos/pokt-network/pocket/pulls/659,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1162137874,Olshansk,6a35868ee75f6c99df368e65221af283178b1cb6,a8e78c8e7a4c1dbf419216c2c2a269ee18081702,"@@ -120,18 +120,7 @@ func (m *pacemaker) ShouldHandleMessage(msg *typesCons.HotstuffMessage) (bool, e
 	// 2. If node is synced, node must reject the proposal because proposal is not valid.
 	if msg.Height > currentHeight {
 		m.logger.Info().Msgf(""⚠️ [WARN] ⚠️ Node at height %d < message height %d"", currentHeight, msg.Height)
-		isSynced, err := m.GetBus().GetConsensusModule().IsSynced()
-		if err != nil {
-			return false, err
-		}
-
-		if !isSynced {
-			err = m.GetBus().GetStateMachineModule().SendEvent(coreTypes.StateMachineEvent_Consensus_IsUnsynced)
-			return false, err
-		}
-
-		return false, nil
-
+		return false, m.GetBus().GetStateMachineModule().SendEvent(coreTypes.StateMachineEvent_Consensus_IsUnsynced)",consensus/pacemaker/module.go,2023-04-10 22:29:12+00:00,2023-04-10T22:41:22Z,"Can you assign this to an `err` local var and `return false, err`. 

This is hard to read.",,,,,123,RIGHT,16,,line,https://api.github.com/repos/pokt-network/pocket/pulls/659,pokt-network/pocket,82d931822979d5286c0cd811cf3f7f31ebb5897b
https://api.github.com/repos/pokt-network/pocket/pulls/659,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1162138206,Olshansk,6a35868ee75f6c99df368e65221af283178b1cb6,a8e78c8e7a4c1dbf419216c2c2a269ee18081702,"@@ -22,21 +22,18 @@ func (m *consensusModule) GetNodeAddress() string {
 	return m.nodeAddress
 }
 
-// IsSynced implements the interface function for checking if the node is synced with the network.
-func (m *consensusModule) IsSynced() (bool, error) {
-	currentHeight := m.GetBus().GetConsensusModule().CurrentHeight()
-	readCtx, err := m.GetBus().GetPersistenceModule().NewReadContext(int64(currentHeight - 1)) // Unknown height
-	if err != nil {
-		return false, err
-	}
-	defer readCtx.Release()
-
-	maxPersistedHeight, err := readCtx.GetMaximumBlockHeight()
-	if err != nil {
-		return false, err
-	}
-
-	maxSeenHeight := m.stateSync.GetAggregatedMetadata().MaxHeight
+// TODO (#352): Implement this function, currently a placeholder.",consensus/module_consensus_state_sync.go,2023-04-10 22:29:51+00:00,2023-04-10T22:41:22Z,"I'm not going to leave any more comments about this, but make sure to be consistent: `TODO(#352):`",,,,,25,RIGHT,28,,line,https://api.github.com/repos/pokt-network/pocket/pulls/659,pokt-network/pocket,82d931822979d5286c0cd811cf3f7f31ebb5897b
https://api.github.com/repos/pokt-network/pocket/pulls/659,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1162138572,Olshansk,6a35868ee75f6c99df368e65221af283178b1cb6,a8e78c8e7a4c1dbf419216c2c2a269ee18081702,"@@ -22,21 +22,18 @@ func (m *consensusModule) GetNodeAddress() string {
 	return m.nodeAddress
 }
 
-// IsSynced implements the interface function for checking if the node is synced with the network.
-func (m *consensusModule) IsSynced() (bool, error) {
-	currentHeight := m.GetBus().GetConsensusModule().CurrentHeight()
-	readCtx, err := m.GetBus().GetPersistenceModule().NewReadContext(int64(currentHeight - 1)) // Unknown height
-	if err != nil {
-		return false, err
-	}
-	defer readCtx.Release()
-
-	maxPersistedHeight, err := readCtx.GetMaximumBlockHeight()
-	if err != nil {
-		return false, err
-	}
-
-	maxSeenHeight := m.stateSync.GetAggregatedMetadata().MaxHeight
+// TODO (#352): Implement this function, currently a placeholder.
+// commitReceivedBlocks commits the blocks received from the blocksReceived channel
+func (m *consensusModule) commitReceivedBlocks() {
+	// runs as a background process in consensus module
+	// listens on the blocksReceived channel
+	// commits the block
+}
 
-	return maxPersistedHeight == maxSeenHeight, nil
+// TODO (#352): Implement this function, currently a placeholder.
+// metadataSyncLoop periodically sends metadata requests to its peers
+func (m *consensusModule) metadataSyncLoop() {
+	// runs as a background process in consensus module",consensus/module_consensus_state_sync.go,2023-04-10 22:30:37+00:00,2023-04-10T22:41:22Z,This is good. You create a placeholder but didn't implement it.,,,,38.0,36,RIGHT,40,33.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/659,pokt-network/pocket,82d931822979d5286c0cd811cf3f7f31ebb5897b
https://api.github.com/repos/pokt-network/pocket/pulls/659,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1162138823,Olshansk,6a35868ee75f6c99df368e65221af283178b1cb6,a8e78c8e7a4c1dbf419216c2c2a269ee18081702,"@@ -22,21 +22,18 @@ func (m *consensusModule) GetNodeAddress() string {
 	return m.nodeAddress
 }
 
-// IsSynced implements the interface function for checking if the node is synced with the network.
-func (m *consensusModule) IsSynced() (bool, error) {
-	currentHeight := m.GetBus().GetConsensusModule().CurrentHeight()
-	readCtx, err := m.GetBus().GetPersistenceModule().NewReadContext(int64(currentHeight - 1)) // Unknown height
-	if err != nil {
-		return false, err
-	}
-	defer readCtx.Release()
-
-	maxPersistedHeight, err := readCtx.GetMaximumBlockHeight()
-	if err != nil {
-		return false, err
-	}
-
-	maxSeenHeight := m.stateSync.GetAggregatedMetadata().MaxHeight
+// TODO (#352): Implement this function, currently a placeholder.
+// commitReceivedBlocks commits the blocks received from the blocksReceived channel
+func (m *consensusModule) commitReceivedBlocks() {",consensus/module_consensus_state_sync.go,2023-04-10 22:31:05+00:00,2023-04-10T22:41:22Z,Let's rename this to `blockApplicationLoop`.,,,,,27,RIGHT,30,,line,https://api.github.com/repos/pokt-network/pocket/pulls/659,pokt-network/pocket,82d931822979d5286c0cd811cf3f7f31ebb5897b
https://api.github.com/repos/pokt-network/pocket/pulls/659,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1162138979,Olshansk,6a35868ee75f6c99df368e65221af283178b1cb6,a8e78c8e7a4c1dbf419216c2c2a269ee18081702,"@@ -22,21 +22,18 @@ func (m *consensusModule) GetNodeAddress() string {
 	return m.nodeAddress
 }
 
-// IsSynced implements the interface function for checking if the node is synced with the network.
-func (m *consensusModule) IsSynced() (bool, error) {
-	currentHeight := m.GetBus().GetConsensusModule().CurrentHeight()
-	readCtx, err := m.GetBus().GetPersistenceModule().NewReadContext(int64(currentHeight - 1)) // Unknown height
-	if err != nil {
-		return false, err
-	}
-	defer readCtx.Release()
-
-	maxPersistedHeight, err := readCtx.GetMaximumBlockHeight()
-	if err != nil {
-		return false, err
-	}
-
-	maxSeenHeight := m.stateSync.GetAggregatedMetadata().MaxHeight
+// TODO (#352): Implement this function, currently a placeholder.
+// commitReceivedBlocks commits the blocks received from the blocksReceived channel
+func (m *consensusModule) commitReceivedBlocks() {
+	// runs as a background process in consensus module
+	// listens on the blocksReceived channel
+	// commits the block
+}
 
-	return maxPersistedHeight == maxSeenHeight, nil
+// TODO (#352): Implement this function, currently a placeholder.
+// metadataSyncLoop periodically sends metadata requests to its peers
+func (m *consensusModule) metadataSyncLoop() {",consensus/module_consensus_state_sync.go,2023-04-10 22:31:24+00:00,2023-04-10T22:41:22Z,Leave a comment that his is intended to run as a background goroutine. Same for the function above.,,,,37.0,35,RIGHT,39,32.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/659,pokt-network/pocket,82d931822979d5286c0cd811cf3f7f31ebb5897b
https://api.github.com/repos/pokt-network/pocket/pulls/659,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1162140166,Olshansk,6a35868ee75f6c99df368e65221af283178b1cb6,a8e78c8e7a4c1dbf419216c2c2a269ee18081702,"@@ -526,40 +536,328 @@ func baseRpcMock(t *testing.T, _ modules.EventsChannel) *mockModules.MockRPCModu
 	return rpcMock
 }
 
-func baseStateMachineMock(t *testing.T, _ modules.EventsChannel, bus modules.Bus) *mockModules.MockStateMachineModule {
-	ctrl := gomock.NewController(t)
-	stateMachineMock := mockModules.NewMockStateMachineModule(ctrl)
-	stateMachineMock.EXPECT().Start().Return(nil).AnyTimes()
-	stateMachineMock.EXPECT().SetBus(gomock.Any()).Return().AnyTimes()
-	stateMachineMock.EXPECT().GetModuleName().Return(modules.StateMachineModuleName).AnyTimes()
-
-	consensusMod := bus.GetConsensusModule()
-
-	stateMachineMock.EXPECT().SendEvent(gomock.Any()).DoAndReturn(func(event coreTypes.StateMachineEvent, args ...any) error {
-		switch coreTypes.StateMachineEvent(event) {
-		case coreTypes.StateMachineEvent_Consensus_IsUnsynced:
-			t.Logf(""Mocked node is unsynced"")
-			return bus.GetStateMachineModule().SendEvent(coreTypes.StateMachineEvent_Consensus_IsSyncing)
-		case coreTypes.StateMachineEvent_Consensus_IsSyncing:
-			t.Logf(""Mocked node is syncing"")
-			maxHeight := consensusMod.GetAggregatedStateSyncMetadataMaxHeight()
-			// TECHDEBT(#352): The asynchronicity of this leads to a non-deterministic failing test.
-			// See this discussion for details: https://github.com/pokt-network/pocket/pull/528/files#r1150711575
-			consensusMod.SetHeight(maxHeight)
-			return nil
-		case coreTypes.StateMachineEvent_Consensus_IsSyncedValidator:
-			t.Logf(""Mocked validator node is synced"")
-			return nil
-		case coreTypes.StateMachineEvent_Consensus_IsSyncedNonValidator:
-			t.Logf(""Mocked non-validator node is synced"")
-			return nil
-		default:
-			log.Printf(""Mocked node is not handling this event: %s"", event)
-			return nil
+func waitForNextBlock(t *testing.T,
+	clck *clock.Mock,
+	eventsChannel modules.EventsChannel,
+	pocketNodes IdToNodeMapping,
+	height uint64,
+	step uint8,
+	round uint8,
+	noOfExpectedMsgs int,
+	maxWaitTime time.Duration,
+	failOnExtraMessages bool) []*anypb.Any {
+
+	leaderId := typesCons.NodeId(pocketNodes[1].GetBus().GetConsensusModule().GetLeaderForView(height, uint64(round), step))
+	newRoundMessages := waitForNewRound(t, clck, eventsChannel, pocketNodes, height, step, round, noOfExpectedMsgs, maxWaitTime, failOnExtraMessages)
+	prepareProposal := waitForPrepareProposal(t, clck, eventsChannel, pocketNodes, newRoundMessages, height, step+1, round, leaderId, noOfExpectedMsgs, maxWaitTime, failOnExtraMessages)
+	prepareVote := waitForPrepareVotes(t, clck, eventsChannel, pocketNodes, prepareProposal, noOfExpectedMsgs, maxWaitTime, failOnExtraMessages)
+	preCommitProposal := waitForPreCommit(t, clck, eventsChannel, pocketNodes, prepareVote, height, step+2, round, leaderId, noOfExpectedMsgs, maxWaitTime, failOnExtraMessages)
+	commitProposal := waitForCommit(t, clck, eventsChannel, pocketNodes, preCommitProposal, height, step+3, round, leaderId, noOfExpectedMsgs, maxWaitTime, failOnExtraMessages)
+	return waitForDecide(t, clck, eventsChannel, pocketNodes, commitProposal, height, step+4, round, leaderId, noOfExpectedMsgs, maxWaitTime, failOnExtraMessages)
+}
+
+func waitForNewRound(t *testing.T,
+	clck *clock.Mock,
+	eventsChannel modules.EventsChannel,
+	pocketNodes IdToNodeMapping,
+	height uint64,
+	step uint8,
+	round uint8,
+	noOfExpectedMsgs int,
+	maxWaitTime time.Duration,
+	failOnExtraMessages bool) []*anypb.Any {
+
+	newRoundMessages, err := WaitForNetworkConsensusEvents(t, clck, eventsChannel, consensus.NewRound, consensus.Propose, noOfExpectedMsgs*noOfExpectedMsgs, maxWaitTime, failOnExtraMessages)
+	require.NoError(t, err)
+	for nodeId, pocketNode := range pocketNodes {
+		nodeState := GetConsensusNodeState(pocketNode)
+		assertNodeConsensusView(t, nodeId,
+			typesCons.ConsensusNodeState{
+				Height: height,
+				Step:   step,
+				Round:  round,
+			},
+			nodeState)
+		require.Equal(t, false, nodeState.IsLeader)
+		require.Equal(t, typesCons.NodeId(0), nodeState.LeaderId)
+	}
+
+	return newRoundMessages
+}
+
+func waitForPrepareProposal(t *testing.T,",consensus/e2e_tests/utils_test.go,2023-04-10 22:33:38+00:00,2023-04-10T22:41:22Z,"This is a good approach, but you're making it too specific. 

Instead of `WaitForXXXXProposal`  or `waitForXXXVote`, just implement `WaitForProposalMsgs` and `WaitForVoteMsgs` and make the `Step` a parameter. It'll reduce the code by a lot and make it easier to read.",,,,,588,RIGHT,160,,line,https://api.github.com/repos/pokt-network/pocket/pulls/659,pokt-network/pocket,82d931822979d5286c0cd811cf3f7f31ebb5897b
https://api.github.com/repos/pokt-network/pocket/pulls/659,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1162140757,Olshansk,6a35868ee75f6c99df368e65221af283178b1cb6,a8e78c8e7a4c1dbf419216c2c2a269ee18081702,"@@ -207,11 +131,10 @@ func TestPacemakerCatchupSameStepDifferentRounds(t *testing.T) {
 	anyMsg, err := anypb.New(prepareProposal)
 	require.NoError(t, err)
 
-	P2PBroadcast(t, pocketNodes, anyMsg)
-
 	numExpectedMsgs := numValidators - 1   // -1 because one of the messages is a self proposal (leader to itself as a replica) that is not passed through the network
 	msgTimeout := paceMakerTimeoutMsec / 2 // /2 because we do not want the pacemaker to trigger a new timeout
-	_, err = WaitForNetworkConsensusEvents(t, clockMock, eventsChannel, consensus.Prepare, consensus.Vote, numExpectedMsgs, time.Duration(msgTimeout), true)
+
+	_ = waitForPrepareVotes(t, clockMock, eventsChannel, pocketNodes, []*anypb.Any{anyMsg}, numExpectedMsgs, time.Duration(msgTimeout), true)
 	require.NoError(t, err)",consensus/e2e_tests/pacemaker_test.go,2023-04-10 22:34:38+00:00,2023-04-10T22:41:22Z,Does `waitForVotes` not return an error?,,137.0,RIGHT,,138,RIGHT,168,,line,https://api.github.com/repos/pokt-network/pocket/pulls/659,pokt-network/pocket,82d931822979d5286c0cd811cf3f7f31ebb5897b
https://api.github.com/repos/pokt-network/pocket/pulls/659,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1162140960,Olshansk,6a35868ee75f6c99df368e65221af283178b1cb6,a8e78c8e7a4c1dbf419216c2c2a269ee18081702,"@@ -43,89 +43,24 @@ func TestPacemakerTimeoutIncreasesRound(t *testing.T) {
 
 	// Advance time by an amount shorter than the pacemaker timeout
 	advanceTime(t, clockMock, 10*time.Millisecond)
-
-	// Verify consensus started - NewRound messages have an N^2 complexity.
-	numExpectedMsgs := numValidators * numValidators
-	_, err := WaitForNetworkConsensusEvents(t, clockMock, eventsChannel, consensus.NewRound, consensus.Propose, numExpectedMsgs, consensusMessageTimeoutMsec, true)
-	require.NoError(t, err)
-
-	for pocketId, pocketNode := range pocketNodes {
-		assertNodeConsensusView(t, pocketId,
-			typesCons.ConsensusNodeState{
-				Height: 1,
-				Step:   uint8(consensus.NewRound),
-				Round:  0,
-			},
-			GetConsensusNodeState(pocketNode))
-	}
+	height := uint64(1)
+	step := uint8(consensus.NewRound)
+	round := uint8(0)
+	_ = waitForNewRound(t, clockMock, eventsChannel, pocketNodes, height, step, round, numValidators, consensusMessageTimeout, true)
 
 	// Force the pacemaker to time out
 	forcePacemakerTimeout(t, clockMock, paceMakerTimeout)
-
-	// Verify that a new round started at the same height
-	_, err = WaitForNetworkConsensusEvents(t, clockMock, eventsChannel, consensus.NewRound, consensus.Propose, numExpectedMsgs, consensusMessageTimeoutMsec, true)
-	require.NoError(t, err)
-	for pocketId, pocketNode := range pocketNodes {
-		assertNodeConsensusView(t, pocketId,
-			typesCons.ConsensusNodeState{
-				Height: 1,
-				Step:   uint8(consensus.NewRound),
-				Round:  1,
-			},
-			GetConsensusNodeState(pocketNode))
-	}
+	_ = waitForNewRound(t, clockMock, eventsChannel, pocketNodes, height, step, round+1, numValidators, consensusMessageTimeout, true)
 
 	forcePacemakerTimeout(t, clockMock, paceMakerTimeout)
-
-	// Check that a new round starts at the same height
-	_, err = WaitForNetworkConsensusEvents(t, clockMock, eventsChannel, consensus.NewRound, consensus.Propose, numExpectedMsgs, consensusMessageTimeoutMsec, true)
-	require.NoError(t, err)
-	for pocketId, pocketNode := range pocketNodes {
-		assertNodeConsensusView(t, pocketId,
-			typesCons.ConsensusNodeState{
-				Height: 1,
-				Step:   uint8(consensus.NewRound),
-				Round:  2,
-			},
-			GetConsensusNodeState(pocketNode))
-	}
+	_ = waitForNewRound(t, clockMock, eventsChannel, pocketNodes, height, step, round+2, numValidators, consensusMessageTimeout, true)
 
 	forcePacemakerTimeout(t, clockMock, paceMakerTimeout)
+	newRoundMessages := waitForNewRound(t, clockMock, eventsChannel, pocketNodes, height, step, round+3, numValidators, consensusMessageTimeout, true)
 
-	// Check that a new round starts at the same height.
-	newRoundMessages, err := WaitForNetworkConsensusEvents(t, clockMock, eventsChannel, consensus.NewRound, consensus.Propose, numExpectedMsgs, consensusMessageTimeoutMsec, true)
+	leaderId := typesCons.NodeId(pocketNodes[1].GetBus().GetConsensusModule().GetLeaderForView(height, uint64(round+3), step))
+	_ = waitForPrepareProposal(t, clockMock, eventsChannel, pocketNodes, newRoundMessages, height, step+1, round+3, leaderId, numValidators, consensusMessageTimeout, true)
 	require.NoError(t, err)",consensus/e2e_tests/pacemaker_test.go,2023-04-10 22:35:01+00:00,2023-04-10T22:41:22Z,Does `waitForProposal` not return an error?,,,,72.0,63,RIGHT,91,115.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/659,pokt-network/pocket,82d931822979d5286c0cd811cf3f7f31ebb5897b
https://api.github.com/repos/pokt-network/pocket/pulls/659,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1162141416,Olshansk,6a35868ee75f6c99df368e65221af283178b1cb6,a8e78c8e7a4c1dbf419216c2c2a269ee18081702,"@@ -39,170 +39,22 @@ func TestHotstuff4Nodes1BlockHappyPath(t *testing.T) {
 	startingRound := uint64(0)
 	startingStep := uint8(consensus.NewRound)
 
-	// Get leaderId for the given height, round and step, by using the Consensus Modules' GetLeaderForView() function.
-	// Any node in pocketNodes mapping can be used to gather leader election result via GetLeaderForView() function.
-	leaderId := typesCons.NodeId(pocketNodes[1].GetBus().GetConsensusModule().GetLeaderForView(startingHeight, startingRound, startingStep))
-	leader := pocketNodes[leaderId]
-
-	// 1. NewRound
-	newRoundMessages, err := WaitForNetworkConsensusEvents(t, clockMock, eventsChannel, consensus.NewRound, consensus.Propose, numValidators*numValidators, 500, true)
-	require.NoError(t, err)
-	for nodeId, pocketNode := range pocketNodes {
-		nodeState := GetConsensusNodeState(pocketNode)
-		assertNodeConsensusView(t, nodeId,
-			typesCons.ConsensusNodeState{
-				Height: startingHeight,
-				Step:   startingStep,
-				Round:  uint8(startingRound),
-			},
-			nodeState)
-		require.Equal(t, false, nodeState.IsLeader)
-		require.Equal(t, typesCons.NodeId(0), nodeState.LeaderId)
-	}
-
-	for _, message := range newRoundMessages {
-		P2PBroadcast(t, pocketNodes, message)
-	}
-	advanceTime(t, clockMock, 10*time.Millisecond)
-
-	// 2. Prepare
-	prepareProposal, err := WaitForNetworkConsensusEvents(t, clockMock, eventsChannel, consensus.Prepare, consensus.Propose, numValidators, 500, true)
-	require.NoError(t, err)
-	for nodeId, pocketNode := range pocketNodes {
-		nodeState := GetConsensusNodeState(pocketNode)
-		assertNodeConsensusView(t, nodeId,
-			typesCons.ConsensusNodeState{
-				Height: startingHeight,
-				Step:   startingStep + 1,
-				Round:  uint8(startingRound),
-			},
-			nodeState)
-		require.Equal(t, leaderId, nodeState.LeaderId, fmt.Sprintf(""%d should be the current leader"", leaderId))
-	}
-
-	for _, message := range prepareProposal {
-		P2PBroadcast(t, pocketNodes, message)
-	}
-	advanceTime(t, clockMock, 10*time.Millisecond)
-
-	// 3. PreCommit
-	prepareVotes, err := WaitForNetworkConsensusEvents(t, clockMock, eventsChannel, consensus.Prepare, consensus.Vote, numValidators, 500, true)
-	require.NoError(t, err)
-
-	for _, vote := range prepareVotes {
-		P2PSend(t, leader, vote)
-	}
-	advanceTime(t, clockMock, 10*time.Millisecond)
-
-	preCommitProposal, err := WaitForNetworkConsensusEvents(t, clockMock, eventsChannel, consensus.PreCommit, consensus.Propose, numValidators, 500, true)
-	require.NoError(t, err)
-	for nodeId, pocketNode := range pocketNodes {
-		nodeState := GetConsensusNodeState(pocketNode)
-		assertNodeConsensusView(t, nodeId,
-			typesCons.ConsensusNodeState{
-				Height: startingHeight,
-				Step:   startingStep + 2,
-				Round:  uint8(startingRound),
-			},
-			nodeState)
-		require.Equal(t, leaderId, nodeState.LeaderId, fmt.Sprintf(""%d should be the current leader"", leaderId))
-	}
-
-	for _, message := range preCommitProposal {
-		P2PBroadcast(t, pocketNodes, message)
-	}
-	advanceTime(t, clockMock, 10*time.Millisecond)
-
-	// 4. Commit
-	preCommitVotes, err := WaitForNetworkConsensusEvents(t, clockMock, eventsChannel, consensus.PreCommit, consensus.Vote, numValidators, 500, true)
-	require.NoError(t, err)
-
-	for _, vote := range preCommitVotes {
-		P2PSend(t, leader, vote)
-	}
-	advanceTime(t, clockMock, 10*time.Millisecond)
-
-	commitProposal, err := WaitForNetworkConsensusEvents(t, clockMock, eventsChannel, consensus.Commit, consensus.Propose, numValidators, 500, true)
-	require.NoError(t, err)
-	for nodeId, pocketNode := range pocketNodes {
-		nodeState := GetConsensusNodeState(pocketNode)
-		assertNodeConsensusView(t, nodeId,
-			typesCons.ConsensusNodeState{
-				Height: startingHeight,
-				Step:   startingStep + 3,
-				Round:  uint8(startingRound),
-			},
-			nodeState)
-		require.Equal(t, leaderId, nodeState.LeaderId, fmt.Sprintf(""%d should be the current leader"", leaderId))
-	}
-
-	for _, message := range commitProposal {
-		P2PBroadcast(t, pocketNodes, message)
-	}
-	advanceTime(t, clockMock, 10*time.Millisecond)
-
-	// 5. Decide
-	commitVotes, err := WaitForNetworkConsensusEvents(t, clockMock, eventsChannel, consensus.Commit, consensus.Vote, numValidators, 500, true)
-	require.NoError(t, err)
-
-	for _, vote := range commitVotes {
-		P2PSend(t, leader, vote)
-	}
-	advanceTime(t, clockMock, 10*time.Millisecond)
-
-	decideProposal, err := WaitForNetworkConsensusEvents(t, clockMock, eventsChannel, consensus.Decide, consensus.Propose, numValidators, 500, true)
-	require.NoError(t, err)
-	for pocketId, pocketNode := range pocketNodes {
-		nodeState := GetConsensusNodeState(pocketNode)
-		// Leader has already committed the block and hence moved to the next height.
-		if pocketId == leaderId {
-			assertNodeConsensusView(t, pocketId,
-				typesCons.ConsensusNodeState{
-					Height: startingHeight + 1,
-					Step:   startingStep,
-					Round:  uint8(startingRound),
-				},
-				nodeState)
-			require.Equal(t, typesCons.NodeId(0), nodeState.LeaderId, ""Leader should be empty"")
-			continue
-		}
-		assertNodeConsensusView(t, pocketId,
-			typesCons.ConsensusNodeState{
-				Height: startingHeight,
-				Step:   startingStep + 4,
-				Round:  uint8(startingRound),
-			},
-			nodeState)
-		require.Equal(t, leaderId, nodeState.LeaderId, fmt.Sprintf(""%d should be the current leader"", leaderId))
-	}
+	decideProposal := waitForNextBlock(t, clockMock, eventsChannel, pocketNodes, startingHeight, startingStep, uint8(startingRound), numValidators, 500, true)",consensus/e2e_tests/hotstuff_test.go,2023-04-10 22:35:55+00:00,2023-04-10T22:41:22Z,"Try reading this in isolation: `decideProposal := waitForNextBlock(`

It's very confusing. I expect `waitForNextBlock` to return a block, not the inside business logic of hotstuff.",,,,,42,RIGHT,158,,line,https://api.github.com/repos/pokt-network/pocket/pulls/659,pokt-network/pocket,82d931822979d5286c0cd811cf3f7f31ebb5897b
https://api.github.com/repos/pokt-network/pocket/pulls/659,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1162142577,Olshansk,6a35868ee75f6c99df368e65221af283178b1cb6,a8e78c8e7a4c1dbf419216c2c2a269ee18081702,"@@ -526,40 +536,328 @@ func baseRpcMock(t *testing.T, _ modules.EventsChannel) *mockModules.MockRPCModu
 	return rpcMock
 }
 
-func baseStateMachineMock(t *testing.T, _ modules.EventsChannel, bus modules.Bus) *mockModules.MockStateMachineModule {
-	ctrl := gomock.NewController(t)
-	stateMachineMock := mockModules.NewMockStateMachineModule(ctrl)
-	stateMachineMock.EXPECT().Start().Return(nil).AnyTimes()
-	stateMachineMock.EXPECT().SetBus(gomock.Any()).Return().AnyTimes()
-	stateMachineMock.EXPECT().GetModuleName().Return(modules.StateMachineModuleName).AnyTimes()
-
-	consensusMod := bus.GetConsensusModule()
-
-	stateMachineMock.EXPECT().SendEvent(gomock.Any()).DoAndReturn(func(event coreTypes.StateMachineEvent, args ...any) error {
-		switch coreTypes.StateMachineEvent(event) {
-		case coreTypes.StateMachineEvent_Consensus_IsUnsynced:
-			t.Logf(""Mocked node is unsynced"")
-			return bus.GetStateMachineModule().SendEvent(coreTypes.StateMachineEvent_Consensus_IsSyncing)
-		case coreTypes.StateMachineEvent_Consensus_IsSyncing:
-			t.Logf(""Mocked node is syncing"")
-			maxHeight := consensusMod.GetAggregatedStateSyncMetadataMaxHeight()
-			// TECHDEBT(#352): The asynchronicity of this leads to a non-deterministic failing test.
-			// See this discussion for details: https://github.com/pokt-network/pocket/pull/528/files#r1150711575
-			consensusMod.SetHeight(maxHeight)
-			return nil
-		case coreTypes.StateMachineEvent_Consensus_IsSyncedValidator:
-			t.Logf(""Mocked validator node is synced"")
-			return nil
-		case coreTypes.StateMachineEvent_Consensus_IsSyncedNonValidator:
-			t.Logf(""Mocked non-validator node is synced"")
-			return nil
-		default:
-			log.Printf(""Mocked node is not handling this event: %s"", event)
-			return nil
+func waitForNextBlock(t *testing.T,
+	clck *clock.Mock,
+	eventsChannel modules.EventsChannel,
+	pocketNodes IdToNodeMapping,
+	height uint64,
+	step uint8,
+	round uint8,
+	noOfExpectedMsgs int,
+	maxWaitTime time.Duration,
+	failOnExtraMessages bool) []*anypb.Any {
+
+	leaderId := typesCons.NodeId(pocketNodes[1].GetBus().GetConsensusModule().GetLeaderForView(height, uint64(round), step))
+	newRoundMessages := waitForNewRound(t, clck, eventsChannel, pocketNodes, height, step, round, noOfExpectedMsgs, maxWaitTime, failOnExtraMessages)
+	prepareProposal := waitForPrepareProposal(t, clck, eventsChannel, pocketNodes, newRoundMessages, height, step+1, round, leaderId, noOfExpectedMsgs, maxWaitTime, failOnExtraMessages)
+	prepareVote := waitForPrepareVotes(t, clck, eventsChannel, pocketNodes, prepareProposal, noOfExpectedMsgs, maxWaitTime, failOnExtraMessages)
+	preCommitProposal := waitForPreCommit(t, clck, eventsChannel, pocketNodes, prepareVote, height, step+2, round, leaderId, noOfExpectedMsgs, maxWaitTime, failOnExtraMessages)
+	commitProposal := waitForCommit(t, clck, eventsChannel, pocketNodes, preCommitProposal, height, step+3, round, leaderId, noOfExpectedMsgs, maxWaitTime, failOnExtraMessages)
+	return waitForDecide(t, clck, eventsChannel, pocketNodes, commitProposal, height, step+4, round, leaderId, noOfExpectedMsgs, maxWaitTime, failOnExtraMessages)
+}
+
+func waitForNewRound(t *testing.T,
+	clck *clock.Mock,
+	eventsChannel modules.EventsChannel,
+	pocketNodes IdToNodeMapping,
+	height uint64,
+	step uint8,
+	round uint8,
+	noOfExpectedMsgs int,
+	maxWaitTime time.Duration,
+	failOnExtraMessages bool) []*anypb.Any {
+
+	newRoundMessages, err := WaitForNetworkConsensusEvents(t, clck, eventsChannel, consensus.NewRound, consensus.Propose, noOfExpectedMsgs*noOfExpectedMsgs, maxWaitTime, failOnExtraMessages)
+	require.NoError(t, err)
+	for nodeId, pocketNode := range pocketNodes {
+		nodeState := GetConsensusNodeState(pocketNode)
+		assertNodeConsensusView(t, nodeId,
+			typesCons.ConsensusNodeState{
+				Height: height,
+				Step:   step,
+				Round:  round,
+			},
+			nodeState)
+		require.Equal(t, false, nodeState.IsLeader)
+		require.Equal(t, typesCons.NodeId(0), nodeState.LeaderId)
+	}
+
+	return newRoundMessages
+}
+
+func waitForPrepareProposal(t *testing.T,
+	clck *clock.Mock,
+	eventsChannel modules.EventsChannel,
+	pocketNodes IdToNodeMapping,
+	newRoundMessages []*anypb.Any,
+	height uint64,
+	step uint8,
+	round uint8,
+	leaderId typesCons.NodeId,
+	noOfExpectedMsgs int,
+	maxWaitTime time.Duration,
+	failOnExtraMessages bool) []*anypb.Any {
+
+	for _, message := range newRoundMessages {
+		P2PBroadcast(t, pocketNodes, message)
+	}
+	advanceTime(t, clck, 10*time.Millisecond)
+
+	prepareProposal, err := WaitForNetworkConsensusEvents(t, clck, eventsChannel, consensus.Prepare, consensus.Propose, noOfExpectedMsgs, maxWaitTime, failOnExtraMessages)
+	require.NoError(t, err)
+	for nodeId, pocketNode := range pocketNodes {
+		nodeState := GetConsensusNodeState(pocketNode)
+		assertNodeConsensusView(t, nodeId,
+			typesCons.ConsensusNodeState{
+				Height: height,
+				Step:   step,
+				Round:  round,
+			},
+			nodeState)
+		require.Equal(t, leaderId, nodeState.LeaderId, fmt.Sprintf(""%d should be the current leader"", leaderId))
+	}
+
+	return prepareProposal
+}
+
+func waitForPrepareVotes(t *testing.T,
+	clck *clock.Mock,
+	eventsChannel modules.EventsChannel,
+	pocketNodes IdToNodeMapping,
+	prepareProposal []*anypb.Any,
+	noOfExpectedMsgs int,
+	maxWaitTime time.Duration,
+	failOnExtraMessages bool) []*anypb.Any {
+
+	for _, message := range prepareProposal {
+		P2PBroadcast(t, pocketNodes, message)
+	}
+	advanceTime(t, clck, 10*time.Millisecond)
+
+	prepareVotes, err := WaitForNetworkConsensusEvents(t, clck, eventsChannel, consensus.Prepare, consensus.Vote, noOfExpectedMsgs, maxWaitTime, failOnExtraMessages)
+	require.NoError(t, err)
+
+	return prepareVotes
+}
+
+func waitForPreCommit(t *testing.T,
+	clck *clock.Mock,
+	eventsChannel modules.EventsChannel,
+	pocketNodes IdToNodeMapping,
+	prepareVotes []*anypb.Any,
+	height uint64,
+	step uint8,
+	round uint8,
+	leaderId typesCons.NodeId,
+	noOfExpectedMsgs int,
+	maxWaitTime time.Duration,
+	failOnExtraMessages bool) []*anypb.Any {
+
+	leader := pocketNodes[leaderId]
+
+	for _, vote := range prepareVotes {
+		P2PSend(t, leader, vote)
+	}
+	advanceTime(t, clck, 10*time.Millisecond)
+
+	preCommitProposal, err := WaitForNetworkConsensusEvents(t, clck, eventsChannel, consensus.PreCommit, consensus.Propose, noOfExpectedMsgs, maxWaitTime, failOnExtraMessages)
+	require.NoError(t, err)
+	for nodeId, pocketNode := range pocketNodes {
+		nodeState := GetConsensusNodeState(pocketNode)
+		assertNodeConsensusView(t, nodeId,
+			typesCons.ConsensusNodeState{
+				Height: height,
+				Step:   step,
+				Round:  round,
+			},
+			nodeState)
+		require.Equal(t, leaderId, nodeState.LeaderId, fmt.Sprintf(""%d should be the current leader"", leaderId))
+	}
+
+	return preCommitProposal
+}
+
+func waitForCommit(t *testing.T,
+	clck *clock.Mock,
+	eventsChannel modules.EventsChannel,
+	pocketNodes IdToNodeMapping,
+	preCommitProposal []*anypb.Any,
+	height uint64,
+	step uint8,
+	round uint8,
+	leaderId typesCons.NodeId,
+	noOfExpectedMsgs int,
+	maxWaitTime time.Duration,
+	failOnExtraMessages bool) []*anypb.Any {
+
+	leader := pocketNodes[leaderId]
+
+	for _, message := range preCommitProposal {
+		P2PBroadcast(t, pocketNodes, message)
+	}
+	advanceTime(t, clck, 10*time.Millisecond)
+
+	preCommitVotes, err := WaitForNetworkConsensusEvents(t, clck, eventsChannel, consensus.PreCommit, consensus.Vote, noOfExpectedMsgs, maxWaitTime, failOnExtraMessages)
+	require.NoError(t, err)
+
+	for _, vote := range preCommitVotes {
+		P2PSend(t, leader, vote)
+	}
+	advanceTime(t, clck, 10*time.Millisecond)
+
+	commitProposal, err := WaitForNetworkConsensusEvents(t, clck, eventsChannel, consensus.Commit, consensus.Propose, noOfExpectedMsgs, maxWaitTime, failOnExtraMessages)
+	require.NoError(t, err)
+	for nodeId, pocketNode := range pocketNodes {
+		nodeState := GetConsensusNodeState(pocketNode)
+		assertNodeConsensusView(t, nodeId,
+			typesCons.ConsensusNodeState{
+				Height: height,
+				Step:   step,
+				Round:  round,
+			},
+			nodeState)
+		require.Equal(t, leaderId, nodeState.LeaderId, fmt.Sprintf(""%d should be the current leader"", leaderId))
+	}
+
+	return commitProposal
+}
+
+func waitForDecide(t *testing.T,
+	clck *clock.Mock,
+	eventsChannel modules.EventsChannel,
+	pocketNodes IdToNodeMapping,
+	commitProposal []*anypb.Any,
+	height uint64,
+	step uint8,
+	round uint8,
+	leaderId typesCons.NodeId,
+	noOfExpectedMsgs int,
+	maxWaitTime time.Duration,
+	failOnExtraMessages bool) []*anypb.Any {
+
+	leader := pocketNodes[leaderId]
+
+	for _, message := range commitProposal {
+		P2PBroadcast(t, pocketNodes, message)
+	}
+	advanceTime(t, clck, 10*time.Millisecond)
+
+	commitVotes, err := WaitForNetworkConsensusEvents(t, clck, eventsChannel, consensus.Commit, consensus.Vote, noOfExpectedMsgs, maxWaitTime, failOnExtraMessages)
+	require.NoError(t, err)
+
+	for _, vote := range commitVotes {
+		P2PSend(t, leader, vote)
+	}
+	advanceTime(t, clck, 10*time.Millisecond)
+
+	decideProposal, err := WaitForNetworkConsensusEvents(t, clck, eventsChannel, consensus.Decide, consensus.Propose, noOfExpectedMsgs, maxWaitTime, failOnExtraMessages)
+	require.NoError(t, err)
+	for pocketId, pocketNode := range pocketNodes {
+		nodeState := GetConsensusNodeState(pocketNode)
+		// Leader has already committed the block and hence moved to the next height.
+		if pocketId == leaderId {
+			assertNodeConsensusView(t, pocketId,
+				typesCons.ConsensusNodeState{
+					Height: height + 1,
+					Step:   1,
+					Round:  round,
+				},
+				nodeState)
+			require.Equal(t, typesCons.NodeId(0), nodeState.LeaderId, ""Leader should be empty"")
+			continue
 		}
-	}).AnyTimes()
+		assertNodeConsensusView(t, pocketId,
+			typesCons.ConsensusNodeState{
+				Height: height,
+				Step:   step,
+				Round:  round,
+			},
+			nodeState)
+		require.Equal(t, leaderId, nodeState.LeaderId, fmt.Sprintf(""%d should be the current leader"", leaderId))
+	}
+
+	return decideProposal
+}
 
-	return stateMachineMock
+// waitForNodeToSync waits for a node to sync to a target height
+// For every missing block for the unsynced node:
+//
+//	first, waits for the node to request a missing block via `waitForNodeToRequestMissingBlock()` function,
+//	then, waits for the node to receive the missing block via `waitForNodeToReceiveMissingBlock()` function,
+//	finally, wait for the node to catch up to the target height via `waitForNodeToCatchUp()` function.
+func waitForNodeToSync(t *testing.T,
+	clck *clock.Mock,
+	eventsChannel modules.EventsChannel,
+	unsyncedNode *shared.Node,
+	allNodes IdToNodeMapping,
+	targetHeight uint64) {
+
+	consensusMod := unsyncedNode.GetBus().GetConsensusModule()
+	currentHeight := consensusMod.CurrentHeight()
+
+	for i := currentHeight; i <= targetHeight; i++ {
+		blockRequest, err := waitForNodeToRequestMissingBlock(t, clck, eventsChannel, allNodes, currentHeight, targetHeight)
+		require.NoError(t, err)
+
+		blockResponse, err := waitForNodeToReceiveMissingBlock(t, clck, eventsChannel, allNodes, blockRequest)
+		require.NoError(t, err)
+
+		err = waitForNodeToCatchUp(t, clck, eventsChannel, unsyncedNode, blockResponse, targetHeight)
+		require.NoError(t, err)
+	}
+}
+
+// TODO (#352): implement this function
+// waitForNodeToRequestMissingBlock waits for unsynced node to request missing block form the network
+func waitForNodeToRequestMissingBlock(
+	t *testing.T,
+	clck *clock.Mock,
+	eventsChannel modules.EventsChannel,
+	allNodes IdToNodeMapping,
+	startingHeight uint64,
+	targetHeight uint64) (*anypb.Any, error) {
+
+	return &anypb.Any{}, nil
+}
+
+// TODO (#352): implement this function.
+// waitForNodeToReceiveMissingBlock requests block request of the unsynced node
+// for given node to node to catch up to the target height by sending the requested block.
+func waitForNodeToReceiveMissingBlock(
+	t *testing.T,
+	clck *clock.Mock,
+	eventsChannel modules.EventsChannel,
+	allNodes IdToNodeMapping,
+	blockReq *anypb.Any) (*anypb.Any, error) {",consensus/e2e_tests/utils_test.go,2023-04-10 22:38:05+00:00,2023-04-10T22:41:22Z,"leaving one comment but ditto everywhere else

```suggestion
	blockReq *anypb.Any
) (*anypb.Any, error) {
```",,,,,831,RIGHT,405,,line,https://api.github.com/repos/pokt-network/pocket/pulls/659,pokt-network/pocket,82d931822979d5286c0cd811cf3f7f31ebb5897b
https://api.github.com/repos/pokt-network/pocket/pulls/659,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1162143350,Olshansk,6a35868ee75f6c99df368e65221af283178b1cb6,a8e78c8e7a4c1dbf419216c2c2a269ee18081702,"@@ -526,40 +536,328 @@ func baseRpcMock(t *testing.T, _ modules.EventsChannel) *mockModules.MockRPCModu
 	return rpcMock
 }
 
-func baseStateMachineMock(t *testing.T, _ modules.EventsChannel, bus modules.Bus) *mockModules.MockStateMachineModule {
-	ctrl := gomock.NewController(t)
-	stateMachineMock := mockModules.NewMockStateMachineModule(ctrl)
-	stateMachineMock.EXPECT().Start().Return(nil).AnyTimes()
-	stateMachineMock.EXPECT().SetBus(gomock.Any()).Return().AnyTimes()
-	stateMachineMock.EXPECT().GetModuleName().Return(modules.StateMachineModuleName).AnyTimes()
-
-	consensusMod := bus.GetConsensusModule()
-
-	stateMachineMock.EXPECT().SendEvent(gomock.Any()).DoAndReturn(func(event coreTypes.StateMachineEvent, args ...any) error {
-		switch coreTypes.StateMachineEvent(event) {
-		case coreTypes.StateMachineEvent_Consensus_IsUnsynced:
-			t.Logf(""Mocked node is unsynced"")
-			return bus.GetStateMachineModule().SendEvent(coreTypes.StateMachineEvent_Consensus_IsSyncing)
-		case coreTypes.StateMachineEvent_Consensus_IsSyncing:
-			t.Logf(""Mocked node is syncing"")
-			maxHeight := consensusMod.GetAggregatedStateSyncMetadataMaxHeight()
-			// TECHDEBT(#352): The asynchronicity of this leads to a non-deterministic failing test.
-			// See this discussion for details: https://github.com/pokt-network/pocket/pull/528/files#r1150711575
-			consensusMod.SetHeight(maxHeight)
-			return nil
-		case coreTypes.StateMachineEvent_Consensus_IsSyncedValidator:
-			t.Logf(""Mocked validator node is synced"")
-			return nil
-		case coreTypes.StateMachineEvent_Consensus_IsSyncedNonValidator:
-			t.Logf(""Mocked non-validator node is synced"")
-			return nil
-		default:
-			log.Printf(""Mocked node is not handling this event: %s"", event)
-			return nil
+func waitForNextBlock(t *testing.T,
+	clck *clock.Mock,
+	eventsChannel modules.EventsChannel,
+	pocketNodes IdToNodeMapping,
+	height uint64,
+	step uint8,
+	round uint8,
+	noOfExpectedMsgs int,
+	maxWaitTime time.Duration,
+	failOnExtraMessages bool) []*anypb.Any {
+
+	leaderId := typesCons.NodeId(pocketNodes[1].GetBus().GetConsensusModule().GetLeaderForView(height, uint64(round), step))
+	newRoundMessages := waitForNewRound(t, clck, eventsChannel, pocketNodes, height, step, round, noOfExpectedMsgs, maxWaitTime, failOnExtraMessages)
+	prepareProposal := waitForPrepareProposal(t, clck, eventsChannel, pocketNodes, newRoundMessages, height, step+1, round, leaderId, noOfExpectedMsgs, maxWaitTime, failOnExtraMessages)
+	prepareVote := waitForPrepareVotes(t, clck, eventsChannel, pocketNodes, prepareProposal, noOfExpectedMsgs, maxWaitTime, failOnExtraMessages)
+	preCommitProposal := waitForPreCommit(t, clck, eventsChannel, pocketNodes, prepareVote, height, step+2, round, leaderId, noOfExpectedMsgs, maxWaitTime, failOnExtraMessages)
+	commitProposal := waitForCommit(t, clck, eventsChannel, pocketNodes, preCommitProposal, height, step+3, round, leaderId, noOfExpectedMsgs, maxWaitTime, failOnExtraMessages)
+	return waitForDecide(t, clck, eventsChannel, pocketNodes, commitProposal, height, step+4, round, leaderId, noOfExpectedMsgs, maxWaitTime, failOnExtraMessages)",consensus/e2e_tests/utils_test.go,2023-04-10 22:39:31+00:00,2023-04-10T22:41:22Z,"Don't do step + 1, +2, +3. Use the actual name so its easier to read",,,,,556,RIGHT,128,,line,https://api.github.com/repos/pokt-network/pocket/pulls/659,pokt-network/pocket,82d931822979d5286c0cd811cf3f7f31ebb5897b
https://api.github.com/repos/pokt-network/pocket/pulls/659,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1162143486,Olshansk,6a35868ee75f6c99df368e65221af283178b1cb6,a8e78c8e7a4c1dbf419216c2c2a269ee18081702,"@@ -526,40 +536,328 @@ func baseRpcMock(t *testing.T, _ modules.EventsChannel) *mockModules.MockRPCModu
 	return rpcMock
 }
 
-func baseStateMachineMock(t *testing.T, _ modules.EventsChannel, bus modules.Bus) *mockModules.MockStateMachineModule {
-	ctrl := gomock.NewController(t)
-	stateMachineMock := mockModules.NewMockStateMachineModule(ctrl)
-	stateMachineMock.EXPECT().Start().Return(nil).AnyTimes()
-	stateMachineMock.EXPECT().SetBus(gomock.Any()).Return().AnyTimes()
-	stateMachineMock.EXPECT().GetModuleName().Return(modules.StateMachineModuleName).AnyTimes()
-
-	consensusMod := bus.GetConsensusModule()
-
-	stateMachineMock.EXPECT().SendEvent(gomock.Any()).DoAndReturn(func(event coreTypes.StateMachineEvent, args ...any) error {
-		switch coreTypes.StateMachineEvent(event) {
-		case coreTypes.StateMachineEvent_Consensus_IsUnsynced:
-			t.Logf(""Mocked node is unsynced"")
-			return bus.GetStateMachineModule().SendEvent(coreTypes.StateMachineEvent_Consensus_IsSyncing)
-		case coreTypes.StateMachineEvent_Consensus_IsSyncing:
-			t.Logf(""Mocked node is syncing"")
-			maxHeight := consensusMod.GetAggregatedStateSyncMetadataMaxHeight()
-			// TECHDEBT(#352): The asynchronicity of this leads to a non-deterministic failing test.
-			// See this discussion for details: https://github.com/pokt-network/pocket/pull/528/files#r1150711575
-			consensusMod.SetHeight(maxHeight)
-			return nil
-		case coreTypes.StateMachineEvent_Consensus_IsSyncedValidator:
-			t.Logf(""Mocked validator node is synced"")
-			return nil
-		case coreTypes.StateMachineEvent_Consensus_IsSyncedNonValidator:
-			t.Logf(""Mocked non-validator node is synced"")
-			return nil
-		default:
-			log.Printf(""Mocked node is not handling this event: %s"", event)
-			return nil
+func waitForNextBlock(t *testing.T,
+	clck *clock.Mock,
+	eventsChannel modules.EventsChannel,
+	pocketNodes IdToNodeMapping,
+	height uint64,
+	step uint8,
+	round uint8,
+	noOfExpectedMsgs int,
+	maxWaitTime time.Duration,
+	failOnExtraMessages bool) []*anypb.Any {
+
+	leaderId := typesCons.NodeId(pocketNodes[1].GetBus().GetConsensusModule().GetLeaderForView(height, uint64(round), step))
+	newRoundMessages := waitForNewRound(t, clck, eventsChannel, pocketNodes, height, step, round, noOfExpectedMsgs, maxWaitTime, failOnExtraMessages)
+	prepareProposal := waitForPrepareProposal(t, clck, eventsChannel, pocketNodes, newRoundMessages, height, step+1, round, leaderId, noOfExpectedMsgs, maxWaitTime, failOnExtraMessages)
+	prepareVote := waitForPrepareVotes(t, clck, eventsChannel, pocketNodes, prepareProposal, noOfExpectedMsgs, maxWaitTime, failOnExtraMessages)
+	preCommitProposal := waitForPreCommit(t, clck, eventsChannel, pocketNodes, prepareVote, height, step+2, round, leaderId, noOfExpectedMsgs, maxWaitTime, failOnExtraMessages)
+	commitProposal := waitForCommit(t, clck, eventsChannel, pocketNodes, preCommitProposal, height, step+3, round, leaderId, noOfExpectedMsgs, maxWaitTime, failOnExtraMessages)
+	return waitForDecide(t, clck, eventsChannel, pocketNodes, commitProposal, height, step+4, round, leaderId, noOfExpectedMsgs, maxWaitTime, failOnExtraMessages)",consensus/e2e_tests/utils_test.go,2023-04-10 22:39:49+00:00,2023-04-10T22:41:22Z,"Return the bloc, not a proposal. The function is called `waitForBlock`",,,,,556,RIGHT,128,,line,https://api.github.com/repos/pokt-network/pocket/pulls/659,pokt-network/pocket,82d931822979d5286c0cd811cf3f7f31ebb5897b
https://api.github.com/repos/pokt-network/pocket/pulls/659,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1163396454,Olshansk,91eedf9ad273055d2dc9855a27dd087edfa90d32,a8e78c8e7a4c1dbf419216c2c2a269ee18081702,"@@ -26,183 +25,27 @@ func TestHotstuff4Nodes1BlockHappyPath(t *testing.T) {
 	// Create & start test pocket nodes
 	eventsChannel := make(modules.EventsChannel, 100)
 	pocketNodes := CreateTestConsensusPocketNodes(t, buses, eventsChannel)
-	StartAllTestPocketNodes(t, pocketNodes)
+	err := StartAllTestPocketNodes(t, pocketNodes)
+	require.NoError(t, err)
 
 	// Debug message to start consensus by triggering first view change
 	for _, pocketNode := range pocketNodes {
 		TriggerNextView(t, pocketNode)
 	}
 	advanceTime(t, clockMock, 10*time.Millisecond)
 
-	// Set starting height, round and step of the test.
-	startingHeight := uint64(1)
-	startingRound := uint64(0)
-	startingStep := uint8(consensus.NewRound)
-
-	// Get leaderId for the given height, round and step, by using the Consensus Modules' GetLeaderForView() function.
-	// Any node in pocketNodes mapping can be used to gather leader election result via GetLeaderForView() function.
-	leaderId := typesCons.NodeId(pocketNodes[1].GetBus().GetConsensusModule().GetLeaderForView(startingHeight, startingRound, startingStep))
-	leader := pocketNodes[leaderId]
-
-	// 1. NewRound
-	newRoundMessages, err := WaitForNetworkConsensusEvents(t, clockMock, eventsChannel, consensus.NewRound, consensus.Propose, numValidators*numValidators, 500, true)
-	require.NoError(t, err)
-	for nodeId, pocketNode := range pocketNodes {
-		nodeState := GetConsensusNodeState(pocketNode)
-		assertNodeConsensusView(t, nodeId,
-			typesCons.ConsensusNodeState{
-				Height: startingHeight,
-				Step:   startingStep,
-				Round:  uint8(startingRound),
-			},
-			nodeState)
-		require.Equal(t, false, nodeState.IsLeader)
-		require.Equal(t, typesCons.NodeId(0), nodeState.LeaderId)
-	}
-
-	for _, message := range newRoundMessages {
-		P2PBroadcast(t, pocketNodes, message)
-	}
-	advanceTime(t, clockMock, 10*time.Millisecond)
-
-	// 2. Prepare
-	prepareProposal, err := WaitForNetworkConsensusEvents(t, clockMock, eventsChannel, consensus.Prepare, consensus.Propose, numValidators, 500, true)
-	require.NoError(t, err)
-	for nodeId, pocketNode := range pocketNodes {
-		nodeState := GetConsensusNodeState(pocketNode)
-		assertNodeConsensusView(t, nodeId,
-			typesCons.ConsensusNodeState{
-				Height: startingHeight,
-				Step:   startingStep + 1,
-				Round:  uint8(startingRound),
-			},
-			nodeState)
-		require.Equal(t, leaderId, nodeState.LeaderId, fmt.Sprintf(""%d should be the current leader"", leaderId))
-	}
-
-	for _, message := range prepareProposal {
-		P2PBroadcast(t, pocketNodes, message)
-	}
-	advanceTime(t, clockMock, 10*time.Millisecond)
-
-	// 3. PreCommit
-	prepareVotes, err := WaitForNetworkConsensusEvents(t, clockMock, eventsChannel, consensus.Prepare, consensus.Vote, numValidators, 500, true)
-	require.NoError(t, err)
-
-	for _, vote := range prepareVotes {
-		P2PSend(t, leader, vote)
-	}
-	advanceTime(t, clockMock, 10*time.Millisecond)
-
-	preCommitProposal, err := WaitForNetworkConsensusEvents(t, clockMock, eventsChannel, consensus.PreCommit, consensus.Propose, numValidators, 500, true)
-	require.NoError(t, err)
-	for nodeId, pocketNode := range pocketNodes {
-		nodeState := GetConsensusNodeState(pocketNode)
-		assertNodeConsensusView(t, nodeId,
-			typesCons.ConsensusNodeState{
-				Height: startingHeight,
-				Step:   startingStep + 2,
-				Round:  uint8(startingRound),
-			},
-			nodeState)
-		require.Equal(t, leaderId, nodeState.LeaderId, fmt.Sprintf(""%d should be the current leader"", leaderId))
-	}
-
-	for _, message := range preCommitProposal {
-		P2PBroadcast(t, pocketNodes, message)
-	}
-	advanceTime(t, clockMock, 10*time.Millisecond)
+	block := waitForNextBlock(t, clockMock, eventsChannel, pocketNodes, 1, 0, 500, true)
+	require.Equal(t, uint64(1), block.BlockHeader.Height)
 
-	// 4. Commit
-	preCommitVotes, err := WaitForNetworkConsensusEvents(t, clockMock, eventsChannel, consensus.PreCommit, consensus.Vote, numValidators, 500, true)
+	_, err = waitForProposalMsgs(t, clockMock, eventsChannel, pocketNodes, nil, 2, uint8(consensus.NewRound), 0, 0, numValidators*numValidators, 500, true)",consensus/e2e_tests/hotstuff_test.go,2023-04-11 22:35:45+00:00,2023-04-11T23:45:10Z,"```suggestion
       // Expecting NewRound messages for height=2 to be sent after a block is committed
	_, err = waitForProposalMsgs(t, clockMock, eventsChannel, pocketNodes, nil, 2, uint8(consensus.NewRound), 0, 0, numValidators*numValidators, 500, true)
```",,,,,40,RIGHT,105,,line,https://api.github.com/repos/pokt-network/pocket/pulls/659,pokt-network/pocket,82d931822979d5286c0cd811cf3f7f31ebb5897b
https://api.github.com/repos/pokt-network/pocket/pulls/659,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1163396677,Olshansk,91eedf9ad273055d2dc9855a27dd087edfa90d32,a8e78c8e7a4c1dbf419216c2c2a269ee18081702,"@@ -44,88 +44,30 @@ func TestPacemakerTimeoutIncreasesRound(t *testing.T) {
 	// Advance time by an amount shorter than the pacemaker timeout
 	advanceTime(t, clockMock, 10*time.Millisecond)
 
-	// Verify consensus started - NewRound messages have an N^2 complexity.
-	numExpectedMsgs := numValidators * numValidators
-	_, err := WaitForNetworkConsensusEvents(t, clockMock, eventsChannel, consensus.NewRound, consensus.Propose, numExpectedMsgs, consensusMessageTimeoutMsec, true)
+	//_ = waitForNewRound(t, clockMock, eventsChannel, pocketNodes, 1, uint8(consensus.NewRound), 0, numValidators, consensusMessageTimeout, true)",consensus/e2e_tests/pacemaker_test.go,2023-04-11 22:36:11+00:00,2023-04-11T23:45:10Z,Remove?,,,,,47,RIGHT,34,,line,https://api.github.com/repos/pokt-network/pocket/pulls/659,pokt-network/pocket,82d931822979d5286c0cd811cf3f7f31ebb5897b
https://api.github.com/repos/pokt-network/pocket/pulls/659,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1163396968,Olshansk,91eedf9ad273055d2dc9855a27dd087edfa90d32,a8e78c8e7a4c1dbf419216c2c2a269ee18081702,"@@ -199,19 +129,19 @@ func TestPacemakerCatchupSameStepDifferentRounds(t *testing.T) {
 	prepareProposal := &typesCons.HotstuffMessage{
 		Type:          consensus.Propose,
 		Height:        testHeight,
-		Step:          consensus.Prepare, // typesCons.HotstuffStep(testStep),
+		Step:          consensus.Prepare,
 		Round:         leaderRound,
 		Block:         block,
 		Justification: nil,
 	}
 	anyMsg, err := anypb.New(prepareProposal)
 	require.NoError(t, err)
 
-	P2PBroadcast(t, pocketNodes, anyMsg)
-
 	numExpectedMsgs := numValidators - 1   // -1 because one of the messages is a self proposal (leader to itself as a replica) that is not passed through the network
 	msgTimeout := paceMakerTimeoutMsec / 2 // /2 because we do not want the pacemaker to trigger a new timeout
-	_, err = WaitForNetworkConsensusEvents(t, clockMock, eventsChannel, consensus.Prepare, consensus.Vote, numExpectedMsgs, time.Duration(msgTimeout), true)
+
+	//_ = waitForPrepareVotes(t, clockMock, eventsChannel, pocketNodes, []*anypb.Any{anyMsg}, numExpectedMsgs, time.Duration(msgTimeout), true)",consensus/e2e_tests/pacemaker_test.go,2023-04-11 22:36:46+00:00,2023-04-11T23:45:10Z,Remove?,,,,,143,RIGHT,188,,line,https://api.github.com/repos/pokt-network/pocket/pulls/659,pokt-network/pocket,82d931822979d5286c0cd811cf3f7f31ebb5897b
https://api.github.com/repos/pokt-network/pocket/pulls/659,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1163397112,Olshansk,91eedf9ad273055d2dc9855a27dd087edfa90d32,a8e78c8e7a4c1dbf419216c2c2a269ee18081702,"@@ -274,34 +262,33 @@ func TestStateSync_UnsyncedPeerSyncs_Success(t *testing.T) {
 		require.Equal(t, typesCons.NodeId(0), nodeState.LeaderId)
 	}
 
-	unsyncedNode.GetBus().GetConsensusModule().SetAggregatedStateSyncMetadata(uint64(1), testHeight, string(leaderPK.Address()))
+	//unsyncedNode.GetBus().GetConsensusModule().PushStateSyncMetadataResponse(uint64(1), testHeight)",consensus/e2e_tests/state_sync_test.go,2023-04-11 22:37:04+00:00,2023-04-11T23:45:10Z,Remove?,,,,,265,RIGHT,120,,line,https://api.github.com/repos/pokt-network/pocket/pulls/659,pokt-network/pocket,82d931822979d5286c0cd811cf3f7f31ebb5897b
https://api.github.com/repos/pokt-network/pocket/pulls/659,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1163413363,Olshansk,91eedf9ad273055d2dc9855a27dd087edfa90d32,a8e78c8e7a4c1dbf419216c2c2a269ee18081702,"@@ -64,12 +70,19 @@ type consensusModule struct {
 	paceMaker         pacemaker.Pacemaker
 	leaderElectionMod leader_election.LeaderElectionModule
 
-	logger    *modules.Logger
-	logPrefix string
+	logger *modules.Logger",consensus/module.go,2023-04-11 23:10:18+00:00,2023-04-11T23:45:11Z,"NIT: THis shold be above ""business logic"" variables",,,,,73,RIGHT,19,,line,https://api.github.com/repos/pokt-network/pocket/pulls/659,pokt-network/pocket,82d931822979d5286c0cd811cf3f7f31ebb5897b
https://api.github.com/repos/pokt-network/pocket/pulls/659,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1163414048,Olshansk,91eedf9ad273055d2dc9855a27dd087edfa90d32,a8e78c8e7a4c1dbf419216c2c2a269ee18081702,"@@ -91,9 +88,9 @@ type ConsensusDebugModule interface {
 
 	SetUtilityUnitOfWork(UtilityUnitOfWork)
 
-	// SetAggregatedStateSyncMetadata is used to set peer's aggregated metadata in testing scenarios to simulate periodic metadata synchronization. It is not intended to be used outside of testing.
-	SetAggregatedStateSyncMetadata(minHeight, maxHeight uint64, peerAddress string)
-	GetAggregatedStateSyncMetadataMaxHeight() (minHeight uint64)
+	// PushStateSyncMetadataResponse is used to simulate metadata received metadata in testing scenarios. It is not intended to be used outside of testing.",shared/modules/consensus_module.go,2023-04-11 23:11:55+00:00,2023-04-11T23:45:11Z,Remove all the commented out code,,,,,91,RIGHT,17,,line,https://api.github.com/repos/pokt-network/pocket/pulls/659,pokt-network/pocket,82d931822979d5286c0cd811cf3f7f31ebb5897b
https://api.github.com/repos/pokt-network/pocket/pulls/659,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1163414731,Olshansk,91eedf9ad273055d2dc9855a27dd087edfa90d32,a8e78c8e7a4c1dbf419216c2c2a269ee18081702,"@@ -37,20 +37,24 @@ func (m *consensusModule) handleStateSyncMessage(stateSyncMessage *typesCons.Sta
 	switch stateSyncMessage.Message.(type) {
 	case *typesCons.StateSyncMessage_MetadataReq:
 		m.logger.Info().Str(""proto_type"", ""MetadataRequest"").Msg(""Handling StateSyncMessage MetadataReq"")
-		if !m.stateSync.IsServerModEnabled() {
+		if !m.serverModeEnabled {",consensus/state_sync_handler.go,2023-04-11 23:13:33+00:00,2023-04-11T23:45:11Z,"Make sure to handle merge conflicts correctly after merging this with main.
",,,,40.0,40,RIGHT,5,7.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/659,pokt-network/pocket,82d931822979d5286c0cd811cf3f7f31ebb5897b
https://api.github.com/repos/pokt-network/pocket/pulls/659,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1163424475,Olshansk,91eedf9ad273055d2dc9855a27dd087edfa90d32,a8e78c8e7a4c1dbf419216c2c2a269ee18081702,"@@ -274,34 +262,33 @@ func TestStateSync_UnsyncedPeerSyncs_Success(t *testing.T) {
 		require.Equal(t, typesCons.NodeId(0), nodeState.LeaderId)
 	}
 
-	unsyncedNode.GetBus().GetConsensusModule().SetAggregatedStateSyncMetadata(uint64(1), testHeight, string(leaderPK.Address()))
+	//unsyncedNode.GetBus().GetConsensusModule().PushStateSyncMetadataResponse(uint64(1), testHeight)
+	metadataReceived := &typesCons.StateSyncMetadataResponse{
+		PeerAddress: """",",consensus/e2e_tests/state_sync_test.go,2023-04-11 23:33:48+00:00,2023-04-11T23:45:11Z,"This will make it easier to find if we ever run into an issue.

```suggestion
		PeerAddress: ""unused_peer_addr_in_tests"",
```",,,,,267,RIGHT,122,,line,https://api.github.com/repos/pokt-network/pocket/pulls/659,pokt-network/pocket,82d931822979d5286c0cd811cf3f7f31ebb5897b
https://api.github.com/repos/pokt-network/pocket/pulls/659,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1163425132,Olshansk,91eedf9ad273055d2dc9855a27dd087edfa90d32,a8e78c8e7a4c1dbf419216c2c2a269ee18081702,"@@ -526,40 +537,221 @@ func baseRpcMock(t *testing.T, _ modules.EventsChannel) *mockModules.MockRPCModu
 	return rpcMock
 }
 
-func baseStateMachineMock(t *testing.T, _ modules.EventsChannel, bus modules.Bus) *mockModules.MockStateMachineModule {
-	ctrl := gomock.NewController(t)
-	stateMachineMock := mockModules.NewMockStateMachineModule(ctrl)
-	stateMachineMock.EXPECT().Start().Return(nil).AnyTimes()
-	stateMachineMock.EXPECT().SetBus(gomock.Any()).Return().AnyTimes()
-	stateMachineMock.EXPECT().GetModuleName().Return(modules.StateMachineModuleName).AnyTimes()
-
-	consensusMod := bus.GetConsensusModule()
-
-	stateMachineMock.EXPECT().SendEvent(gomock.Any()).DoAndReturn(func(event coreTypes.StateMachineEvent, args ...any) error {
-		switch coreTypes.StateMachineEvent(event) {
-		case coreTypes.StateMachineEvent_Consensus_IsUnsynced:
-			t.Logf(""Mocked node is unsynced"")
-			return bus.GetStateMachineModule().SendEvent(coreTypes.StateMachineEvent_Consensus_IsSyncing)
-		case coreTypes.StateMachineEvent_Consensus_IsSyncing:
-			t.Logf(""Mocked node is syncing"")
-			maxHeight := consensusMod.GetAggregatedStateSyncMetadataMaxHeight()
-			// TECHDEBT(#352): The asynchronicity of this leads to a non-deterministic failing test.
-			// See this discussion for details: https://github.com/pokt-network/pocket/pull/528/files#r1150711575
-			consensusMod.SetHeight(maxHeight)
-			return nil
-		case coreTypes.StateMachineEvent_Consensus_IsSyncedValidator:
-			t.Logf(""Mocked validator node is synced"")
-			return nil
-		case coreTypes.StateMachineEvent_Consensus_IsSyncedNonValidator:
-			t.Logf(""Mocked non-validator node is synced"")
-			return nil
-		default:
-			log.Printf(""Mocked node is not handling this event: %s"", event)
-			return nil
+func waitForNextBlock(t *testing.T,
+	clck *clock.Mock,
+	eventsChannel modules.EventsChannel,
+	pocketNodes IdToNodeMapping,
+	height uint64,
+	round uint8,
+	maxWaitTime time.Duration,
+	failOnExtraMessages bool,
+) *coreTypes.Block {
+	leaderId := typesCons.NodeId(pocketNodes[1].GetBus().GetConsensusModule().GetLeaderForView(height, uint64(round), uint8(consensus.NewRound)))
+
+	newRoundMessages, err := waitForProposalMsgs(t, clck, eventsChannel, pocketNodes, nil, height, uint8(consensus.NewRound), round, 0, numValidators*numValidators, maxWaitTime, failOnExtraMessages)",consensus/e2e_tests/utils_test.go,2023-04-11 23:35:22+00:00,2023-04-11T23:45:11Z,The only thing I find a bit confusing is how this works if we don't broadcast the messages we're aggregating?,,,,,551,RIGHT,123,,line,https://api.github.com/repos/pokt-network/pocket/pulls/659,pokt-network/pocket,82d931822979d5286c0cd811cf3f7f31ebb5897b
https://api.github.com/repos/pokt-network/pocket/pulls/659,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1163425846,Olshansk,91eedf9ad273055d2dc9855a27dd087edfa90d32,a8e78c8e7a4c1dbf419216c2c2a269ee18081702,"@@ -526,40 +537,221 @@ func baseRpcMock(t *testing.T, _ modules.EventsChannel) *mockModules.MockRPCModu
 	return rpcMock
 }
 
-func baseStateMachineMock(t *testing.T, _ modules.EventsChannel, bus modules.Bus) *mockModules.MockStateMachineModule {
-	ctrl := gomock.NewController(t)
-	stateMachineMock := mockModules.NewMockStateMachineModule(ctrl)
-	stateMachineMock.EXPECT().Start().Return(nil).AnyTimes()
-	stateMachineMock.EXPECT().SetBus(gomock.Any()).Return().AnyTimes()
-	stateMachineMock.EXPECT().GetModuleName().Return(modules.StateMachineModuleName).AnyTimes()
-
-	consensusMod := bus.GetConsensusModule()
-
-	stateMachineMock.EXPECT().SendEvent(gomock.Any()).DoAndReturn(func(event coreTypes.StateMachineEvent, args ...any) error {
-		switch coreTypes.StateMachineEvent(event) {
-		case coreTypes.StateMachineEvent_Consensus_IsUnsynced:
-			t.Logf(""Mocked node is unsynced"")
-			return bus.GetStateMachineModule().SendEvent(coreTypes.StateMachineEvent_Consensus_IsSyncing)
-		case coreTypes.StateMachineEvent_Consensus_IsSyncing:
-			t.Logf(""Mocked node is syncing"")
-			maxHeight := consensusMod.GetAggregatedStateSyncMetadataMaxHeight()
-			// TECHDEBT(#352): The asynchronicity of this leads to a non-deterministic failing test.
-			// See this discussion for details: https://github.com/pokt-network/pocket/pull/528/files#r1150711575
-			consensusMod.SetHeight(maxHeight)
-			return nil
-		case coreTypes.StateMachineEvent_Consensus_IsSyncedValidator:
-			t.Logf(""Mocked validator node is synced"")
-			return nil
-		case coreTypes.StateMachineEvent_Consensus_IsSyncedNonValidator:
-			t.Logf(""Mocked non-validator node is synced"")
-			return nil
-		default:
-			log.Printf(""Mocked node is not handling this event: %s"", event)
-			return nil
+func waitForNextBlock(t *testing.T,
+	clck *clock.Mock,
+	eventsChannel modules.EventsChannel,
+	pocketNodes IdToNodeMapping,
+	height uint64,
+	round uint8,
+	maxWaitTime time.Duration,
+	failOnExtraMessages bool,
+) *coreTypes.Block {
+	leaderId := typesCons.NodeId(pocketNodes[1].GetBus().GetConsensusModule().GetLeaderForView(height, uint64(round), uint8(consensus.NewRound)))
+
+	newRoundMessages, err := waitForProposalMsgs(t, clck, eventsChannel, pocketNodes, nil, height, uint8(consensus.NewRound), round, 0, numValidators*numValidators, maxWaitTime, failOnExtraMessages)
+	require.NoError(t, err)
+
+	prepareProposals, err := waitForProposalMsgs(t, clck, eventsChannel, pocketNodes, newRoundMessages, height, uint8(consensus.Prepare), round, leaderId, numValidators, maxWaitTime, failOnExtraMessages)
+	require.NoError(t, err)
+
+	prepareVotes, err := waitForVotes(t, clck, eventsChannel, pocketNodes, prepareProposals, numValidators, 2, maxWaitTime, failOnExtraMessages)
+	require.NoError(t, err)
+
+	preCommitProposals, err := waitForProposalMsgs(t, clck, eventsChannel, pocketNodes, prepareVotes, height, uint8(consensus.PreCommit), round, leaderId, numValidators, maxWaitTime, failOnExtraMessages)
+	require.NoError(t, err)
+
+	preCommitVotes, err := waitForVotes(t, clck, eventsChannel, pocketNodes, preCommitProposals, numValidators, 3, maxWaitTime, failOnExtraMessages)
+	require.NoError(t, err)
+
+	commitProposal, err := waitForProposalMsgs(t, clck, eventsChannel, pocketNodes, preCommitVotes, height, uint8(consensus.Commit), round, leaderId, numValidators, maxWaitTime, failOnExtraMessages)
+	require.NoError(t, err)
+
+	commitVotes, err := waitForVotes(t, clck, eventsChannel, pocketNodes, commitProposal, numValidators, 4, maxWaitTime, failOnExtraMessages)
+	require.NoError(t, err)
+
+	decideProposal, err := waitForProposalMsgs(t, clck, eventsChannel, pocketNodes, commitVotes, height, uint8(consensus.Decide), round, leaderId, numValidators, maxWaitTime, failOnExtraMessages)
+	require.NoError(t, err)
+
+	for _, message := range decideProposal {
+		P2PBroadcast(t, pocketNodes, message)
+	}
+	advanceTime(t, clck, 10*time.Millisecond)
+
+	blockStore := pocketNodes[1].GetBus().GetPersistenceModule().GetBlockStore()
+	heightBytes := utils.HeightToBytes(height)
+
+	blockBytes, err := blockStore.Get(heightBytes)
+	require.NoError(t, err)
+
+	var block coreTypes.Block
+	err = codec.GetCodec().Unmarshal(blockBytes, &block)
+	require.NoError(t, err)
+
+	return &block
+}
+
+func waitForProposalMsgs(t *testing.T,
+	clck *clock.Mock,
+	eventsChannel modules.EventsChannel,
+	pocketNodes IdToNodeMapping,
+	proposalsToSend []*anypb.Any,
+	height uint64,
+	step uint8,
+	round uint8,
+	leaderId typesCons.NodeId,
+	noOfExpectedMsgs int,
+	maxWaitTime time.Duration,
+	failOnExtraMessages bool,
+) ([]*anypb.Any, error) {
+
+	for _, message := range proposalsToSend {",consensus/e2e_tests/utils_test.go,2023-04-11 23:36:58+00:00,2023-04-11T23:45:11Z,"This is more of a design / discussion point and I'm open to being wrong.

This function is called `waitForProposalMsgs`, but it's actually do ""Broadcast current proposal and wait for new proposal"". 

Personally, even though it's extra code, I don't think this forloop should be inside of this function and be explicit in `waitForBlock`.

Wdyt?",,,,,607,RIGHT,179,,line,https://api.github.com/repos/pokt-network/pocket/pulls/659,pokt-network/pocket,82d931822979d5286c0cd811cf3f7f31ebb5897b
https://api.github.com/repos/pokt-network/pocket/pulls/659,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1163426111,Olshansk,91eedf9ad273055d2dc9855a27dd087edfa90d32,a8e78c8e7a4c1dbf419216c2c2a269ee18081702,"@@ -526,40 +537,221 @@ func baseRpcMock(t *testing.T, _ modules.EventsChannel) *mockModules.MockRPCModu
 	return rpcMock
 }
 
-func baseStateMachineMock(t *testing.T, _ modules.EventsChannel, bus modules.Bus) *mockModules.MockStateMachineModule {
-	ctrl := gomock.NewController(t)
-	stateMachineMock := mockModules.NewMockStateMachineModule(ctrl)
-	stateMachineMock.EXPECT().Start().Return(nil).AnyTimes()
-	stateMachineMock.EXPECT().SetBus(gomock.Any()).Return().AnyTimes()
-	stateMachineMock.EXPECT().GetModuleName().Return(modules.StateMachineModuleName).AnyTimes()
-
-	consensusMod := bus.GetConsensusModule()
-
-	stateMachineMock.EXPECT().SendEvent(gomock.Any()).DoAndReturn(func(event coreTypes.StateMachineEvent, args ...any) error {
-		switch coreTypes.StateMachineEvent(event) {
-		case coreTypes.StateMachineEvent_Consensus_IsUnsynced:
-			t.Logf(""Mocked node is unsynced"")
-			return bus.GetStateMachineModule().SendEvent(coreTypes.StateMachineEvent_Consensus_IsSyncing)
-		case coreTypes.StateMachineEvent_Consensus_IsSyncing:
-			t.Logf(""Mocked node is syncing"")
-			maxHeight := consensusMod.GetAggregatedStateSyncMetadataMaxHeight()
-			// TECHDEBT(#352): The asynchronicity of this leads to a non-deterministic failing test.
-			// See this discussion for details: https://github.com/pokt-network/pocket/pull/528/files#r1150711575
-			consensusMod.SetHeight(maxHeight)
-			return nil
-		case coreTypes.StateMachineEvent_Consensus_IsSyncedValidator:
-			t.Logf(""Mocked validator node is synced"")
-			return nil
-		case coreTypes.StateMachineEvent_Consensus_IsSyncedNonValidator:
-			t.Logf(""Mocked non-validator node is synced"")
-			return nil
-		default:
-			log.Printf(""Mocked node is not handling this event: %s"", event)
-			return nil
+func waitForNextBlock(t *testing.T,
+	clck *clock.Mock,
+	eventsChannel modules.EventsChannel,
+	pocketNodes IdToNodeMapping,
+	height uint64,
+	round uint8,
+	maxWaitTime time.Duration,
+	failOnExtraMessages bool,
+) *coreTypes.Block {
+	leaderId := typesCons.NodeId(pocketNodes[1].GetBus().GetConsensusModule().GetLeaderForView(height, uint64(round), uint8(consensus.NewRound)))
+
+	newRoundMessages, err := waitForProposalMsgs(t, clck, eventsChannel, pocketNodes, nil, height, uint8(consensus.NewRound), round, 0, numValidators*numValidators, maxWaitTime, failOnExtraMessages)
+	require.NoError(t, err)
+
+	prepareProposals, err := waitForProposalMsgs(t, clck, eventsChannel, pocketNodes, newRoundMessages, height, uint8(consensus.Prepare), round, leaderId, numValidators, maxWaitTime, failOnExtraMessages)
+	require.NoError(t, err)
+
+	prepareVotes, err := waitForVotes(t, clck, eventsChannel, pocketNodes, prepareProposals, numValidators, 2, maxWaitTime, failOnExtraMessages)
+	require.NoError(t, err)
+
+	preCommitProposals, err := waitForProposalMsgs(t, clck, eventsChannel, pocketNodes, prepareVotes, height, uint8(consensus.PreCommit), round, leaderId, numValidators, maxWaitTime, failOnExtraMessages)
+	require.NoError(t, err)
+
+	preCommitVotes, err := waitForVotes(t, clck, eventsChannel, pocketNodes, preCommitProposals, numValidators, 3, maxWaitTime, failOnExtraMessages)
+	require.NoError(t, err)
+
+	commitProposal, err := waitForProposalMsgs(t, clck, eventsChannel, pocketNodes, preCommitVotes, height, uint8(consensus.Commit), round, leaderId, numValidators, maxWaitTime, failOnExtraMessages)
+	require.NoError(t, err)
+
+	commitVotes, err := waitForVotes(t, clck, eventsChannel, pocketNodes, commitProposal, numValidators, 4, maxWaitTime, failOnExtraMessages)
+	require.NoError(t, err)
+
+	decideProposal, err := waitForProposalMsgs(t, clck, eventsChannel, pocketNodes, commitVotes, height, uint8(consensus.Decide), round, leaderId, numValidators, maxWaitTime, failOnExtraMessages)
+	require.NoError(t, err)
+
+	for _, message := range decideProposal {
+		P2PBroadcast(t, pocketNodes, message)
+	}
+	advanceTime(t, clck, 10*time.Millisecond)
+
+	blockStore := pocketNodes[1].GetBus().GetPersistenceModule().GetBlockStore()
+	heightBytes := utils.HeightToBytes(height)
+
+	blockBytes, err := blockStore.Get(heightBytes)
+	require.NoError(t, err)
+
+	var block coreTypes.Block
+	err = codec.GetCodec().Unmarshal(blockBytes, &block)
+	require.NoError(t, err)
+
+	return &block
+}
+
+func waitForProposalMsgs(t *testing.T,
+	clck *clock.Mock,
+	eventsChannel modules.EventsChannel,
+	pocketNodes IdToNodeMapping,
+	proposalsToSend []*anypb.Any,
+	height uint64,
+	step uint8,
+	round uint8,
+	leaderId typesCons.NodeId,
+	noOfExpectedMsgs int,
+	maxWaitTime time.Duration,
+	failOnExtraMessages bool,
+) ([]*anypb.Any, error) {
+
+	for _, message := range proposalsToSend {
+		P2PBroadcast(t, pocketNodes, message)
+	}
+	advanceTime(t, clck, 10*time.Millisecond)
+
+	proposalMsgs, err := WaitForNetworkConsensusEvents(t, clck, eventsChannel, typesCons.HotstuffStep(step), consensus.Propose, noOfExpectedMsgs, maxWaitTime, failOnExtraMessages)
+	if err != nil {
+		return nil, err
+	}
+
+	for nodeId, pocketNode := range pocketNodes {
+		nodeState := GetConsensusNodeState(pocketNode)
+		if (typesCons.HotstuffStep(step) == consensus.Decide) && (nodeId == leaderId) {
+			assertNodeConsensusView(t, nodeId,
+				typesCons.ConsensusNodeState{
+					Height: height + 1,
+					Step:   1,
+					Round:  round,
+				},
+				nodeState)
+			require.Equal(t, typesCons.NodeId(0), nodeState.LeaderId, ""Leader should be empty"")
+			continue",consensus/e2e_tests/utils_test.go,2023-04-11 23:37:35+00:00,2023-04-11T23:45:11Z,"Since you're doing a `continue`, we can avoid the `else` inside of the forloop.",,,,643.0,628,RIGHT,200,215.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/659,pokt-network/pocket,82d931822979d5286c0cd811cf3f7f31ebb5897b
https://api.github.com/repos/pokt-network/pocket/pulls/659,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1163428201,Olshansk,91eedf9ad273055d2dc9855a27dd087edfa90d32,a8e78c8e7a4c1dbf419216c2c2a269ee18081702,"@@ -526,40 +537,221 @@ func baseRpcMock(t *testing.T, _ modules.EventsChannel) *mockModules.MockRPCModu
 	return rpcMock
 }
 
-func baseStateMachineMock(t *testing.T, _ modules.EventsChannel, bus modules.Bus) *mockModules.MockStateMachineModule {
-	ctrl := gomock.NewController(t)
-	stateMachineMock := mockModules.NewMockStateMachineModule(ctrl)
-	stateMachineMock.EXPECT().Start().Return(nil).AnyTimes()
-	stateMachineMock.EXPECT().SetBus(gomock.Any()).Return().AnyTimes()
-	stateMachineMock.EXPECT().GetModuleName().Return(modules.StateMachineModuleName).AnyTimes()
-
-	consensusMod := bus.GetConsensusModule()
-
-	stateMachineMock.EXPECT().SendEvent(gomock.Any()).DoAndReturn(func(event coreTypes.StateMachineEvent, args ...any) error {
-		switch coreTypes.StateMachineEvent(event) {
-		case coreTypes.StateMachineEvent_Consensus_IsUnsynced:
-			t.Logf(""Mocked node is unsynced"")
-			return bus.GetStateMachineModule().SendEvent(coreTypes.StateMachineEvent_Consensus_IsSyncing)
-		case coreTypes.StateMachineEvent_Consensus_IsSyncing:
-			t.Logf(""Mocked node is syncing"")
-			maxHeight := consensusMod.GetAggregatedStateSyncMetadataMaxHeight()
-			// TECHDEBT(#352): The asynchronicity of this leads to a non-deterministic failing test.
-			// See this discussion for details: https://github.com/pokt-network/pocket/pull/528/files#r1150711575
-			consensusMod.SetHeight(maxHeight)
-			return nil
-		case coreTypes.StateMachineEvent_Consensus_IsSyncedValidator:
-			t.Logf(""Mocked validator node is synced"")
-			return nil
-		case coreTypes.StateMachineEvent_Consensus_IsSyncedNonValidator:
-			t.Logf(""Mocked non-validator node is synced"")
-			return nil
-		default:
-			log.Printf(""Mocked node is not handling this event: %s"", event)
-			return nil
+func waitForNextBlock(t *testing.T,
+	clck *clock.Mock,
+	eventsChannel modules.EventsChannel,
+	pocketNodes IdToNodeMapping,
+	height uint64,
+	round uint8,
+	maxWaitTime time.Duration,
+	failOnExtraMessages bool,
+) *coreTypes.Block {
+	leaderId := typesCons.NodeId(pocketNodes[1].GetBus().GetConsensusModule().GetLeaderForView(height, uint64(round), uint8(consensus.NewRound)))
+
+	newRoundMessages, err := waitForProposalMsgs(t, clck, eventsChannel, pocketNodes, nil, height, uint8(consensus.NewRound), round, 0, numValidators*numValidators, maxWaitTime, failOnExtraMessages)
+	require.NoError(t, err)
+
+	prepareProposals, err := waitForProposalMsgs(t, clck, eventsChannel, pocketNodes, newRoundMessages, height, uint8(consensus.Prepare), round, leaderId, numValidators, maxWaitTime, failOnExtraMessages)
+	require.NoError(t, err)
+
+	prepareVotes, err := waitForVotes(t, clck, eventsChannel, pocketNodes, prepareProposals, numValidators, 2, maxWaitTime, failOnExtraMessages)
+	require.NoError(t, err)
+
+	preCommitProposals, err := waitForProposalMsgs(t, clck, eventsChannel, pocketNodes, prepareVotes, height, uint8(consensus.PreCommit), round, leaderId, numValidators, maxWaitTime, failOnExtraMessages)
+	require.NoError(t, err)
+
+	preCommitVotes, err := waitForVotes(t, clck, eventsChannel, pocketNodes, preCommitProposals, numValidators, 3, maxWaitTime, failOnExtraMessages)
+	require.NoError(t, err)
+
+	commitProposal, err := waitForProposalMsgs(t, clck, eventsChannel, pocketNodes, preCommitVotes, height, uint8(consensus.Commit), round, leaderId, numValidators, maxWaitTime, failOnExtraMessages)
+	require.NoError(t, err)
+
+	commitVotes, err := waitForVotes(t, clck, eventsChannel, pocketNodes, commitProposal, numValidators, 4, maxWaitTime, failOnExtraMessages)
+	require.NoError(t, err)
+
+	decideProposal, err := waitForProposalMsgs(t, clck, eventsChannel, pocketNodes, commitVotes, height, uint8(consensus.Decide), round, leaderId, numValidators, maxWaitTime, failOnExtraMessages)
+	require.NoError(t, err)
+
+	for _, message := range decideProposal {
+		P2PBroadcast(t, pocketNodes, message)
+	}
+	advanceTime(t, clck, 10*time.Millisecond)
+
+	blockStore := pocketNodes[1].GetBus().GetPersistenceModule().GetBlockStore()
+	heightBytes := utils.HeightToBytes(height)
+
+	blockBytes, err := blockStore.Get(heightBytes)
+	require.NoError(t, err)
+
+	var block coreTypes.Block
+	err = codec.GetCodec().Unmarshal(blockBytes, &block)
+	require.NoError(t, err)
+
+	return &block
+}
+
+func waitForProposalMsgs(t *testing.T,
+	clck *clock.Mock,
+	eventsChannel modules.EventsChannel,
+	pocketNodes IdToNodeMapping,
+	proposalsToSend []*anypb.Any,
+	height uint64,
+	step uint8,
+	round uint8,
+	leaderId typesCons.NodeId,
+	noOfExpectedMsgs int,
+	maxWaitTime time.Duration,
+	failOnExtraMessages bool,
+) ([]*anypb.Any, error) {
+
+	for _, message := range proposalsToSend {
+		P2PBroadcast(t, pocketNodes, message)
+	}
+	advanceTime(t, clck, 10*time.Millisecond)
+
+	proposalMsgs, err := WaitForNetworkConsensusEvents(t, clck, eventsChannel, typesCons.HotstuffStep(step), consensus.Propose, noOfExpectedMsgs, maxWaitTime, failOnExtraMessages)
+	if err != nil {
+		return nil, err
+	}
+
+	for nodeId, pocketNode := range pocketNodes {
+		nodeState := GetConsensusNodeState(pocketNode)
+		if (typesCons.HotstuffStep(step) == consensus.Decide) && (nodeId == leaderId) {
+			assertNodeConsensusView(t, nodeId,
+				typesCons.ConsensusNodeState{
+					Height: height + 1,
+					Step:   1,
+					Round:  round,
+				},
+				nodeState)
+			require.Equal(t, typesCons.NodeId(0), nodeState.LeaderId, ""Leader should be empty"")
+			continue
+		} else {
+			assertNodeConsensusView(t, nodeId,
+				typesCons.ConsensusNodeState{
+					Height: height,
+					Step:   step,
+					Round:  round,
+				},
+				nodeState)
+			require.Equal(t, leaderId, nodeState.LeaderId, fmt.Sprintf(""%d should be the current leader"", leaderId))
 		}
-	}).AnyTimes()
+	}
 
-	return stateMachineMock
+	return proposalMsgs, nil
+}
+
+func waitForVotes(t *testing.T,
+	clck *clock.Mock,
+	eventsChannel modules.EventsChannel,
+	pocketNodes IdToNodeMapping,
+	prepareProposal []*anypb.Any,",consensus/e2e_tests/utils_test.go,2023-04-11 23:42:01+00:00,2023-04-11T23:45:11Z,Ditto above. I don't think this should be part of the header or the logic,,,,,648,RIGHT,222,,line,https://api.github.com/repos/pokt-network/pocket/pulls/659,pokt-network/pocket,82d931822979d5286c0cd811cf3f7f31ebb5897b
https://api.github.com/repos/pokt-network/pocket/pulls/659,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1163428538,Olshansk,91eedf9ad273055d2dc9855a27dd087edfa90d32,a8e78c8e7a4c1dbf419216c2c2a269ee18081702,"@@ -526,40 +537,221 @@ func baseRpcMock(t *testing.T, _ modules.EventsChannel) *mockModules.MockRPCModu
 	return rpcMock
 }
 
-func baseStateMachineMock(t *testing.T, _ modules.EventsChannel, bus modules.Bus) *mockModules.MockStateMachineModule {
-	ctrl := gomock.NewController(t)
-	stateMachineMock := mockModules.NewMockStateMachineModule(ctrl)
-	stateMachineMock.EXPECT().Start().Return(nil).AnyTimes()
-	stateMachineMock.EXPECT().SetBus(gomock.Any()).Return().AnyTimes()
-	stateMachineMock.EXPECT().GetModuleName().Return(modules.StateMachineModuleName).AnyTimes()
-
-	consensusMod := bus.GetConsensusModule()
-
-	stateMachineMock.EXPECT().SendEvent(gomock.Any()).DoAndReturn(func(event coreTypes.StateMachineEvent, args ...any) error {
-		switch coreTypes.StateMachineEvent(event) {
-		case coreTypes.StateMachineEvent_Consensus_IsUnsynced:
-			t.Logf(""Mocked node is unsynced"")
-			return bus.GetStateMachineModule().SendEvent(coreTypes.StateMachineEvent_Consensus_IsSyncing)
-		case coreTypes.StateMachineEvent_Consensus_IsSyncing:
-			t.Logf(""Mocked node is syncing"")
-			maxHeight := consensusMod.GetAggregatedStateSyncMetadataMaxHeight()
-			// TECHDEBT(#352): The asynchronicity of this leads to a non-deterministic failing test.
-			// See this discussion for details: https://github.com/pokt-network/pocket/pull/528/files#r1150711575
-			consensusMod.SetHeight(maxHeight)
-			return nil
-		case coreTypes.StateMachineEvent_Consensus_IsSyncedValidator:
-			t.Logf(""Mocked validator node is synced"")
-			return nil
-		case coreTypes.StateMachineEvent_Consensus_IsSyncedNonValidator:
-			t.Logf(""Mocked non-validator node is synced"")
-			return nil
-		default:
-			log.Printf(""Mocked node is not handling this event: %s"", event)
-			return nil
+func waitForNextBlock(t *testing.T,
+	clck *clock.Mock,
+	eventsChannel modules.EventsChannel,
+	pocketNodes IdToNodeMapping,
+	height uint64,
+	round uint8,
+	maxWaitTime time.Duration,
+	failOnExtraMessages bool,
+) *coreTypes.Block {
+	leaderId := typesCons.NodeId(pocketNodes[1].GetBus().GetConsensusModule().GetLeaderForView(height, uint64(round), uint8(consensus.NewRound)))
+
+	newRoundMessages, err := waitForProposalMsgs(t, clck, eventsChannel, pocketNodes, nil, height, uint8(consensus.NewRound), round, 0, numValidators*numValidators, maxWaitTime, failOnExtraMessages)
+	require.NoError(t, err)
+
+	prepareProposals, err := waitForProposalMsgs(t, clck, eventsChannel, pocketNodes, newRoundMessages, height, uint8(consensus.Prepare), round, leaderId, numValidators, maxWaitTime, failOnExtraMessages)
+	require.NoError(t, err)
+
+	prepareVotes, err := waitForVotes(t, clck, eventsChannel, pocketNodes, prepareProposals, numValidators, 2, maxWaitTime, failOnExtraMessages)
+	require.NoError(t, err)
+
+	preCommitProposals, err := waitForProposalMsgs(t, clck, eventsChannel, pocketNodes, prepareVotes, height, uint8(consensus.PreCommit), round, leaderId, numValidators, maxWaitTime, failOnExtraMessages)
+	require.NoError(t, err)
+
+	preCommitVotes, err := waitForVotes(t, clck, eventsChannel, pocketNodes, preCommitProposals, numValidators, 3, maxWaitTime, failOnExtraMessages)
+	require.NoError(t, err)
+
+	commitProposal, err := waitForProposalMsgs(t, clck, eventsChannel, pocketNodes, preCommitVotes, height, uint8(consensus.Commit), round, leaderId, numValidators, maxWaitTime, failOnExtraMessages)
+	require.NoError(t, err)
+
+	commitVotes, err := waitForVotes(t, clck, eventsChannel, pocketNodes, commitProposal, numValidators, 4, maxWaitTime, failOnExtraMessages)
+	require.NoError(t, err)
+
+	decideProposal, err := waitForProposalMsgs(t, clck, eventsChannel, pocketNodes, commitVotes, height, uint8(consensus.Decide), round, leaderId, numValidators, maxWaitTime, failOnExtraMessages)
+	require.NoError(t, err)
+
+	for _, message := range decideProposal {
+		P2PBroadcast(t, pocketNodes, message)
+	}
+	advanceTime(t, clck, 10*time.Millisecond)
+
+	blockStore := pocketNodes[1].GetBus().GetPersistenceModule().GetBlockStore()
+	heightBytes := utils.HeightToBytes(height)
+
+	blockBytes, err := blockStore.Get(heightBytes)
+	require.NoError(t, err)
+
+	var block coreTypes.Block
+	err = codec.GetCodec().Unmarshal(blockBytes, &block)
+	require.NoError(t, err)
+
+	return &block
+}
+
+func waitForProposalMsgs(t *testing.T,
+	clck *clock.Mock,
+	eventsChannel modules.EventsChannel,
+	pocketNodes IdToNodeMapping,
+	proposalsToSend []*anypb.Any,
+	height uint64,
+	step uint8,
+	round uint8,
+	leaderId typesCons.NodeId,
+	noOfExpectedMsgs int,
+	maxWaitTime time.Duration,
+	failOnExtraMessages bool,
+) ([]*anypb.Any, error) {
+
+	for _, message := range proposalsToSend {
+		P2PBroadcast(t, pocketNodes, message)
+	}
+	advanceTime(t, clck, 10*time.Millisecond)
+
+	proposalMsgs, err := WaitForNetworkConsensusEvents(t, clck, eventsChannel, typesCons.HotstuffStep(step), consensus.Propose, noOfExpectedMsgs, maxWaitTime, failOnExtraMessages)
+	if err != nil {
+		return nil, err
+	}
+
+	for nodeId, pocketNode := range pocketNodes {
+		nodeState := GetConsensusNodeState(pocketNode)
+		if (typesCons.HotstuffStep(step) == consensus.Decide) && (nodeId == leaderId) {
+			assertNodeConsensusView(t, nodeId,
+				typesCons.ConsensusNodeState{
+					Height: height + 1,
+					Step:   1,
+					Round:  round,
+				},
+				nodeState)
+			require.Equal(t, typesCons.NodeId(0), nodeState.LeaderId, ""Leader should be empty"")
+			continue
+		} else {
+			assertNodeConsensusView(t, nodeId,
+				typesCons.ConsensusNodeState{
+					Height: height,
+					Step:   step,
+					Round:  round,
+				},
+				nodeState)
+			require.Equal(t, leaderId, nodeState.LeaderId, fmt.Sprintf(""%d should be the current leader"", leaderId))
 		}
-	}).AnyTimes()
+	}
 
-	return stateMachineMock
+	return proposalMsgs, nil
+}
+
+func waitForVotes(t *testing.T,
+	clck *clock.Mock,
+	eventsChannel modules.EventsChannel,
+	pocketNodes IdToNodeMapping,
+	prepareProposal []*anypb.Any,
+	noOfExpectedMsgs int,
+	step int,
+	maxWaitTime time.Duration,
+	failOnExtraMessages bool,
+) ([]*anypb.Any, error) {
+
+	for _, message := range prepareProposal {
+		P2PBroadcast(t, pocketNodes, message)
+	}
+	advanceTime(t, clck, 10*time.Millisecond)
+
+	votes, err := WaitForNetworkConsensusEvents(t, clck, eventsChannel, typesCons.HotstuffStep(step), consensus.Vote, noOfExpectedMsgs, maxWaitTime, failOnExtraMessages)",consensus/e2e_tests/utils_test.go,2023-04-11 23:42:47+00:00,2023-04-11T23:45:11Z,You can return this directly.,,,,,660,RIGHT,234,,line,https://api.github.com/repos/pokt-network/pocket/pulls/659,pokt-network/pocket,82d931822979d5286c0cd811cf3f7f31ebb5897b
https://api.github.com/repos/pokt-network/pocket/pulls/659,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1163428691,Olshansk,91eedf9ad273055d2dc9855a27dd087edfa90d32,a8e78c8e7a4c1dbf419216c2c2a269ee18081702,"@@ -526,40 +537,221 @@ func baseRpcMock(t *testing.T, _ modules.EventsChannel) *mockModules.MockRPCModu
 	return rpcMock
 }
 
-func baseStateMachineMock(t *testing.T, _ modules.EventsChannel, bus modules.Bus) *mockModules.MockStateMachineModule {
-	ctrl := gomock.NewController(t)
-	stateMachineMock := mockModules.NewMockStateMachineModule(ctrl)
-	stateMachineMock.EXPECT().Start().Return(nil).AnyTimes()
-	stateMachineMock.EXPECT().SetBus(gomock.Any()).Return().AnyTimes()
-	stateMachineMock.EXPECT().GetModuleName().Return(modules.StateMachineModuleName).AnyTimes()
-
-	consensusMod := bus.GetConsensusModule()
-
-	stateMachineMock.EXPECT().SendEvent(gomock.Any()).DoAndReturn(func(event coreTypes.StateMachineEvent, args ...any) error {
-		switch coreTypes.StateMachineEvent(event) {
-		case coreTypes.StateMachineEvent_Consensus_IsUnsynced:
-			t.Logf(""Mocked node is unsynced"")
-			return bus.GetStateMachineModule().SendEvent(coreTypes.StateMachineEvent_Consensus_IsSyncing)
-		case coreTypes.StateMachineEvent_Consensus_IsSyncing:
-			t.Logf(""Mocked node is syncing"")
-			maxHeight := consensusMod.GetAggregatedStateSyncMetadataMaxHeight()
-			// TECHDEBT(#352): The asynchronicity of this leads to a non-deterministic failing test.
-			// See this discussion for details: https://github.com/pokt-network/pocket/pull/528/files#r1150711575
-			consensusMod.SetHeight(maxHeight)
-			return nil
-		case coreTypes.StateMachineEvent_Consensus_IsSyncedValidator:
-			t.Logf(""Mocked validator node is synced"")
-			return nil
-		case coreTypes.StateMachineEvent_Consensus_IsSyncedNonValidator:
-			t.Logf(""Mocked non-validator node is synced"")
-			return nil
-		default:
-			log.Printf(""Mocked node is not handling this event: %s"", event)
-			return nil
+func waitForNextBlock(t *testing.T,
+	clck *clock.Mock,
+	eventsChannel modules.EventsChannel,
+	pocketNodes IdToNodeMapping,
+	height uint64,
+	round uint8,
+	maxWaitTime time.Duration,
+	failOnExtraMessages bool,
+) *coreTypes.Block {
+	leaderId := typesCons.NodeId(pocketNodes[1].GetBus().GetConsensusModule().GetLeaderForView(height, uint64(round), uint8(consensus.NewRound)))
+
+	newRoundMessages, err := waitForProposalMsgs(t, clck, eventsChannel, pocketNodes, nil, height, uint8(consensus.NewRound), round, 0, numValidators*numValidators, maxWaitTime, failOnExtraMessages)
+	require.NoError(t, err)
+
+	prepareProposals, err := waitForProposalMsgs(t, clck, eventsChannel, pocketNodes, newRoundMessages, height, uint8(consensus.Prepare), round, leaderId, numValidators, maxWaitTime, failOnExtraMessages)
+	require.NoError(t, err)
+
+	prepareVotes, err := waitForVotes(t, clck, eventsChannel, pocketNodes, prepareProposals, numValidators, 2, maxWaitTime, failOnExtraMessages)
+	require.NoError(t, err)
+
+	preCommitProposals, err := waitForProposalMsgs(t, clck, eventsChannel, pocketNodes, prepareVotes, height, uint8(consensus.PreCommit), round, leaderId, numValidators, maxWaitTime, failOnExtraMessages)
+	require.NoError(t, err)
+
+	preCommitVotes, err := waitForVotes(t, clck, eventsChannel, pocketNodes, preCommitProposals, numValidators, 3, maxWaitTime, failOnExtraMessages)
+	require.NoError(t, err)
+
+	commitProposal, err := waitForProposalMsgs(t, clck, eventsChannel, pocketNodes, preCommitVotes, height, uint8(consensus.Commit), round, leaderId, numValidators, maxWaitTime, failOnExtraMessages)
+	require.NoError(t, err)
+
+	commitVotes, err := waitForVotes(t, clck, eventsChannel, pocketNodes, commitProposal, numValidators, 4, maxWaitTime, failOnExtraMessages)
+	require.NoError(t, err)
+
+	decideProposal, err := waitForProposalMsgs(t, clck, eventsChannel, pocketNodes, commitVotes, height, uint8(consensus.Decide), round, leaderId, numValidators, maxWaitTime, failOnExtraMessages)
+	require.NoError(t, err)
+
+	for _, message := range decideProposal {
+		P2PBroadcast(t, pocketNodes, message)
+	}
+	advanceTime(t, clck, 10*time.Millisecond)
+
+	blockStore := pocketNodes[1].GetBus().GetPersistenceModule().GetBlockStore()
+	heightBytes := utils.HeightToBytes(height)
+
+	blockBytes, err := blockStore.Get(heightBytes)
+	require.NoError(t, err)
+
+	var block coreTypes.Block
+	err = codec.GetCodec().Unmarshal(blockBytes, &block)
+	require.NoError(t, err)
+
+	return &block
+}
+
+func waitForProposalMsgs(t *testing.T,",consensus/e2e_tests/utils_test.go,2023-04-11 23:43:13+00:00,2023-04-11T23:45:11Z,"Move `t *testing.T` to new line.

Ditto below",,,,,593,RIGHT,165,,line,https://api.github.com/repos/pokt-network/pocket/pulls/659,pokt-network/pocket,82d931822979d5286c0cd811cf3f7f31ebb5897b
https://api.github.com/repos/pokt-network/pocket/pulls/659,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1163429377,Olshansk,91eedf9ad273055d2dc9855a27dd087edfa90d32,a8e78c8e7a4c1dbf419216c2c2a269ee18081702,"@@ -526,40 +537,221 @@ func baseRpcMock(t *testing.T, _ modules.EventsChannel) *mockModules.MockRPCModu
 	return rpcMock
 }
 
-func baseStateMachineMock(t *testing.T, _ modules.EventsChannel, bus modules.Bus) *mockModules.MockStateMachineModule {
-	ctrl := gomock.NewController(t)
-	stateMachineMock := mockModules.NewMockStateMachineModule(ctrl)
-	stateMachineMock.EXPECT().Start().Return(nil).AnyTimes()
-	stateMachineMock.EXPECT().SetBus(gomock.Any()).Return().AnyTimes()
-	stateMachineMock.EXPECT().GetModuleName().Return(modules.StateMachineModuleName).AnyTimes()
-
-	consensusMod := bus.GetConsensusModule()
-
-	stateMachineMock.EXPECT().SendEvent(gomock.Any()).DoAndReturn(func(event coreTypes.StateMachineEvent, args ...any) error {
-		switch coreTypes.StateMachineEvent(event) {
-		case coreTypes.StateMachineEvent_Consensus_IsUnsynced:
-			t.Logf(""Mocked node is unsynced"")
-			return bus.GetStateMachineModule().SendEvent(coreTypes.StateMachineEvent_Consensus_IsSyncing)
-		case coreTypes.StateMachineEvent_Consensus_IsSyncing:
-			t.Logf(""Mocked node is syncing"")
-			maxHeight := consensusMod.GetAggregatedStateSyncMetadataMaxHeight()
-			// TECHDEBT(#352): The asynchronicity of this leads to a non-deterministic failing test.
-			// See this discussion for details: https://github.com/pokt-network/pocket/pull/528/files#r1150711575
-			consensusMod.SetHeight(maxHeight)
-			return nil
-		case coreTypes.StateMachineEvent_Consensus_IsSyncedValidator:
-			t.Logf(""Mocked validator node is synced"")
-			return nil
-		case coreTypes.StateMachineEvent_Consensus_IsSyncedNonValidator:
-			t.Logf(""Mocked non-validator node is synced"")
-			return nil
-		default:
-			log.Printf(""Mocked node is not handling this event: %s"", event)
-			return nil
+func waitForNextBlock(t *testing.T,
+	clck *clock.Mock,
+	eventsChannel modules.EventsChannel,
+	pocketNodes IdToNodeMapping,
+	height uint64,
+	round uint8,
+	maxWaitTime time.Duration,
+	failOnExtraMessages bool,
+) *coreTypes.Block {
+	leaderId := typesCons.NodeId(pocketNodes[1].GetBus().GetConsensusModule().GetLeaderForView(height, uint64(round), uint8(consensus.NewRound)))
+
+	newRoundMessages, err := waitForProposalMsgs(t, clck, eventsChannel, pocketNodes, nil, height, uint8(consensus.NewRound), round, 0, numValidators*numValidators, maxWaitTime, failOnExtraMessages)
+	require.NoError(t, err)
+
+	prepareProposals, err := waitForProposalMsgs(t, clck, eventsChannel, pocketNodes, newRoundMessages, height, uint8(consensus.Prepare), round, leaderId, numValidators, maxWaitTime, failOnExtraMessages)
+	require.NoError(t, err)
+
+	prepareVotes, err := waitForVotes(t, clck, eventsChannel, pocketNodes, prepareProposals, numValidators, 2, maxWaitTime, failOnExtraMessages)
+	require.NoError(t, err)
+
+	preCommitProposals, err := waitForProposalMsgs(t, clck, eventsChannel, pocketNodes, prepareVotes, height, uint8(consensus.PreCommit), round, leaderId, numValidators, maxWaitTime, failOnExtraMessages)
+	require.NoError(t, err)
+
+	preCommitVotes, err := waitForVotes(t, clck, eventsChannel, pocketNodes, preCommitProposals, numValidators, 3, maxWaitTime, failOnExtraMessages)
+	require.NoError(t, err)
+
+	commitProposal, err := waitForProposalMsgs(t, clck, eventsChannel, pocketNodes, preCommitVotes, height, uint8(consensus.Commit), round, leaderId, numValidators, maxWaitTime, failOnExtraMessages)
+	require.NoError(t, err)
+
+	commitVotes, err := waitForVotes(t, clck, eventsChannel, pocketNodes, commitProposal, numValidators, 4, maxWaitTime, failOnExtraMessages)
+	require.NoError(t, err)
+
+	decideProposal, err := waitForProposalMsgs(t, clck, eventsChannel, pocketNodes, commitVotes, height, uint8(consensus.Decide), round, leaderId, numValidators, maxWaitTime, failOnExtraMessages)
+	require.NoError(t, err)
+
+	for _, message := range decideProposal {
+		P2PBroadcast(t, pocketNodes, message)
+	}
+	advanceTime(t, clck, 10*time.Millisecond)
+
+	blockStore := pocketNodes[1].GetBus().GetPersistenceModule().GetBlockStore()
+	heightBytes := utils.HeightToBytes(height)
+
+	blockBytes, err := blockStore.Get(heightBytes)
+	require.NoError(t, err)
+
+	var block coreTypes.Block
+	err = codec.GetCodec().Unmarshal(blockBytes, &block)
+	require.NoError(t, err)
+
+	return &block
+}
+
+func waitForProposalMsgs(t *testing.T,
+	clck *clock.Mock,
+	eventsChannel modules.EventsChannel,
+	pocketNodes IdToNodeMapping,
+	proposalsToSend []*anypb.Any,
+	height uint64,
+	step uint8,
+	round uint8,
+	leaderId typesCons.NodeId,
+	noOfExpectedMsgs int,
+	maxWaitTime time.Duration,
+	failOnExtraMessages bool,
+) ([]*anypb.Any, error) {
+
+	for _, message := range proposalsToSend {
+		P2PBroadcast(t, pocketNodes, message)
+	}
+	advanceTime(t, clck, 10*time.Millisecond)
+
+	proposalMsgs, err := WaitForNetworkConsensusEvents(t, clck, eventsChannel, typesCons.HotstuffStep(step), consensus.Propose, noOfExpectedMsgs, maxWaitTime, failOnExtraMessages)
+	if err != nil {
+		return nil, err
+	}
+
+	for nodeId, pocketNode := range pocketNodes {
+		nodeState := GetConsensusNodeState(pocketNode)
+		if (typesCons.HotstuffStep(step) == consensus.Decide) && (nodeId == leaderId) {
+			assertNodeConsensusView(t, nodeId,
+				typesCons.ConsensusNodeState{
+					Height: height + 1,
+					Step:   1,
+					Round:  round,
+				},
+				nodeState)
+			require.Equal(t, typesCons.NodeId(0), nodeState.LeaderId, ""Leader should be empty"")
+			continue
+		} else {
+			assertNodeConsensusView(t, nodeId,
+				typesCons.ConsensusNodeState{
+					Height: height,
+					Step:   step,
+					Round:  round,
+				},
+				nodeState)
+			require.Equal(t, leaderId, nodeState.LeaderId, fmt.Sprintf(""%d should be the current leader"", leaderId))
 		}
-	}).AnyTimes()
+	}
 
-	return stateMachineMock
+	return proposalMsgs, nil
+}
+
+func waitForVotes(t *testing.T,
+	clck *clock.Mock,
+	eventsChannel modules.EventsChannel,
+	pocketNodes IdToNodeMapping,
+	prepareProposal []*anypb.Any,
+	noOfExpectedMsgs int,
+	step int,
+	maxWaitTime time.Duration,
+	failOnExtraMessages bool,
+) ([]*anypb.Any, error) {
+
+	for _, message := range prepareProposal {
+		P2PBroadcast(t, pocketNodes, message)
+	}
+	advanceTime(t, clck, 10*time.Millisecond)
+
+	votes, err := WaitForNetworkConsensusEvents(t, clck, eventsChannel, typesCons.HotstuffStep(step), consensus.Vote, noOfExpectedMsgs, maxWaitTime, failOnExtraMessages)
+
+	return votes, err
+}
+
+// waitForNodeToSync waits for a node to sync to a target height
+// For every missing block for the unsynced node:
+//
+//	first, waits for the node to request a missing block via `waitForNodeToRequestMissingBlock()` function,
+//	then, waits for the node to receive the missing block via `waitForNodeToReceiveMissingBlock()` function,
+//	finally, wait for the node to catch up to the target height via `waitForNodeToCatchUp()` function.
+func waitForNodeToSync(t *testing.T,
+	clck *clock.Mock,
+	eventsChannel modules.EventsChannel,
+	unsyncedNode *shared.Node,
+	allNodes IdToNodeMapping,
+	targetHeight uint64,
+) error {
+
+	currentHeight := unsyncedNode.GetBus().GetConsensusModule().CurrentHeight()
+
+	for i := currentHeight; i <= targetHeight; i++ {
+		blockRequest, err := waitForNodeToRequestMissingBlock(t, clck, eventsChannel, allNodes, currentHeight, targetHeight)
+		if err != nil {",consensus/e2e_tests/utils_test.go,2023-04-11 23:44:52+00:00,2023-04-11T23:45:11Z,"Question: Why did you decide to return the error instead of just `require.NoError(t, err)` in the tests?",,,,681.0,683,RIGHT,257,254.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/659,pokt-network/pocket,82d931822979d5286c0cd811cf3f7f31ebb5897b
https://api.github.com/repos/pokt-network/pocket/pulls/673,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1164830153,Olshansk,012869d5f22bbdf8c483b10c86a38ef4bea25b71,fdffc4e7ad58f80d6670c8f6c0f5b6c4aed8be86,"@@ -4,7 +4,7 @@ go 1.18
 
 // See the following link for reasoning on why we need the replacement:
 // https://discuss.dgraph.io/t/error-mremap-size-mismatch-on-arm64/15333/8
-replace github.com/dgraph-io/ristretto v0.1.0 => github.com/46bit/ristretto v0.1.0-with-arm-fix
+//replace github.com/dgraph-io/ristretto v0.1.0 => github.com/46bit/ristretto v0.1.0-with-arm-fix",go.mod,2023-04-13 01:20:42+00:00,2023-04-13T01:20:45Z,I think this is going to cause issues for everyone on `ARM64`. Does it not work for you at all?,,,,,7,RIGHT,5,,line,https://api.github.com/repos/pokt-network/pocket/pulls/673,pokt-network/pocket,8bf179719a3b0c7ad89f590602b0ae596b49032a
https://api.github.com/repos/pokt-network/pocket/pulls/658,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1163014983,dylanlott,0da261fde9b7d07e94ae2db6630578b17eb94b0a,3cb1bf6acf7ef4e78246e5cacaf70a291c61bfdb,"@@ -14,7 +14,7 @@ and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0
 
 ## [0.0.0.29] - 2023-03-30
 
-- `cluster-manager` now waits for `v1-validator001` to be online AND responsive by checking the `/v1/health` endpoint (dogfooding)
+- `cluster-manager` now waits for `validator-001-pocket-validator` to be online AND responsive by checking the `/v1/health` endpoint (dogfooding)",build/docs/CHANGELOG.md,2023-04-11 15:45:27+00:00,2023-04-11T15:45:29Z,Not confirmed yet but this rename to `validator-001-pocket-validator` could break E2E tests. It would be a small fix but just wanted to make you aware.,,,,,17,RIGHT,5,,line,https://api.github.com/repos/pokt-network/pocket/pulls/658,pokt-network/pocket,4e5d17b8d927884980c821471a1be3bccb63a529
https://api.github.com/repos/pokt-network/pocket/pulls/658,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1163416326,okdas,a936073987b3086dac9907c1aac6b4ffb47ad5ec,3cb1bf6acf7ef4e78246e5cacaf70a291c61bfdb,"@@ -14,7 +14,7 @@ import (
 var rpcURL string
 
 func init() {
-	rpcURL = fmt.Sprintf(""http://%s:%s"", runtime.GetEnv(""RPC_HOST"", ""v1-validator001""), defaults.DefaultRPCPort)
+	rpcURL = fmt.Sprintf(""http://%s:%s"", runtime.GetEnv(""RPC_HOST"", ""pocket-validators""), defaults.DefaultRPCPort)",e2e/tests/validator.go,2023-04-11 23:16:39+00:00,2023-04-11T23:16:39Z,"@dylan `pocket-validators` is a Service (k8s object), or a DNS name, that will resolve to all healthy validators, so we're not limited to just validator number one.",,,,17.0,17,RIGHT,5,5.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/658,pokt-network/pocket,4e5d17b8d927884980c821471a1be3bccb63a529
https://api.github.com/repos/pokt-network/pocket/pulls/658,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1163416694,okdas,a936073987b3086dac9907c1aac6b4ffb47ad5ec,3cb1bf6acf7ef4e78246e5cacaf70a291c61bfdb,"@@ -34,8 +34,8 @@ var (
 
 const (
 	// defines the host & port scheme that LocalNet uses for naming validators.
-	// e.g. v1-validator-001 thru v1-validator-999
-	validatorServiceURLTmpl = ""v1-validator%s:%d""
+	// e.g. validator-001 thru validator-999
+	validatorServiceURLTmpl = ""validator-%s-pocket-validator:%d""",e2e/tests/steps_init_test.go,2023-04-11 23:17:28+00:00,2023-04-11T23:17:28Z,@dylanlott the test appears to be green in Tilt with that change. I think we're good! :) Thanks for bringing that to my attention.,,,,38.0,38,RIGHT,7,7.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/658,pokt-network/pocket,4e5d17b8d927884980c821471a1be3bccb63a529
https://api.github.com/repos/pokt-network/pocket/pulls/658,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1166089424,Olshansk,a8bc3e338010cd97276592ba428d372ec5d13bdd,3cb1bf6acf7ef4e78246e5cacaf70a291c61bfdb,"@@ -0,0 +1,130 @@
+<div align=""center"">
+  <a href=""https://www.pokt.network"">
+    <img src=""https://user-images.githubusercontent.com/2219004/151564884-212c0e40-3bfa-412e-a341-edb54b5f1498.jpeg"" alt=""Pocket Network logo"" width=""340""/>
+  </a>
+</div>
+
+# pocket-validator
+
+Validator for Pocket Network - decentralized blockchain infrastructure
+
+## Requirements
+
+### Private key
+
+In order to use this chart, you must have a Pocket Network wallet with a private key (make sure you made a backup!).
+If you do not have a private key, you can create one by following the instructions [here](https://docs.pokt.network/pokt/wallets/#create-wallet).
+This helm chart assumes user utilizes Kubernetes Secret to store the private key for an additional layer of protection. The key should not be protected with password.",charts/pocket-validator/README.md,2023-04-13 22:33:51+00:00,2023-04-13T22:43:18Z,"```suggestion
This helm chart assumes the user utilizes Kubernetes Secret to store the private key for an additional layer of protection. The key should not be protected with a password.
```",,,,,17,RIGHT,17,,line,https://api.github.com/repos/pokt-network/pocket/pulls/658,pokt-network/pocket,4e5d17b8d927884980c821471a1be3bccb63a529
https://api.github.com/repos/pokt-network/pocket/pulls/658,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1166089881,Olshansk,a8bc3e338010cd97276592ba428d372ec5d13bdd,3cb1bf6acf7ef4e78246e5cacaf70a291c61bfdb,"@@ -0,0 +1,130 @@
+<div align=""center"">
+  <a href=""https://www.pokt.network"">
+    <img src=""https://user-images.githubusercontent.com/2219004/151564884-212c0e40-3bfa-412e-a341-edb54b5f1498.jpeg"" alt=""Pocket Network logo"" width=""340""/>
+  </a>
+</div>
+
+# pocket-validator
+
+Validator for Pocket Network - decentralized blockchain infrastructure
+
+## Requirements
+
+### Private key
+
+In order to use this chart, you must have a Pocket Network wallet with a private key (make sure you made a backup!).
+If you do not have a private key, you can create one by following the instructions [here](https://docs.pokt.network/pokt/wallets/#create-wallet).
+This helm chart assumes user utilizes Kubernetes Secret to store the private key for an additional layer of protection. The key should not be protected with password.
+
+Here is an example of the private key stored in a Kubernetes Secret:
+
+```yaml
+apiVersion: v1
+kind: Secret
+metadata:
+    name: validator-private-key
+stringData:
+    ""1919605e50c0a60177d0554b528c9810313523b3"": ""4d6d24690137b0c43dee3490cafa4ca49cc1c4facdd1a73be1255a5b752223dc2b7672ea2493dcdd0efc6c6caf1073c4f3ff8508c686031e2d1244c02f0b900d""
+```
+
+This secret can then be utilized with this helm chart using the following variables:
+
+```yaml
+privateKeySecretKeyRef:
+  name: validator-private-key
+  key: 1919605e50c0a60177d0554b528c9810313523b3
+```
+
+## Values
+
+| Key | Type | Default | Description |
+|-----|------|---------|-------------|
+| affinity | object | `{}` |  |
+| config.consensus.max_mempool_bytes | int | `500000000` |  |
+| config.consensus.pacemaker_config.debug_time_between_steps_msec | int | `1000` |  |
+| config.consensus.pacemaker_config.manual | bool | `true` |  |
+| config.consensus.pacemaker_config.timeout_msec | int | `10000` |  |
+| config.consensus.private_key | string | `""""` |  |
+| config.logger.format | string | `""json""` |  |
+| config.logger.level | string | `""debug""` |  |
+| config.p2p.is_empty_connection_type | bool | `false` |  |
+| config.p2p.max_mempool_count | int | `100000` |  |
+| config.p2p.port | int | `42069` |  |
+| config.p2p.private_key | string | `""""` |  |
+| config.p2p.use_rain_tree | bool | `true` |  |
+| config.persistence.block_store_path | string | `""/pocket/validator/block-store""` |  |
+| config.persistence.health_check_period | string | `""30s""` |  |
+| config.persistence.max_conn_idle_time | string | `""1m""` |  |
+| config.persistence.max_conn_lifetime | string | `""5m""` |  |
+| config.persistence.max_conns_count | int | `50` |  |
+| config.persistence.min_conns_count | int | `1` |  |
+| config.persistence.node_schema | string | `""validator""` |  |
+| config.persistence.postgres_url | string | `""""` |  |
+| config.persistence.trees_store_dir | string | `""/pocket/validator/trees""` |  |
+| config.persistence.tx_indexer_path | string | `""/pocket/validator/tx-indexer""` |  |
+| config.private_key | string | `""""` |  |
+| config.root_directory | string | `""/go/src/github.com/pocket-network""` |  |
+| config.rpc.enabled | bool | `true` |  |
+| config.rpc.port | string | `""50832""` |  |
+| config.rpc.timeout | int | `30000` |  |
+| config.rpc.use_cors | bool | `false` |  |
+| config.telemetry.address | string | `""0.0.0.0:9000""` |  |
+| config.telemetry.enabled | bool | `true` |  |
+| config.telemetry.endpoint | string | `""/metrics""` |  |
+| config.use_libp2p | bool | `false` |  |
+| config.utility.max_mempool_transaction_bytes | int | `1073741824` |  |
+| config.utility.max_mempool_transactions | int | `9000` |  |
+| externalPostgresql.database | string | `""""` | name of the external database |
+| externalPostgresql.enabled | bool | `false` | use external postgres database |
+| externalPostgresql.host | string | `""""` | host of the external database |
+| externalPostgresql.passwordSecretKeyRef.key | string | `""""` | key in the Secret that contains the database password |
+| externalPostgresql.passwordSecretKeyRef.name | string | `""""` | name of the Secret in the same namespace that contains the database password |
+| externalPostgresql.port | int | `5432` | port of the external database |
+| externalPostgresql.userSecretKeyRef.key | string | `""""` | key in the Secret that contains the database user |
+| externalPostgresql.userSecretKeyRef.name | string | `""""` | name of the Secret in the same namespace that contains the database user |
+| fullnameOverride | string | `""""` |  |
+| genesis.externalConfigMap.key | string | `""""` | Key in the ConfigMap that contains the genesis file, only used if `genesis.preProvisionedGenesis.enabled` is false |
+| genesis.externalConfigMap.name | string | `""""` | Name of the ConfigMap that contains the genesis file, only used if `genesis.preProvisionedGenesis.enabled` is false |
+| genesis.preProvisionedGenesis.enabled | bool | `true` | Use genesis file supplied by the Helm chart, of false refer to `genesis.externalConfigMap` |
+| genesis.preProvisionedGenesis.type | string | `""devnet""` | Type of the genesis file to use, can be `devnet`, `testnet`, `mainnet` |
+| global.postgresql.service.ports.postgresql | string | `""5432""` |  |
+| image.pullPolicy | string | `""IfNotPresent""` | image pull policy |
+| image.repository | string | `""ghcr.io/pokt-network/pocket-v1""` | image repository |
+| image.tag | string | `""latest""` | image tag |
+| imagePullSecrets | list | `[]` | image pull secrets |
+| ingress.annotations | object | `{}` |  |
+| ingress.className | string | `""""` |  |
+| ingress.enabled | bool | `false` | enable ingress for RPC port |
+| ingress.hosts[0].host | string | `""chart-example.local""` |  |
+| ingress.hosts[0].paths[0].path | string | `""/""` |  |
+| ingress.hosts[0].paths[0].pathType | string | `""ImplementationSpecific""` |  |
+| ingress.tls | list | `[]` |  |
+| nameOverride | string | `""""` |  |
+| nodeSelector | object | `{}` |  |
+| persistence.accessModes | list | `[""ReadWriteOnce""]` | persistent Volume Access Modes |
+| persistence.annotations | object | `{}` | annotations of the persistent volume claim |
+| persistence.dataSource | object | `{}` | custom data source of the persistent volume claim |
+| persistence.enabled | bool | `true` | enable persistent volume claim |
+| persistence.existingClaim | string | `""""` | name of an existing PVC to use for persistence |
+| persistence.reclaimPolicy | string | `""Delete""` | persistent volume reclaim policy |
+| persistence.selector | object | `{}` | selector to match an existing Persistent Volume |
+| persistence.size | string | `""8Gi""` | size of the persistent volume claim |
+| persistence.storageClass | string | `""""` | storage class of the persistent volume claim |
+| podAnnotations | object | `{}` | pod annotations |
+| podSecurityContext | object | `{}` |  |
+| postgresql.enabled | bool | `true` | deploy postgresql database automatically. Refer to https://github.com/bitnami/charts/blob/main/bitnami/postgresql/values.yaml for additional options. |
+| postgresql.primary.persistence.enabled | bool | `false` | enable persistent volume claim for PostgreSQL |
+| postgresql.primary.persistence.size | string | `""8Gi""` | size of the persistent volume claim for PostgreSQL |
+| privateKeySecretKeyRef.key | string | `""""` | REQUIRED. Key in the Secret that contains the private key of the node |
+| privateKeySecretKeyRef.name | string | `""""` | REQUIRED. Name of the Secret in the same namespace that contains the private key of the node |
+| resources | object | `{}` | resources limits and requests |
+| securityContext | object | `{}` |  |
+| service.annotations | object | `{}` | service annotations |
+| service.ports.consensus | int | `42069` | consensus port of the node |
+| service.ports.metrics | int | `9000` | OpenTelemetry metrics port of the node |
+| service.ports.rpc | int | `50832` | rpc port of the node |
+| service.type | string | `""ClusterIP""` | service type |
+| serviceAccount.annotations | object | `{}` | Annotations to add to the service account |
+| serviceAccount.create | bool | `true` | Specifies whether a service account should be created |
+| serviceAccount.name | string | `""""` | The name of the service account to use. If not set and create is true, a name is generated using the fullname template |
+| tolerations | list | `[]` |  |",charts/pocket-validator/README.md,2023-04-13 22:34:38+00:00,2023-04-13T22:43:18Z,Should we add a GITHUB_WIKI tag here?,,,,128.0,130,RIGHT,130,128.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/658,pokt-network/pocket,4e5d17b8d927884980c821471a1be3bccb63a529
https://api.github.com/repos/pokt-network/pocket/pulls/658,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1166090353,Olshansk,a8bc3e338010cd97276592ba428d372ec5d13bdd,3cb1bf6acf7ef4e78246e5cacaf70a291c61bfdb,"@@ -0,0 +1,14 @@
+# Changelog
+
+All notable changes to helm charts will be documented in this file.
+
+The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
+and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).
+
+## [Unreleased]
+
+## [0.0.0.1] - 2023-04-11
+
+- Introduced `pocket-validator` helm chart.
+
+<!-- GITHUB_WIKI: charts -->",charts/CHANGELOG.md,2023-04-13 22:35:27+00:00,2023-04-13T22:43:18Z,"```suggestion
<!-- GITHUB_WIKI: changelog/charts -->
```",,,,,14,RIGHT,14,,line,https://api.github.com/repos/pokt-network/pocket/pulls/658,pokt-network/pocket,4e5d17b8d927884980c821471a1be3bccb63a529
https://api.github.com/repos/pokt-network/pocket/pulls/658,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1166093809,Olshansk,a8bc3e338010cd97276592ba428d372ec5d13bdd,3cb1bf6acf7ef4e78246e5cacaf70a291c61bfdb,"@@ -176,22 +158,25 @@ k8s_yaml([""manifests/cli-client.yaml""])
 k8s_resource('pocket-v1-cli-client', labels=['client'])
 k8s_yaml(['manifests/cluster-manager.yaml'])
 k8s_resource('pocket-v1-cluster-manager', labels=['cluster-manager'])
-k8s_yaml(
-    [
-        local(
-            ""templates/v1-validator-template.sh %s""
-            % localnet_config[""validators""][""count""],
-            quiet=True,
-        ),
-    ]
-)
-
 
-# Uncomment in order to expose postgres port to 5432 on the host machine in case the developer wants to connect to postgres directly
-# First port is the port on the host machine, second is the port on the container, so if you already have postgres running on the host machine, you can change the first port to something else
-# k8s_resource(new_name='postgres',
-#              workload=""dependencies-postgresql"",
-#              port_forwards=""5432:5432"")
+check_helm_dependencies_for_chart(root_dir + ""/charts/pocket-validator"")
+for x in range(localnet_config[""validators""][""count""]):
+    validator_number = x + 1
+    formatted_validator_number = local('printf ""%03d"" ' + str(validator_number))",build/localnet/Tiltfile,2023-04-13 22:42:13+00:00,2023-04-13T22:43:18Z,Why not do  `str(num).zfill(3)`? or `4` depending on what you're trying to achieve,,,,165.0,165,RIGHT,84,84.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/658,pokt-network/pocket,4e5d17b8d927884980c821471a1be3bccb63a529
https://api.github.com/repos/pokt-network/pocket/pulls/658,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1166094042,Olshansk,a8bc3e338010cd97276592ba428d372ec5d13bdd,3cb1bf6acf7ef4e78246e5cacaf70a291c61bfdb,"@@ -64,9 +59,3 @@ prometheus:
   url: http://{{ include ""prometheus.fullname"" .}}:{{ .Values.prometheus.server.service.servicePort }}{{ .Values.prometheus.server.prefixURL }}
   datasource:
     jsonData: {}
-
-# https://github.com/bitnami/charts/blob/main/bitnami/postgresql/values.yaml
-postgres:",build/localnet/dependencies/values.yaml,2023-04-13 22:42:37+00:00,2023-04-13T22:43:18Z,Why can we remove this?,,,,69.0,69,LEFT,15,15.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/658,pokt-network/pocket,4e5d17b8d927884980c821471a1be3bccb63a529
https://api.github.com/repos/pokt-network/pocket/pulls/653,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1160177918,Olshansk,e5cf35e950020a6e16608501447b8b1c774485c9,dfd58a46beb6b39cff76da504a3be54b2840b164,"@@ -0,0 +1,72 @@
+# Pocket 1.0 E2E Testing Framework",e2e/README.md,2023-04-06 19:32:58+00:00,2023-04-06T20:07:08Z,"Save the file after making the change 
```suggestion
# Pocket 1.0 E2E Testing Framework <!-- omit in toc -->
```",,,,,1,RIGHT,1,,line,https://api.github.com/repos/pokt-network/pocket/pulls/653,pokt-network/pocket,f4b9e504bd881326f9528ee370010ca55b67141f
https://api.github.com/repos/pokt-network/pocket/pulls/653,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1160178591,Olshansk,e5cf35e950020a6e16608501447b8b1c774485c9,dfd58a46beb6b39cff76da504a3be54b2840b164,"@@ -0,0 +1,22 @@
+# Changelog
+
+All notable changes to this module will be documented in this file.
+
+The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
+and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).
+
+## [Unreleased]
+
+## [0.0.0.1] - 2023-04-05
+
+Adds Stake, Unstake, & Send Tests  (#644)",e2e/docs/CHANGELOG.md,2023-04-06 19:33:51+00:00,2023-04-06T20:07:08Z,I like the idea of adding the PR numbers in the releases. Not a must but nice,,,,,12,RIGHT,12,,line,https://api.github.com/repos/pokt-network/pocket/pulls/653,pokt-network/pocket,f4b9e504bd881326f9528ee370010ca55b67141f
https://api.github.com/repos/pokt-network/pocket/pulls/653,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1160179611,Olshansk,e5cf35e950020a6e16608501447b8b1c774485c9,dfd58a46beb6b39cff76da504a3be54b2840b164,"@@ -0,0 +1,72 @@
+# Pocket 1.0 E2E Testing Framework
+
+<!-- TOC -->
+
+- [Pocket 1.0 E2E Testing Framework](#pocket-10-e2e-testing-framework)
+  - [Development](#development)
+    - [Typical Development Workflow](#typical-development-workflow)
+    - [Build Tags](#build-tags)
+    - [Issue templates](#issue-templates)
+  - [Implementation](#implementation)
+
+<!-- /TOC -->
+
+> tl; dr - `make localnet_up` and then `make test_e2e`
+
+![Tilt button for running E2E tests](docs/tilt-button.png)",e2e/README.md,2023-04-06 19:35:16+00:00,2023-04-06T20:07:08Z,"Optional NIT: I've started uploading the image to github and just using a link (to avoid needing to include all the files in the source directory), though I do realize it means we don't own it...",,,,13.0,16,RIGHT,16,13.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/653,pokt-network/pocket,f4b9e504bd881326f9528ee370010ca55b67141f
https://api.github.com/repos/pokt-network/pocket/pulls/653,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1160180621,Olshansk,e5cf35e950020a6e16608501447b8b1c774485c9,dfd58a46beb6b39cff76da504a3be54b2840b164,"@@ -0,0 +1,216 @@
+//go:build e2e
+
+package e2e
+
+import (
+	""fmt""
+	""log""
+	""os""
+	""path/filepath""
+	""strings""
+	""testing""
+
+	""github.com/pokt-network/pocket/runtime/defaults""
+	cryptoPocket ""github.com/pokt-network/pocket/shared/crypto""
+	pocketk8s ""github.com/pokt-network/pocket/shared/k8s""
+	""k8s.io/client-go/kubernetes""
+	""k8s.io/client-go/tools/clientcmd""
+
+	""github.com/cucumber/godog""
+)
+
+var (
+	// validatorKeys is hydrated by the clientset with credentials for all validators
+	validatorKeys map[string]string",e2e/tests/steps_init_test.go,2023-04-06 19:36:50+00:00,2023-04-06T20:07:08Z,Can you add a comment on the key-value types here?,,,,27.0,24,RIGHT,24,27.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/653,pokt-network/pocket,f4b9e504bd881326f9528ee370010ca55b67141f
https://api.github.com/repos/pokt-network/pocket/pulls/653,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1160181004,Olshansk,e5cf35e950020a6e16608501447b8b1c774485c9,dfd58a46beb6b39cff76da504a3be54b2840b164,"@@ -0,0 +1,216 @@
+//go:build e2e
+
+package e2e
+
+import (
+	""fmt""
+	""log""
+	""os""
+	""path/filepath""
+	""strings""
+	""testing""
+
+	""github.com/pokt-network/pocket/runtime/defaults""
+	cryptoPocket ""github.com/pokt-network/pocket/shared/crypto""
+	pocketk8s ""github.com/pokt-network/pocket/shared/k8s""
+	""k8s.io/client-go/kubernetes""
+	""k8s.io/client-go/tools/clientcmd""
+
+	""github.com/cucumber/godog""
+)
+
+var (
+	// validatorKeys is hydrated by the clientset with credentials for all validators
+	validatorKeys map[string]string
+	// clientset is the kubernetes API we acquire from the user's $HOME/.kube/config
+	clientset *kubernetes.Clientset
+	// validator holds command results between runs and reports errors to the test suite
+	validator = &validatorPod{}
+	// validatorA maps to suffix ID 001 of the kube pod that we use as our control agent
+	validatorA string = ""001""
+	// validatorB maps to suffix ID 002",e2e/tests/steps_init_test.go,2023-04-06 19:37:18+00:00,2023-04-06T20:07:08Z,Make these `const`,,,,,31,RIGHT,31,,line,https://api.github.com/repos/pokt-network/pocket/pulls/653,pokt-network/pocket,f4b9e504bd881326f9528ee370010ca55b67141f
https://api.github.com/repos/pokt-network/pocket/pulls/653,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1160181664,Olshansk,e5cf35e950020a6e16608501447b8b1c774485c9,dfd58a46beb6b39cff76da504a3be54b2840b164,"@@ -0,0 +1,216 @@
+//go:build e2e
+
+package e2e
+
+import (
+	""fmt""
+	""log""
+	""os""
+	""path/filepath""
+	""strings""
+	""testing""
+
+	""github.com/pokt-network/pocket/runtime/defaults""
+	cryptoPocket ""github.com/pokt-network/pocket/shared/crypto""
+	pocketk8s ""github.com/pokt-network/pocket/shared/k8s""
+	""k8s.io/client-go/kubernetes""
+	""k8s.io/client-go/tools/clientcmd""
+
+	""github.com/cucumber/godog""
+)
+
+var (
+	// validatorKeys is hydrated by the clientset with credentials for all validators
+	validatorKeys map[string]string
+	// clientset is the kubernetes API we acquire from the user's $HOME/.kube/config
+	clientset *kubernetes.Clientset
+	// validator holds command results between runs and reports errors to the test suite
+	validator = &validatorPod{}
+	// validatorA maps to suffix ID 001 of the kube pod that we use as our control agent
+	validatorA string = ""001""
+	// validatorB maps to suffix ID 002
+	validatorB string = ""002""
+	chainId           = ""0001""
+)
+
+func init() {
+	cs, err := getClientset()
+	if err != nil {
+		log.Fatalf(""failed to get clientset: %v"", err)",e2e/tests/steps_init_test.go,2023-04-06 19:38:10+00:00,2023-04-06T20:07:08Z,"I recently learnt from @bryanchriswhite that we should use %w for error: https://stackoverflow.com/questions/61283248/format-errors-in-go-s-v-or-w

Ditto elsewhere.",,,,,39,RIGHT,39,,line,https://api.github.com/repos/pokt-network/pocket/pulls/653,pokt-network/pocket,f4b9e504bd881326f9528ee370010ca55b67141f
https://api.github.com/repos/pokt-network/pocket/pulls/653,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1160181899,Olshansk,e5cf35e950020a6e16608501447b8b1c774485c9,dfd58a46beb6b39cff76da504a3be54b2840b164,"@@ -0,0 +1,216 @@
+//go:build e2e
+
+package e2e
+
+import (
+	""fmt""
+	""log""
+	""os""
+	""path/filepath""
+	""strings""
+	""testing""
+
+	""github.com/pokt-network/pocket/runtime/defaults""
+	cryptoPocket ""github.com/pokt-network/pocket/shared/crypto""
+	pocketk8s ""github.com/pokt-network/pocket/shared/k8s""
+	""k8s.io/client-go/kubernetes""
+	""k8s.io/client-go/tools/clientcmd""
+
+	""github.com/cucumber/godog""
+)
+
+var (
+	// validatorKeys is hydrated by the clientset with credentials for all validators
+	validatorKeys map[string]string
+	// clientset is the kubernetes API we acquire from the user's $HOME/.kube/config
+	clientset *kubernetes.Clientset
+	// validator holds command results between runs and reports errors to the test suite
+	validator = &validatorPod{}
+	// validatorA maps to suffix ID 001 of the kube pod that we use as our control agent
+	validatorA string = ""001""
+	// validatorB maps to suffix ID 002
+	validatorB string = ""002""
+	chainId           = ""0001""
+)
+
+func init() {
+	cs, err := getClientset()
+	if err != nil {
+		log.Fatalf(""failed to get clientset: %v"", err)
+	}
+	clientset = cs
+	vkmap, err := pocketk8s.FetchValidatorPrivateKeys(clientset)
+	if err != nil {
+		log.Fatalf(""failed to get validator keys: %v"", err)
+	}
+	validatorKeys = vkmap
+}
+
+// TestFeatures runs the e2e tests specifiedin any .features files in this directory",e2e/tests/steps_init_test.go,2023-04-06 19:38:32+00:00,2023-04-06T20:07:08Z,"```suggestion
// TestFeatures runs the e2e tests specified in any .features files in this directory
```",,,,,49,RIGHT,49,,line,https://api.github.com/repos/pokt-network/pocket/pulls/653,pokt-network/pocket,f4b9e504bd881326f9528ee370010ca55b67141f
https://api.github.com/repos/pokt-network/pocket/pulls/653,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1160182912,Olshansk,e5cf35e950020a6e16608501447b8b1c774485c9,dfd58a46beb6b39cff76da504a3be54b2840b164,"@@ -0,0 +1,216 @@
+//go:build e2e
+
+package e2e
+
+import (
+	""fmt""
+	""log""
+	""os""
+	""path/filepath""
+	""strings""
+	""testing""
+
+	""github.com/pokt-network/pocket/runtime/defaults""
+	cryptoPocket ""github.com/pokt-network/pocket/shared/crypto""
+	pocketk8s ""github.com/pokt-network/pocket/shared/k8s""
+	""k8s.io/client-go/kubernetes""
+	""k8s.io/client-go/tools/clientcmd""
+
+	""github.com/cucumber/godog""
+)
+
+var (
+	// validatorKeys is hydrated by the clientset with credentials for all validators
+	validatorKeys map[string]string
+	// clientset is the kubernetes API we acquire from the user's $HOME/.kube/config
+	clientset *kubernetes.Clientset
+	// validator holds command results between runs and reports errors to the test suite
+	validator = &validatorPod{}
+	// validatorA maps to suffix ID 001 of the kube pod that we use as our control agent
+	validatorA string = ""001""
+	// validatorB maps to suffix ID 002
+	validatorB string = ""002""
+	chainId           = ""0001""
+)
+
+func init() {
+	cs, err := getClientset()
+	if err != nil {
+		log.Fatalf(""failed to get clientset: %v"", err)
+	}
+	clientset = cs
+	vkmap, err := pocketk8s.FetchValidatorPrivateKeys(clientset)
+	if err != nil {
+		log.Fatalf(""failed to get validator keys: %v"", err)
+	}
+	validatorKeys = vkmap
+}
+
+// TestFeatures runs the e2e tests specifiedin any .features files in this directory
+// * This test suite assumes that a LocalNet is running that can be accessed by `kubectl`
+func TestFeatures(t *testing.T) {
+	suite := godog.TestSuite{
+		ScenarioInitializer: InitializeScenario,
+		Options: &godog.Options{
+			Format:   ""pretty"",
+			Paths:    []string{""./""},
+			TestingT: t,
+		},
+	}
+	if suite.Run() != 0 {
+		t.Fatal(""non-zero status returned, failed to run feature tests"")
+	}
+}
+
+// InitializeScenario registers step regexes to function handlers
+func InitializeScenario(ctx *godog.ScenarioContext) {
+	ctx.Step(`^the user runs the command ""([^""]*)""$`, theUserRunsTheCommand)
+	ctx.Step(`^the user should be able to see standard output containing ""([^""]*)""$`, theUserShouldBeAbleToSeeStandardOutputContaining)
+	ctx.Step(`^the user has a validator$`, theUserHasAValidator)
+	ctx.Step(`^the validator should have exited without error$`, theValidatorShouldHaveExitedWithoutError)
+	ctx.Step(`^the user stakes their validator with (\d+) POKT$`, theUserStakesTheirValidatorWithPOKT)
+	ctx.Step(`^the user should be able to unstake their wallet$`, theUserShouldBeAbleToUnstakeTheirWallet)",e2e/tests/steps_init_test.go,2023-04-06 19:39:50+00:00,2023-04-06T20:07:08Z,"NIT: I think we should rename all instances of wallet here to `Validator`. Users will also be able to stake servicers, applications, portal, etc so it could get confusing.",,,,,72,RIGHT,72,,line,https://api.github.com/repos/pokt-network/pocket/pulls/653,pokt-network/pocket,f4b9e504bd881326f9528ee370010ca55b67141f
https://api.github.com/repos/pokt-network/pocket/pulls/653,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1160183893,Olshansk,e5cf35e950020a6e16608501447b8b1c774485c9,dfd58a46beb6b39cff76da504a3be54b2840b164,"@@ -0,0 +1,216 @@
+//go:build e2e
+
+package e2e
+
+import (
+	""fmt""
+	""log""
+	""os""
+	""path/filepath""
+	""strings""
+	""testing""
+
+	""github.com/pokt-network/pocket/runtime/defaults""
+	cryptoPocket ""github.com/pokt-network/pocket/shared/crypto""
+	pocketk8s ""github.com/pokt-network/pocket/shared/k8s""
+	""k8s.io/client-go/kubernetes""
+	""k8s.io/client-go/tools/clientcmd""
+
+	""github.com/cucumber/godog""
+)
+
+var (
+	// validatorKeys is hydrated by the clientset with credentials for all validators
+	validatorKeys map[string]string
+	// clientset is the kubernetes API we acquire from the user's $HOME/.kube/config
+	clientset *kubernetes.Clientset
+	// validator holds command results between runs and reports errors to the test suite
+	validator = &validatorPod{}
+	// validatorA maps to suffix ID 001 of the kube pod that we use as our control agent
+	validatorA string = ""001""
+	// validatorB maps to suffix ID 002
+	validatorB string = ""002""
+	chainId           = ""0001""
+)
+
+func init() {
+	cs, err := getClientset()
+	if err != nil {
+		log.Fatalf(""failed to get clientset: %v"", err)
+	}
+	clientset = cs
+	vkmap, err := pocketk8s.FetchValidatorPrivateKeys(clientset)
+	if err != nil {
+		log.Fatalf(""failed to get validator keys: %v"", err)
+	}
+	validatorKeys = vkmap
+}
+
+// TestFeatures runs the e2e tests specifiedin any .features files in this directory
+// * This test suite assumes that a LocalNet is running that can be accessed by `kubectl`
+func TestFeatures(t *testing.T) {
+	suite := godog.TestSuite{
+		ScenarioInitializer: InitializeScenario,
+		Options: &godog.Options{
+			Format:   ""pretty"",
+			Paths:    []string{""./""},
+			TestingT: t,
+		},
+	}
+	if suite.Run() != 0 {
+		t.Fatal(""non-zero status returned, failed to run feature tests"")
+	}
+}
+
+// InitializeScenario registers step regexes to function handlers
+func InitializeScenario(ctx *godog.ScenarioContext) {
+	ctx.Step(`^the user runs the command ""([^""]*)""$`, theUserRunsTheCommand)
+	ctx.Step(`^the user should be able to see standard output containing ""([^""]*)""$`, theUserShouldBeAbleToSeeStandardOutputContaining)
+	ctx.Step(`^the user has a validator$`, theUserHasAValidator)
+	ctx.Step(`^the validator should have exited without error$`, theValidatorShouldHaveExitedWithoutError)
+	ctx.Step(`^the user stakes their validator with (\d+) POKT$`, theUserStakesTheirValidatorWithPOKT)
+	ctx.Step(`^the user should be able to unstake their wallet$`, theUserShouldBeAbleToUnstakeTheirWallet)
+	ctx.Step(`^the user sends (\d+) POKT to another address$`, theUserSendsPOKTToAnotherAddress)
+}
+
+func theUserHasAValidator() error {
+	res, err := validator.RunCommand(""help"")
+	if err != nil {
+		log.Printf(""validator error: %+v"", err)
+		return err
+	}
+	validator.result = res
+	return err",e2e/tests/steps_init_test.go,2023-04-06 19:41:10+00:00,2023-04-06T20:07:08Z,"```suggestion
	return nil
```",,,,,83,RIGHT,83,,line,https://api.github.com/repos/pokt-network/pocket/pulls/653,pokt-network/pocket,f4b9e504bd881326f9528ee370010ca55b67141f
https://api.github.com/repos/pokt-network/pocket/pulls/653,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1160185541,Olshansk,e5cf35e950020a6e16608501447b8b1c774485c9,dfd58a46beb6b39cff76da504a3be54b2840b164,"@@ -0,0 +1,216 @@
+//go:build e2e
+
+package e2e
+
+import (
+	""fmt""
+	""log""
+	""os""
+	""path/filepath""
+	""strings""
+	""testing""
+
+	""github.com/pokt-network/pocket/runtime/defaults""
+	cryptoPocket ""github.com/pokt-network/pocket/shared/crypto""
+	pocketk8s ""github.com/pokt-network/pocket/shared/k8s""
+	""k8s.io/client-go/kubernetes""
+	""k8s.io/client-go/tools/clientcmd""
+
+	""github.com/cucumber/godog""
+)
+
+var (
+	// validatorKeys is hydrated by the clientset with credentials for all validators
+	validatorKeys map[string]string
+	// clientset is the kubernetes API we acquire from the user's $HOME/.kube/config
+	clientset *kubernetes.Clientset
+	// validator holds command results between runs and reports errors to the test suite
+	validator = &validatorPod{}
+	// validatorA maps to suffix ID 001 of the kube pod that we use as our control agent
+	validatorA string = ""001""
+	// validatorB maps to suffix ID 002
+	validatorB string = ""002""
+	chainId           = ""0001""
+)
+
+func init() {
+	cs, err := getClientset()
+	if err != nil {
+		log.Fatalf(""failed to get clientset: %v"", err)
+	}
+	clientset = cs
+	vkmap, err := pocketk8s.FetchValidatorPrivateKeys(clientset)
+	if err != nil {
+		log.Fatalf(""failed to get validator keys: %v"", err)
+	}
+	validatorKeys = vkmap
+}
+
+// TestFeatures runs the e2e tests specifiedin any .features files in this directory
+// * This test suite assumes that a LocalNet is running that can be accessed by `kubectl`
+func TestFeatures(t *testing.T) {
+	suite := godog.TestSuite{
+		ScenarioInitializer: InitializeScenario,
+		Options: &godog.Options{
+			Format:   ""pretty"",
+			Paths:    []string{""./""},
+			TestingT: t,
+		},
+	}
+	if suite.Run() != 0 {
+		t.Fatal(""non-zero status returned, failed to run feature tests"")
+	}
+}
+
+// InitializeScenario registers step regexes to function handlers
+func InitializeScenario(ctx *godog.ScenarioContext) {
+	ctx.Step(`^the user runs the command ""([^""]*)""$`, theUserRunsTheCommand)
+	ctx.Step(`^the user should be able to see standard output containing ""([^""]*)""$`, theUserShouldBeAbleToSeeStandardOutputContaining)
+	ctx.Step(`^the user has a validator$`, theUserHasAValidator)
+	ctx.Step(`^the validator should have exited without error$`, theValidatorShouldHaveExitedWithoutError)
+	ctx.Step(`^the user stakes their validator with (\d+) POKT$`, theUserStakesTheirValidatorWithPOKT)
+	ctx.Step(`^the user should be able to unstake their wallet$`, theUserShouldBeAbleToUnstakeTheirWallet)
+	ctx.Step(`^the user sends (\d+) POKT to another address$`, theUserSendsPOKTToAnotherAddress)
+}
+
+func theUserHasAValidator() error {
+	res, err := validator.RunCommand(""help"")
+	if err != nil {
+		log.Printf(""validator error: %+v"", err)
+		return err
+	}
+	validator.result = res
+	return err
+}
+
+func theValidatorShouldHaveExitedWithoutError() error {
+	return validator.result.Err
+}
+
+func theUserRunsTheCommand(cmd string) error {
+	cmds := strings.Split(cmd, "" "")
+	result, err := validator.RunCommand(cmds...)
+	if err != nil {
+		validator.result = result
+		return err
+	}
+	if result.Err != nil {
+		return result.Err
+	}
+	return nil
+}
+
+func theUserShouldBeAbleToSeeStandardOutputContaining(arg1 string) error {
+	if !strings.Contains(validator.result.Stdout, arg1) {
+		return fmt.Errorf(""stdout must contain %s"", arg1)
+	}
+	return nil
+}
+
+func theUserStakesTheirValidatorWithPOKT(amount int) error {",e2e/tests/steps_init_test.go,2023-04-06 19:43:31+00:00,2023-04-06T20:07:08Z,remove `WithPOKT` - there is nothing else to stake a validator with,,,,,110,RIGHT,110,,line,https://api.github.com/repos/pokt-network/pocket/pulls/653,pokt-network/pocket,f4b9e504bd881326f9528ee370010ca55b67141f
https://api.github.com/repos/pokt-network/pocket/pulls/653,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1160185731,Olshansk,e5cf35e950020a6e16608501447b8b1c774485c9,dfd58a46beb6b39cff76da504a3be54b2840b164,"@@ -0,0 +1,216 @@
+//go:build e2e
+
+package e2e
+
+import (
+	""fmt""
+	""log""
+	""os""
+	""path/filepath""
+	""strings""
+	""testing""
+
+	""github.com/pokt-network/pocket/runtime/defaults""
+	cryptoPocket ""github.com/pokt-network/pocket/shared/crypto""
+	pocketk8s ""github.com/pokt-network/pocket/shared/k8s""
+	""k8s.io/client-go/kubernetes""
+	""k8s.io/client-go/tools/clientcmd""
+
+	""github.com/cucumber/godog""
+)
+
+var (
+	// validatorKeys is hydrated by the clientset with credentials for all validators
+	validatorKeys map[string]string
+	// clientset is the kubernetes API we acquire from the user's $HOME/.kube/config
+	clientset *kubernetes.Clientset
+	// validator holds command results between runs and reports errors to the test suite
+	validator = &validatorPod{}
+	// validatorA maps to suffix ID 001 of the kube pod that we use as our control agent
+	validatorA string = ""001""
+	// validatorB maps to suffix ID 002
+	validatorB string = ""002""
+	chainId           = ""0001""
+)
+
+func init() {
+	cs, err := getClientset()
+	if err != nil {
+		log.Fatalf(""failed to get clientset: %v"", err)
+	}
+	clientset = cs
+	vkmap, err := pocketk8s.FetchValidatorPrivateKeys(clientset)
+	if err != nil {
+		log.Fatalf(""failed to get validator keys: %v"", err)
+	}
+	validatorKeys = vkmap
+}
+
+// TestFeatures runs the e2e tests specifiedin any .features files in this directory
+// * This test suite assumes that a LocalNet is running that can be accessed by `kubectl`
+func TestFeatures(t *testing.T) {
+	suite := godog.TestSuite{
+		ScenarioInitializer: InitializeScenario,
+		Options: &godog.Options{
+			Format:   ""pretty"",
+			Paths:    []string{""./""},
+			TestingT: t,
+		},
+	}
+	if suite.Run() != 0 {
+		t.Fatal(""non-zero status returned, failed to run feature tests"")
+	}
+}
+
+// InitializeScenario registers step regexes to function handlers
+func InitializeScenario(ctx *godog.ScenarioContext) {
+	ctx.Step(`^the user runs the command ""([^""]*)""$`, theUserRunsTheCommand)
+	ctx.Step(`^the user should be able to see standard output containing ""([^""]*)""$`, theUserShouldBeAbleToSeeStandardOutputContaining)
+	ctx.Step(`^the user has a validator$`, theUserHasAValidator)
+	ctx.Step(`^the validator should have exited without error$`, theValidatorShouldHaveExitedWithoutError)
+	ctx.Step(`^the user stakes their validator with (\d+) POKT$`, theUserStakesTheirValidatorWithPOKT)
+	ctx.Step(`^the user should be able to unstake their wallet$`, theUserShouldBeAbleToUnstakeTheirWallet)
+	ctx.Step(`^the user sends (\d+) POKT to another address$`, theUserSendsPOKTToAnotherAddress)
+}
+
+func theUserHasAValidator() error {
+	res, err := validator.RunCommand(""help"")
+	if err != nil {
+		log.Printf(""validator error: %+v"", err)
+		return err
+	}
+	validator.result = res
+	return err
+}
+
+func theValidatorShouldHaveExitedWithoutError() error {
+	return validator.result.Err
+}
+
+func theUserRunsTheCommand(cmd string) error {
+	cmds := strings.Split(cmd, "" "")
+	result, err := validator.RunCommand(cmds...)
+	if err != nil {
+		validator.result = result
+		return err
+	}
+	if result.Err != nil {
+		return result.Err
+	}
+	return nil
+}
+
+func theUserShouldBeAbleToSeeStandardOutputContaining(arg1 string) error {
+	if !strings.Contains(validator.result.Stdout, arg1) {
+		return fmt.Errorf(""stdout must contain %s"", arg1)
+	}
+	return nil
+}
+
+func theUserStakesTheirValidatorWithPOKT(amount int) error {
+	return stakeValidator(fmt.Sprintf(""%d"", amount))
+}
+
+func theUserShouldBeAbleToUnstakeTheirWallet() error {",e2e/tests/steps_init_test.go,2023-04-06 19:43:47+00:00,2023-04-06T20:07:08Z,s/Wallet/Validator - not going to leave more redundant comments about this,,,,,114,RIGHT,114,,line,https://api.github.com/repos/pokt-network/pocket/pulls/653,pokt-network/pocket,f4b9e504bd881326f9528ee370010ca55b67141f
https://api.github.com/repos/pokt-network/pocket/pulls/653,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1160186585,Olshansk,e5cf35e950020a6e16608501447b8b1c774485c9,dfd58a46beb6b39cff76da504a3be54b2840b164,"@@ -0,0 +1,216 @@
+//go:build e2e
+
+package e2e
+
+import (
+	""fmt""
+	""log""
+	""os""
+	""path/filepath""
+	""strings""
+	""testing""
+
+	""github.com/pokt-network/pocket/runtime/defaults""
+	cryptoPocket ""github.com/pokt-network/pocket/shared/crypto""
+	pocketk8s ""github.com/pokt-network/pocket/shared/k8s""
+	""k8s.io/client-go/kubernetes""
+	""k8s.io/client-go/tools/clientcmd""
+
+	""github.com/cucumber/godog""
+)
+
+var (
+	// validatorKeys is hydrated by the clientset with credentials for all validators
+	validatorKeys map[string]string
+	// clientset is the kubernetes API we acquire from the user's $HOME/.kube/config
+	clientset *kubernetes.Clientset
+	// validator holds command results between runs and reports errors to the test suite
+	validator = &validatorPod{}
+	// validatorA maps to suffix ID 001 of the kube pod that we use as our control agent
+	validatorA string = ""001""
+	// validatorB maps to suffix ID 002
+	validatorB string = ""002""
+	chainId           = ""0001""
+)
+
+func init() {
+	cs, err := getClientset()
+	if err != nil {
+		log.Fatalf(""failed to get clientset: %v"", err)
+	}
+	clientset = cs
+	vkmap, err := pocketk8s.FetchValidatorPrivateKeys(clientset)
+	if err != nil {
+		log.Fatalf(""failed to get validator keys: %v"", err)
+	}
+	validatorKeys = vkmap
+}
+
+// TestFeatures runs the e2e tests specifiedin any .features files in this directory
+// * This test suite assumes that a LocalNet is running that can be accessed by `kubectl`
+func TestFeatures(t *testing.T) {
+	suite := godog.TestSuite{
+		ScenarioInitializer: InitializeScenario,
+		Options: &godog.Options{
+			Format:   ""pretty"",
+			Paths:    []string{""./""},
+			TestingT: t,
+		},
+	}
+	if suite.Run() != 0 {
+		t.Fatal(""non-zero status returned, failed to run feature tests"")
+	}
+}
+
+// InitializeScenario registers step regexes to function handlers
+func InitializeScenario(ctx *godog.ScenarioContext) {
+	ctx.Step(`^the user runs the command ""([^""]*)""$`, theUserRunsTheCommand)
+	ctx.Step(`^the user should be able to see standard output containing ""([^""]*)""$`, theUserShouldBeAbleToSeeStandardOutputContaining)
+	ctx.Step(`^the user has a validator$`, theUserHasAValidator)
+	ctx.Step(`^the validator should have exited without error$`, theValidatorShouldHaveExitedWithoutError)
+	ctx.Step(`^the user stakes their validator with (\d+) POKT$`, theUserStakesTheirValidatorWithPOKT)
+	ctx.Step(`^the user should be able to unstake their wallet$`, theUserShouldBeAbleToUnstakeTheirWallet)
+	ctx.Step(`^the user sends (\d+) POKT to another address$`, theUserSendsPOKTToAnotherAddress)
+}
+
+func theUserHasAValidator() error {
+	res, err := validator.RunCommand(""help"")
+	if err != nil {
+		log.Printf(""validator error: %+v"", err)
+		return err
+	}
+	validator.result = res
+	return err
+}
+
+func theValidatorShouldHaveExitedWithoutError() error {
+	return validator.result.Err
+}
+
+func theUserRunsTheCommand(cmd string) error {
+	cmds := strings.Split(cmd, "" "")
+	result, err := validator.RunCommand(cmds...)
+	if err != nil {
+		validator.result = result
+		return err
+	}
+	if result.Err != nil {
+		return result.Err
+	}
+	return nil
+}
+
+func theUserShouldBeAbleToSeeStandardOutputContaining(arg1 string) error {
+	if !strings.Contains(validator.result.Stdout, arg1) {
+		return fmt.Errorf(""stdout must contain %s"", arg1)
+	}
+	return nil
+}
+
+func theUserStakesTheirValidatorWithPOKT(amount int) error {
+	return stakeValidator(fmt.Sprintf(""%d"", amount))
+}
+
+func theUserShouldBeAbleToUnstakeTheirWallet() error {
+	return unstakeValidator()
+}
+
+// sends amount of POKT from v1-validator-001 to v1-validator-002
+func theUserSendsPOKTToAnotherAddress(amount int) error {
+	privateKey := getPrivateKey(validatorKeys, validatorA)
+	valB := getPrivateKey(validatorKeys, validatorB)
+	args := []string{
+		""--non_interactive=true"",
+		""--remote_cli_url="" + rpcURL,
+		""Account"",
+		""Send"",
+		privateKey.Address().String(),
+		valB.Address().String(),
+		fmt.Sprintf(""%d"", amount),
+	}
+	validator.RunCommand(args...)
+	res, err := validator.RunCommand(args...)
+	if err != nil {
+		validator.result = res",e2e/tests/steps_init_test.go,2023-04-06 19:45:04+00:00,2023-04-06T20:07:08Z,"We're doing `validator.result = res` in both the err and non-err branches.

Either:
1. Remove from err branch
2. Do it before checking for errors

Ditto everywhere else",,,,,134,RIGHT,134,,line,https://api.github.com/repos/pokt-network/pocket/pulls/653,pokt-network/pocket,f4b9e504bd881326f9528ee370010ca55b67141f
https://api.github.com/repos/pokt-network/pocket/pulls/653,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1160188897,Olshansk,e5cf35e950020a6e16608501447b8b1c774485c9,dfd58a46beb6b39cff76da504a3be54b2840b164,"@@ -0,0 +1,216 @@
+//go:build e2e
+
+package e2e
+
+import (
+	""fmt""
+	""log""
+	""os""
+	""path/filepath""
+	""strings""
+	""testing""
+
+	""github.com/pokt-network/pocket/runtime/defaults""
+	cryptoPocket ""github.com/pokt-network/pocket/shared/crypto""
+	pocketk8s ""github.com/pokt-network/pocket/shared/k8s""
+	""k8s.io/client-go/kubernetes""
+	""k8s.io/client-go/tools/clientcmd""
+
+	""github.com/cucumber/godog""
+)
+
+var (
+	// validatorKeys is hydrated by the clientset with credentials for all validators
+	validatorKeys map[string]string
+	// clientset is the kubernetes API we acquire from the user's $HOME/.kube/config
+	clientset *kubernetes.Clientset
+	// validator holds command results between runs and reports errors to the test suite
+	validator = &validatorPod{}
+	// validatorA maps to suffix ID 001 of the kube pod that we use as our control agent
+	validatorA string = ""001""
+	// validatorB maps to suffix ID 002
+	validatorB string = ""002""
+	chainId           = ""0001""
+)
+
+func init() {
+	cs, err := getClientset()
+	if err != nil {
+		log.Fatalf(""failed to get clientset: %v"", err)
+	}
+	clientset = cs
+	vkmap, err := pocketk8s.FetchValidatorPrivateKeys(clientset)
+	if err != nil {
+		log.Fatalf(""failed to get validator keys: %v"", err)
+	}
+	validatorKeys = vkmap
+}
+
+// TestFeatures runs the e2e tests specifiedin any .features files in this directory
+// * This test suite assumes that a LocalNet is running that can be accessed by `kubectl`
+func TestFeatures(t *testing.T) {
+	suite := godog.TestSuite{
+		ScenarioInitializer: InitializeScenario,
+		Options: &godog.Options{
+			Format:   ""pretty"",
+			Paths:    []string{""./""},
+			TestingT: t,
+		},
+	}
+	if suite.Run() != 0 {
+		t.Fatal(""non-zero status returned, failed to run feature tests"")
+	}
+}
+
+// InitializeScenario registers step regexes to function handlers
+func InitializeScenario(ctx *godog.ScenarioContext) {
+	ctx.Step(`^the user runs the command ""([^""]*)""$`, theUserRunsTheCommand)
+	ctx.Step(`^the user should be able to see standard output containing ""([^""]*)""$`, theUserShouldBeAbleToSeeStandardOutputContaining)
+	ctx.Step(`^the user has a validator$`, theUserHasAValidator)
+	ctx.Step(`^the validator should have exited without error$`, theValidatorShouldHaveExitedWithoutError)
+	ctx.Step(`^the user stakes their validator with (\d+) POKT$`, theUserStakesTheirValidatorWithPOKT)
+	ctx.Step(`^the user should be able to unstake their wallet$`, theUserShouldBeAbleToUnstakeTheirWallet)
+	ctx.Step(`^the user sends (\d+) POKT to another address$`, theUserSendsPOKTToAnotherAddress)
+}
+
+func theUserHasAValidator() error {
+	res, err := validator.RunCommand(""help"")
+	if err != nil {
+		log.Printf(""validator error: %+v"", err)
+		return err
+	}
+	validator.result = res
+	return err
+}
+
+func theValidatorShouldHaveExitedWithoutError() error {
+	return validator.result.Err
+}
+
+func theUserRunsTheCommand(cmd string) error {
+	cmds := strings.Split(cmd, "" "")
+	result, err := validator.RunCommand(cmds...)
+	if err != nil {
+		validator.result = result
+		return err
+	}
+	if result.Err != nil {
+		return result.Err
+	}
+	return nil
+}
+
+func theUserShouldBeAbleToSeeStandardOutputContaining(arg1 string) error {
+	if !strings.Contains(validator.result.Stdout, arg1) {
+		return fmt.Errorf(""stdout must contain %s"", arg1)
+	}
+	return nil
+}
+
+func theUserStakesTheirValidatorWithPOKT(amount int) error {
+	return stakeValidator(fmt.Sprintf(""%d"", amount))
+}
+
+func theUserShouldBeAbleToUnstakeTheirWallet() error {
+	return unstakeValidator()
+}
+
+// sends amount of POKT from v1-validator-001 to v1-validator-002
+func theUserSendsPOKTToAnotherAddress(amount int) error {
+	privateKey := getPrivateKey(validatorKeys, validatorA)
+	valB := getPrivateKey(validatorKeys, validatorB)
+	args := []string{
+		""--non_interactive=true"",
+		""--remote_cli_url="" + rpcURL,
+		""Account"",
+		""Send"",
+		privateKey.Address().String(),
+		valB.Address().String(),
+		fmt.Sprintf(""%d"", amount),
+	}
+	validator.RunCommand(args...)
+	res, err := validator.RunCommand(args...)
+	if err != nil {
+		validator.result = res
+		return err
+	}
+	validator.result = res
+	return nil
+}
+
+// stakeValidator runs Validator stake command with the address, amount, chains..., and serviceURL provided
+func stakeValidator(amount string) error {
+	privateKey := getPrivateKey(validatorKeys, validatorA)
+	validatorServiceUrl := fmt.Sprintf(""v1-validator%s:%d"", validatorA, defaults.DefaultP2PPort)",e2e/tests/steps_init_test.go,2023-04-06 19:48:10+00:00,2023-04-06T20:07:08Z,Move the string template into a const,,,,,144,RIGHT,144,,line,https://api.github.com/repos/pokt-network/pocket/pulls/653,pokt-network/pocket,f4b9e504bd881326f9528ee370010ca55b67141f
https://api.github.com/repos/pokt-network/pocket/pulls/653,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1160189170,Olshansk,e5cf35e950020a6e16608501447b8b1c774485c9,dfd58a46beb6b39cff76da504a3be54b2840b164,"@@ -0,0 +1,216 @@
+//go:build e2e
+
+package e2e
+
+import (
+	""fmt""
+	""log""
+	""os""
+	""path/filepath""
+	""strings""
+	""testing""
+
+	""github.com/pokt-network/pocket/runtime/defaults""
+	cryptoPocket ""github.com/pokt-network/pocket/shared/crypto""
+	pocketk8s ""github.com/pokt-network/pocket/shared/k8s""
+	""k8s.io/client-go/kubernetes""
+	""k8s.io/client-go/tools/clientcmd""
+
+	""github.com/cucumber/godog""
+)
+
+var (
+	// validatorKeys is hydrated by the clientset with credentials for all validators
+	validatorKeys map[string]string
+	// clientset is the kubernetes API we acquire from the user's $HOME/.kube/config
+	clientset *kubernetes.Clientset
+	// validator holds command results between runs and reports errors to the test suite
+	validator = &validatorPod{}
+	// validatorA maps to suffix ID 001 of the kube pod that we use as our control agent
+	validatorA string = ""001""
+	// validatorB maps to suffix ID 002
+	validatorB string = ""002""
+	chainId           = ""0001""
+)
+
+func init() {
+	cs, err := getClientset()
+	if err != nil {
+		log.Fatalf(""failed to get clientset: %v"", err)
+	}
+	clientset = cs
+	vkmap, err := pocketk8s.FetchValidatorPrivateKeys(clientset)
+	if err != nil {
+		log.Fatalf(""failed to get validator keys: %v"", err)
+	}
+	validatorKeys = vkmap
+}
+
+// TestFeatures runs the e2e tests specifiedin any .features files in this directory
+// * This test suite assumes that a LocalNet is running that can be accessed by `kubectl`
+func TestFeatures(t *testing.T) {
+	suite := godog.TestSuite{
+		ScenarioInitializer: InitializeScenario,
+		Options: &godog.Options{
+			Format:   ""pretty"",
+			Paths:    []string{""./""},
+			TestingT: t,
+		},
+	}
+	if suite.Run() != 0 {
+		t.Fatal(""non-zero status returned, failed to run feature tests"")
+	}
+}
+
+// InitializeScenario registers step regexes to function handlers
+func InitializeScenario(ctx *godog.ScenarioContext) {
+	ctx.Step(`^the user runs the command ""([^""]*)""$`, theUserRunsTheCommand)
+	ctx.Step(`^the user should be able to see standard output containing ""([^""]*)""$`, theUserShouldBeAbleToSeeStandardOutputContaining)
+	ctx.Step(`^the user has a validator$`, theUserHasAValidator)
+	ctx.Step(`^the validator should have exited without error$`, theValidatorShouldHaveExitedWithoutError)
+	ctx.Step(`^the user stakes their validator with (\d+) POKT$`, theUserStakesTheirValidatorWithPOKT)
+	ctx.Step(`^the user should be able to unstake their wallet$`, theUserShouldBeAbleToUnstakeTheirWallet)
+	ctx.Step(`^the user sends (\d+) POKT to another address$`, theUserSendsPOKTToAnotherAddress)
+}
+
+func theUserHasAValidator() error {
+	res, err := validator.RunCommand(""help"")
+	if err != nil {
+		log.Printf(""validator error: %+v"", err)
+		return err
+	}
+	validator.result = res
+	return err
+}
+
+func theValidatorShouldHaveExitedWithoutError() error {
+	return validator.result.Err
+}
+
+func theUserRunsTheCommand(cmd string) error {
+	cmds := strings.Split(cmd, "" "")
+	result, err := validator.RunCommand(cmds...)
+	if err != nil {
+		validator.result = result
+		return err
+	}
+	if result.Err != nil {
+		return result.Err
+	}
+	return nil
+}
+
+func theUserShouldBeAbleToSeeStandardOutputContaining(arg1 string) error {
+	if !strings.Contains(validator.result.Stdout, arg1) {
+		return fmt.Errorf(""stdout must contain %s"", arg1)
+	}
+	return nil
+}
+
+func theUserStakesTheirValidatorWithPOKT(amount int) error {
+	return stakeValidator(fmt.Sprintf(""%d"", amount))
+}
+
+func theUserShouldBeAbleToUnstakeTheirWallet() error {
+	return unstakeValidator()
+}
+
+// sends amount of POKT from v1-validator-001 to v1-validator-002
+func theUserSendsPOKTToAnotherAddress(amount int) error {
+	privateKey := getPrivateKey(validatorKeys, validatorA)
+	valB := getPrivateKey(validatorKeys, validatorB)
+	args := []string{
+		""--non_interactive=true"",
+		""--remote_cli_url="" + rpcURL,
+		""Account"",
+		""Send"",
+		privateKey.Address().String(),
+		valB.Address().String(),
+		fmt.Sprintf(""%d"", amount),
+	}
+	validator.RunCommand(args...)
+	res, err := validator.RunCommand(args...)
+	if err != nil {
+		validator.result = res
+		return err
+	}
+	validator.result = res
+	return nil
+}
+
+// stakeValidator runs Validator stake command with the address, amount, chains..., and serviceURL provided
+func stakeValidator(amount string) error {
+	privateKey := getPrivateKey(validatorKeys, validatorA)
+	validatorServiceUrl := fmt.Sprintf(""v1-validator%s:%d"", validatorA, defaults.DefaultP2PPort)
+	args := []string{
+		// NB: ignore passing a --pwd flag because",e2e/tests/steps_init_test.go,2023-04-06 19:48:33+00:00,2023-04-06T20:07:09Z,This applies to everything so I think its okay to remove the comment,,,,,146,RIGHT,146,,line,https://api.github.com/repos/pokt-network/pocket/pulls/653,pokt-network/pocket,f4b9e504bd881326f9528ee370010ca55b67141f
https://api.github.com/repos/pokt-network/pocket/pulls/653,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1160191104,Olshansk,e5cf35e950020a6e16608501447b8b1c774485c9,dfd58a46beb6b39cff76da504a3be54b2840b164,"@@ -0,0 +1,229 @@
+# Pocket 1.0 E2E Testing Framework",e2e/docs/E2E_FRAMEWORK.md,2023-04-06 19:51:23+00:00,2023-04-06T20:07:09Z,Add the `omit in toc` comment and resave so the TOC is updated,,,,1.0,1,RIGHT,1,1.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/653,pokt-network/pocket,f4b9e504bd881326f9528ee370010ca55b67141f
https://api.github.com/repos/pokt-network/pocket/pulls/653,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1160191255,Olshansk,e5cf35e950020a6e16608501447b8b1c774485c9,dfd58a46beb6b39cff76da504a3be54b2840b164,"@@ -0,0 +1,229 @@
+# Pocket 1.0 E2E Testing Framework
+
+## Table of Contents
+
+<!-- TOC -->
+
+- [Pocket 1.0 E2E Testing Framework](#pocket-10-e2e-testing-framework)
+  - [Table of Contents](#table-of-contents)
+  - [Problem Statement](#problem-statement)
+  - [Purpose](#purpose)
+  - [Goals](#goals)
+  - [Non-Goals](#non-goals)
+  - [Key Terms](#key-terms)
+  - [Proposed Solution](#proposed-solution)
+    - [Root Feature Example](#root-feature-example)
+    - [Structure](#structure)
+    - [PocketClient Interface](#pocketclient-interface)
+    - [**Dependencies**](#dependencies)",e2e/docs/E2E_FRAMEWORK.md,2023-04-06 19:51:35+00:00,2023-04-06T20:07:09Z,No need to make titles bolded - ditto below,,,,18.0,18,RIGHT,18,18.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/653,pokt-network/pocket,f4b9e504bd881326f9528ee370010ca55b67141f
https://api.github.com/repos/pokt-network/pocket/pulls/653,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1160192131,Olshansk,e5cf35e950020a6e16608501447b8b1c774485c9,dfd58a46beb6b39cff76da504a3be54b2840b164,"@@ -0,0 +1,229 @@
+# Pocket 1.0 E2E Testing Framework
+
+## Table of Contents
+
+<!-- TOC -->
+
+- [Pocket 1.0 E2E Testing Framework](#pocket-10-e2e-testing-framework)
+  - [Table of Contents](#table-of-contents)
+  - [Problem Statement](#problem-statement)
+  - [Purpose](#purpose)
+  - [Goals](#goals)
+  - [Non-Goals](#non-goals)
+  - [Key Terms](#key-terms)
+  - [Proposed Solution](#proposed-solution)
+    - [Root Feature Example](#root-feature-example)
+    - [Structure](#structure)
+    - [PocketClient Interface](#pocketclient-interface)
+    - [**Dependencies**](#dependencies)
+  - [Rollout Plan](#rollout-plan)
+  - [Decomposition](#decomposition)
+    - [**Step 0: E2E Test Harness with LocalNet**](#step-0-e2e-test-harness-with-localnet)
+    - [**Step 1.1: CI/CD Integration.**](#step-11-cicd-integration)
+    - [**Step 1.2: DevNet Integration**](#step-12-devnet-integration)
+    - [Step 1.3 E2E Test Coverage](#step-13-e2e-test-coverage)
+    - [**Step 2.1: Byzantine Network Simulator**](#step-21-byzantine-network-simulator)
+  - [Success Criteria](#success-criteria)
+
+<!-- /TOC -->
+
+## Problem Statement
+
+As the POKT network scales, it will become increasingly important to test its technical aspects and security guarantees. Starting that growth with a solid foundation of end-to-end tests will have long-term gains in code quality and confidence. However, building a stable (read: not flaky) and extensible end-to-end test suite is a difficult endeavor reaching across several layers of abstraction. This document outlines the details of implementing a behavior-driven development harness for POKT V1.
+
+## Purpose
+
+The purpose of this set of tests is to aid development efforts going forward with V1. This test suite should develop in lockstep with DevNet. Rapid iteration on DevNet will be crucial for a successful late-summer TestNet launch.",e2e/docs/E2E_FRAMEWORK.md,2023-04-06 19:52:47+00:00,2023-04-06T20:07:09Z,"Let's add a date instead of `late-summer`, since this statement will definitely get outdated",,,,36.0,36,RIGHT,36,36.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/653,pokt-network/pocket,f4b9e504bd881326f9528ee370010ca55b67141f
https://api.github.com/repos/pokt-network/pocket/pulls/653,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1160193616,Olshansk,e5cf35e950020a6e16608501447b8b1c774485c9,dfd58a46beb6b39cff76da504a3be54b2840b164,"@@ -0,0 +1,72 @@
+# Pocket 1.0 E2E Testing Framework
+
+<!-- TOC -->
+
+- [Pocket 1.0 E2E Testing Framework](#pocket-10-e2e-testing-framework)
+  - [Development](#development)
+    - [Typical Development Workflow](#typical-development-workflow)
+    - [Build Tags](#build-tags)
+    - [Issue templates](#issue-templates)
+  - [Implementation](#implementation)
+
+<!-- /TOC -->
+
+> tl; dr - `make localnet_up` and then `make test_e2e`
+
+![Tilt button for running E2E tests](docs/tilt-button.png)
+
+You can also click the `e2e-tests` button in the Tilt UI, which is handy during development.
+
+## Development
+
+`make localnet_up` to start a LocalNet. `make test_e2e` after it's up to run the end to end test suite.
+
+The code depends on a Kube config located at the `$HOME/.kube/config` default path for retrieving a `Clientset`.
+
+### Typical Development Workflow
+
+`godog run e2e/tests/` generates error stubs based on the detected feature files. This speeds up writing tests because you can copy & paste over the stubbed-out Go step definitions of new steps that need writing.
+
+### Build Tags
+
+Because the E2E tests depend on a Kubernetes environment to be available, the E2E tests package gets a build tag so the E2E tests are ignored unless the test command is run with -tags=e2e. Issue [#581](https://github.com/pokt-network/pocket/issues/581) covers running the E2E tests in the delivery pipeline. This also means the `develop_test` Make target won't run E2E tests.",e2e/README.md,2023-04-06 19:54:49+00:00,2023-04-06T20:07:09Z,"Hashtags automatically link within github if it's the same repo. Nice handy tool; ditto below.

```suggestion
Because the E2E tests depend on a Kubernetes environment to be available, the E2E tests package gets a build tag so the E2E tests are ignored unless the test command is run with -tags=e2e. Issue #581 covers running the E2E tests in the delivery pipeline. This also means the `develop_test` Make target won't run E2E tests.
```",,,,,32,RIGHT,32,,line,https://api.github.com/repos/pokt-network/pocket/pulls/653,pokt-network/pocket,f4b9e504bd881326f9528ee370010ca55b67141f
https://api.github.com/repos/pokt-network/pocket/pulls/653,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1160196541,Olshansk,e5cf35e950020a6e16608501447b8b1c774485c9,dfd58a46beb6b39cff76da504a3be54b2840b164,"@@ -0,0 +1,229 @@
+# Pocket 1.0 E2E Testing Framework
+",e2e/docs/E2E_FRAMEWORK.md,2023-04-06 19:58:36+00:00,2023-04-06T20:07:09Z,"I think we should rename this file to `E2E_ADR` - Architecture decision record. 

Similar to tendermint: https://github.com/InjectiveLabs/informal-tendermint/blob/main/docs/architecture/README.md",,,,2.0,2,RIGHT,2,2.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/653,pokt-network/pocket,f4b9e504bd881326f9528ee370010ca55b67141f
https://api.github.com/repos/pokt-network/pocket/pulls/653,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1160198492,Olshansk,e5cf35e950020a6e16608501447b8b1c774485c9,dfd58a46beb6b39cff76da504a3be54b2840b164,"@@ -0,0 +1,229 @@
+# Pocket 1.0 E2E Testing Framework
+
+## Table of Contents
+
+<!-- TOC -->
+
+- [Pocket 1.0 E2E Testing Framework](#pocket-10-e2e-testing-framework)
+  - [Table of Contents](#table-of-contents)
+  - [Problem Statement](#problem-statement)
+  - [Purpose](#purpose)
+  - [Goals](#goals)
+  - [Non-Goals](#non-goals)
+  - [Key Terms](#key-terms)
+  - [Proposed Solution](#proposed-solution)
+    - [Root Feature Example](#root-feature-example)
+    - [Structure](#structure)
+    - [PocketClient Interface](#pocketclient-interface)
+    - [**Dependencies**](#dependencies)
+  - [Rollout Plan](#rollout-plan)
+  - [Decomposition](#decomposition)
+    - [**Step 0: E2E Test Harness with LocalNet**](#step-0-e2e-test-harness-with-localnet)
+    - [**Step 1.1: CI/CD Integration.**](#step-11-cicd-integration)
+    - [**Step 1.2: DevNet Integration**](#step-12-devnet-integration)
+    - [Step 1.3 E2E Test Coverage](#step-13-e2e-test-coverage)
+    - [**Step 2.1: Byzantine Network Simulator**](#step-21-byzantine-network-simulator)
+  - [Success Criteria](#success-criteria)
+
+<!-- /TOC -->
+
+## Problem Statement
+
+As the POKT network scales, it will become increasingly important to test its technical aspects and security guarantees. Starting that growth with a solid foundation of end-to-end tests will have long-term gains in code quality and confidence. However, building a stable (read: not flaky) and extensible end-to-end test suite is a difficult endeavor reaching across several layers of abstraction. This document outlines the details of implementing a behavior-driven development harness for POKT V1.
+
+## Purpose
+
+The purpose of this set of tests is to aid development efforts going forward with V1. This test suite should develop in lockstep with DevNet. Rapid iteration on DevNet will be crucial for a successful late-summer TestNet launch.
+
+## Goals
+
+Stated goals from the original [GitHub ticket](https://github.com/pokt-network/pocket/issues/466) for #466:
+
+- Create the foundation for a framework on which ALL future E2E automation will be built (e.g. including relays, state sync, etc...)
+  - The current umbrella ticket will be used to link tickets expanding on this one’s features.
+- Enable both application-level automation (e.g. sending a transaction or staking an actor)
+- Determine if there is a need/benefit in using [https://github.com/testcontainers/testcontainers-go](https://github.com/testcontainers/testcontainers-go)
+  - Decision: No. The E2E suite is focusing on building around the LocalNet. Test containers don’t offer the right level of abstraction that best fits our plans.
+
+## Non-Goals
+
+- Changing any core functionality. The E2E tests should assume the node as a black box for test purposes.
+- Writing a network simulator, load tester, or stress tester.
+
+## Key Terms
+
+**LocalNet** - a local development environment that is maintained by Tilt.
+
+**DevNet** - development network that acts as a rough staging environment.
+
+**TestNet** - a production-like test network targeted for launch by the end of the summer of 2023 that is more permanent on principle.
+
+**Gherkin** - a syntax for writing behavior tests that match to function handlers allowing declarative behavioral tests to be written for a given piece of software. They follow the `Given/When/Then` format.
+
+**Cucumber** - Gherkin syntax (above) is used to write Cucumber tests.
+
+**B.D.D.** - Behavior-driven development. A type of testing that asserts on the behavior the user should experience when interacting with the program under test. It is typically used in close relationship with a product development team for this reason.
+
+**Kubernetes** - a container orchestration platform that LocalNet uses to manage the development environment for POKT.
+
+**Tilt** - allows for fine-grained container scripting in Kubernetes environments including automatic restarts and rebuilds of Docker resources.
+
+## Proposed Solution
+
+The proposed solution is to run Cucumber behavior tests against the LocalNet.
+
+1. Run a LocalNet instance
+2. Take control of the `v1-client` pod
+3. Feed that pod RPC messages via `kubectl`
+4. Evaluate the success or error and subsequent network conditions.
+
+### Root Feature Example
+
+Below is an example of testing the `help` command of the Pocket binary.
+
+```gherkin
+Feature: Root Namespace
+
+  Scenario: User Needs Help
+    Given the user has a validator
+    When the user runs the command ""help""
+    Then the user should be able to see standard output containing ""Available Commands""
+    And the pocket client should have exited without error
+```
+
+Scenarios are specific sets of `Given When Then` step definitions and are composable to some degree. [Step definitions](https://cucumber.io/docs/cucumber/step-definitions/) are functions with a regular expression that links it to a Gherkin step.
+
+The goal is to specify a handful of basic but flexible step definitions that are composed into more complex scenarios with only Gherkin tests being written to define functionality.
+
+Adaptability of the `RunCommand` method is the crux of this design.
+
+```go
+// the step regex is registered in the beginning of the tests.
+ctx.Step(`^the user runs the command ""([^""]*)""$`, theUserRunsTheCommand)
+// and the associated Go function that it targets and the cmd arg it takes
+func theUserRunsTheCommand(cmd string) error {
+    cmds := strings.Split(cmd, "" "")
+    result, err := validator.RunCommand(cmds...)
+    if err != nil {
+        validator.result = result",e2e/docs/E2E_FRAMEWORK.md,2023-04-06 20:00:38+00:00,2023-04-06T20:07:09Z,should we do this if there is no error?,,,,108.0,108,RIGHT,108,108.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/653,pokt-network/pocket,f4b9e504bd881326f9528ee370010ca55b67141f
https://api.github.com/repos/pokt-network/pocket/pulls/653,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1160199089,Olshansk,e5cf35e950020a6e16608501447b8b1c774485c9,dfd58a46beb6b39cff76da504a3be54b2840b164,"@@ -0,0 +1,229 @@
+# Pocket 1.0 E2E Testing Framework
+
+## Table of Contents
+
+<!-- TOC -->
+
+- [Pocket 1.0 E2E Testing Framework](#pocket-10-e2e-testing-framework)
+  - [Table of Contents](#table-of-contents)
+  - [Problem Statement](#problem-statement)
+  - [Purpose](#purpose)
+  - [Goals](#goals)
+  - [Non-Goals](#non-goals)
+  - [Key Terms](#key-terms)
+  - [Proposed Solution](#proposed-solution)
+    - [Root Feature Example](#root-feature-example)
+    - [Structure](#structure)
+    - [PocketClient Interface](#pocketclient-interface)
+    - [**Dependencies**](#dependencies)
+  - [Rollout Plan](#rollout-plan)
+  - [Decomposition](#decomposition)
+    - [**Step 0: E2E Test Harness with LocalNet**](#step-0-e2e-test-harness-with-localnet)
+    - [**Step 1.1: CI/CD Integration.**](#step-11-cicd-integration)
+    - [**Step 1.2: DevNet Integration**](#step-12-devnet-integration)
+    - [Step 1.3 E2E Test Coverage](#step-13-e2e-test-coverage)
+    - [**Step 2.1: Byzantine Network Simulator**](#step-21-byzantine-network-simulator)
+  - [Success Criteria](#success-criteria)
+
+<!-- /TOC -->
+
+## Problem Statement
+
+As the POKT network scales, it will become increasingly important to test its technical aspects and security guarantees. Starting that growth with a solid foundation of end-to-end tests will have long-term gains in code quality and confidence. However, building a stable (read: not flaky) and extensible end-to-end test suite is a difficult endeavor reaching across several layers of abstraction. This document outlines the details of implementing a behavior-driven development harness for POKT V1.
+
+## Purpose
+
+The purpose of this set of tests is to aid development efforts going forward with V1. This test suite should develop in lockstep with DevNet. Rapid iteration on DevNet will be crucial for a successful late-summer TestNet launch.
+
+## Goals
+
+Stated goals from the original [GitHub ticket](https://github.com/pokt-network/pocket/issues/466) for #466:
+
+- Create the foundation for a framework on which ALL future E2E automation will be built (e.g. including relays, state sync, etc...)
+  - The current umbrella ticket will be used to link tickets expanding on this one’s features.
+- Enable both application-level automation (e.g. sending a transaction or staking an actor)
+- Determine if there is a need/benefit in using [https://github.com/testcontainers/testcontainers-go](https://github.com/testcontainers/testcontainers-go)
+  - Decision: No. The E2E suite is focusing on building around the LocalNet. Test containers don’t offer the right level of abstraction that best fits our plans.
+
+## Non-Goals
+
+- Changing any core functionality. The E2E tests should assume the node as a black box for test purposes.
+- Writing a network simulator, load tester, or stress tester.
+
+## Key Terms
+
+**LocalNet** - a local development environment that is maintained by Tilt.
+
+**DevNet** - development network that acts as a rough staging environment.
+
+**TestNet** - a production-like test network targeted for launch by the end of the summer of 2023 that is more permanent on principle.
+
+**Gherkin** - a syntax for writing behavior tests that match to function handlers allowing declarative behavioral tests to be written for a given piece of software. They follow the `Given/When/Then` format.
+
+**Cucumber** - Gherkin syntax (above) is used to write Cucumber tests.
+
+**B.D.D.** - Behavior-driven development. A type of testing that asserts on the behavior the user should experience when interacting with the program under test. It is typically used in close relationship with a product development team for this reason.
+
+**Kubernetes** - a container orchestration platform that LocalNet uses to manage the development environment for POKT.
+
+**Tilt** - allows for fine-grained container scripting in Kubernetes environments including automatic restarts and rebuilds of Docker resources.
+
+## Proposed Solution
+
+The proposed solution is to run Cucumber behavior tests against the LocalNet.
+
+1. Run a LocalNet instance
+2. Take control of the `v1-client` pod
+3. Feed that pod RPC messages via `kubectl`
+4. Evaluate the success or error and subsequent network conditions.
+
+### Root Feature Example
+
+Below is an example of testing the `help` command of the Pocket binary.
+
+```gherkin
+Feature: Root Namespace
+
+  Scenario: User Needs Help
+    Given the user has a validator
+    When the user runs the command ""help""
+    Then the user should be able to see standard output containing ""Available Commands""
+    And the pocket client should have exited without error
+```
+
+Scenarios are specific sets of `Given When Then` step definitions and are composable to some degree. [Step definitions](https://cucumber.io/docs/cucumber/step-definitions/) are functions with a regular expression that links it to a Gherkin step.
+
+The goal is to specify a handful of basic but flexible step definitions that are composed into more complex scenarios with only Gherkin tests being written to define functionality.
+
+Adaptability of the `RunCommand` method is the crux of this design.
+
+```go
+// the step regex is registered in the beginning of the tests.
+ctx.Step(`^the user runs the command ""([^""]*)""$`, theUserRunsTheCommand)
+// and the associated Go function that it targets and the cmd arg it takes
+func theUserRunsTheCommand(cmd string) error {
+    cmds := strings.Split(cmd, "" "")
+    result, err := validator.RunCommand(cmds...)
+    if err != nil {
+        validator.result = result
+        return err
+    }
+    if result.Err != nil {
+        return result.Err
+    }
+    return nil
+}
+```
+
+- The above step definition function is incredibly powerful in that it allows the Validator to compose and execute commands on the Pod. The tests form this into a step definition for staking, unstaking, & help command validation, etc…",e2e/docs/E2E_FRAMEWORK.md,2023-04-06 20:01:10+00:00,2023-04-06T20:07:09Z,"Optional. I think this will help

```suggestion
- The above step definition function is incredibly powerful in that it allows the `Validator` to compose and execute commands on the `Pod`. The tests form this into a step definition for staking, unstaking, & help command validation, etc…
```",,,,118.0,118,RIGHT,118,118.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/653,pokt-network/pocket,f4b9e504bd881326f9528ee370010ca55b67141f
https://api.github.com/repos/pokt-network/pocket/pulls/653,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1160201921,Olshansk,e5cf35e950020a6e16608501447b8b1c774485c9,dfd58a46beb6b39cff76da504a3be54b2840b164,"@@ -0,0 +1,229 @@
+# Pocket 1.0 E2E Testing Framework
+
+## Table of Contents
+
+<!-- TOC -->
+
+- [Pocket 1.0 E2E Testing Framework](#pocket-10-e2e-testing-framework)
+  - [Table of Contents](#table-of-contents)
+  - [Problem Statement](#problem-statement)
+  - [Purpose](#purpose)
+  - [Goals](#goals)
+  - [Non-Goals](#non-goals)
+  - [Key Terms](#key-terms)
+  - [Proposed Solution](#proposed-solution)
+    - [Root Feature Example](#root-feature-example)
+    - [Structure](#structure)
+    - [PocketClient Interface](#pocketclient-interface)
+    - [**Dependencies**](#dependencies)
+  - [Rollout Plan](#rollout-plan)
+  - [Decomposition](#decomposition)
+    - [**Step 0: E2E Test Harness with LocalNet**](#step-0-e2e-test-harness-with-localnet)
+    - [**Step 1.1: CI/CD Integration.**](#step-11-cicd-integration)
+    - [**Step 1.2: DevNet Integration**](#step-12-devnet-integration)
+    - [Step 1.3 E2E Test Coverage](#step-13-e2e-test-coverage)
+    - [**Step 2.1: Byzantine Network Simulator**](#step-21-byzantine-network-simulator)
+  - [Success Criteria](#success-criteria)
+
+<!-- /TOC -->
+
+## Problem Statement
+
+As the POKT network scales, it will become increasingly important to test its technical aspects and security guarantees. Starting that growth with a solid foundation of end-to-end tests will have long-term gains in code quality and confidence. However, building a stable (read: not flaky) and extensible end-to-end test suite is a difficult endeavor reaching across several layers of abstraction. This document outlines the details of implementing a behavior-driven development harness for POKT V1.
+
+## Purpose
+
+The purpose of this set of tests is to aid development efforts going forward with V1. This test suite should develop in lockstep with DevNet. Rapid iteration on DevNet will be crucial for a successful late-summer TestNet launch.
+
+## Goals
+
+Stated goals from the original [GitHub ticket](https://github.com/pokt-network/pocket/issues/466) for #466:
+
+- Create the foundation for a framework on which ALL future E2E automation will be built (e.g. including relays, state sync, etc...)
+  - The current umbrella ticket will be used to link tickets expanding on this one’s features.
+- Enable both application-level automation (e.g. sending a transaction or staking an actor)
+- Determine if there is a need/benefit in using [https://github.com/testcontainers/testcontainers-go](https://github.com/testcontainers/testcontainers-go)
+  - Decision: No. The E2E suite is focusing on building around the LocalNet. Test containers don’t offer the right level of abstraction that best fits our plans.
+
+## Non-Goals
+
+- Changing any core functionality. The E2E tests should assume the node as a black box for test purposes.
+- Writing a network simulator, load tester, or stress tester.
+
+## Key Terms
+
+**LocalNet** - a local development environment that is maintained by Tilt.
+
+**DevNet** - development network that acts as a rough staging environment.
+
+**TestNet** - a production-like test network targeted for launch by the end of the summer of 2023 that is more permanent on principle.
+
+**Gherkin** - a syntax for writing behavior tests that match to function handlers allowing declarative behavioral tests to be written for a given piece of software. They follow the `Given/When/Then` format.
+
+**Cucumber** - Gherkin syntax (above) is used to write Cucumber tests.
+
+**B.D.D.** - Behavior-driven development. A type of testing that asserts on the behavior the user should experience when interacting with the program under test. It is typically used in close relationship with a product development team for this reason.
+
+**Kubernetes** - a container orchestration platform that LocalNet uses to manage the development environment for POKT.
+
+**Tilt** - allows for fine-grained container scripting in Kubernetes environments including automatic restarts and rebuilds of Docker resources.
+
+## Proposed Solution
+
+The proposed solution is to run Cucumber behavior tests against the LocalNet.
+
+1. Run a LocalNet instance
+2. Take control of the `v1-client` pod
+3. Feed that pod RPC messages via `kubectl`
+4. Evaluate the success or error and subsequent network conditions.
+
+### Root Feature Example
+
+Below is an example of testing the `help` command of the Pocket binary.
+
+```gherkin
+Feature: Root Namespace
+
+  Scenario: User Needs Help
+    Given the user has a validator
+    When the user runs the command ""help""
+    Then the user should be able to see standard output containing ""Available Commands""
+    And the pocket client should have exited without error
+```
+
+Scenarios are specific sets of `Given When Then` step definitions and are composable to some degree. [Step definitions](https://cucumber.io/docs/cucumber/step-definitions/) are functions with a regular expression that links it to a Gherkin step.
+
+The goal is to specify a handful of basic but flexible step definitions that are composed into more complex scenarios with only Gherkin tests being written to define functionality.
+
+Adaptability of the `RunCommand` method is the crux of this design.
+
+```go
+// the step regex is registered in the beginning of the tests.
+ctx.Step(`^the user runs the command ""([^""]*)""$`, theUserRunsTheCommand)
+// and the associated Go function that it targets and the cmd arg it takes
+func theUserRunsTheCommand(cmd string) error {
+    cmds := strings.Split(cmd, "" "")
+    result, err := validator.RunCommand(cmds...)
+    if err != nil {
+        validator.result = result
+        return err
+    }
+    if result.Err != nil {
+        return result.Err
+    }
+    return nil
+}
+```
+
+- The above step definition function is incredibly powerful in that it allows the Validator to compose and execute commands on the Pod. The tests form this into a step definition for staking, unstaking, & help command validation, etc…
+- A developer define custom step definitions for specific behavior, but Gherkin tests can also invoke `theUserRunsTheCommand` to achieve almost any behavior. Test syntax can thus be highly flexible and scenarios should be designed with this in mind.
+
+### Structure
+
+- The `e2e` directory is created and includes the feature files and test architecture inside. There should be no other necessary adaptations to the code, however.
+- A new `make` target is introduced for `test_e2e` that runs the E2E test suite.
+
+### PocketClient Interface
+
+```go
+// PocketClient is a single function interface for interacting with a node.
+type PocketClient interface {
+    RunCommand(...string) (*commandResult, error)
+}
+```
+
+- The `PocketClient` interface is included in the test suite and defines a single function interface with the `RunCommand` method.
+- The `validatorPod` adapter fulfills the `PocketClient` interface and lets us call commands through Kubernetes. This is the main way that tests assemble the environment for later assertions.
+
+```go
+// validatorPod holds the connection information to pod validator-001 for testing
+type validatorPod struct {
+    result *commandResult // stores the result of the last command that was run
+}
+
+// RunCommand runs a command on the v1-cli-client.
+func (v *validatorPod) RunCommand(args ...string) (*commandResult, error) {
+    base := []string{
+        ""exec"", ""-i"", ""deploy/pocket-v1-cli-client"",
+        ""--container"", ""pocket"",
+        ""--"", cliPath,
+        ""--non_interactive=true"",
+        ""--remote_cli_url="" + rpcURL,
+    }
+    args = append(base, args...)
+    cmd := exec.Command(""kubectl"", args...)
+    r := &commandResult{}
+    out, err := cmd.Output()
+    if err != nil {
+        v.result = r
+        return r, err
+    }
+    r.Stdout = string(out)
+    v.result = r
+    return r, nil
+}
+```
+
+```mermaid
+---
+title: E2E Lifecycle
+---
+flowchart TD
+    subgraph Init [Initialization]
+        Harness[Harness initialization] --$HOME/.kube/config--> Kubeconfig
+        Kubeconfig --> Clientset
+    end
+        Kubeconfig --> Kubectl
+        Kubeconfig --> DevNet
+    subgraph LocalNet[LocalNet]
+        Kubectl -- commandResult --> Validator
+        Validator -- args --> Kubectl
+    end
+    subgraph DevNet [DevNet]
+        Runner[E2E Test Runner]
+    end
+```
+
+- E2E scenarios only run once Kubectl is loaded. Multiple scenarios are run against the same cluster.
+
+### **Dependencies**
+
+- The `godog` dependency is added to the `go.mod`. It is used to run the Cucumber tests defined in `e2e/tests`.
+- E2E suite indirectly relies on specific pod names in the LocalNet configuration that will break tests if they’re changed.
+
+## Rollout Plan
+
+To implement the current proposed solution, ticket [#466](https://github.com/pokt-network/pocket/issues/466) is decomposed into a multi-step plan that can be parallelized if necessary. The bare requirements of #466 focus around automating the end-to-end testing of the CLI, which will be achieved in the first ticket, but planning for and accomplishing the goals of the spirit of the ticket requires subsequent tickets to define.
+
+- Step 0 merges in a minimal test harness and the supporting documentation.
+- Support for the E2E suite is built into CI/CD and DevNet in step 1.X. Other developers can start adding tests as soon as Step 0 is merged.
+- Specific feature coverage is tracked in Step 1.3.
+- Step 2 uses the existing LocalNet integration to build a flexible test environment capable of simulating complex Byzantine conditions and behaviors, faulty and chaotic network conditions, and load.
+
+## Decomposition
+
+This plan involves a phased approach to adding an end-to-end test suite. The parts can be broken down into smaller tasks that can be done in parallel in two places. The DevNet integration and Simulation network are not dependent on each other, nor are they dependent on CI/CD integration. Each step has a corresponding issue in Github with more detailed scope of work and acceptance criteria.
+
+### **Step 0: [E2E Test Harness with LocalNet](https://github.com/pokt-network/pocket/issues/580)**
+
+This step covers the minimum acceptance criteria to run E2E tests against a LocalNet and documents how to work them into a development flow for the rest of the team.
+
+### **Step 1.1: [CI/CD Integration.](https://github.com/pokt-network/pocket/issues/581)**
+
+Running the E2E tests regularly and for each new change is a large part of the value of these tests. This step explores adding E2E test runs on DevNet to an ArgoCD action that fires on code changes.",e2e/docs/E2E_FRAMEWORK.md,2023-04-06 20:04:15+00:00,2023-04-06T20:07:09Z,on merges to main and optional labels to PRs,,,,213.0,213,RIGHT,213,213.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/653,pokt-network/pocket,f4b9e504bd881326f9528ee370010ca55b67141f
https://api.github.com/repos/pokt-network/pocket/pulls/653,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1161016750,Olshansk,87aa9b4b49694082e11e27c59fe7b754419fb6cb,dfd58a46beb6b39cff76da504a3be54b2840b164,"@@ -1,52 +1,63 @@
-//go:build e2e
+// //go:build e2e
 
 package e2e
 
 import (
 	""fmt""
-	""log""
 	""os""
 	""path/filepath""
 	""strings""
 	""testing""
 
+	pocketLogger ""github.com/pokt-network/pocket/logger""
 	""github.com/pokt-network/pocket/runtime/defaults""
 	cryptoPocket ""github.com/pokt-network/pocket/shared/crypto""
 	pocketk8s ""github.com/pokt-network/pocket/shared/k8s""
-	""k8s.io/client-go/kubernetes""
-	""k8s.io/client-go/tools/clientcmd""
 
 	""github.com/cucumber/godog""
+	""k8s.io/client-go/kubernetes""
+	""k8s.io/client-go/tools/clientcmd""
 )
 
 var (
-	// validatorKeys is hydrated by the clientset with credentials for all validators
+	logger = pocketLogger.Global.CreateLoggerForModule(""e2e"")",e2e/tests/steps_init_test.go,2023-04-07 23:07:47+00:00,2023-04-07T23:10:20Z,Nice addition 👍 ,,,,23.0,23,RIGHT,28,23.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/653,pokt-network/pocket,f4b9e504bd881326f9528ee370010ca55b67141f
https://api.github.com/repos/pokt-network/pocket/pulls/653,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1161017261,Olshansk,87aa9b4b49694082e11e27c59fe7b754419fb6cb,dfd58a46beb6b39cff76da504a3be54b2840b164,"@@ -107,11 +114,11 @@ func theUserShouldBeAbleToSeeStandardOutputContaining(arg1 string) error {
 	return nil
 }
 
-func theUserStakesTheirValidatorWithPOKT(amount int) error {
+func theUserStakesTheirValidatorWithAmountPOKT(amount int) error {",e2e/tests/steps_init_test.go,2023-04-07 23:08:41+00:00,2023-04-07T23:10:20Z,NIT: I don't think we need `POKT` here. It's the currency of the network :),,,,,117,RIGHT,122,,line,https://api.github.com/repos/pokt-network/pocket/pulls/653,pokt-network/pocket,f4b9e504bd881326f9528ee370010ca55b67141f
https://api.github.com/repos/pokt-network/pocket/pulls/653,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1161017749,Olshansk,87aa9b4b49694082e11e27c59fe7b754419fb6cb,dfd58a46beb6b39cff76da504a3be54b2840b164,"@@ -7,17 +7,17 @@ Feature: Validators Namespace
     Then the user should be able to see standard output containing ""Available Commands""
     And the validator should have exited without error
 
-  Scenario: User Can Stake Their Wallet
+  Scenario: User Can Stake An Address 
     Given the user has a validator
-    When the user stakes their validator with 150000000001 POKT
+    When the user stakes their validator with amount 150000000001 POKT",e2e/tests/valdators.feature,2023-04-07 23:09:31+00:00,2023-04-07T23:10:20Z,"s/POKT/uPOKT

It's 15K pot and the number here is 15 * 1e6.

Do a grep in the PR to fix elsewhere",,,,,12,RIGHT,8,,line,https://api.github.com/repos/pokt-network/pocket/pulls/653,pokt-network/pocket,f4b9e504bd881326f9528ee370010ca55b67141f
https://api.github.com/repos/pokt-network/pocket/pulls/653,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1161017876,Olshansk,87aa9b4b49694082e11e27c59fe7b754419fb6cb,dfd58a46beb6b39cff76da504a3be54b2840b164,"@@ -1,4 +1,4 @@
-//go:build e2e
+// //go:build e2e",e2e/tests/validator.go,2023-04-07 23:09:44+00:00,2023-04-07T23:10:20Z,Confirming that this wasn't an accident?,,,,,1,RIGHT,2,,line,https://api.github.com/repos/pokt-network/pocket/pulls/653,pokt-network/pocket,f4b9e504bd881326f9528ee370010ca55b67141f
https://api.github.com/repos/pokt-network/pocket/pulls/690,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1170117406,0xBigBoss,ec70c7eb3414746b6e826df320e09ea25a5f7dd2,ec70c7eb3414746b6e826df320e09ea25a5f7dd2,"@@ -32,17 +32,17 @@ gantt
     title Pocket V1 Roadmap
     dateFormat  YYYY-MM-DD
     section Milestone 1
-      Pocket PoS       :a1, 2022-06-01, 395d
+      Pocket PoS       :a1, 2022-06-01, 456d
     section Milestone 2
-        Pocket DoS       :a1, 2022-07-01, 365d
+        Pocket DoS       :a1, 2022-07-01, 426d
     section Milestone 3
-        Pocket RoS       :a1, 2022-12-01, 241d
+        Pocket RoS       :a1, 2022-12-01, 301d
     section Milestone 4
-        Pocket CoS       :a1, 2023-07-01, 152d
+        Pocket CoS       :a1, 2023-09-01, 152d
     section Milestone 5
-        Pocket IoS       :a1, 2023-12-01, 45d
+        Pocket IoS       :a1, 2024-02-01, 45d
     section Milestone 6
-        Pocket FoS       :a1, 2024-01-15, 90d
+        Pocket FoS       :a1, 2024-03-15, 90d",docs/roadmap/README.md,2023-04-18 14:21:53+00:00,2023-04-18T14:21:56Z,"feels right around the corner 🤠 
",,,,45.0,45,RIGHT,20,20.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/690,pokt-network/pocket,82eba4102ecd2a9ced388621af547df3176a46a7
https://api.github.com/repos/pokt-network/pocket/pulls/693,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1174064823,Olshansk,d828eeb1f1f8d0ce119a5140727e213fc06b41ef,93ae471a7bfbf61c930d7d9dd10e9123f9b1bdaf,"@@ -26,8 +26,11 @@ import (
 var (
 	_ typesP2P.Network           = &rainTreeNetwork{}
 	_ modules.IntegratableModule = &rainTreeNetwork{}
+	_ rainTreeFactory            = &rainTreeNetwork{}
 )
 
+type rainTreeFactory = modules.FactoryWithConfig[typesP2P.Network, RainTreeConfig]",p2p/raintree/network.go,2023-04-21 18:36:28+00:00,2023-04-21T18:43:44Z,"so we're going to have to do this everywhere, right?

If so, can you add a techdebt comment where with define `FactoryWithConfig` et al to not forget?",,,,32.0,32,RIGHT,7,7.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/693,pokt-network/pocket,b4a039741460ac41671cebf81756ea33100de5d1
https://api.github.com/repos/pokt-network/pocket/pulls/677,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1167264919,Olshansk,bd521a07dc2a9a39942f9458b6da9de0855f20a3,ce2e203930b2b56e482444864ab6aadd8b83fc8c,"@@ -148,15 +148,15 @@ func (indexer *txIndexer) indexByHeightAndIndex(height int64, index int32, bz []
 	return indexer.db.Set(indexer.heightAndIndexKey(height, index), bz)
 }
 
-func (indexer *txIndexer) indexBySender(sender string, bz []byte) error {
-	return indexer.db.Set(indexer.senderKey(sender), bz)
+func (indexer *txIndexer) indexBySenderHeightAndIndex(sender string, height int64, index int32, bz []byte) error {",persistence/indexer/indexer.go,2023-04-14 20:51:54+00:00,2023-04-14T20:53:12Z,"```suggestion
func (indexer *txIndexer) indexBySenderHeightAndBlockIndex(sender string, height int64, blockIndex int32, bz []byte) error {
```",,,,,151,RIGHT,19,,line,https://api.github.com/repos/pokt-network/pocket/pulls/677,pokt-network/pocket,fa106f51f4ffa865052d979f0af3593c4b7da4c2
https://api.github.com/repos/pokt-network/pocket/pulls/704,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1179437124,dylanlott,29ac878a1f7218a217bf2872a345eccf736c8bf0,f845c6a67fb4b70039c7a080d6f05673f5273b6e,"@@ -9,11 +9,11 @@ import (
 
 // TECHDEBT(olshansky): When we delete `stdnetwork` and only go with `raintree`, this interface
 // can be simplified greatly.
-type Network interface {
+type Router interface {",p2p/types/router.go,2023-04-27 16:39:02+00:00,2023-04-27T16:52:51Z,Very much agree that Router is better than Network. It's clearer what it's actually doing in the code.,,,,12.0,12,RIGHT,5,5.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/704,pokt-network/pocket,9a687abbb9f94ac3976e0e569a7da0b1bd6e153f
https://api.github.com/repos/pokt-network/pocket/pulls/704,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1179439480,dylanlott,29ac878a1f7218a217bf2872a345eccf736c8bf0,f845c6a67fb4b70039c7a080d6f05673f5273b6e,"@@ -9,11 +9,11 @@ import (
 
 // TECHDEBT(olshansky): When we delete `stdnetwork` and only go with `raintree`, this interface
 // can be simplified greatly.
-type Network interface {
+type Router interface {
 	modules.IntegratableModule
 
-	NetworkBroadcast(data []byte) error
-	NetworkSend(data []byte, address cryptoPocket.Address) error",p2p/types/router.go,2023-04-27 16:41:13+00:00,2023-04-27T16:52:51Z,You love to see it go 🙌,15.0,15.0,LEFT,16.0,16,LEFT,9,9.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/704,pokt-network/pocket,9a687abbb9f94ac3976e0e569a7da0b1bd6e153f
https://api.github.com/repos/pokt-network/pocket/pulls/683,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1170652453,Olshansk,99b25a3c935430fbc59bbac616ccce34fba4f778,e2864b82e0b52b527cf11e0a05062f4779fef9fe,"@@ -23,6 +23,7 @@ message GenesisState {
 
 // TECHDEBT: Explore a more general purpose ""feature flag"" approach that makes it easy to add/remove
 // parameters and add activation heights for them as well.
+// n
 message Params {",runtime/genesis/proto/genesis.proto,2023-04-18 23:10:43+00:00,2023-04-19T03:05:12Z,"Note to reviewer: I know you're not supposed to change proto field IDs in prod, but we're not there yet.

Also, don't worry, I didn't do this manually. https://marketplace.visualstudio.com/items?itemName=ripwu.protobuf-helper",,,,28.0,27,RIGHT,5,8.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/683,pokt-network/pocket,fb245bc027ae55aaee936daf9f85ecb2d9ad8b40
https://api.github.com/repos/pokt-network/pocket/pulls/683,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1171774525,dylanlott,cc15ba1ea64bab29113ec8247bc952b2cc657856,e2864b82e0b52b527cf11e0a05062f4779fef9fe,"@@ -20,16 +20,17 @@ enum StakeStatus {
 }
 
 // TODO(#555): Investigate ways of having actor specific params that are not part of the shared struct.
+//             Potentially having a separate struct for each actor type and a shared base.
 message Actor {
   ActorType actor_type = 1;
   string address = 2;
   string public_key = 3;
-  repeated string chains = 4; // Not applicable to `Validator` actors
+  repeated string chains = 4; // NB: Not applicable `Validator` actors
   // proto-gen-c does not support `go_name` at the time of writing resulting
   // in the output go field being snakeCase: ServiceUrl (https://github.com/golang/protobuf/issues/555)
   string service_url = 5; // Not applicable to `Application` actors
   string staked_amount = 6;
-  int64 paused_height = 7;
-  int64 unstaking_height = 8;
-  string output = 9;
+  int64 paused_height = 7; // TECHDEBT: Revisit this parameter and see if it can be removed for simplification purposes.
+  int64 unstaking_height = 8; // TECHDEBT: Revisit this parameter and see if it can be removed for simplification purposes.
+  string output = 9; // TECHDEBT: Revisit custodial / non-custodial flows (e.g. what if we want multiple outsputs for business purposes)",shared/core/types/proto/actor.proto,2023-04-19 19:33:33+00:00,2023-04-19T21:03:01Z,outsputs --> outputs,,,,,35,RIGHT,20,,line,https://api.github.com/repos/pokt-network/pocket/pulls/683,pokt-network/pocket,fb245bc027ae55aaee936daf9f85ecb2d9ad8b40
https://api.github.com/repos/pokt-network/pocket/pulls/683,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1171780235,dylanlott,cc15ba1ea64bab29113ec8247bc952b2cc657856,e2864b82e0b52b527cf11e0a05062f4779fef9fe,"@@ -1,157 +1,280 @@
 package utility
 
-// IMPORTANT: The interface and implementation defined in this file are for illustrative purposes only
-// and need to be revisited before any implementation commences.
-
 import (
 	""encoding/binary""
+	""encoding/hex""
+	""fmt""
+	""math""
+	""math/rand""
 
+	""github.com/pokt-network/pocket/logger""
 	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
 	""github.com/pokt-network/pocket/shared/crypto""
+	""github.com/pokt-network/pocket/shared/modules""
 	""github.com/pokt-network/pocket/utility/types""
+	""golang.org/x/exp/slices""
 )
 
-// TODO: When implementing please review if block height tolerance (+,-1) is included in the session protocol: pokt-network/pocket-core#1464 CC @Olshansk
-
-// REFACTOR: Move these into `utility/types` and consider creating an enum
-type RelayChain string
-type GeoZone string
-
-type Session interface {
-	NewSession(sessionHeight int64, relayChain RelayChain, geoZone GeoZone, application *coreTypes.Actor) (Session, types.Error)
-	GetSessionID() []byte             // the identifier of the dispatched session
-	GetSessionHeight() int64          // the block height when the session started
-	GetRelayChain() RelayChain        // the web3 chain identifier
-	GetGeoZone() GeoZone              // the geo-location zone where the application is intending to operate during the session
-	GetApplication() *coreTypes.Actor // the Application consuming the web3 access
-	GetServicers() []*coreTypes.Actor // the Servicers providing Web3 to the application
-	GetFishermen() []*coreTypes.Actor // the Fishermen monitoring the servicers
-}
+// sessionHydrator is an internal structure used to prepare a Session returned by `GetSession` below
+type sessionHydrator struct {
+	logger modules.Logger
+
+	// The height of the request for which the session is being hydrated
+	blockHeight int64
 
-var _ Session = &session{}
+	// The session being hydrated and returned
+	session *coreTypes.Session
 
-type session struct {
-	sessionId   []byte
-	height      int64
-	relayChain  RelayChain
-	geoZone     GeoZone
-	application *coreTypes.Actor
-	servicers   []*coreTypes.Actor
-	fishermen   []*coreTypes.Actor
+	// Caches a readCtx to avoid draining too many connections to the database
+	readCtx modules.PersistenceReadContext
+
+	// A redundant helper that maintains a hex decoded copy of `session.Id` used for session hydration
+	sessionIdBz []byte
 }
 
-func (*session) NewSession(
-	sessionHeight int64,
-	relayChain RelayChain,
-	geoZone GeoZone,
-	application *coreTypes.Actor,
-) (Session, types.Error) {
-	s := &session{
-		height:      sessionHeight,
-		relayChain:  relayChain,
-		geoZone:     geoZone,
-		application: application,
-	}
-
-	// TODO: make these configurable or based on governance params
-	numServicers := 1
-	numFisherman := 1
-
-	var err types.Error
-	if s.servicers, err = s.selectSessionServicers(numServicers); err != nil {
+// GetSession is an implementation of the exposed `UtilityModule.GetSession` function
+func (m *utilityModule) GetSession(appAddr string, height int64, relayChain, geoZone string) (*coreTypes.Session, error) {
+	persistenceModule := m.GetBus().GetPersistenceModule()
+	readCtx, err := persistenceModule.NewReadContext(height)
+	if err != nil {
 		return nil, err
 	}
-	if s.fishermen, err = s.selectSessionFishermen(numFisherman); err != nil {
+	defer readCtx.Release()
+
+	session := &coreTypes.Session{
+		RelayChain: relayChain,
+		GeoZone:    geoZone,
+	}
+
+	sessionHydrator := &sessionHydrator{
+		logger:      m.logger.With().Str(""source"", ""sessionHydrator"").Logger(),
+		blockHeight: height,
+		session:     session,
+		readCtx:     readCtx,
+	}
+
+	if err := sessionHydrator.hydrateSessionHeight(height); err != nil {
 		return nil, err
 	}
-	if s.sessionId, err = s.getSessionId(); err != nil {
+
+	if err := sessionHydrator.hydrateSessionApplication(appAddr); err != nil {
 		return nil, err
 	}
-	return s, nil
-}
 
-func (s *session) GetSessionID() []byte {
-	return s.sessionId
-}
+	if err := sessionHydrator.validateApplicationSession(); err != nil {
+		return nil, err
+	}
 
-func (s *session) GetSessionHeight() int64 {
-	return s.height
-}
+	if err := sessionHydrator.hydrateSessionID(); err != nil {
+		return nil, err
+	}
 
-func (s *session) GetRelayChain() RelayChain {
-	return s.relayChain
-}
+	if err := sessionHydrator.hydrateSessionServicers(); err != nil {
+		return nil, err
+	}
+
+	if err := sessionHydrator.hydrateSessionFishermen(); err != nil {
+		return nil, err
+	}
 
-func (s *session) GetGeoZone() GeoZone {
-	return s.geoZone
+	return sessionHydrator.session, nil
 }
 
-func (s *session) GetApplication() *coreTypes.Actor {
-	return s.application
+// hydrateSessionHeight hydrates the height at which the session started given the current block height
+func (s *sessionHydrator) hydrateSessionHeight(blockHeight int64) error {
+	numBlocksPerSession, err := s.readCtx.GetIntParam(types.BlocksPerSessionParamName, blockHeight)
+	if err != nil {
+		return err
+	}
+	numBlocksAheadOfSession := blockHeight % int64(numBlocksPerSession)
+
+	s.session.NumSessionBlocks = int64(numBlocksPerSession)
+	s.session.SessionNumber = int64(blockHeight / int64(numBlocksPerSession))
+	s.session.SessionHeight = blockHeight - numBlocksAheadOfSession
+	return nil
 }
 
-func (s *session) GetFishermen() []*coreTypes.Actor {
-	return s.fishermen
+// hydrateSessionApplication hydrates the full Application actor based on the address the session is being
+// dispatched for.
+func (s *sessionHydrator) hydrateSessionApplication(appAddr string) error {
+	// TECHDEBT: We can remove this decoding process once we use `strings` instead of `[]byte` for addresses
+	addr, err := hex.DecodeString(appAddr)
+	if err != nil {
+		return err
+	}
+	s.session.Application, err = s.readCtx.GetActor(coreTypes.ActorType_ACTOR_TYPE_APP, addr, s.session.SessionHeight)
+	return err
 }
 
-func (s *session) GetServicers() []*coreTypes.Actor {
-	return s.servicers
+// validateApplicationSession validates that the application can dispatch a session at the requested geo zone and for the request relay chain
+func (s *sessionHydrator) validateApplicationSession() error {
+	// TODO(#XXX): Filter by geo-zone
+	app := s.session.Application
+
+	if !slices.Contains(app.Chains, s.session.RelayChain) {
+		return fmt.Errorf(""application %s does not stake for relay chain %s"", app.Address, s.session.RelayChain)
+	}
+
+	if !(app.PausedHeight == -1 && app.UnstakingHeight == -1) {
+		return fmt.Errorf(""application %s is either unstaked or paused"", app.Address)
+	}
+
+	// TODO: Consider what else we should validate for here
+	return nil
 }
 
-// use the seed information to determine a SHA3Hash that is used to find the closest N actors based
-// by comparing the sessionKey with the actors' public key
-func (s *session) getSessionId() ([]byte, types.Error) {
+// hydrateSessionID use both session and on-chain data to determine a unique session ID
+func (s *sessionHydrator) hydrateSessionID() error {
 	sessionHeightBz := make([]byte, 8)
-	binary.LittleEndian.PutUint64(sessionHeightBz, uint64(s.height))
+	binary.LittleEndian.PutUint64(sessionHeightBz, uint64(s.session.SessionHeight))
 
-	blockHashBz := []byte(""get block hash bytes at s.sessionHeight from persistence module"")
+	prevHashHeight := int64(math.Max(float64(s.session.SessionHeight)-1, 0))
+	prevHash, err := s.readCtx.GetBlockHash(prevHashHeight)
+	if err != nil {
+		return err
+	}
+	prevHashBz, err := hex.DecodeString(prevHash)
 
-	appPubKey, err := crypto.NewPublicKey(s.application.GetPublicKey())
+	appPubKeyBz := []byte(s.session.Application.PublicKey)
+	relayChainBz := []byte(string(s.session.RelayChain))
+	geoZoneBz := []byte(s.session.GeoZone)
+
+	s.sessionIdBz = concat(sessionHeightBz, prevHashBz, geoZoneBz, relayChainBz, appPubKeyBz)
+	s.session.Id = crypto.GetHashStringFromBytes(s.sessionIdBz)
+
+	return nil
+}
+
+// hydrateSessionServicers finds the servicers that are staked at the session height and populates the session with them
+func (s *sessionHydrator) hydrateSessionServicers() error {
+	// number of servicers per session at this height
+	numServicers, err := s.readCtx.GetIntParam(types.ServicersPerSessionParamName, s.session.SessionHeight)
 	if err != nil {
-		return nil, types.ErrNewPublicKeyFromBytes(err)
+		return err
 	}
 
-	return concat(sessionHeightBz, blockHashBz, []byte(s.geoZone), []byte(s.relayChain), appPubKey.Bytes()), nil
+	// returns all the staked servicers at this session height
+	servicers, err := s.readCtx.GetAllServicers(s.session.SessionHeight)
+	if err != nil {
+		return err
+	}
+
+	// OPTIMIZE: Consider updating the persistence module so a single SQL query can retrieve all of the actors at once.
+	candidateServicers := make([]*coreTypes.Actor, 0)
+	for _, servicer := range servicers {
+		// Sanity check the servicer is not paused, jailed or unstaking
+		if !(servicer.PausedHeight == -1 && servicer.UnstakingHeight == -1) {
+			return fmt.Errorf(""hydrateSessionServicers should not have encountered a paused or unstaking servicer: %s"", servicer.Address)
+		}
+
+		// TODO(#XXX): Filter by geo-zone
+
+		// OPTIMIZE: If this was a map[string]struct{}, we could have avoided the loop
+		var chain string
+		for _, chain = range servicer.Chains {
+			if chain != s.session.RelayChain {
+				chain = """"
+				continue
+			}
+		}
+		if chain != """" {
+			candidateServicers = append(candidateServicers, servicer)
+		}
+	}
+
+	s.session.Servicers = pseudoRandomSelection(candidateServicers, numServicers, s.sessionIdBz)
+	return nil
 }
 
-// uses the current 'world state' to determine the servicers in the session
-// 1) get an ordered list of the public keys of servicers who are:
-//   - actively staked
-//   - staked within geo-zone (or closest geo-zones)
-//   - staked for relay-chain
-//
-// 2) calls `pseudoRandomSelection(servicers, numberOfNodesPerSession)`
-func (s *session) selectSessionServicers(numServicers int) ([]*coreTypes.Actor, types.Error) {
-	// IMPORTANT: This function is for behaviour illustrative purposes only and implementation may differ.
-	return nil, nil
+// hydrateSessionFishermen finds the fishermen that are staked at the session height and populates the session with them
+func (s *sessionHydrator) hydrateSessionFishermen() error {
+	// number of fisherman per session at this height
+	numFishermen, err := s.readCtx.GetIntParam(types.FishermanPerSessionParamName, s.session.SessionHeight)
+	if err != nil {
+		return err
+	}
+
+	// returns all the staked fisherman at this session height
+	fishermen, err := s.readCtx.GetAllFishermen(s.session.SessionHeight)
+	if err != nil {
+		return err
+	}
+
+	// OPTIMIZE: Consider updating the persistence module so a single SQL query can retrieve all of the actors at once.
+	candidateFishermen := make([]*coreTypes.Actor, 0)
+	for _, fisherman := range fishermen {
+		// Sanity check the fisherman is not paused, jailed or unstaking
+		if !(fisherman.PausedHeight == -1 && fisherman.UnstakingHeight == -1) {
+			return fmt.Errorf(""hydrateSessionFishermen should not have encountered a paused or unstaking fisherman: %s"", fisherman.Address)
+		}
+
+		// TODO(#XXX): Filter by geo-zone
+
+		// OPTIMIZE: If this was a map[string]struct{}, we could have avoided the loop
+		var chain string
+		for _, chain = range fisherman.Chains {
+			if chain != s.session.RelayChain {
+				chain = """"
+				continue
+			}
+		}
+		if chain != """" {
+			candidateFishermen = append(candidateFishermen, fisherman)
+		}
+	}
+
+	s.session.Fishermen = pseudoRandomSelection(candidateFishermen, numFishermen, s.sessionIdBz)
+	return nil
 }
 
-// uses the current 'world state' to determine the fishermen in the session
-// 1) get an ordered list of the public keys of fishermen who are:
-//   - actively staked
-//   - staked within geo-zone  (or closest geo-zones)
-//   - staked for relay-chain
-//
-// 2) calls `pseudoRandomSelection(fishermen, numberOfFishPerSession)`
-func (s *session) selectSessionFishermen(numFishermen int) ([]*coreTypes.Actor, types.Error) {
-	// IMPORTANT: This function is for behaviour illustrative purposes only and implementation may differ.
-	return nil, nil
+// pseudoRandomSelection returns a random subset of the candidates.
+// TECHDEBT: We are using a `Go` native implementation for a pseudo-random number generator. In order
+// for it to be language agnostic, a general purpose algorithm needs ot be used.
+func pseudoRandomSelection(candidates []*coreTypes.Actor, numTarget int, sessionId []byte) []*coreTypes.Actor {
+	// If there aren't enough candidates, return all of them
+	if numTarget > len(candidates) {
+		logger.Global.Warn().Msgf(""pseudoRandomSelection: numTarget (%d) is greater than the number of candidates (%d)"", numTarget, len(candidates))
+		return candidates
+	}
+
+	// Take the first 8 bytes of sessionId to use as the seed
+	seed := int64(binary.BigEndian.Uint64(crypto.SHA3Hash(sessionId)[:8]))
+
+	// Retrieve the indices for the candidates
+	actors := make([]*coreTypes.Actor, 0)
+	uniqueIndices := uniqueRandomIndices(seed, int64(len(candidates)), int64(numTarget))
+	for idx := range uniqueIndices {
+		actors = append(actors, candidates[idx])
+	}
+
+	return actors
 }
 
-// 1) passed an ordered list of the public keys of actors and number of nodes
-// 2) pseudo-insert the session `key` string into the list and find the first actor directly below
-// 3) newKey = Hash( key + actor1PublicKey )
-// 4) repeat steps 2 and 3 until all N actor are found
-// FAQ:
-// Q) why do we hash to find a newKey between every actor selection?
-// A) pseudo-random selection only works if each iteration is re-randomized
-//
-//	or it would be subject to lexicographical proximity bias attacks
-//
-//nolint:unused // This is a demonstratable function
-func (s *session) pseudoRandomSelection(orderedListOfPublicKeys []string, numActorsToSelect int) []*coreTypes.Actor {
-	// IMPORTANT: This function is for behaviour illustrative purposes only and implementation may differ.
-	return nil
+// OPTIMIZE: Postgres uses a `Twisted Mersenne Twister (TMT)` randomness algorithm.
+// We could potentially look into changing everything into a single SQL query but
+// would nee dto verify that it can be implemented in a platform agnostic way.",utility/session.go,2023-04-19 19:40:24+00:00,2023-04-19T21:03:01Z,"_""would need to""_",,,,,255,RIGHT,365,,line,https://api.github.com/repos/pokt-network/pocket/pulls/683,pokt-network/pocket,fb245bc027ae55aaee936daf9f85ecb2d9ad8b40
https://api.github.com/repos/pokt-network/pocket/pulls/683,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1171805653,dylanlott,cc15ba1ea64bab29113ec8247bc952b2cc657856,e2864b82e0b52b527cf11e0a05062f4779fef9fe,"@@ -1,157 +1,280 @@
 package utility
 
-// IMPORTANT: The interface and implementation defined in this file are for illustrative purposes only
-// and need to be revisited before any implementation commences.
-
 import (
 	""encoding/binary""
+	""encoding/hex""
+	""fmt""
+	""math""
+	""math/rand""
 
+	""github.com/pokt-network/pocket/logger""
 	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
 	""github.com/pokt-network/pocket/shared/crypto""
+	""github.com/pokt-network/pocket/shared/modules""
 	""github.com/pokt-network/pocket/utility/types""
+	""golang.org/x/exp/slices""
 )
 
-// TODO: When implementing please review if block height tolerance (+,-1) is included in the session protocol: pokt-network/pocket-core#1464 CC @Olshansk
-
-// REFACTOR: Move these into `utility/types` and consider creating an enum
-type RelayChain string
-type GeoZone string
-
-type Session interface {
-	NewSession(sessionHeight int64, relayChain RelayChain, geoZone GeoZone, application *coreTypes.Actor) (Session, types.Error)
-	GetSessionID() []byte             // the identifier of the dispatched session
-	GetSessionHeight() int64          // the block height when the session started
-	GetRelayChain() RelayChain        // the web3 chain identifier
-	GetGeoZone() GeoZone              // the geo-location zone where the application is intending to operate during the session
-	GetApplication() *coreTypes.Actor // the Application consuming the web3 access
-	GetServicers() []*coreTypes.Actor // the Servicers providing Web3 to the application
-	GetFishermen() []*coreTypes.Actor // the Fishermen monitoring the servicers
-}
+// sessionHydrator is an internal structure used to prepare a Session returned by `GetSession` below
+type sessionHydrator struct {
+	logger modules.Logger
+
+	// The height of the request for which the session is being hydrated
+	blockHeight int64
 
-var _ Session = &session{}
+	// The session being hydrated and returned
+	session *coreTypes.Session
 
-type session struct {
-	sessionId   []byte
-	height      int64
-	relayChain  RelayChain
-	geoZone     GeoZone
-	application *coreTypes.Actor
-	servicers   []*coreTypes.Actor
-	fishermen   []*coreTypes.Actor
+	// Caches a readCtx to avoid draining too many connections to the database
+	readCtx modules.PersistenceReadContext
+
+	// A redundant helper that maintains a hex decoded copy of `session.Id` used for session hydration
+	sessionIdBz []byte
 }
 
-func (*session) NewSession(
-	sessionHeight int64,
-	relayChain RelayChain,
-	geoZone GeoZone,
-	application *coreTypes.Actor,
-) (Session, types.Error) {
-	s := &session{
-		height:      sessionHeight,
-		relayChain:  relayChain,
-		geoZone:     geoZone,
-		application: application,
-	}
-
-	// TODO: make these configurable or based on governance params
-	numServicers := 1
-	numFisherman := 1
-
-	var err types.Error
-	if s.servicers, err = s.selectSessionServicers(numServicers); err != nil {
+// GetSession is an implementation of the exposed `UtilityModule.GetSession` function
+func (m *utilityModule) GetSession(appAddr string, height int64, relayChain, geoZone string) (*coreTypes.Session, error) {
+	persistenceModule := m.GetBus().GetPersistenceModule()
+	readCtx, err := persistenceModule.NewReadContext(height)
+	if err != nil {
 		return nil, err
 	}
-	if s.fishermen, err = s.selectSessionFishermen(numFisherman); err != nil {
+	defer readCtx.Release()
+
+	session := &coreTypes.Session{
+		RelayChain: relayChain,
+		GeoZone:    geoZone,
+	}
+
+	sessionHydrator := &sessionHydrator{
+		logger:      m.logger.With().Str(""source"", ""sessionHydrator"").Logger(),
+		blockHeight: height,
+		session:     session,
+		readCtx:     readCtx,
+	}
+
+	if err := sessionHydrator.hydrateSessionHeight(height); err != nil {
 		return nil, err
 	}
-	if s.sessionId, err = s.getSessionId(); err != nil {
+
+	if err := sessionHydrator.hydrateSessionApplication(appAddr); err != nil {
 		return nil, err
 	}
-	return s, nil
-}
 
-func (s *session) GetSessionID() []byte {
-	return s.sessionId
-}
+	if err := sessionHydrator.validateApplicationSession(); err != nil {
+		return nil, err
+	}
 
-func (s *session) GetSessionHeight() int64 {
-	return s.height
-}
+	if err := sessionHydrator.hydrateSessionID(); err != nil {
+		return nil, err
+	}
 
-func (s *session) GetRelayChain() RelayChain {
-	return s.relayChain
-}
+	if err := sessionHydrator.hydrateSessionServicers(); err != nil {
+		return nil, err
+	}
+
+	if err := sessionHydrator.hydrateSessionFishermen(); err != nil {
+		return nil, err
+	}
 
-func (s *session) GetGeoZone() GeoZone {
-	return s.geoZone
+	return sessionHydrator.session, nil
 }
 
-func (s *session) GetApplication() *coreTypes.Actor {
-	return s.application
+// hydrateSessionHeight hydrates the height at which the session started given the current block height
+func (s *sessionHydrator) hydrateSessionHeight(blockHeight int64) error {
+	numBlocksPerSession, err := s.readCtx.GetIntParam(types.BlocksPerSessionParamName, blockHeight)
+	if err != nil {
+		return err
+	}
+	numBlocksAheadOfSession := blockHeight % int64(numBlocksPerSession)
+
+	s.session.NumSessionBlocks = int64(numBlocksPerSession)
+	s.session.SessionNumber = int64(blockHeight / int64(numBlocksPerSession))
+	s.session.SessionHeight = blockHeight - numBlocksAheadOfSession
+	return nil
 }
 
-func (s *session) GetFishermen() []*coreTypes.Actor {
-	return s.fishermen
+// hydrateSessionApplication hydrates the full Application actor based on the address the session is being
+// dispatched for.
+func (s *sessionHydrator) hydrateSessionApplication(appAddr string) error {
+	// TECHDEBT: We can remove this decoding process once we use `strings` instead of `[]byte` for addresses
+	addr, err := hex.DecodeString(appAddr)
+	if err != nil {
+		return err
+	}
+	s.session.Application, err = s.readCtx.GetActor(coreTypes.ActorType_ACTOR_TYPE_APP, addr, s.session.SessionHeight)
+	return err
 }
 
-func (s *session) GetServicers() []*coreTypes.Actor {
-	return s.servicers
+// validateApplicationSession validates that the application can dispatch a session at the requested geo zone and for the request relay chain
+func (s *sessionHydrator) validateApplicationSession() error {
+	// TODO(#XXX): Filter by geo-zone
+	app := s.session.Application
+
+	if !slices.Contains(app.Chains, s.session.RelayChain) {
+		return fmt.Errorf(""application %s does not stake for relay chain %s"", app.Address, s.session.RelayChain)
+	}
+
+	if !(app.PausedHeight == -1 && app.UnstakingHeight == -1) {
+		return fmt.Errorf(""application %s is either unstaked or paused"", app.Address)
+	}
+
+	// TODO: Consider what else we should validate for here
+	return nil
 }
 
-// use the seed information to determine a SHA3Hash that is used to find the closest N actors based
-// by comparing the sessionKey with the actors' public key
-func (s *session) getSessionId() ([]byte, types.Error) {
+// hydrateSessionID use both session and on-chain data to determine a unique session ID
+func (s *sessionHydrator) hydrateSessionID() error {
 	sessionHeightBz := make([]byte, 8)
-	binary.LittleEndian.PutUint64(sessionHeightBz, uint64(s.height))
+	binary.LittleEndian.PutUint64(sessionHeightBz, uint64(s.session.SessionHeight))
 
-	blockHashBz := []byte(""get block hash bytes at s.sessionHeight from persistence module"")
+	prevHashHeight := int64(math.Max(float64(s.session.SessionHeight)-1, 0))
+	prevHash, err := s.readCtx.GetBlockHash(prevHashHeight)
+	if err != nil {
+		return err
+	}
+	prevHashBz, err := hex.DecodeString(prevHash)
 
-	appPubKey, err := crypto.NewPublicKey(s.application.GetPublicKey())
+	appPubKeyBz := []byte(s.session.Application.PublicKey)
+	relayChainBz := []byte(string(s.session.RelayChain))
+	geoZoneBz := []byte(s.session.GeoZone)
+
+	s.sessionIdBz = concat(sessionHeightBz, prevHashBz, geoZoneBz, relayChainBz, appPubKeyBz)
+	s.session.Id = crypto.GetHashStringFromBytes(s.sessionIdBz)
+
+	return nil
+}
+
+// hydrateSessionServicers finds the servicers that are staked at the session height and populates the session with them
+func (s *sessionHydrator) hydrateSessionServicers() error {
+	// number of servicers per session at this height
+	numServicers, err := s.readCtx.GetIntParam(types.ServicersPerSessionParamName, s.session.SessionHeight)
 	if err != nil {
-		return nil, types.ErrNewPublicKeyFromBytes(err)
+		return err
 	}
 
-	return concat(sessionHeightBz, blockHashBz, []byte(s.geoZone), []byte(s.relayChain), appPubKey.Bytes()), nil
+	// returns all the staked servicers at this session height
+	servicers, err := s.readCtx.GetAllServicers(s.session.SessionHeight)
+	if err != nil {
+		return err
+	}
+
+	// OPTIMIZE: Consider updating the persistence module so a single SQL query can retrieve all of the actors at once.
+	candidateServicers := make([]*coreTypes.Actor, 0)
+	for _, servicer := range servicers {
+		// Sanity check the servicer is not paused, jailed or unstaking
+		if !(servicer.PausedHeight == -1 && servicer.UnstakingHeight == -1) {
+			return fmt.Errorf(""hydrateSessionServicers should not have encountered a paused or unstaking servicer: %s"", servicer.Address)
+		}
+
+		// TODO(#XXX): Filter by geo-zone
+
+		// OPTIMIZE: If this was a map[string]struct{}, we could have avoided the loop
+		var chain string
+		for _, chain = range servicer.Chains {
+			if chain != s.session.RelayChain {
+				chain = """"
+				continue
+			}
+		}
+		if chain != """" {
+			candidateServicers = append(candidateServicers, servicer)
+		}
+	}
+
+	s.session.Servicers = pseudoRandomSelection(candidateServicers, numServicers, s.sessionIdBz)
+	return nil
 }
 
-// uses the current 'world state' to determine the servicers in the session
-// 1) get an ordered list of the public keys of servicers who are:
-//   - actively staked
-//   - staked within geo-zone (or closest geo-zones)
-//   - staked for relay-chain
-//
-// 2) calls `pseudoRandomSelection(servicers, numberOfNodesPerSession)`
-func (s *session) selectSessionServicers(numServicers int) ([]*coreTypes.Actor, types.Error) {
-	// IMPORTANT: This function is for behaviour illustrative purposes only and implementation may differ.
-	return nil, nil
+// hydrateSessionFishermen finds the fishermen that are staked at the session height and populates the session with them
+func (s *sessionHydrator) hydrateSessionFishermen() error {
+	// number of fisherman per session at this height
+	numFishermen, err := s.readCtx.GetIntParam(types.FishermanPerSessionParamName, s.session.SessionHeight)
+	if err != nil {
+		return err
+	}
+
+	// returns all the staked fisherman at this session height
+	fishermen, err := s.readCtx.GetAllFishermen(s.session.SessionHeight)
+	if err != nil {
+		return err
+	}
+
+	// OPTIMIZE: Consider updating the persistence module so a single SQL query can retrieve all of the actors at once.
+	candidateFishermen := make([]*coreTypes.Actor, 0)
+	for _, fisherman := range fishermen {
+		// Sanity check the fisherman is not paused, jailed or unstaking
+		if !(fisherman.PausedHeight == -1 && fisherman.UnstakingHeight == -1) {
+			return fmt.Errorf(""hydrateSessionFishermen should not have encountered a paused or unstaking fisherman: %s"", fisherman.Address)
+		}
+
+		// TODO(#XXX): Filter by geo-zone
+
+		// OPTIMIZE: If this was a map[string]struct{}, we could have avoided the loop
+		var chain string
+		for _, chain = range fisherman.Chains {
+			if chain != s.session.RelayChain {
+				chain = """"
+				continue
+			}
+		}
+		if chain != """" {
+			candidateFishermen = append(candidateFishermen, fisherman)
+		}
+	}
+
+	s.session.Fishermen = pseudoRandomSelection(candidateFishermen, numFishermen, s.sessionIdBz)
+	return nil
 }
 
-// uses the current 'world state' to determine the fishermen in the session
-// 1) get an ordered list of the public keys of fishermen who are:
-//   - actively staked
-//   - staked within geo-zone  (or closest geo-zones)
-//   - staked for relay-chain
-//
-// 2) calls `pseudoRandomSelection(fishermen, numberOfFishPerSession)`
-func (s *session) selectSessionFishermen(numFishermen int) ([]*coreTypes.Actor, types.Error) {
-	// IMPORTANT: This function is for behaviour illustrative purposes only and implementation may differ.
-	return nil, nil
+// pseudoRandomSelection returns a random subset of the candidates.
+// TECHDEBT: We are using a `Go` native implementation for a pseudo-random number generator. In order
+// for it to be language agnostic, a general purpose algorithm needs ot be used.",utility/session.go,2023-04-19 20:10:25+00:00,2023-04-19T21:03:01Z,"_""needs to be used""_",,,,,232,RIGHT,328,,line,https://api.github.com/repos/pokt-network/pocket/pulls/683,pokt-network/pocket,fb245bc027ae55aaee936daf9f85ecb2d9ad8b40
https://api.github.com/repos/pokt-network/pocket/pulls/683,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1171806715,dylanlott,cc15ba1ea64bab29113ec8247bc952b2cc657856,e2864b82e0b52b527cf11e0a05062f4779fef9fe,"@@ -1,157 +1,280 @@
 package utility
 
-// IMPORTANT: The interface and implementation defined in this file are for illustrative purposes only
-// and need to be revisited before any implementation commences.
-
 import (
 	""encoding/binary""
+	""encoding/hex""
+	""fmt""
+	""math""
+	""math/rand""
 
+	""github.com/pokt-network/pocket/logger""
 	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
 	""github.com/pokt-network/pocket/shared/crypto""
+	""github.com/pokt-network/pocket/shared/modules""
 	""github.com/pokt-network/pocket/utility/types""
+	""golang.org/x/exp/slices""
 )
 
-// TODO: When implementing please review if block height tolerance (+,-1) is included in the session protocol: pokt-network/pocket-core#1464 CC @Olshansk
-
-// REFACTOR: Move these into `utility/types` and consider creating an enum
-type RelayChain string
-type GeoZone string
-
-type Session interface {
-	NewSession(sessionHeight int64, relayChain RelayChain, geoZone GeoZone, application *coreTypes.Actor) (Session, types.Error)
-	GetSessionID() []byte             // the identifier of the dispatched session
-	GetSessionHeight() int64          // the block height when the session started
-	GetRelayChain() RelayChain        // the web3 chain identifier
-	GetGeoZone() GeoZone              // the geo-location zone where the application is intending to operate during the session
-	GetApplication() *coreTypes.Actor // the Application consuming the web3 access
-	GetServicers() []*coreTypes.Actor // the Servicers providing Web3 to the application
-	GetFishermen() []*coreTypes.Actor // the Fishermen monitoring the servicers
-}
+// sessionHydrator is an internal structure used to prepare a Session returned by `GetSession` below
+type sessionHydrator struct {
+	logger modules.Logger
+
+	// The height of the request for which the session is being hydrated
+	blockHeight int64
 
-var _ Session = &session{}
+	// The session being hydrated and returned
+	session *coreTypes.Session
 
-type session struct {
-	sessionId   []byte
-	height      int64
-	relayChain  RelayChain
-	geoZone     GeoZone
-	application *coreTypes.Actor
-	servicers   []*coreTypes.Actor
-	fishermen   []*coreTypes.Actor
+	// Caches a readCtx to avoid draining too many connections to the database
+	readCtx modules.PersistenceReadContext
+
+	// A redundant helper that maintains a hex decoded copy of `session.Id` used for session hydration
+	sessionIdBz []byte
 }
 
-func (*session) NewSession(
-	sessionHeight int64,
-	relayChain RelayChain,
-	geoZone GeoZone,
-	application *coreTypes.Actor,
-) (Session, types.Error) {
-	s := &session{
-		height:      sessionHeight,
-		relayChain:  relayChain,
-		geoZone:     geoZone,
-		application: application,
-	}
-
-	// TODO: make these configurable or based on governance params
-	numServicers := 1
-	numFisherman := 1
-
-	var err types.Error
-	if s.servicers, err = s.selectSessionServicers(numServicers); err != nil {
+// GetSession is an implementation of the exposed `UtilityModule.GetSession` function
+func (m *utilityModule) GetSession(appAddr string, height int64, relayChain, geoZone string) (*coreTypes.Session, error) {
+	persistenceModule := m.GetBus().GetPersistenceModule()
+	readCtx, err := persistenceModule.NewReadContext(height)
+	if err != nil {
 		return nil, err
 	}
-	if s.fishermen, err = s.selectSessionFishermen(numFisherman); err != nil {
+	defer readCtx.Release()
+
+	session := &coreTypes.Session{
+		RelayChain: relayChain,
+		GeoZone:    geoZone,
+	}
+
+	sessionHydrator := &sessionHydrator{
+		logger:      m.logger.With().Str(""source"", ""sessionHydrator"").Logger(),
+		blockHeight: height,
+		session:     session,
+		readCtx:     readCtx,
+	}
+
+	if err := sessionHydrator.hydrateSessionHeight(height); err != nil {
 		return nil, err
 	}
-	if s.sessionId, err = s.getSessionId(); err != nil {
+
+	if err := sessionHydrator.hydrateSessionApplication(appAddr); err != nil {
 		return nil, err
 	}
-	return s, nil
-}
 
-func (s *session) GetSessionID() []byte {
-	return s.sessionId
-}
+	if err := sessionHydrator.validateApplicationSession(); err != nil {
+		return nil, err
+	}
 
-func (s *session) GetSessionHeight() int64 {
-	return s.height
-}
+	if err := sessionHydrator.hydrateSessionID(); err != nil {
+		return nil, err
+	}
 
-func (s *session) GetRelayChain() RelayChain {
-	return s.relayChain
-}
+	if err := sessionHydrator.hydrateSessionServicers(); err != nil {
+		return nil, err
+	}
+
+	if err := sessionHydrator.hydrateSessionFishermen(); err != nil {
+		return nil, err
+	}
 
-func (s *session) GetGeoZone() GeoZone {
-	return s.geoZone
+	return sessionHydrator.session, nil
 }
 
-func (s *session) GetApplication() *coreTypes.Actor {
-	return s.application
+// hydrateSessionHeight hydrates the height at which the session started given the current block height
+func (s *sessionHydrator) hydrateSessionHeight(blockHeight int64) error {
+	numBlocksPerSession, err := s.readCtx.GetIntParam(types.BlocksPerSessionParamName, blockHeight)
+	if err != nil {
+		return err
+	}
+	numBlocksAheadOfSession := blockHeight % int64(numBlocksPerSession)
+
+	s.session.NumSessionBlocks = int64(numBlocksPerSession)
+	s.session.SessionNumber = int64(blockHeight / int64(numBlocksPerSession))
+	s.session.SessionHeight = blockHeight - numBlocksAheadOfSession
+	return nil
 }
 
-func (s *session) GetFishermen() []*coreTypes.Actor {
-	return s.fishermen
+// hydrateSessionApplication hydrates the full Application actor based on the address the session is being
+// dispatched for.
+func (s *sessionHydrator) hydrateSessionApplication(appAddr string) error {
+	// TECHDEBT: We can remove this decoding process once we use `strings` instead of `[]byte` for addresses
+	addr, err := hex.DecodeString(appAddr)
+	if err != nil {
+		return err
+	}
+	s.session.Application, err = s.readCtx.GetActor(coreTypes.ActorType_ACTOR_TYPE_APP, addr, s.session.SessionHeight)
+	return err
 }
 
-func (s *session) GetServicers() []*coreTypes.Actor {
-	return s.servicers
+// validateApplicationSession validates that the application can dispatch a session at the requested geo zone and for the request relay chain
+func (s *sessionHydrator) validateApplicationSession() error {
+	// TODO(#XXX): Filter by geo-zone
+	app := s.session.Application
+
+	if !slices.Contains(app.Chains, s.session.RelayChain) {
+		return fmt.Errorf(""application %s does not stake for relay chain %s"", app.Address, s.session.RelayChain)
+	}
+
+	if !(app.PausedHeight == -1 && app.UnstakingHeight == -1) {
+		return fmt.Errorf(""application %s is either unstaked or paused"", app.Address)
+	}
+
+	// TODO: Consider what else we should validate for here
+	return nil
 }
 
-// use the seed information to determine a SHA3Hash that is used to find the closest N actors based
-// by comparing the sessionKey with the actors' public key
-func (s *session) getSessionId() ([]byte, types.Error) {
+// hydrateSessionID use both session and on-chain data to determine a unique session ID
+func (s *sessionHydrator) hydrateSessionID() error {
 	sessionHeightBz := make([]byte, 8)
-	binary.LittleEndian.PutUint64(sessionHeightBz, uint64(s.height))
+	binary.LittleEndian.PutUint64(sessionHeightBz, uint64(s.session.SessionHeight))
 
-	blockHashBz := []byte(""get block hash bytes at s.sessionHeight from persistence module"")
+	prevHashHeight := int64(math.Max(float64(s.session.SessionHeight)-1, 0))
+	prevHash, err := s.readCtx.GetBlockHash(prevHashHeight)
+	if err != nil {
+		return err
+	}
+	prevHashBz, err := hex.DecodeString(prevHash)
 
-	appPubKey, err := crypto.NewPublicKey(s.application.GetPublicKey())
+	appPubKeyBz := []byte(s.session.Application.PublicKey)
+	relayChainBz := []byte(string(s.session.RelayChain))
+	geoZoneBz := []byte(s.session.GeoZone)
+
+	s.sessionIdBz = concat(sessionHeightBz, prevHashBz, geoZoneBz, relayChainBz, appPubKeyBz)
+	s.session.Id = crypto.GetHashStringFromBytes(s.sessionIdBz)
+
+	return nil
+}
+
+// hydrateSessionServicers finds the servicers that are staked at the session height and populates the session with them
+func (s *sessionHydrator) hydrateSessionServicers() error {
+	// number of servicers per session at this height
+	numServicers, err := s.readCtx.GetIntParam(types.ServicersPerSessionParamName, s.session.SessionHeight)
 	if err != nil {
-		return nil, types.ErrNewPublicKeyFromBytes(err)
+		return err
 	}
 
-	return concat(sessionHeightBz, blockHashBz, []byte(s.geoZone), []byte(s.relayChain), appPubKey.Bytes()), nil
+	// returns all the staked servicers at this session height
+	servicers, err := s.readCtx.GetAllServicers(s.session.SessionHeight)
+	if err != nil {
+		return err
+	}
+
+	// OPTIMIZE: Consider updating the persistence module so a single SQL query can retrieve all of the actors at once.
+	candidateServicers := make([]*coreTypes.Actor, 0)
+	for _, servicer := range servicers {
+		// Sanity check the servicer is not paused, jailed or unstaking
+		if !(servicer.PausedHeight == -1 && servicer.UnstakingHeight == -1) {
+			return fmt.Errorf(""hydrateSessionServicers should not have encountered a paused or unstaking servicer: %s"", servicer.Address)
+		}
+
+		// TODO(#XXX): Filter by geo-zone
+
+		// OPTIMIZE: If this was a map[string]struct{}, we could have avoided the loop
+		var chain string
+		for _, chain = range servicer.Chains {
+			if chain != s.session.RelayChain {
+				chain = """"
+				continue
+			}
+		}
+		if chain != """" {
+			candidateServicers = append(candidateServicers, servicer)
+		}
+	}
+
+	s.session.Servicers = pseudoRandomSelection(candidateServicers, numServicers, s.sessionIdBz)
+	return nil
 }
 
-// uses the current 'world state' to determine the servicers in the session
-// 1) get an ordered list of the public keys of servicers who are:
-//   - actively staked
-//   - staked within geo-zone (or closest geo-zones)
-//   - staked for relay-chain
-//
-// 2) calls `pseudoRandomSelection(servicers, numberOfNodesPerSession)`
-func (s *session) selectSessionServicers(numServicers int) ([]*coreTypes.Actor, types.Error) {
-	// IMPORTANT: This function is for behaviour illustrative purposes only and implementation may differ.
-	return nil, nil
+// hydrateSessionFishermen finds the fishermen that are staked at the session height and populates the session with them
+func (s *sessionHydrator) hydrateSessionFishermen() error {
+	// number of fisherman per session at this height
+	numFishermen, err := s.readCtx.GetIntParam(types.FishermanPerSessionParamName, s.session.SessionHeight)
+	if err != nil {
+		return err
+	}
+
+	// returns all the staked fisherman at this session height",utility/session.go,2023-04-19 20:11:43+00:00,2023-04-19T21:03:01Z,"""fishermen"" ",,,,,197,RIGHT,283,,line,https://api.github.com/repos/pokt-network/pocket/pulls/683,pokt-network/pocket,fb245bc027ae55aaee936daf9f85ecb2d9ad8b40
https://api.github.com/repos/pokt-network/pocket/pulls/683,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1171807268,dylanlott,cc15ba1ea64bab29113ec8247bc952b2cc657856,e2864b82e0b52b527cf11e0a05062f4779fef9fe,"@@ -1,157 +1,280 @@
 package utility
 
-// IMPORTANT: The interface and implementation defined in this file are for illustrative purposes only
-// and need to be revisited before any implementation commences.
-
 import (
 	""encoding/binary""
+	""encoding/hex""
+	""fmt""
+	""math""
+	""math/rand""
 
+	""github.com/pokt-network/pocket/logger""
 	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
 	""github.com/pokt-network/pocket/shared/crypto""
+	""github.com/pokt-network/pocket/shared/modules""
 	""github.com/pokt-network/pocket/utility/types""
+	""golang.org/x/exp/slices""
 )
 
-// TODO: When implementing please review if block height tolerance (+,-1) is included in the session protocol: pokt-network/pocket-core#1464 CC @Olshansk
-
-// REFACTOR: Move these into `utility/types` and consider creating an enum
-type RelayChain string
-type GeoZone string
-
-type Session interface {
-	NewSession(sessionHeight int64, relayChain RelayChain, geoZone GeoZone, application *coreTypes.Actor) (Session, types.Error)
-	GetSessionID() []byte             // the identifier of the dispatched session
-	GetSessionHeight() int64          // the block height when the session started
-	GetRelayChain() RelayChain        // the web3 chain identifier
-	GetGeoZone() GeoZone              // the geo-location zone where the application is intending to operate during the session
-	GetApplication() *coreTypes.Actor // the Application consuming the web3 access
-	GetServicers() []*coreTypes.Actor // the Servicers providing Web3 to the application
-	GetFishermen() []*coreTypes.Actor // the Fishermen monitoring the servicers
-}
+// sessionHydrator is an internal structure used to prepare a Session returned by `GetSession` below
+type sessionHydrator struct {
+	logger modules.Logger
+
+	// The height of the request for which the session is being hydrated
+	blockHeight int64
 
-var _ Session = &session{}
+	// The session being hydrated and returned
+	session *coreTypes.Session
 
-type session struct {
-	sessionId   []byte
-	height      int64
-	relayChain  RelayChain
-	geoZone     GeoZone
-	application *coreTypes.Actor
-	servicers   []*coreTypes.Actor
-	fishermen   []*coreTypes.Actor
+	// Caches a readCtx to avoid draining too many connections to the database
+	readCtx modules.PersistenceReadContext
+
+	// A redundant helper that maintains a hex decoded copy of `session.Id` used for session hydration
+	sessionIdBz []byte
 }
 
-func (*session) NewSession(
-	sessionHeight int64,
-	relayChain RelayChain,
-	geoZone GeoZone,
-	application *coreTypes.Actor,
-) (Session, types.Error) {
-	s := &session{
-		height:      sessionHeight,
-		relayChain:  relayChain,
-		geoZone:     geoZone,
-		application: application,
-	}
-
-	// TODO: make these configurable or based on governance params
-	numServicers := 1
-	numFisherman := 1
-
-	var err types.Error
-	if s.servicers, err = s.selectSessionServicers(numServicers); err != nil {
+// GetSession is an implementation of the exposed `UtilityModule.GetSession` function
+func (m *utilityModule) GetSession(appAddr string, height int64, relayChain, geoZone string) (*coreTypes.Session, error) {
+	persistenceModule := m.GetBus().GetPersistenceModule()
+	readCtx, err := persistenceModule.NewReadContext(height)
+	if err != nil {
 		return nil, err
 	}
-	if s.fishermen, err = s.selectSessionFishermen(numFisherman); err != nil {
+	defer readCtx.Release()
+
+	session := &coreTypes.Session{
+		RelayChain: relayChain,
+		GeoZone:    geoZone,
+	}
+
+	sessionHydrator := &sessionHydrator{
+		logger:      m.logger.With().Str(""source"", ""sessionHydrator"").Logger(),
+		blockHeight: height,
+		session:     session,
+		readCtx:     readCtx,
+	}
+
+	if err := sessionHydrator.hydrateSessionHeight(height); err != nil {
 		return nil, err
 	}
-	if s.sessionId, err = s.getSessionId(); err != nil {
+
+	if err := sessionHydrator.hydrateSessionApplication(appAddr); err != nil {
 		return nil, err
 	}
-	return s, nil
-}
 
-func (s *session) GetSessionID() []byte {
-	return s.sessionId
-}
+	if err := sessionHydrator.validateApplicationSession(); err != nil {
+		return nil, err
+	}
 
-func (s *session) GetSessionHeight() int64 {
-	return s.height
-}
+	if err := sessionHydrator.hydrateSessionID(); err != nil {
+		return nil, err
+	}
 
-func (s *session) GetRelayChain() RelayChain {
-	return s.relayChain
-}
+	if err := sessionHydrator.hydrateSessionServicers(); err != nil {
+		return nil, err
+	}
+
+	if err := sessionHydrator.hydrateSessionFishermen(); err != nil {
+		return nil, err
+	}
 
-func (s *session) GetGeoZone() GeoZone {
-	return s.geoZone
+	return sessionHydrator.session, nil
 }
 
-func (s *session) GetApplication() *coreTypes.Actor {
-	return s.application
+// hydrateSessionHeight hydrates the height at which the session started given the current block height
+func (s *sessionHydrator) hydrateSessionHeight(blockHeight int64) error {
+	numBlocksPerSession, err := s.readCtx.GetIntParam(types.BlocksPerSessionParamName, blockHeight)
+	if err != nil {
+		return err
+	}
+	numBlocksAheadOfSession := blockHeight % int64(numBlocksPerSession)
+
+	s.session.NumSessionBlocks = int64(numBlocksPerSession)
+	s.session.SessionNumber = int64(blockHeight / int64(numBlocksPerSession))
+	s.session.SessionHeight = blockHeight - numBlocksAheadOfSession
+	return nil
 }
 
-func (s *session) GetFishermen() []*coreTypes.Actor {
-	return s.fishermen
+// hydrateSessionApplication hydrates the full Application actor based on the address the session is being
+// dispatched for.
+func (s *sessionHydrator) hydrateSessionApplication(appAddr string) error {
+	// TECHDEBT: We can remove this decoding process once we use `strings` instead of `[]byte` for addresses
+	addr, err := hex.DecodeString(appAddr)
+	if err != nil {
+		return err
+	}
+	s.session.Application, err = s.readCtx.GetActor(coreTypes.ActorType_ACTOR_TYPE_APP, addr, s.session.SessionHeight)
+	return err
 }
 
-func (s *session) GetServicers() []*coreTypes.Actor {
-	return s.servicers
+// validateApplicationSession validates that the application can dispatch a session at the requested geo zone and for the request relay chain
+func (s *sessionHydrator) validateApplicationSession() error {
+	// TODO(#XXX): Filter by geo-zone
+	app := s.session.Application
+
+	if !slices.Contains(app.Chains, s.session.RelayChain) {
+		return fmt.Errorf(""application %s does not stake for relay chain %s"", app.Address, s.session.RelayChain)
+	}
+
+	if !(app.PausedHeight == -1 && app.UnstakingHeight == -1) {
+		return fmt.Errorf(""application %s is either unstaked or paused"", app.Address)
+	}
+
+	// TODO: Consider what else we should validate for here
+	return nil
 }
 
-// use the seed information to determine a SHA3Hash that is used to find the closest N actors based
-// by comparing the sessionKey with the actors' public key
-func (s *session) getSessionId() ([]byte, types.Error) {
+// hydrateSessionID use both session and on-chain data to determine a unique session ID
+func (s *sessionHydrator) hydrateSessionID() error {
 	sessionHeightBz := make([]byte, 8)
-	binary.LittleEndian.PutUint64(sessionHeightBz, uint64(s.height))
+	binary.LittleEndian.PutUint64(sessionHeightBz, uint64(s.session.SessionHeight))
 
-	blockHashBz := []byte(""get block hash bytes at s.sessionHeight from persistence module"")
+	prevHashHeight := int64(math.Max(float64(s.session.SessionHeight)-1, 0))
+	prevHash, err := s.readCtx.GetBlockHash(prevHashHeight)
+	if err != nil {
+		return err
+	}
+	prevHashBz, err := hex.DecodeString(prevHash)
 
-	appPubKey, err := crypto.NewPublicKey(s.application.GetPublicKey())
+	appPubKeyBz := []byte(s.session.Application.PublicKey)
+	relayChainBz := []byte(string(s.session.RelayChain))
+	geoZoneBz := []byte(s.session.GeoZone)
+
+	s.sessionIdBz = concat(sessionHeightBz, prevHashBz, geoZoneBz, relayChainBz, appPubKeyBz)
+	s.session.Id = crypto.GetHashStringFromBytes(s.sessionIdBz)
+
+	return nil
+}
+
+// hydrateSessionServicers finds the servicers that are staked at the session height and populates the session with them
+func (s *sessionHydrator) hydrateSessionServicers() error {
+	// number of servicers per session at this height
+	numServicers, err := s.readCtx.GetIntParam(types.ServicersPerSessionParamName, s.session.SessionHeight)
 	if err != nil {
-		return nil, types.ErrNewPublicKeyFromBytes(err)
+		return err
 	}
 
-	return concat(sessionHeightBz, blockHashBz, []byte(s.geoZone), []byte(s.relayChain), appPubKey.Bytes()), nil
+	// returns all the staked servicers at this session height
+	servicers, err := s.readCtx.GetAllServicers(s.session.SessionHeight)
+	if err != nil {
+		return err
+	}
+
+	// OPTIMIZE: Consider updating the persistence module so a single SQL query can retrieve all of the actors at once.
+	candidateServicers := make([]*coreTypes.Actor, 0)
+	for _, servicer := range servicers {
+		// Sanity check the servicer is not paused, jailed or unstaking
+		if !(servicer.PausedHeight == -1 && servicer.UnstakingHeight == -1) {
+			return fmt.Errorf(""hydrateSessionServicers should not have encountered a paused or unstaking servicer: %s"", servicer.Address)
+		}
+
+		// TODO(#XXX): Filter by geo-zone",utility/session.go,2023-04-19 20:12:25+00:00,2023-04-19T21:03:01Z,"Nit: would be great to have the issue number for this in the final version, but I'm sure you're planning on adding that.",,,,,170,RIGHT,246,,line,https://api.github.com/repos/pokt-network/pocket/pulls/683,pokt-network/pocket,fb245bc027ae55aaee936daf9f85ecb2d9ad8b40
https://api.github.com/repos/pokt-network/pocket/pulls/683,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1171818498,dylanlott,cc15ba1ea64bab29113ec8247bc952b2cc657856,e2864b82e0b52b527cf11e0a05062f4779fef9fe,"@@ -7,6 +7,11 @@ and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0
 
 ## [Unreleased]
 
+## [0.0.0.36] - 2023-04-18
+
+- Added a `fisherman_per_session` governance parameter
+- Updated the default `blocks_per_session` from `4` to `1`",build/docs/CHANGELOG.md,2023-04-19 20:25:25+00:00,2023-04-19T21:03:01Z,"What implications does this have across session and block creation? I can't find any numbers about this in the whitepaper, but I might not be looking hard enough.",,,,13.0,13,RIGHT,7,7.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/683,pokt-network/pocket,fb245bc027ae55aaee936daf9f85ecb2d9ad8b40
https://api.github.com/repos/pokt-network/pocket/pulls/683,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1171820405,dylanlott,cc15ba1ea64bab29113ec8247bc952b2cc657856,e2864b82e0b52b527cf11e0a05062f4779fef9fe,"@@ -7,6 +7,12 @@ and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0
 
 ## [Unreleased]
 
+## [0.0.0.49] - 2023-04-18
+
+- Implemented a new `GetActor` persistence modular functoin
+- Added `fisherman_per_session` parameter",persistence/docs/CHANGELOG.md,2023-04-19 20:27:06+00:00,2023-04-19T21:03:01Z,`fishermen_per_session`,,,,13.0,13,RIGHT,7,7.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/683,pokt-network/pocket,fb245bc027ae55aaee936daf9f85ecb2d9ad8b40
https://api.github.com/repos/pokt-network/pocket/pulls/683,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1171820923,dylanlott,cc15ba1ea64bab29113ec8247bc952b2cc657856,e2864b82e0b52b527cf11e0a05062f4779fef9fe,"@@ -57,7 +58,8 @@ func TestPersistenceContextParallelReadWrite(t *testing.T) {
 }
 
 func TestPersistenceContextTwoWritesErrors(t *testing.T) {
-	prepareAndCleanContext(t)
+	clearAllState()",persistence/test/module_test.go,2023-04-19 20:27:40+00:00,2023-04-19T21:03:01Z,Isn't this redundant if you're doing it in each `t.Cleanup`?,,,,61.0,61,RIGHT,15,15.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/683,pokt-network/pocket,fb245bc027ae55aaee936daf9f85ecb2d9ad8b40
https://api.github.com/repos/pokt-network/pocket/pulls/683,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1171822440,dylanlott,cc15ba1ea64bab29113ec8247bc952b2cc657856,e2864b82e0b52b527cf11e0a05062f4779fef9fe,"@@ -44,9 +44,9 @@ func TestStateHash_DeterministicStateWhenUpdatingAppStake(t *testing.T) {
 	// logic changes, these hashes will need to be updated based on the test output.
 	// TODO: Add an explicit updateSnapshots flag to the test to make this more clear.
 	stateHashes := []string{",persistence/test/state_test.go,2023-04-19 20:29:37+00:00,2023-04-19T21:03:02Z,Would this be better as a const since they shouldn't ever change?,,,,46.0,46,RIGHT,3,3.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/683,pokt-network/pocket,fb245bc027ae55aaee936daf9f85ecb2d9ad8b40
https://api.github.com/repos/pokt-network/pocket/pulls/683,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1171825622,dylanlott,cc15ba1ea64bab29113ec8247bc952b2cc657856,e2864b82e0b52b527cf11e0a05062f4779fef9fe,"@@ -130,6 +131,7 @@ type PersistenceWriteContext interface {
 
 type PersistenceReadContext interface {
 	// Context Operations
+	// TECHDEBT: Remove this function since read contexts are height agnostic - it's an accessor to the state of the blockchain at any height.",shared/modules/persistence_module.go,2023-04-19 20:33:34+00:00,2023-04-19T21:03:02Z,Definitely agree with this. Doing so also removes a potential error path 👍,,,,134.0,134,RIGHT,12,12.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/683,pokt-network/pocket,fb245bc027ae55aaee936daf9f85ecb2d9ad8b40
https://api.github.com/repos/pokt-network/pocket/pulls/683,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1171827832,dylanlott,cc15ba1ea64bab29113ec8247bc952b2cc657856,e2864b82e0b52b527cf11e0a05062f4779fef9fe,"@@ -1,157 +1,280 @@
 package utility
 
-// IMPORTANT: The interface and implementation defined in this file are for illustrative purposes only
-// and need to be revisited before any implementation commences.
-
 import (
 	""encoding/binary""
+	""encoding/hex""
+	""fmt""
+	""math""
+	""math/rand""
 
+	""github.com/pokt-network/pocket/logger""
 	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
 	""github.com/pokt-network/pocket/shared/crypto""
+	""github.com/pokt-network/pocket/shared/modules""
 	""github.com/pokt-network/pocket/utility/types""
+	""golang.org/x/exp/slices""
 )
 
-// TODO: When implementing please review if block height tolerance (+,-1) is included in the session protocol: pokt-network/pocket-core#1464 CC @Olshansk
-
-// REFACTOR: Move these into `utility/types` and consider creating an enum
-type RelayChain string
-type GeoZone string
-
-type Session interface {
-	NewSession(sessionHeight int64, relayChain RelayChain, geoZone GeoZone, application *coreTypes.Actor) (Session, types.Error)
-	GetSessionID() []byte             // the identifier of the dispatched session
-	GetSessionHeight() int64          // the block height when the session started
-	GetRelayChain() RelayChain        // the web3 chain identifier
-	GetGeoZone() GeoZone              // the geo-location zone where the application is intending to operate during the session
-	GetApplication() *coreTypes.Actor // the Application consuming the web3 access
-	GetServicers() []*coreTypes.Actor // the Servicers providing Web3 to the application
-	GetFishermen() []*coreTypes.Actor // the Fishermen monitoring the servicers
-}
+// sessionHydrator is an internal structure used to prepare a Session returned by `GetSession` below
+type sessionHydrator struct {
+	logger modules.Logger
+
+	// The height of the request for which the session is being hydrated
+	blockHeight int64
 
-var _ Session = &session{}
+	// The session being hydrated and returned
+	session *coreTypes.Session
 
-type session struct {
-	sessionId   []byte
-	height      int64
-	relayChain  RelayChain
-	geoZone     GeoZone
-	application *coreTypes.Actor
-	servicers   []*coreTypes.Actor
-	fishermen   []*coreTypes.Actor
+	// Caches a readCtx to avoid draining too many connections to the database
+	readCtx modules.PersistenceReadContext
+
+	// A redundant helper that maintains a hex decoded copy of `session.Id` used for session hydration
+	sessionIdBz []byte
 }
 
-func (*session) NewSession(
-	sessionHeight int64,
-	relayChain RelayChain,
-	geoZone GeoZone,
-	application *coreTypes.Actor,
-) (Session, types.Error) {
-	s := &session{
-		height:      sessionHeight,
-		relayChain:  relayChain,
-		geoZone:     geoZone,
-		application: application,
-	}
-
-	// TODO: make these configurable or based on governance params
-	numServicers := 1
-	numFisherman := 1
-
-	var err types.Error
-	if s.servicers, err = s.selectSessionServicers(numServicers); err != nil {
+// GetSession is an implementation of the exposed `UtilityModule.GetSession` function
+func (m *utilityModule) GetSession(appAddr string, height int64, relayChain, geoZone string) (*coreTypes.Session, error) {
+	persistenceModule := m.GetBus().GetPersistenceModule()
+	readCtx, err := persistenceModule.NewReadContext(height)
+	if err != nil {
 		return nil, err
 	}
-	if s.fishermen, err = s.selectSessionFishermen(numFisherman); err != nil {
+	defer readCtx.Release()
+
+	session := &coreTypes.Session{
+		RelayChain: relayChain,
+		GeoZone:    geoZone,
+	}
+
+	sessionHydrator := &sessionHydrator{
+		logger:      m.logger.With().Str(""source"", ""sessionHydrator"").Logger(),
+		blockHeight: height,
+		session:     session,
+		readCtx:     readCtx,
+	}
+
+	if err := sessionHydrator.hydrateSessionHeight(height); err != nil {
 		return nil, err
 	}
-	if s.sessionId, err = s.getSessionId(); err != nil {
+
+	if err := sessionHydrator.hydrateSessionApplication(appAddr); err != nil {
 		return nil, err
 	}
-	return s, nil
-}
 
-func (s *session) GetSessionID() []byte {
-	return s.sessionId
-}
+	if err := sessionHydrator.validateApplicationSession(); err != nil {
+		return nil, err
+	}
 
-func (s *session) GetSessionHeight() int64 {
-	return s.height
-}
+	if err := sessionHydrator.hydrateSessionID(); err != nil {
+		return nil, err
+	}
 
-func (s *session) GetRelayChain() RelayChain {
-	return s.relayChain
-}
+	if err := sessionHydrator.hydrateSessionServicers(); err != nil {
+		return nil, err
+	}
+
+	if err := sessionHydrator.hydrateSessionFishermen(); err != nil {
+		return nil, err
+	}
 
-func (s *session) GetGeoZone() GeoZone {
-	return s.geoZone
+	return sessionHydrator.session, nil
 }
 
-func (s *session) GetApplication() *coreTypes.Actor {
-	return s.application
+// hydrateSessionHeight hydrates the height at which the session started given the current block height
+func (s *sessionHydrator) hydrateSessionHeight(blockHeight int64) error {
+	numBlocksPerSession, err := s.readCtx.GetIntParam(types.BlocksPerSessionParamName, blockHeight)
+	if err != nil {
+		return err
+	}
+	numBlocksAheadOfSession := blockHeight % int64(numBlocksPerSession)
+
+	s.session.NumSessionBlocks = int64(numBlocksPerSession)
+	s.session.SessionNumber = int64(blockHeight / int64(numBlocksPerSession))
+	s.session.SessionHeight = blockHeight - numBlocksAheadOfSession
+	return nil
 }
 
-func (s *session) GetFishermen() []*coreTypes.Actor {
-	return s.fishermen
+// hydrateSessionApplication hydrates the full Application actor based on the address the session is being
+// dispatched for.
+func (s *sessionHydrator) hydrateSessionApplication(appAddr string) error {
+	// TECHDEBT: We can remove this decoding process once we use `strings` instead of `[]byte` for addresses
+	addr, err := hex.DecodeString(appAddr)
+	if err != nil {
+		return err
+	}
+	s.session.Application, err = s.readCtx.GetActor(coreTypes.ActorType_ACTOR_TYPE_APP, addr, s.session.SessionHeight)
+	return err
 }
 
-func (s *session) GetServicers() []*coreTypes.Actor {
-	return s.servicers
+// validateApplicationSession validates that the application can dispatch a session at the requested geo zone and for the request relay chain
+func (s *sessionHydrator) validateApplicationSession() error {
+	// TODO(#XXX): Filter by geo-zone
+	app := s.session.Application
+
+	if !slices.Contains(app.Chains, s.session.RelayChain) {
+		return fmt.Errorf(""application %s does not stake for relay chain %s"", app.Address, s.session.RelayChain)
+	}
+
+	if !(app.PausedHeight == -1 && app.UnstakingHeight == -1) {
+		return fmt.Errorf(""application %s is either unstaked or paused"", app.Address)
+	}
+
+	// TODO: Consider what else we should validate for here
+	return nil
 }
 
-// use the seed information to determine a SHA3Hash that is used to find the closest N actors based
-// by comparing the sessionKey with the actors' public key
-func (s *session) getSessionId() ([]byte, types.Error) {
+// hydrateSessionID use both session and on-chain data to determine a unique session ID
+func (s *sessionHydrator) hydrateSessionID() error {
 	sessionHeightBz := make([]byte, 8)
-	binary.LittleEndian.PutUint64(sessionHeightBz, uint64(s.height))
+	binary.LittleEndian.PutUint64(sessionHeightBz, uint64(s.session.SessionHeight))
 
-	blockHashBz := []byte(""get block hash bytes at s.sessionHeight from persistence module"")
+	prevHashHeight := int64(math.Max(float64(s.session.SessionHeight)-1, 0))
+	prevHash, err := s.readCtx.GetBlockHash(prevHashHeight)
+	if err != nil {
+		return err
+	}
+	prevHashBz, err := hex.DecodeString(prevHash)
 
-	appPubKey, err := crypto.NewPublicKey(s.application.GetPublicKey())
+	appPubKeyBz := []byte(s.session.Application.PublicKey)
+	relayChainBz := []byte(string(s.session.RelayChain))
+	geoZoneBz := []byte(s.session.GeoZone)
+
+	s.sessionIdBz = concat(sessionHeightBz, prevHashBz, geoZoneBz, relayChainBz, appPubKeyBz)
+	s.session.Id = crypto.GetHashStringFromBytes(s.sessionIdBz)
+
+	return nil
+}
+
+// hydrateSessionServicers finds the servicers that are staked at the session height and populates the session with them
+func (s *sessionHydrator) hydrateSessionServicers() error {
+	// number of servicers per session at this height
+	numServicers, err := s.readCtx.GetIntParam(types.ServicersPerSessionParamName, s.session.SessionHeight)
 	if err != nil {
-		return nil, types.ErrNewPublicKeyFromBytes(err)
+		return err
 	}
 
-	return concat(sessionHeightBz, blockHashBz, []byte(s.geoZone), []byte(s.relayChain), appPubKey.Bytes()), nil
+	// returns all the staked servicers at this session height
+	servicers, err := s.readCtx.GetAllServicers(s.session.SessionHeight)
+	if err != nil {
+		return err
+	}
+
+	// OPTIMIZE: Consider updating the persistence module so a single SQL query can retrieve all of the actors at once.
+	candidateServicers := make([]*coreTypes.Actor, 0)
+	for _, servicer := range servicers {
+		// Sanity check the servicer is not paused, jailed or unstaking
+		if !(servicer.PausedHeight == -1 && servicer.UnstakingHeight == -1) {
+			return fmt.Errorf(""hydrateSessionServicers should not have encountered a paused or unstaking servicer: %s"", servicer.Address)
+		}
+
+		// TODO(#XXX): Filter by geo-zone
+
+		// OPTIMIZE: If this was a map[string]struct{}, we could have avoided the loop
+		var chain string
+		for _, chain = range servicer.Chains {
+			if chain != s.session.RelayChain {
+				chain = """"
+				continue
+			}
+		}
+		if chain != """" {
+			candidateServicers = append(candidateServicers, servicer)
+		}
+	}
+
+	s.session.Servicers = pseudoRandomSelection(candidateServicers, numServicers, s.sessionIdBz)
+	return nil
 }
 
-// uses the current 'world state' to determine the servicers in the session
-// 1) get an ordered list of the public keys of servicers who are:
-//   - actively staked
-//   - staked within geo-zone (or closest geo-zones)
-//   - staked for relay-chain
-//
-// 2) calls `pseudoRandomSelection(servicers, numberOfNodesPerSession)`
-func (s *session) selectSessionServicers(numServicers int) ([]*coreTypes.Actor, types.Error) {
-	// IMPORTANT: This function is for behaviour illustrative purposes only and implementation may differ.
-	return nil, nil
+// hydrateSessionFishermen finds the fishermen that are staked at the session height and populates the session with them
+func (s *sessionHydrator) hydrateSessionFishermen() error {
+	// number of fisherman per session at this height",utility/session.go,2023-04-19 20:36:17+00:00,2023-04-19T21:03:02Z,"""number of _fishermen_""",,,,,191,RIGHT,277,,line,https://api.github.com/repos/pokt-network/pocket/pulls/683,pokt-network/pocket,fb245bc027ae55aaee936daf9f85ecb2d9ad8b40
https://api.github.com/repos/pokt-network/pocket/pulls/683,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1171828752,dylanlott,cc15ba1ea64bab29113ec8247bc952b2cc657856,e2864b82e0b52b527cf11e0a05062f4779fef9fe,"@@ -1,157 +1,280 @@
 package utility
 
-// IMPORTANT: The interface and implementation defined in this file are for illustrative purposes only
-// and need to be revisited before any implementation commences.
-
 import (
 	""encoding/binary""
+	""encoding/hex""
+	""fmt""
+	""math""
+	""math/rand""
 
+	""github.com/pokt-network/pocket/logger""
 	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
 	""github.com/pokt-network/pocket/shared/crypto""
+	""github.com/pokt-network/pocket/shared/modules""
 	""github.com/pokt-network/pocket/utility/types""
+	""golang.org/x/exp/slices""
 )
 
-// TODO: When implementing please review if block height tolerance (+,-1) is included in the session protocol: pokt-network/pocket-core#1464 CC @Olshansk
-
-// REFACTOR: Move these into `utility/types` and consider creating an enum
-type RelayChain string
-type GeoZone string
-
-type Session interface {
-	NewSession(sessionHeight int64, relayChain RelayChain, geoZone GeoZone, application *coreTypes.Actor) (Session, types.Error)
-	GetSessionID() []byte             // the identifier of the dispatched session
-	GetSessionHeight() int64          // the block height when the session started
-	GetRelayChain() RelayChain        // the web3 chain identifier
-	GetGeoZone() GeoZone              // the geo-location zone where the application is intending to operate during the session
-	GetApplication() *coreTypes.Actor // the Application consuming the web3 access
-	GetServicers() []*coreTypes.Actor // the Servicers providing Web3 to the application
-	GetFishermen() []*coreTypes.Actor // the Fishermen monitoring the servicers
-}
+// sessionHydrator is an internal structure used to prepare a Session returned by `GetSession` below
+type sessionHydrator struct {
+	logger modules.Logger
+
+	// The height of the request for which the session is being hydrated
+	blockHeight int64
 
-var _ Session = &session{}
+	// The session being hydrated and returned
+	session *coreTypes.Session
 
-type session struct {
-	sessionId   []byte
-	height      int64
-	relayChain  RelayChain
-	geoZone     GeoZone
-	application *coreTypes.Actor
-	servicers   []*coreTypes.Actor
-	fishermen   []*coreTypes.Actor
+	// Caches a readCtx to avoid draining too many connections to the database
+	readCtx modules.PersistenceReadContext
+
+	// A redundant helper that maintains a hex decoded copy of `session.Id` used for session hydration
+	sessionIdBz []byte
 }
 
-func (*session) NewSession(
-	sessionHeight int64,
-	relayChain RelayChain,
-	geoZone GeoZone,
-	application *coreTypes.Actor,
-) (Session, types.Error) {
-	s := &session{
-		height:      sessionHeight,
-		relayChain:  relayChain,
-		geoZone:     geoZone,
-		application: application,
-	}
-
-	// TODO: make these configurable or based on governance params
-	numServicers := 1
-	numFisherman := 1
-
-	var err types.Error
-	if s.servicers, err = s.selectSessionServicers(numServicers); err != nil {
+// GetSession is an implementation of the exposed `UtilityModule.GetSession` function
+func (m *utilityModule) GetSession(appAddr string, height int64, relayChain, geoZone string) (*coreTypes.Session, error) {
+	persistenceModule := m.GetBus().GetPersistenceModule()
+	readCtx, err := persistenceModule.NewReadContext(height)
+	if err != nil {
 		return nil, err
 	}
-	if s.fishermen, err = s.selectSessionFishermen(numFisherman); err != nil {
+	defer readCtx.Release()
+
+	session := &coreTypes.Session{
+		RelayChain: relayChain,
+		GeoZone:    geoZone,
+	}
+
+	sessionHydrator := &sessionHydrator{
+		logger:      m.logger.With().Str(""source"", ""sessionHydrator"").Logger(),
+		blockHeight: height,
+		session:     session,
+		readCtx:     readCtx,
+	}
+
+	if err := sessionHydrator.hydrateSessionHeight(height); err != nil {
 		return nil, err
 	}
-	if s.sessionId, err = s.getSessionId(); err != nil {
+
+	if err := sessionHydrator.hydrateSessionApplication(appAddr); err != nil {
 		return nil, err
 	}
-	return s, nil
-}
 
-func (s *session) GetSessionID() []byte {
-	return s.sessionId
-}
+	if err := sessionHydrator.validateApplicationSession(); err != nil {
+		return nil, err
+	}
 
-func (s *session) GetSessionHeight() int64 {
-	return s.height
-}
+	if err := sessionHydrator.hydrateSessionID(); err != nil {
+		return nil, err
+	}
 
-func (s *session) GetRelayChain() RelayChain {
-	return s.relayChain
-}
+	if err := sessionHydrator.hydrateSessionServicers(); err != nil {
+		return nil, err
+	}
+
+	if err := sessionHydrator.hydrateSessionFishermen(); err != nil {
+		return nil, err
+	}
 
-func (s *session) GetGeoZone() GeoZone {
-	return s.geoZone
+	return sessionHydrator.session, nil
 }
 
-func (s *session) GetApplication() *coreTypes.Actor {
-	return s.application
+// hydrateSessionHeight hydrates the height at which the session started given the current block height
+func (s *sessionHydrator) hydrateSessionHeight(blockHeight int64) error {
+	numBlocksPerSession, err := s.readCtx.GetIntParam(types.BlocksPerSessionParamName, blockHeight)
+	if err != nil {
+		return err
+	}
+	numBlocksAheadOfSession := blockHeight % int64(numBlocksPerSession)
+
+	s.session.NumSessionBlocks = int64(numBlocksPerSession)
+	s.session.SessionNumber = int64(blockHeight / int64(numBlocksPerSession))
+	s.session.SessionHeight = blockHeight - numBlocksAheadOfSession
+	return nil
 }
 
-func (s *session) GetFishermen() []*coreTypes.Actor {
-	return s.fishermen
+// hydrateSessionApplication hydrates the full Application actor based on the address the session is being
+// dispatched for.
+func (s *sessionHydrator) hydrateSessionApplication(appAddr string) error {
+	// TECHDEBT: We can remove this decoding process once we use `strings` instead of `[]byte` for addresses
+	addr, err := hex.DecodeString(appAddr)
+	if err != nil {
+		return err
+	}
+	s.session.Application, err = s.readCtx.GetActor(coreTypes.ActorType_ACTOR_TYPE_APP, addr, s.session.SessionHeight)
+	return err
 }
 
-func (s *session) GetServicers() []*coreTypes.Actor {
-	return s.servicers
+// validateApplicationSession validates that the application can dispatch a session at the requested geo zone and for the request relay chain
+func (s *sessionHydrator) validateApplicationSession() error {
+	// TODO(#XXX): Filter by geo-zone
+	app := s.session.Application
+
+	if !slices.Contains(app.Chains, s.session.RelayChain) {
+		return fmt.Errorf(""application %s does not stake for relay chain %s"", app.Address, s.session.RelayChain)
+	}
+
+	if !(app.PausedHeight == -1 && app.UnstakingHeight == -1) {
+		return fmt.Errorf(""application %s is either unstaked or paused"", app.Address)
+	}
+
+	// TODO: Consider what else we should validate for here
+	return nil
 }
 
-// use the seed information to determine a SHA3Hash that is used to find the closest N actors based
-// by comparing the sessionKey with the actors' public key
-func (s *session) getSessionId() ([]byte, types.Error) {
+// hydrateSessionID use both session and on-chain data to determine a unique session ID
+func (s *sessionHydrator) hydrateSessionID() error {
 	sessionHeightBz := make([]byte, 8)
-	binary.LittleEndian.PutUint64(sessionHeightBz, uint64(s.height))
+	binary.LittleEndian.PutUint64(sessionHeightBz, uint64(s.session.SessionHeight))
 
-	blockHashBz := []byte(""get block hash bytes at s.sessionHeight from persistence module"")
+	prevHashHeight := int64(math.Max(float64(s.session.SessionHeight)-1, 0))
+	prevHash, err := s.readCtx.GetBlockHash(prevHashHeight)
+	if err != nil {
+		return err
+	}
+	prevHashBz, err := hex.DecodeString(prevHash)
 
-	appPubKey, err := crypto.NewPublicKey(s.application.GetPublicKey())
+	appPubKeyBz := []byte(s.session.Application.PublicKey)
+	relayChainBz := []byte(string(s.session.RelayChain))
+	geoZoneBz := []byte(s.session.GeoZone)
+
+	s.sessionIdBz = concat(sessionHeightBz, prevHashBz, geoZoneBz, relayChainBz, appPubKeyBz)
+	s.session.Id = crypto.GetHashStringFromBytes(s.sessionIdBz)
+
+	return nil
+}
+
+// hydrateSessionServicers finds the servicers that are staked at the session height and populates the session with them
+func (s *sessionHydrator) hydrateSessionServicers() error {
+	// number of servicers per session at this height
+	numServicers, err := s.readCtx.GetIntParam(types.ServicersPerSessionParamName, s.session.SessionHeight)
 	if err != nil {
-		return nil, types.ErrNewPublicKeyFromBytes(err)
+		return err
 	}
 
-	return concat(sessionHeightBz, blockHashBz, []byte(s.geoZone), []byte(s.relayChain), appPubKey.Bytes()), nil
+	// returns all the staked servicers at this session height
+	servicers, err := s.readCtx.GetAllServicers(s.session.SessionHeight)
+	if err != nil {
+		return err
+	}
+
+	// OPTIMIZE: Consider updating the persistence module so a single SQL query can retrieve all of the actors at once.
+	candidateServicers := make([]*coreTypes.Actor, 0)
+	for _, servicer := range servicers {
+		// Sanity check the servicer is not paused, jailed or unstaking
+		if !(servicer.PausedHeight == -1 && servicer.UnstakingHeight == -1) {
+			return fmt.Errorf(""hydrateSessionServicers should not have encountered a paused or unstaking servicer: %s"", servicer.Address)
+		}
+
+		// TODO(#XXX): Filter by geo-zone
+
+		// OPTIMIZE: If this was a map[string]struct{}, we could have avoided the loop
+		var chain string
+		for _, chain = range servicer.Chains {
+			if chain != s.session.RelayChain {
+				chain = """"
+				continue
+			}
+		}
+		if chain != """" {
+			candidateServicers = append(candidateServicers, servicer)
+		}
+	}
+
+	s.session.Servicers = pseudoRandomSelection(candidateServicers, numServicers, s.sessionIdBz)
+	return nil
 }
 
-// uses the current 'world state' to determine the servicers in the session
-// 1) get an ordered list of the public keys of servicers who are:
-//   - actively staked
-//   - staked within geo-zone (or closest geo-zones)
-//   - staked for relay-chain
-//
-// 2) calls `pseudoRandomSelection(servicers, numberOfNodesPerSession)`
-func (s *session) selectSessionServicers(numServicers int) ([]*coreTypes.Actor, types.Error) {
-	// IMPORTANT: This function is for behaviour illustrative purposes only and implementation may differ.
-	return nil, nil
+// hydrateSessionFishermen finds the fishermen that are staked at the session height and populates the session with them
+func (s *sessionHydrator) hydrateSessionFishermen() error {
+	// number of fisherman per session at this height
+	numFishermen, err := s.readCtx.GetIntParam(types.FishermanPerSessionParamName, s.session.SessionHeight)
+	if err != nil {
+		return err
+	}
+
+	// returns all the staked fisherman at this session height
+	fishermen, err := s.readCtx.GetAllFishermen(s.session.SessionHeight)
+	if err != nil {
+		return err
+	}
+
+	// OPTIMIZE: Consider updating the persistence module so a single SQL query can retrieve all of the actors at once.
+	candidateFishermen := make([]*coreTypes.Actor, 0)
+	for _, fisherman := range fishermen {",utility/session.go,2023-04-19 20:37:06+00:00,2023-04-19T21:03:45Z,"Consider ""fisher"" instead of ""fisherman""",,,,,205,RIGHT,291,,line,https://api.github.com/repos/pokt-network/pocket/pulls/683,pokt-network/pocket,fb245bc027ae55aaee936daf9f85ecb2d9ad8b40
https://api.github.com/repos/pokt-network/pocket/pulls/683,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1171829906,dylanlott,cc15ba1ea64bab29113ec8247bc952b2cc657856,e2864b82e0b52b527cf11e0a05062f4779fef9fe,"@@ -4138,6 +4138,7 @@
     ""fisherman_unstaking_blocks"": 2016,
     ""fisherman_minimum_pause_blocks"": 4,",build/config/genesis.json,2023-04-19 20:38:21+00:00,2023-04-19T21:03:02Z,"All of these config values should be `fishermen` I think? Unless there's only ever a single fisher per session, I would say it should be plural. Either way, I won't leave any more comments about this to avoid more duplication.",,,,4139.0,4139,RIGHT,2,11.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/683,pokt-network/pocket,fb245bc027ae55aaee936daf9f85ecb2d9ad8b40
https://api.github.com/repos/pokt-network/pocket/pulls/683,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1171830229,dylanlott,cc15ba1ea64bab29113ec8247bc952b2cc657856,e2864b82e0b52b527cf11e0a05062f4779fef9fe,"@@ -7,6 +7,11 @@ and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0
 
 ## [Unreleased]
 
+## [0.0.0.36] - 2023-04-18
+
+- Added a `fisherman_per_session` governance parameter",build/docs/CHANGELOG.md,2023-04-19 20:38:45+00:00,2023-04-19T21:03:02Z,`fishermen_per_session`,,,,12.0,12,RIGHT,6,6.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/683,pokt-network/pocket,fb245bc027ae55aaee936daf9f85ecb2d9ad8b40
https://api.github.com/repos/pokt-network/pocket/pulls/683,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1171838568,dylanlott,cc15ba1ea64bab29113ec8247bc952b2cc657856,e2864b82e0b52b527cf11e0a05062f4779fef9fe,"@@ -1,157 +1,280 @@
 package utility
 
-// IMPORTANT: The interface and implementation defined in this file are for illustrative purposes only
-// and need to be revisited before any implementation commences.
-
 import (
 	""encoding/binary""
+	""encoding/hex""
+	""fmt""
+	""math""
+	""math/rand""
 
+	""github.com/pokt-network/pocket/logger""
 	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
 	""github.com/pokt-network/pocket/shared/crypto""
+	""github.com/pokt-network/pocket/shared/modules""
 	""github.com/pokt-network/pocket/utility/types""
+	""golang.org/x/exp/slices""
 )
 
-// TODO: When implementing please review if block height tolerance (+,-1) is included in the session protocol: pokt-network/pocket-core#1464 CC @Olshansk
-
-// REFACTOR: Move these into `utility/types` and consider creating an enum
-type RelayChain string
-type GeoZone string
-
-type Session interface {
-	NewSession(sessionHeight int64, relayChain RelayChain, geoZone GeoZone, application *coreTypes.Actor) (Session, types.Error)
-	GetSessionID() []byte             // the identifier of the dispatched session
-	GetSessionHeight() int64          // the block height when the session started
-	GetRelayChain() RelayChain        // the web3 chain identifier
-	GetGeoZone() GeoZone              // the geo-location zone where the application is intending to operate during the session
-	GetApplication() *coreTypes.Actor // the Application consuming the web3 access
-	GetServicers() []*coreTypes.Actor // the Servicers providing Web3 to the application
-	GetFishermen() []*coreTypes.Actor // the Fishermen monitoring the servicers
-}
+// sessionHydrator is an internal structure used to prepare a Session returned by `GetSession` below
+type sessionHydrator struct {
+	logger modules.Logger
+
+	// The height of the request for which the session is being hydrated
+	blockHeight int64
 
-var _ Session = &session{}
+	// The session being hydrated and returned
+	session *coreTypes.Session
 
-type session struct {
-	sessionId   []byte
-	height      int64
-	relayChain  RelayChain
-	geoZone     GeoZone
-	application *coreTypes.Actor
-	servicers   []*coreTypes.Actor
-	fishermen   []*coreTypes.Actor
+	// Caches a readCtx to avoid draining too many connections to the database
+	readCtx modules.PersistenceReadContext
+
+	// A redundant helper that maintains a hex decoded copy of `session.Id` used for session hydration
+	sessionIdBz []byte
 }
 
-func (*session) NewSession(
-	sessionHeight int64,
-	relayChain RelayChain,
-	geoZone GeoZone,
-	application *coreTypes.Actor,
-) (Session, types.Error) {
-	s := &session{
-		height:      sessionHeight,
-		relayChain:  relayChain,
-		geoZone:     geoZone,
-		application: application,
-	}
-
-	// TODO: make these configurable or based on governance params
-	numServicers := 1
-	numFisherman := 1
-
-	var err types.Error
-	if s.servicers, err = s.selectSessionServicers(numServicers); err != nil {
+// GetSession is an implementation of the exposed `UtilityModule.GetSession` function
+func (m *utilityModule) GetSession(appAddr string, height int64, relayChain, geoZone string) (*coreTypes.Session, error) {
+	persistenceModule := m.GetBus().GetPersistenceModule()
+	readCtx, err := persistenceModule.NewReadContext(height)
+	if err != nil {
 		return nil, err
 	}
-	if s.fishermen, err = s.selectSessionFishermen(numFisherman); err != nil {
+	defer readCtx.Release()
+
+	session := &coreTypes.Session{
+		RelayChain: relayChain,
+		GeoZone:    geoZone,
+	}
+
+	sessionHydrator := &sessionHydrator{
+		logger:      m.logger.With().Str(""source"", ""sessionHydrator"").Logger(),
+		blockHeight: height,
+		session:     session,
+		readCtx:     readCtx,
+	}
+
+	if err := sessionHydrator.hydrateSessionHeight(height); err != nil {
 		return nil, err
 	}
-	if s.sessionId, err = s.getSessionId(); err != nil {
+
+	if err := sessionHydrator.hydrateSessionApplication(appAddr); err != nil {
 		return nil, err
 	}
-	return s, nil
-}
 
-func (s *session) GetSessionID() []byte {
-	return s.sessionId
-}
+	if err := sessionHydrator.validateApplicationSession(); err != nil {
+		return nil, err
+	}
 
-func (s *session) GetSessionHeight() int64 {
-	return s.height
-}
+	if err := sessionHydrator.hydrateSessionID(); err != nil {
+		return nil, err
+	}
 
-func (s *session) GetRelayChain() RelayChain {
-	return s.relayChain
-}
+	if err := sessionHydrator.hydrateSessionServicers(); err != nil {
+		return nil, err
+	}
+
+	if err := sessionHydrator.hydrateSessionFishermen(); err != nil {
+		return nil, err
+	}
 
-func (s *session) GetGeoZone() GeoZone {
-	return s.geoZone
+	return sessionHydrator.session, nil
 }
 
-func (s *session) GetApplication() *coreTypes.Actor {
-	return s.application
+// hydrateSessionHeight hydrates the height at which the session started given the current block height
+func (s *sessionHydrator) hydrateSessionHeight(blockHeight int64) error {
+	numBlocksPerSession, err := s.readCtx.GetIntParam(types.BlocksPerSessionParamName, blockHeight)
+	if err != nil {
+		return err
+	}
+	numBlocksAheadOfSession := blockHeight % int64(numBlocksPerSession)
+
+	s.session.NumSessionBlocks = int64(numBlocksPerSession)
+	s.session.SessionNumber = int64(blockHeight / int64(numBlocksPerSession))
+	s.session.SessionHeight = blockHeight - numBlocksAheadOfSession
+	return nil
 }
 
-func (s *session) GetFishermen() []*coreTypes.Actor {
-	return s.fishermen
+// hydrateSessionApplication hydrates the full Application actor based on the address the session is being
+// dispatched for.
+func (s *sessionHydrator) hydrateSessionApplication(appAddr string) error {
+	// TECHDEBT: We can remove this decoding process once we use `strings` instead of `[]byte` for addresses
+	addr, err := hex.DecodeString(appAddr)
+	if err != nil {
+		return err
+	}
+	s.session.Application, err = s.readCtx.GetActor(coreTypes.ActorType_ACTOR_TYPE_APP, addr, s.session.SessionHeight)
+	return err
 }
 
-func (s *session) GetServicers() []*coreTypes.Actor {
-	return s.servicers
+// validateApplicationSession validates that the application can dispatch a session at the requested geo zone and for the request relay chain
+func (s *sessionHydrator) validateApplicationSession() error {
+	// TODO(#XXX): Filter by geo-zone
+	app := s.session.Application
+
+	if !slices.Contains(app.Chains, s.session.RelayChain) {
+		return fmt.Errorf(""application %s does not stake for relay chain %s"", app.Address, s.session.RelayChain)
+	}
+
+	if !(app.PausedHeight == -1 && app.UnstakingHeight == -1) {
+		return fmt.Errorf(""application %s is either unstaked or paused"", app.Address)
+	}
+
+	// TODO: Consider what else we should validate for here
+	return nil
 }
 
-// use the seed information to determine a SHA3Hash that is used to find the closest N actors based
-// by comparing the sessionKey with the actors' public key
-func (s *session) getSessionId() ([]byte, types.Error) {
+// hydrateSessionID use both session and on-chain data to determine a unique session ID
+func (s *sessionHydrator) hydrateSessionID() error {
 	sessionHeightBz := make([]byte, 8)
-	binary.LittleEndian.PutUint64(sessionHeightBz, uint64(s.height))
+	binary.LittleEndian.PutUint64(sessionHeightBz, uint64(s.session.SessionHeight))
 
-	blockHashBz := []byte(""get block hash bytes at s.sessionHeight from persistence module"")
+	prevHashHeight := int64(math.Max(float64(s.session.SessionHeight)-1, 0))
+	prevHash, err := s.readCtx.GetBlockHash(prevHashHeight)
+	if err != nil {
+		return err
+	}
+	prevHashBz, err := hex.DecodeString(prevHash)
 
-	appPubKey, err := crypto.NewPublicKey(s.application.GetPublicKey())
+	appPubKeyBz := []byte(s.session.Application.PublicKey)
+	relayChainBz := []byte(string(s.session.RelayChain))
+	geoZoneBz := []byte(s.session.GeoZone)
+
+	s.sessionIdBz = concat(sessionHeightBz, prevHashBz, geoZoneBz, relayChainBz, appPubKeyBz)
+	s.session.Id = crypto.GetHashStringFromBytes(s.sessionIdBz)
+
+	return nil
+}
+
+// hydrateSessionServicers finds the servicers that are staked at the session height and populates the session with them
+func (s *sessionHydrator) hydrateSessionServicers() error {
+	// number of servicers per session at this height
+	numServicers, err := s.readCtx.GetIntParam(types.ServicersPerSessionParamName, s.session.SessionHeight)
 	if err != nil {
-		return nil, types.ErrNewPublicKeyFromBytes(err)
+		return err
 	}
 
-	return concat(sessionHeightBz, blockHashBz, []byte(s.geoZone), []byte(s.relayChain), appPubKey.Bytes()), nil
+	// returns all the staked servicers at this session height
+	servicers, err := s.readCtx.GetAllServicers(s.session.SessionHeight)
+	if err != nil {
+		return err
+	}
+
+	// OPTIMIZE: Consider updating the persistence module so a single SQL query can retrieve all of the actors at once.
+	candidateServicers := make([]*coreTypes.Actor, 0)
+	for _, servicer := range servicers {
+		// Sanity check the servicer is not paused, jailed or unstaking
+		if !(servicer.PausedHeight == -1 && servicer.UnstakingHeight == -1) {
+			return fmt.Errorf(""hydrateSessionServicers should not have encountered a paused or unstaking servicer: %s"", servicer.Address)
+		}
+
+		// TODO(#XXX): Filter by geo-zone
+
+		// OPTIMIZE: If this was a map[string]struct{}, we could have avoided the loop
+		var chain string
+		for _, chain = range servicer.Chains {
+			if chain != s.session.RelayChain {
+				chain = """"
+				continue
+			}
+		}
+		if chain != """" {
+			candidateServicers = append(candidateServicers, servicer)
+		}
+	}
+
+	s.session.Servicers = pseudoRandomSelection(candidateServicers, numServicers, s.sessionIdBz)
+	return nil
 }
 
-// uses the current 'world state' to determine the servicers in the session
-// 1) get an ordered list of the public keys of servicers who are:
-//   - actively staked
-//   - staked within geo-zone (or closest geo-zones)
-//   - staked for relay-chain
-//
-// 2) calls `pseudoRandomSelection(servicers, numberOfNodesPerSession)`
-func (s *session) selectSessionServicers(numServicers int) ([]*coreTypes.Actor, types.Error) {
-	// IMPORTANT: This function is for behaviour illustrative purposes only and implementation may differ.
-	return nil, nil
+// hydrateSessionFishermen finds the fishermen that are staked at the session height and populates the session with them
+func (s *sessionHydrator) hydrateSessionFishermen() error {
+	// number of fisherman per session at this height
+	numFishermen, err := s.readCtx.GetIntParam(types.FishermanPerSessionParamName, s.session.SessionHeight)
+	if err != nil {
+		return err
+	}
+
+	// returns all the staked fisherman at this session height
+	fishermen, err := s.readCtx.GetAllFishermen(s.session.SessionHeight)
+	if err != nil {
+		return err
+	}
+
+	// OPTIMIZE: Consider updating the persistence module so a single SQL query can retrieve all of the actors at once.
+	candidateFishermen := make([]*coreTypes.Actor, 0)
+	for _, fisherman := range fishermen {
+		// Sanity check the fisherman is not paused, jailed or unstaking
+		if !(fisherman.PausedHeight == -1 && fisherman.UnstakingHeight == -1) {
+			return fmt.Errorf(""hydrateSessionFishermen should not have encountered a paused or unstaking fisherman: %s"", fisherman.Address)
+		}
+
+		// TODO(#XXX): Filter by geo-zone
+
+		// OPTIMIZE: If this was a map[string]struct{}, we could have avoided the loop
+		var chain string
+		for _, chain = range fisherman.Chains {
+			if chain != s.session.RelayChain {
+				chain = """"
+				continue
+			}
+		}
+		if chain != """" {
+			candidateFishermen = append(candidateFishermen, fisherman)
+		}
+	}
+
+	s.session.Fishermen = pseudoRandomSelection(candidateFishermen, numFishermen, s.sessionIdBz)
+	return nil
 }
 
-// uses the current 'world state' to determine the fishermen in the session
-// 1) get an ordered list of the public keys of fishermen who are:
-//   - actively staked
-//   - staked within geo-zone  (or closest geo-zones)
-//   - staked for relay-chain
-//
-// 2) calls `pseudoRandomSelection(fishermen, numberOfFishPerSession)`
-func (s *session) selectSessionFishermen(numFishermen int) ([]*coreTypes.Actor, types.Error) {
-	// IMPORTANT: This function is for behaviour illustrative purposes only and implementation may differ.
-	return nil, nil
+// pseudoRandomSelection returns a random subset of the candidates.
+// TECHDEBT: We are using a `Go` native implementation for a pseudo-random number generator. In order
+// for it to be language agnostic, a general purpose algorithm needs ot be used.",utility/session.go,2023-04-19 20:48:28+00:00,2023-04-19T21:03:02Z,Good subject for an ADR as we implement Session handling 🚀,,231.0,RIGHT,,232,RIGHT,328,,line,https://api.github.com/repos/pokt-network/pocket/pulls/683,pokt-network/pocket,fb245bc027ae55aaee936daf9f85ecb2d9ad8b40
https://api.github.com/repos/pokt-network/pocket/pulls/683,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1173557619,bryanchriswhite,c723b33e617e0622e4431df83ec52a2c4ae4d958,e2864b82e0b52b527cf11e0a05062f4779fef9fe,"@@ -436,8 +436,10 @@ benchmark_p2p_peerstore: ## Run P2P peerstore benchmarks
 
 ### Inspired by @goldinguy_ in this post: https://goldin.io/blog/stop-using-todo ###
 # TODO          - General Purpose catch-all.
+# ADR           - A TODO that will require a full on ADR in the future",Makefile,2023-04-21 09:31:00+00:00,2023-04-21T09:31:01Z,"How do you feel about `DECIDE` or `DECISION` instead? I think totally makes sense to use `ADR` in the description but I suspect the todo itself would read nicer in context:

```
// DECIDE: whether to support X
...
// DECISION: how to optimize for Y
```",,,,,439,RIGHT,4,,line,https://api.github.com/repos/pokt-network/pocket/pulls/683,pokt-network/pocket,fb245bc027ae55aaee936daf9f85ecb2d9ad8b40
https://api.github.com/repos/pokt-network/pocket/pulls/683,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1173557820,bryanchriswhite,c723b33e617e0622e4431df83ec52a2c4ae4d958,e2864b82e0b52b527cf11e0a05062f4779fef9fe,"@@ -41,8 +41,8 @@ var (
 	StakeToUpdate        = utils.BigIntToString((&big.Int{}).Add(DefaultStakeBig, DefaultDeltaBig))
 
 	DefaultStakeStatus     = int32(coreTypes.StakeStatus_Staked)
-	DefaultPauseHeight     = int64(-1) // pauseHeight=-1 means not paused
-	DefaultUnstakingHeight = int64(-1) // pauseHeight=-1 means not unstaking
+	DefaultPauseHeight     = int64(-1) // pauseHeight=-1 implies not paused
+	DefaultUnstakingHeight = int64(-1) // unstakingHeight=-1 implies not unstaking",persistence/test/setup_test.go,2023-04-21 09:31:11+00:00,2023-04-21T09:31:11Z,I appreciate your making the distinction between `means` and `implies` :sunglasses: ,44.0,44.0,LEFT,45.0,45,RIGHT,7,7.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/683,pokt-network/pocket,fb245bc027ae55aaee936daf9f85ecb2d9ad8b40
https://api.github.com/repos/pokt-network/pocket/pulls/683,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1173565356,bryanchriswhite,c723b33e617e0622e4431df83ec52a2c4ae4d958,e2864b82e0b52b527cf11e0a05062f4779fef9fe,"@@ -6,108 +6,149 @@ import (
 	""fmt""
 	""strconv""
 
+	""github.com/pokt-network/pocket/logger""
 	""github.com/pokt-network/pocket/runtime/configs""
 	""github.com/pokt-network/pocket/runtime/genesis""
 	""github.com/pokt-network/pocket/runtime/test_artifacts/keygen""
+	""github.com/pokt-network/pocket/shared/core/types""
 	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
 	""github.com/pokt-network/pocket/shared/crypto""
 	""google.golang.org/protobuf/types/known/timestamppb""
 )
 
-// IMPROVE: Generate a proper genesis suite in the future.
-func NewGenesisState(numValidators, numServicers, numApplications, numFisherman int) (genesisState *genesis.GenesisState, validatorPrivateKeys []string) {
-	apps, appsPrivateKeys := NewActors(coreTypes.ActorType_ACTOR_TYPE_APP, numApplications)
-	vals, validatorPrivateKeys := NewActors(coreTypes.ActorType_ACTOR_TYPE_VAL, numValidators)
-	servicers, snPrivateKeys := NewActors(coreTypes.ActorType_ACTOR_TYPE_SERVICER, numServicers)
-	fish, fishPrivateKeys := NewActors(coreTypes.ActorType_ACTOR_TYPE_FISH, numFisherman)
+type GenesisOption func(*genesis.GenesisState)
+
+// IMPROVE: Extend the utilities here into a proper genesis suite in the future.
+func NewGenesisState(numValidators, numServicers, numApplications, numFisherman int, genesisOpts ...GenesisOption) (genesisState *genesis.GenesisState, validatorPrivateKeys []string) {",runtime/test_artifacts/generator.go,2023-04-21 09:38:48+00:00,2023-04-21T09:39:35Z,What do you think about multi-lining this signature for readability?,,,,,22,RIGHT,23,,line,https://api.github.com/repos/pokt-network/pocket/pulls/683,pokt-network/pocket,fb245bc027ae55aaee936daf9f85ecb2d9ad8b40
https://api.github.com/repos/pokt-network/pocket/pulls/683,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1173573637,bryanchriswhite,c723b33e617e0622e4431df83ec52a2c4ae4d958,e2864b82e0b52b527cf11e0a05062f4779fef9fe,"@@ -6,108 +6,149 @@ import (
 	""fmt""
 	""strconv""
 
+	""github.com/pokt-network/pocket/logger""
 	""github.com/pokt-network/pocket/runtime/configs""
 	""github.com/pokt-network/pocket/runtime/genesis""
 	""github.com/pokt-network/pocket/runtime/test_artifacts/keygen""
+	""github.com/pokt-network/pocket/shared/core/types""
 	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
 	""github.com/pokt-network/pocket/shared/crypto""
 	""google.golang.org/protobuf/types/known/timestamppb""
 )
 
-// IMPROVE: Generate a proper genesis suite in the future.
-func NewGenesisState(numValidators, numServicers, numApplications, numFisherman int) (genesisState *genesis.GenesisState, validatorPrivateKeys []string) {
-	apps, appsPrivateKeys := NewActors(coreTypes.ActorType_ACTOR_TYPE_APP, numApplications)
-	vals, validatorPrivateKeys := NewActors(coreTypes.ActorType_ACTOR_TYPE_VAL, numValidators)
-	servicers, snPrivateKeys := NewActors(coreTypes.ActorType_ACTOR_TYPE_SERVICER, numServicers)
-	fish, fishPrivateKeys := NewActors(coreTypes.ActorType_ACTOR_TYPE_FISH, numFisherman)
+type GenesisOption func(*genesis.GenesisState)
+
+// IMPROVE: Extend the utilities here into a proper genesis suite in the future.
+func NewGenesisState(numValidators, numServicers, numApplications, numFisherman int, genesisOpts ...GenesisOption) (genesisState *genesis.GenesisState, validatorPrivateKeys []string) {
+	applications, appPrivateKeys := NewActors(coreTypes.ActorType_ACTOR_TYPE_APP, numApplications, DefaultChains)
+	validators, validatorPrivateKeys := NewActors(coreTypes.ActorType_ACTOR_TYPE_VAL, numValidators, nil)
+	servicers, servicerPrivateKeys := NewActors(coreTypes.ActorType_ACTOR_TYPE_SERVICER, numServicers, DefaultChains)
+	fishermen, fishPrivateKeys := NewActors(coreTypes.ActorType_ACTOR_TYPE_FISH, numFisherman, DefaultChains)
+
+	allActorsKeys := append(append(append(validatorPrivateKeys, servicerPrivateKeys...), fishPrivateKeys...), appPrivateKeys...)
+	allActorAccounts := newAccountsWithKeys(allActorsKeys)
 
 	genesisState = &genesis.GenesisState{
 		GenesisTime:   timestamppb.Now(),
 		ChainId:       DefaultChainID,
 		MaxBlockBytes: DefaultMaxBlockBytes,
 		Pools:         NewPools(),
-		Accounts:      NewAccounts(numValidators+numServicers+numApplications+numFisherman, append(append(append(validatorPrivateKeys, snPrivateKeys...), fishPrivateKeys...), appsPrivateKeys...)...), // TODO(olshansky): clean this up
-		Applications:  apps,
-		Validators:    vals,
+		Accounts:      allActorAccounts,
+		Applications:  applications,
+		Validators:    validators,
 		Servicers:     servicers,
-		Fishermen:     fish,
+		Fishermen:     fishermen,
 		Params:        DefaultParams(),
 	}
 
-	// TODO: Generalize this to all actors and not just validators
+	for _, o := range genesisOpts {
+		o(genesisState)
+	}
+
+	// TECHDEBT: Generalize this to all actors and not just validators
 	return genesisState, validatorPrivateKeys
 }
 
+func WithActors(actors []*coreTypes.Actor, actorKeys []string) func(*genesis.GenesisState) {
+	return func(genesis *genesis.GenesisState) {
+		newActorAccounts := newAccountsWithKeys(actorKeys)
+		genesis.Accounts = append(genesis.Accounts, newActorAccounts...)
+		for _, actor := range actors {
+			switch actor.ActorType {
+			case types.ActorType_ACTOR_TYPE_APP:
+				genesis.Applications = append(genesis.Applications, actor)
+			case coreTypes.ActorType_ACTOR_TYPE_VAL:
+				genesis.Validators = append(genesis.Validators, actor)
+			case coreTypes.ActorType_ACTOR_TYPE_SERVICER:
+				genesis.Servicers = append(genesis.Servicers, actor)
+			case coreTypes.ActorType_ACTOR_TYPE_FISH:
+				genesis.Fishermen = append(genesis.Fishermen, actor)
+			default:
+				panic(fmt.Sprintf(""invalid actor type: %s"", actor.ActorType))
+			}
+		}
+	}
+}
+
 func NewDefaultConfigs(privateKeys []string) (cfgs []*configs.Config) {
 	for i, pk := range privateKeys {
+		postgresSchema := ""node"" + strconv.Itoa(i+1)",runtime/test_artifacts/generator.go,2023-04-21 09:47:07+00:00,2023-04-21T09:48:34Z,"1. Where is this convention derived from? Can we link back to it or some docs in a comment?
2. nit: I think it would improve maintainability slightly if we move this to a helper function. ",,,,,75,RIGHT,81,,line,https://api.github.com/repos/pokt-network/pocket/pulls/683,pokt-network/pocket,fb245bc027ae55aaee936daf9f85ecb2d9ad8b40
https://api.github.com/repos/pokt-network/pocket/pulls/683,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1173577698,bryanchriswhite,c723b33e617e0622e4431df83ec52a2c4ae4d958,e2864b82e0b52b527cf11e0a05062f4779fef9fe,"@@ -6,108 +6,149 @@ import (
 	""fmt""
 	""strconv""
 
+	""github.com/pokt-network/pocket/logger""
 	""github.com/pokt-network/pocket/runtime/configs""
 	""github.com/pokt-network/pocket/runtime/genesis""
 	""github.com/pokt-network/pocket/runtime/test_artifacts/keygen""
+	""github.com/pokt-network/pocket/shared/core/types""
 	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
 	""github.com/pokt-network/pocket/shared/crypto""
 	""google.golang.org/protobuf/types/known/timestamppb""
 )
 
-// IMPROVE: Generate a proper genesis suite in the future.
-func NewGenesisState(numValidators, numServicers, numApplications, numFisherman int) (genesisState *genesis.GenesisState, validatorPrivateKeys []string) {
-	apps, appsPrivateKeys := NewActors(coreTypes.ActorType_ACTOR_TYPE_APP, numApplications)
-	vals, validatorPrivateKeys := NewActors(coreTypes.ActorType_ACTOR_TYPE_VAL, numValidators)
-	servicers, snPrivateKeys := NewActors(coreTypes.ActorType_ACTOR_TYPE_SERVICER, numServicers)
-	fish, fishPrivateKeys := NewActors(coreTypes.ActorType_ACTOR_TYPE_FISH, numFisherman)
+type GenesisOption func(*genesis.GenesisState)
+
+// IMPROVE: Extend the utilities here into a proper genesis suite in the future.
+func NewGenesisState(numValidators, numServicers, numApplications, numFisherman int, genesisOpts ...GenesisOption) (genesisState *genesis.GenesisState, validatorPrivateKeys []string) {
+	applications, appPrivateKeys := NewActors(coreTypes.ActorType_ACTOR_TYPE_APP, numApplications, DefaultChains)
+	validators, validatorPrivateKeys := NewActors(coreTypes.ActorType_ACTOR_TYPE_VAL, numValidators, nil)
+	servicers, servicerPrivateKeys := NewActors(coreTypes.ActorType_ACTOR_TYPE_SERVICER, numServicers, DefaultChains)
+	fishermen, fishPrivateKeys := NewActors(coreTypes.ActorType_ACTOR_TYPE_FISH, numFisherman, DefaultChains)
+
+	allActorsKeys := append(append(append(validatorPrivateKeys, servicerPrivateKeys...), fishPrivateKeys...), appPrivateKeys...)
+	allActorAccounts := newAccountsWithKeys(allActorsKeys)
 
 	genesisState = &genesis.GenesisState{
 		GenesisTime:   timestamppb.Now(),
 		ChainId:       DefaultChainID,
 		MaxBlockBytes: DefaultMaxBlockBytes,
 		Pools:         NewPools(),
-		Accounts:      NewAccounts(numValidators+numServicers+numApplications+numFisherman, append(append(append(validatorPrivateKeys, snPrivateKeys...), fishPrivateKeys...), appsPrivateKeys...)...), // TODO(olshansky): clean this up
-		Applications:  apps,
-		Validators:    vals,
+		Accounts:      allActorAccounts,
+		Applications:  applications,
+		Validators:    validators,
 		Servicers:     servicers,
-		Fishermen:     fish,
+		Fishermen:     fishermen,
 		Params:        DefaultParams(),
 	}
 
-	// TODO: Generalize this to all actors and not just validators
+	for _, o := range genesisOpts {
+		o(genesisState)
+	}
+
+	// TECHDEBT: Generalize this to all actors and not just validators
 	return genesisState, validatorPrivateKeys
 }
 
+func WithActors(actors []*coreTypes.Actor, actorKeys []string) func(*genesis.GenesisState) {
+	return func(genesis *genesis.GenesisState) {
+		newActorAccounts := newAccountsWithKeys(actorKeys)
+		genesis.Accounts = append(genesis.Accounts, newActorAccounts...)
+		for _, actor := range actors {
+			switch actor.ActorType {
+			case types.ActorType_ACTOR_TYPE_APP:
+				genesis.Applications = append(genesis.Applications, actor)
+			case coreTypes.ActorType_ACTOR_TYPE_VAL:
+				genesis.Validators = append(genesis.Validators, actor)
+			case coreTypes.ActorType_ACTOR_TYPE_SERVICER:
+				genesis.Servicers = append(genesis.Servicers, actor)
+			case coreTypes.ActorType_ACTOR_TYPE_FISH:
+				genesis.Fishermen = append(genesis.Fishermen, actor)
+			default:
+				panic(fmt.Sprintf(""invalid actor type: %s"", actor.ActorType))
+			}
+		}
+	}
+}
+
 func NewDefaultConfigs(privateKeys []string) (cfgs []*configs.Config) {
 	for i, pk := range privateKeys {
+		postgresSchema := ""node"" + strconv.Itoa(i+1)
 		cfgs = append(cfgs, configs.NewDefaultConfig(
 			configs.WithPK(pk),
-			configs.WithNodeSchema(""node""+strconv.Itoa(i+1)),
+			configs.WithNodeSchema(postgresSchema),
 		))
 	}
-	return
+	return cfgs
 }
 
-// REFACTOR: Test artifact generator should reflect the sum of the initial account values to populate the initial pool values
 func NewPools() (pools []*coreTypes.Account) {
 	for _, value := range coreTypes.Pools_value {
 		if value == int32(coreTypes.Pools_POOLS_UNSPECIFIED) {
 			continue
 		}
 
+		// TECHDEBT: Test artifact should reflect the sum of the initial account values
+		// rather than be set to `DefaultAccountAmountString`
 		amount := DefaultAccountAmountString
 		if value == int32(coreTypes.Pools_POOLS_FEE_COLLECTOR) {
-			amount = ""0""
+			amount = ""0"" // fees are empty at genesis
 		}
 
+		poolAddr := hex.EncodeToString(coreTypes.Pools(value).Address())
+
 		pools = append(pools, &coreTypes.Account{
-			Address: hex.EncodeToString(coreTypes.Pools(value).Address()),
+			Address: poolAddr,
 			Amount:  amount,
 		})
 	}
-	return
+	return pools
+}
+
+func newAccountsWithKeys(privateKeys []string) (accounts []*coreTypes.Account) {
+	for _, pk := range privateKeys {
+		pk, _ := crypto.NewPrivateKey(pk)
+		addr := pk.Address().String()
+		accounts = append(accounts, &coreTypes.Account{
+			Address: addr,
+			Amount:  DefaultAccountAmountString,
+		})
+	}
+	return accounts
 }
 
-func NewAccounts(n int, privateKeys ...string) (accounts []*coreTypes.Account) {
-	for i := 0; i < n; i++ {
+//nolint:unused
+func newAccounts(numActors int) (accounts []*coreTypes.Account) {",runtime/test_artifacts/generator.go,2023-04-21 09:51:20+00:00,2023-04-21T09:51:20Z,Do you anticipate needing this soon? Would you mind adding comment?,,119.0,RIGHT,,120,RIGHT,134,,line,https://api.github.com/repos/pokt-network/pocket/pulls/683,pokt-network/pocket,fb245bc027ae55aaee936daf9f85ecb2d9ad8b40
https://api.github.com/repos/pokt-network/pocket/pulls/683,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1173578890,bryanchriswhite,c723b33e617e0622e4431df83ec52a2c4ae4d958,e2864b82e0b52b527cf11e0a05062f4779fef9fe,"@@ -6,108 +6,149 @@ import (
 	""fmt""
 	""strconv""
 
+	""github.com/pokt-network/pocket/logger""
 	""github.com/pokt-network/pocket/runtime/configs""
 	""github.com/pokt-network/pocket/runtime/genesis""
 	""github.com/pokt-network/pocket/runtime/test_artifacts/keygen""
+	""github.com/pokt-network/pocket/shared/core/types""
 	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
 	""github.com/pokt-network/pocket/shared/crypto""
 	""google.golang.org/protobuf/types/known/timestamppb""
 )
 
-// IMPROVE: Generate a proper genesis suite in the future.
-func NewGenesisState(numValidators, numServicers, numApplications, numFisherman int) (genesisState *genesis.GenesisState, validatorPrivateKeys []string) {
-	apps, appsPrivateKeys := NewActors(coreTypes.ActorType_ACTOR_TYPE_APP, numApplications)
-	vals, validatorPrivateKeys := NewActors(coreTypes.ActorType_ACTOR_TYPE_VAL, numValidators)
-	servicers, snPrivateKeys := NewActors(coreTypes.ActorType_ACTOR_TYPE_SERVICER, numServicers)
-	fish, fishPrivateKeys := NewActors(coreTypes.ActorType_ACTOR_TYPE_FISH, numFisherman)
+type GenesisOption func(*genesis.GenesisState)
+
+// IMPROVE: Extend the utilities here into a proper genesis suite in the future.
+func NewGenesisState(numValidators, numServicers, numApplications, numFisherman int, genesisOpts ...GenesisOption) (genesisState *genesis.GenesisState, validatorPrivateKeys []string) {
+	applications, appPrivateKeys := NewActors(coreTypes.ActorType_ACTOR_TYPE_APP, numApplications, DefaultChains)
+	validators, validatorPrivateKeys := NewActors(coreTypes.ActorType_ACTOR_TYPE_VAL, numValidators, nil)
+	servicers, servicerPrivateKeys := NewActors(coreTypes.ActorType_ACTOR_TYPE_SERVICER, numServicers, DefaultChains)
+	fishermen, fishPrivateKeys := NewActors(coreTypes.ActorType_ACTOR_TYPE_FISH, numFisherman, DefaultChains)
+
+	allActorsKeys := append(append(append(validatorPrivateKeys, servicerPrivateKeys...), fishPrivateKeys...), appPrivateKeys...)
+	allActorAccounts := newAccountsWithKeys(allActorsKeys)
 
 	genesisState = &genesis.GenesisState{
 		GenesisTime:   timestamppb.Now(),
 		ChainId:       DefaultChainID,
 		MaxBlockBytes: DefaultMaxBlockBytes,
 		Pools:         NewPools(),
-		Accounts:      NewAccounts(numValidators+numServicers+numApplications+numFisherman, append(append(append(validatorPrivateKeys, snPrivateKeys...), fishPrivateKeys...), appsPrivateKeys...)...), // TODO(olshansky): clean this up
-		Applications:  apps,
-		Validators:    vals,
+		Accounts:      allActorAccounts,
+		Applications:  applications,
+		Validators:    validators,
 		Servicers:     servicers,
-		Fishermen:     fish,
+		Fishermen:     fishermen,
 		Params:        DefaultParams(),
 	}
 
-	// TODO: Generalize this to all actors and not just validators
+	for _, o := range genesisOpts {
+		o(genesisState)
+	}
+
+	// TECHDEBT: Generalize this to all actors and not just validators
 	return genesisState, validatorPrivateKeys
 }
 
+func WithActors(actors []*coreTypes.Actor, actorKeys []string) func(*genesis.GenesisState) {
+	return func(genesis *genesis.GenesisState) {
+		newActorAccounts := newAccountsWithKeys(actorKeys)
+		genesis.Accounts = append(genesis.Accounts, newActorAccounts...)
+		for _, actor := range actors {
+			switch actor.ActorType {
+			case types.ActorType_ACTOR_TYPE_APP:
+				genesis.Applications = append(genesis.Applications, actor)
+			case coreTypes.ActorType_ACTOR_TYPE_VAL:
+				genesis.Validators = append(genesis.Validators, actor)
+			case coreTypes.ActorType_ACTOR_TYPE_SERVICER:
+				genesis.Servicers = append(genesis.Servicers, actor)
+			case coreTypes.ActorType_ACTOR_TYPE_FISH:
+				genesis.Fishermen = append(genesis.Fishermen, actor)
+			default:
+				panic(fmt.Sprintf(""invalid actor type: %s"", actor.ActorType))
+			}
+		}
+	}
+}
+
 func NewDefaultConfigs(privateKeys []string) (cfgs []*configs.Config) {
 	for i, pk := range privateKeys {
+		postgresSchema := ""node"" + strconv.Itoa(i+1)
 		cfgs = append(cfgs, configs.NewDefaultConfig(
 			configs.WithPK(pk),
-			configs.WithNodeSchema(""node""+strconv.Itoa(i+1)),
+			configs.WithNodeSchema(postgresSchema),
 		))
 	}
-	return
+	return cfgs
 }
 
-// REFACTOR: Test artifact generator should reflect the sum of the initial account values to populate the initial pool values
 func NewPools() (pools []*coreTypes.Account) {
 	for _, value := range coreTypes.Pools_value {
 		if value == int32(coreTypes.Pools_POOLS_UNSPECIFIED) {
 			continue
 		}
 
+		// TECHDEBT: Test artifact should reflect the sum of the initial account values
+		// rather than be set to `DefaultAccountAmountString`
 		amount := DefaultAccountAmountString
 		if value == int32(coreTypes.Pools_POOLS_FEE_COLLECTOR) {
-			amount = ""0""
+			amount = ""0"" // fees are empty at genesis
 		}
 
+		poolAddr := hex.EncodeToString(coreTypes.Pools(value).Address())
+
 		pools = append(pools, &coreTypes.Account{
-			Address: hex.EncodeToString(coreTypes.Pools(value).Address()),
+			Address: poolAddr,
 			Amount:  amount,
 		})
 	}
-	return
+	return pools
+}
+
+func newAccountsWithKeys(privateKeys []string) (accounts []*coreTypes.Account) {
+	for _, pk := range privateKeys {
+		pk, _ := crypto.NewPrivateKey(pk)
+		addr := pk.Address().String()
+		accounts = append(accounts, &coreTypes.Account{
+			Address: addr,
+			Amount:  DefaultAccountAmountString,
+		})
+	}
+	return accounts
 }
 
-func NewAccounts(n int, privateKeys ...string) (accounts []*coreTypes.Account) {
-	for i := 0; i < n; i++ {
+//nolint:unused
+func newAccounts(numActors int) (accounts []*coreTypes.Account) {
+	for i := 0; i < numActors; i++ {
 		_, _, addr := keygen.GetInstance().Next()
-		if privateKeys != nil {
-			pk, _ := crypto.NewPrivateKey(privateKeys[i])
-			addr = pk.Address().String()
-		}
 		accounts = append(accounts, &coreTypes.Account{
 			Address: addr,
 			Amount:  DefaultAccountAmountString,
 		})
 	}
-	return
+	return accounts
 }
 
-// TODO: The current implementation of NewActors  will have overlapping `ServiceUrl` for different
-//
-//	types of actors which needs to be fixed.
-func NewActors(actorType coreTypes.ActorType, n int) (actors []*coreTypes.Actor, privateKeys []string) {
-	for i := 0; i < n; i++ {
+// TECHDEBT: Current implementation of `NewActors` will result in non-unique ServiceURLs if called
+// more than once.",runtime/test_artifacts/generator.go,2023-04-21 09:52:32+00:00,2023-04-21T09:52:33Z,:ok_hand: Nice clarification!,148.0,131.0,RIGHT,149.0,132,RIGHT,156,174.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/683,pokt-network/pocket,fb245bc027ae55aaee936daf9f85ecb2d9ad8b40
https://api.github.com/repos/pokt-network/pocket/pulls/683,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1173583019,bryanchriswhite,c723b33e617e0622e4431df83ec52a2c4ae4d958,e2864b82e0b52b527cf11e0a05062f4779fef9fe,"@@ -6,108 +6,149 @@ import (
 	""fmt""
 	""strconv""
 
+	""github.com/pokt-network/pocket/logger""
 	""github.com/pokt-network/pocket/runtime/configs""
 	""github.com/pokt-network/pocket/runtime/genesis""
 	""github.com/pokt-network/pocket/runtime/test_artifacts/keygen""
+	""github.com/pokt-network/pocket/shared/core/types""
 	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
 	""github.com/pokt-network/pocket/shared/crypto""
 	""google.golang.org/protobuf/types/known/timestamppb""
 )
 
-// IMPROVE: Generate a proper genesis suite in the future.
-func NewGenesisState(numValidators, numServicers, numApplications, numFisherman int) (genesisState *genesis.GenesisState, validatorPrivateKeys []string) {
-	apps, appsPrivateKeys := NewActors(coreTypes.ActorType_ACTOR_TYPE_APP, numApplications)
-	vals, validatorPrivateKeys := NewActors(coreTypes.ActorType_ACTOR_TYPE_VAL, numValidators)
-	servicers, snPrivateKeys := NewActors(coreTypes.ActorType_ACTOR_TYPE_SERVICER, numServicers)
-	fish, fishPrivateKeys := NewActors(coreTypes.ActorType_ACTOR_TYPE_FISH, numFisherman)
+type GenesisOption func(*genesis.GenesisState)
+
+// IMPROVE: Extend the utilities here into a proper genesis suite in the future.
+func NewGenesisState(numValidators, numServicers, numApplications, numFisherman int, genesisOpts ...GenesisOption) (genesisState *genesis.GenesisState, validatorPrivateKeys []string) {
+	applications, appPrivateKeys := NewActors(coreTypes.ActorType_ACTOR_TYPE_APP, numApplications, DefaultChains)
+	validators, validatorPrivateKeys := NewActors(coreTypes.ActorType_ACTOR_TYPE_VAL, numValidators, nil)
+	servicers, servicerPrivateKeys := NewActors(coreTypes.ActorType_ACTOR_TYPE_SERVICER, numServicers, DefaultChains)
+	fishermen, fishPrivateKeys := NewActors(coreTypes.ActorType_ACTOR_TYPE_FISH, numFisherman, DefaultChains)
+
+	allActorsKeys := append(append(append(validatorPrivateKeys, servicerPrivateKeys...), fishPrivateKeys...), appPrivateKeys...)
+	allActorAccounts := newAccountsWithKeys(allActorsKeys)
 
 	genesisState = &genesis.GenesisState{
 		GenesisTime:   timestamppb.Now(),
 		ChainId:       DefaultChainID,
 		MaxBlockBytes: DefaultMaxBlockBytes,
 		Pools:         NewPools(),
-		Accounts:      NewAccounts(numValidators+numServicers+numApplications+numFisherman, append(append(append(validatorPrivateKeys, snPrivateKeys...), fishPrivateKeys...), appsPrivateKeys...)...), // TODO(olshansky): clean this up
-		Applications:  apps,
-		Validators:    vals,
+		Accounts:      allActorAccounts,
+		Applications:  applications,
+		Validators:    validators,
 		Servicers:     servicers,
-		Fishermen:     fish,
+		Fishermen:     fishermen,
 		Params:        DefaultParams(),
 	}
 
-	// TODO: Generalize this to all actors and not just validators
+	for _, o := range genesisOpts {
+		o(genesisState)
+	}
+
+	// TECHDEBT: Generalize this to all actors and not just validators
 	return genesisState, validatorPrivateKeys
 }
 
+func WithActors(actors []*coreTypes.Actor, actorKeys []string) func(*genesis.GenesisState) {
+	return func(genesis *genesis.GenesisState) {
+		newActorAccounts := newAccountsWithKeys(actorKeys)
+		genesis.Accounts = append(genesis.Accounts, newActorAccounts...)
+		for _, actor := range actors {
+			switch actor.ActorType {
+			case types.ActorType_ACTOR_TYPE_APP:
+				genesis.Applications = append(genesis.Applications, actor)
+			case coreTypes.ActorType_ACTOR_TYPE_VAL:
+				genesis.Validators = append(genesis.Validators, actor)
+			case coreTypes.ActorType_ACTOR_TYPE_SERVICER:
+				genesis.Servicers = append(genesis.Servicers, actor)
+			case coreTypes.ActorType_ACTOR_TYPE_FISH:
+				genesis.Fishermen = append(genesis.Fishermen, actor)
+			default:
+				panic(fmt.Sprintf(""invalid actor type: %s"", actor.ActorType))
+			}
+		}
+	}
+}
+
 func NewDefaultConfigs(privateKeys []string) (cfgs []*configs.Config) {
 	for i, pk := range privateKeys {
+		postgresSchema := ""node"" + strconv.Itoa(i+1)
 		cfgs = append(cfgs, configs.NewDefaultConfig(
 			configs.WithPK(pk),
-			configs.WithNodeSchema(""node""+strconv.Itoa(i+1)),
+			configs.WithNodeSchema(postgresSchema),
 		))
 	}
-	return
+	return cfgs
 }
 
-// REFACTOR: Test artifact generator should reflect the sum of the initial account values to populate the initial pool values
 func NewPools() (pools []*coreTypes.Account) {
 	for _, value := range coreTypes.Pools_value {
 		if value == int32(coreTypes.Pools_POOLS_UNSPECIFIED) {
 			continue
 		}
 
+		// TECHDEBT: Test artifact should reflect the sum of the initial account values
+		// rather than be set to `DefaultAccountAmountString`
 		amount := DefaultAccountAmountString
 		if value == int32(coreTypes.Pools_POOLS_FEE_COLLECTOR) {
-			amount = ""0""
+			amount = ""0"" // fees are empty at genesis
 		}
 
+		poolAddr := hex.EncodeToString(coreTypes.Pools(value).Address())
+
 		pools = append(pools, &coreTypes.Account{
-			Address: hex.EncodeToString(coreTypes.Pools(value).Address()),
+			Address: poolAddr,
 			Amount:  amount,
 		})
 	}
-	return
+	return pools
+}
+
+func newAccountsWithKeys(privateKeys []string) (accounts []*coreTypes.Account) {
+	for _, pk := range privateKeys {
+		pk, _ := crypto.NewPrivateKey(pk)
+		addr := pk.Address().String()
+		accounts = append(accounts, &coreTypes.Account{
+			Address: addr,
+			Amount:  DefaultAccountAmountString,
+		})
+	}
+	return accounts
 }
 
-func NewAccounts(n int, privateKeys ...string) (accounts []*coreTypes.Account) {
-	for i := 0; i < n; i++ {
+//nolint:unused
+func newAccounts(numActors int) (accounts []*coreTypes.Account) {
+	for i := 0; i < numActors; i++ {
 		_, _, addr := keygen.GetInstance().Next()
-		if privateKeys != nil {
-			pk, _ := crypto.NewPrivateKey(privateKeys[i])
-			addr = pk.Address().String()
-		}
 		accounts = append(accounts, &coreTypes.Account{
 			Address: addr,
 			Amount:  DefaultAccountAmountString,
 		})
 	}
-	return
+	return accounts
 }
 
-// TODO: The current implementation of NewActors  will have overlapping `ServiceUrl` for different
-//
-//	types of actors which needs to be fixed.
-func NewActors(actorType coreTypes.ActorType, n int) (actors []*coreTypes.Actor, privateKeys []string) {
-	for i := 0; i < n; i++ {
+// TECHDEBT: Current implementation of `NewActors` will result in non-unique ServiceURLs if called
+// more than once.
+func NewActors(actorType coreTypes.ActorType, numActors int, chains []string) (actors []*coreTypes.Actor, privateKeys []string) {
+	// If the actor type is a validator, the chains must be nil since they are chain agnostic
+	if actorType == coreTypes.ActorType_ACTOR_TYPE_VAL {
+		logger.Global.Warn().Msgf(""validator actors should not have chains but a list was provided: %v"", chains)",runtime/test_artifacts/generator.go,2023-04-21 09:56:55+00:00,2023-04-21T09:57:21Z,nit: consider moving [`p2p/utils.MarshalZerologArray()`](https://github.com/pokt-network/pocket/blob/main/p2p/utils/url_conversion.go#L201) to the new [`internal/testutils`](https://github.com/pokt-network/pocket/tree/main/internal/testutil) pkg and using it here instead of `Msgf` with `%v`.,,,,,136,RIGHT,160,,line,https://api.github.com/repos/pokt-network/pocket/pulls/683,pokt-network/pocket,fb245bc027ae55aaee936daf9f85ecb2d9ad8b40
https://api.github.com/repos/pokt-network/pocket/pulls/683,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1173586364,bryanchriswhite,c723b33e617e0622e4431df83ec52a2c4ae4d958,e2864b82e0b52b527cf11e0a05062f4779fef9fe,"@@ -6,108 +6,149 @@ import (
 	""fmt""
 	""strconv""
 
+	""github.com/pokt-network/pocket/logger""
 	""github.com/pokt-network/pocket/runtime/configs""
 	""github.com/pokt-network/pocket/runtime/genesis""
 	""github.com/pokt-network/pocket/runtime/test_artifacts/keygen""
+	""github.com/pokt-network/pocket/shared/core/types""
 	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
 	""github.com/pokt-network/pocket/shared/crypto""
 	""google.golang.org/protobuf/types/known/timestamppb""
 )
 
-// IMPROVE: Generate a proper genesis suite in the future.
-func NewGenesisState(numValidators, numServicers, numApplications, numFisherman int) (genesisState *genesis.GenesisState, validatorPrivateKeys []string) {
-	apps, appsPrivateKeys := NewActors(coreTypes.ActorType_ACTOR_TYPE_APP, numApplications)
-	vals, validatorPrivateKeys := NewActors(coreTypes.ActorType_ACTOR_TYPE_VAL, numValidators)
-	servicers, snPrivateKeys := NewActors(coreTypes.ActorType_ACTOR_TYPE_SERVICER, numServicers)
-	fish, fishPrivateKeys := NewActors(coreTypes.ActorType_ACTOR_TYPE_FISH, numFisherman)
+type GenesisOption func(*genesis.GenesisState)
+
+// IMPROVE: Extend the utilities here into a proper genesis suite in the future.
+func NewGenesisState(numValidators, numServicers, numApplications, numFisherman int, genesisOpts ...GenesisOption) (genesisState *genesis.GenesisState, validatorPrivateKeys []string) {
+	applications, appPrivateKeys := NewActors(coreTypes.ActorType_ACTOR_TYPE_APP, numApplications, DefaultChains)
+	validators, validatorPrivateKeys := NewActors(coreTypes.ActorType_ACTOR_TYPE_VAL, numValidators, nil)
+	servicers, servicerPrivateKeys := NewActors(coreTypes.ActorType_ACTOR_TYPE_SERVICER, numServicers, DefaultChains)
+	fishermen, fishPrivateKeys := NewActors(coreTypes.ActorType_ACTOR_TYPE_FISH, numFisherman, DefaultChains)
+
+	allActorsKeys := append(append(append(validatorPrivateKeys, servicerPrivateKeys...), fishPrivateKeys...), appPrivateKeys...)
+	allActorAccounts := newAccountsWithKeys(allActorsKeys)
 
 	genesisState = &genesis.GenesisState{
 		GenesisTime:   timestamppb.Now(),
 		ChainId:       DefaultChainID,
 		MaxBlockBytes: DefaultMaxBlockBytes,
 		Pools:         NewPools(),
-		Accounts:      NewAccounts(numValidators+numServicers+numApplications+numFisherman, append(append(append(validatorPrivateKeys, snPrivateKeys...), fishPrivateKeys...), appsPrivateKeys...)...), // TODO(olshansky): clean this up
-		Applications:  apps,
-		Validators:    vals,
+		Accounts:      allActorAccounts,
+		Applications:  applications,
+		Validators:    validators,
 		Servicers:     servicers,
-		Fishermen:     fish,
+		Fishermen:     fishermen,
 		Params:        DefaultParams(),
 	}
 
-	// TODO: Generalize this to all actors and not just validators
+	for _, o := range genesisOpts {
+		o(genesisState)
+	}
+
+	// TECHDEBT: Generalize this to all actors and not just validators
 	return genesisState, validatorPrivateKeys
 }
 
+func WithActors(actors []*coreTypes.Actor, actorKeys []string) func(*genesis.GenesisState) {
+	return func(genesis *genesis.GenesisState) {
+		newActorAccounts := newAccountsWithKeys(actorKeys)
+		genesis.Accounts = append(genesis.Accounts, newActorAccounts...)
+		for _, actor := range actors {
+			switch actor.ActorType {
+			case types.ActorType_ACTOR_TYPE_APP:
+				genesis.Applications = append(genesis.Applications, actor)
+			case coreTypes.ActorType_ACTOR_TYPE_VAL:
+				genesis.Validators = append(genesis.Validators, actor)
+			case coreTypes.ActorType_ACTOR_TYPE_SERVICER:
+				genesis.Servicers = append(genesis.Servicers, actor)
+			case coreTypes.ActorType_ACTOR_TYPE_FISH:
+				genesis.Fishermen = append(genesis.Fishermen, actor)
+			default:
+				panic(fmt.Sprintf(""invalid actor type: %s"", actor.ActorType))
+			}
+		}
+	}
+}
+
 func NewDefaultConfigs(privateKeys []string) (cfgs []*configs.Config) {
 	for i, pk := range privateKeys {
+		postgresSchema := ""node"" + strconv.Itoa(i+1)
 		cfgs = append(cfgs, configs.NewDefaultConfig(
 			configs.WithPK(pk),
-			configs.WithNodeSchema(""node""+strconv.Itoa(i+1)),
+			configs.WithNodeSchema(postgresSchema),
 		))
 	}
-	return
+	return cfgs
 }
 
-// REFACTOR: Test artifact generator should reflect the sum of the initial account values to populate the initial pool values
 func NewPools() (pools []*coreTypes.Account) {
 	for _, value := range coreTypes.Pools_value {
 		if value == int32(coreTypes.Pools_POOLS_UNSPECIFIED) {
 			continue
 		}
 
+		// TECHDEBT: Test artifact should reflect the sum of the initial account values
+		// rather than be set to `DefaultAccountAmountString`
 		amount := DefaultAccountAmountString
 		if value == int32(coreTypes.Pools_POOLS_FEE_COLLECTOR) {
-			amount = ""0""
+			amount = ""0"" // fees are empty at genesis
 		}
 
+		poolAddr := hex.EncodeToString(coreTypes.Pools(value).Address())
+
 		pools = append(pools, &coreTypes.Account{
-			Address: hex.EncodeToString(coreTypes.Pools(value).Address()),
+			Address: poolAddr,
 			Amount:  amount,
 		})
 	}
-	return
+	return pools
+}
+
+func newAccountsWithKeys(privateKeys []string) (accounts []*coreTypes.Account) {
+	for _, pk := range privateKeys {
+		pk, _ := crypto.NewPrivateKey(pk)
+		addr := pk.Address().String()
+		accounts = append(accounts, &coreTypes.Account{
+			Address: addr,
+			Amount:  DefaultAccountAmountString,
+		})
+	}
+	return accounts
 }
 
-func NewAccounts(n int, privateKeys ...string) (accounts []*coreTypes.Account) {
-	for i := 0; i < n; i++ {
+//nolint:unused
+func newAccounts(numActors int) (accounts []*coreTypes.Account) {
+	for i := 0; i < numActors; i++ {
 		_, _, addr := keygen.GetInstance().Next()
-		if privateKeys != nil {
-			pk, _ := crypto.NewPrivateKey(privateKeys[i])
-			addr = pk.Address().String()
-		}
 		accounts = append(accounts, &coreTypes.Account{
 			Address: addr,
 			Amount:  DefaultAccountAmountString,
 		})
 	}
-	return
+	return accounts
 }
 
-// TODO: The current implementation of NewActors  will have overlapping `ServiceUrl` for different
-//
-//	types of actors which needs to be fixed.
-func NewActors(actorType coreTypes.ActorType, n int) (actors []*coreTypes.Actor, privateKeys []string) {
-	for i := 0; i < n; i++ {
+// TECHDEBT: Current implementation of `NewActors` will result in non-unique ServiceURLs if called
+// more than once.
+func NewActors(actorType coreTypes.ActorType, numActors int, chains []string) (actors []*coreTypes.Actor, privateKeys []string) {
+	// If the actor type is a validator, the chains must be nil since they are chain agnostic
+	if actorType == coreTypes.ActorType_ACTOR_TYPE_VAL {
+		logger.Global.Warn().Msgf(""validator actors should not have chains but a list was provided: %v"", chains)
+		chains = nil
+	}
+	for i := 0; i < numActors; i++ {
 		serviceURL := getServiceURL(i + 1)
-		actor, pk := NewDefaultActor(int32(actorType), serviceURL)
+		actor, pk := NewDefaultActor(actorType, serviceURL, chains)
 		actors = append(actors, actor)
 		privateKeys = append(privateKeys, pk)
 	}
-
-	return
+	return actors, privateKeys
 }
 
-func getServiceURL(n int) string {
-	return fmt.Sprintf(ServiceURLFormat, n)
-}
-
-func NewDefaultActor(actorType int32, serviceURL string) (actor *coreTypes.Actor, privateKey string) {
+func NewDefaultActor(actorType coreTypes.ActorType, serviceURL string, chains []string) (actor *coreTypes.Actor, privateKey string) {",runtime/test_artifacts/generator.go,2023-04-21 10:00:28+00:00,2023-04-21T10:00:29Z,nit: multi-line?,,,,,148,RIGHT,180,,line,https://api.github.com/repos/pokt-network/pocket/pulls/683,pokt-network/pocket,fb245bc027ae55aaee936daf9f85ecb2d9ad8b40
https://api.github.com/repos/pokt-network/pocket/pulls/683,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1173592752,bryanchriswhite,c723b33e617e0622e4431df83ec52a2c4ae4d958,e2864b82e0b52b527cf11e0a05062f4779fef9fe,"@@ -7,9 +7,15 @@ and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0
 
 ## [Unreleased]
 
+## [0.0.0.53] - 2023-04-18
+
+- Added a new `Session` protobuf
+- Added a `GetActor` function to the Persistence module interface
+- Added a `GetSession` function to the Utility module interface
+
 ## [0.0.0.52] - 2023-04-17
 
-- Removed *temporary* `shared/p2p` package; consolidated into `p2p`
+- Removed _temporary_ `shared/p2p` package; consolidated into `p2p`",shared/CHANGELOG.md,2023-04-21 10:07:23+00:00,2023-04-21T10:07:50Z,nit: 😲 should  I have used `__` instead of `**`? Is/should this documented anywhere? Do you have opinions about modifying changelog history generally? ,20.0,12.0,LEFT,26.0,18,RIGHT,13,18.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/683,pokt-network/pocket,fb245bc027ae55aaee936daf9f85ecb2d9ad8b40
https://api.github.com/repos/pokt-network/pocket/pulls/683,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1173594568,bryanchriswhite,c723b33e617e0622e4431df83ec52a2c4ae4d958,e2864b82e0b52b527cf11e0a05062f4779fef9fe,"@@ -20,16 +20,17 @@ enum StakeStatus {
 }
 
 // TODO(#555): Investigate ways of having actor specific params that are not part of the shared struct.
+//             Potentially having a separate struct for each actor type and a shared base.
 message Actor {
   ActorType actor_type = 1;
   string address = 2;
   string public_key = 3;
-  repeated string chains = 4; // Not applicable to `Validator` actors
+  repeated string chains = 4; // NB: Not applicable `Validator` actors",shared/core/types/proto/actor.proto,2023-04-21 10:09:25+00:00,2023-04-21T10:09:26Z,nit:  :eyes: :smiling_face_with_tear: - should we add this to the makefile? ,,,,28.0,28,RIGHT,10,10.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/683,pokt-network/pocket,fb245bc027ae55aaee936daf9f85ecb2d9ad8b40
https://api.github.com/repos/pokt-network/pocket/pulls/683,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1176124782,bryanchriswhite,50d0c7174f166c4424631ca68fc3ed05fbb46ed6,e2864b82e0b52b527cf11e0a05062f4779fef9fe,"@@ -1,81 +1,54 @@
-## Protocols
-
-### Session Protocol
-
-`Pocket` implements the V1 Utility Specification's Session Protocol by satisfying the following interface:
-
-```golang
-type Session interface {
-    NewSession(sessionHeight int64, blockHash string, geoZone GeoZone, relayChain RelayChain, application *coreTypes.Actor) (Session, types.Error)
-    GetServicers() []*coreTypes.Actor // the Servicers providing Web3 access to the Application
-    GetFishermen() []*coreTypes.Actor    // the Fishermen monitoring the Servicers
-    GetApplication() *coreTypes.Actor    // the Application consuming Web3 access
-    GetRelayChain() RelayChain        // the identifier of the web3 Relay Chain
-    GetGeoZone() GeoZone              // the geolocation zone where the Application is registered
-    GetSessionHeight() int64          // the block height when the Session started
-}
-```
+# Session Protocol <!-- omit in toc -->
 
-#### Session Creation Flow
+- [Interface](#interface)
+- [Session Creation Flow](#session-creation-flow)
 
-1. Create a session object from the seed data (see #2)
-2. Create a key concatenating and hashing the seed data
-   - `key = Hash(sessionHeight + blockHash + geoZone + relayChain + appPublicKey)`
-3. Get an ordered list of the public keys of servicers who are:
-   - actively staked
-   - staked within geo-zone
-   - staked for relay-chain
-4. Pseudo-insert the session `key` string into the list and find the first actor directly below on the list
-5. Determine a new seedKey with the following formula: ` key = Hash( key + actor1PublicKey )` where `actor1PublicKey` is the key determined in step 4
-6. Repeat steps 4 and 5 until all N servicers are found
-7. Do steps 3 - 6 for Fishermen as well
+_WIP: Run `TODO_SEARCH=utility/session_ make todo*search` to identify all the WIP related to session generation.*",utility/doc/PROTOCOL_SESSION.md,2023-04-25 07:37:18+00:00,2023-04-25T07:37:18Z,Markdown ambiguity strikes again; it looks like this line uses `_` to start itilicizing but then uses `*` to end it.,,,,,6,RIGHT,35,,line,https://api.github.com/repos/pokt-network/pocket/pulls/683,pokt-network/pocket,fb245bc027ae55aaee936daf9f85ecb2d9ad8b40
https://api.github.com/repos/pokt-network/pocket/pulls/683,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1176130164,bryanchriswhite,50d0c7174f166c4424631ca68fc3ed05fbb46ed6,e2864b82e0b52b527cf11e0a05062f4779fef9fe,"@@ -1,81 +1,54 @@
-## Protocols
-
-### Session Protocol
-
-`Pocket` implements the V1 Utility Specification's Session Protocol by satisfying the following interface:
-
-```golang
-type Session interface {
-    NewSession(sessionHeight int64, blockHash string, geoZone GeoZone, relayChain RelayChain, application *coreTypes.Actor) (Session, types.Error)
-    GetServicers() []*coreTypes.Actor // the Servicers providing Web3 access to the Application
-    GetFishermen() []*coreTypes.Actor    // the Fishermen monitoring the Servicers
-    GetApplication() *coreTypes.Actor    // the Application consuming Web3 access
-    GetRelayChain() RelayChain        // the identifier of the web3 Relay Chain
-    GetGeoZone() GeoZone              // the geolocation zone where the Application is registered
-    GetSessionHeight() int64          // the block height when the Session started
-}
-```
+# Session Protocol <!-- omit in toc -->
 
-#### Session Creation Flow
+- [Interface](#interface)
+- [Session Creation Flow](#session-creation-flow)
 
-1. Create a session object from the seed data (see #2)
-2. Create a key concatenating and hashing the seed data
-   - `key = Hash(sessionHeight + blockHash + geoZone + relayChain + appPublicKey)`
-3. Get an ordered list of the public keys of servicers who are:
-   - actively staked
-   - staked within geo-zone
-   - staked for relay-chain
-4. Pseudo-insert the session `key` string into the list and find the first actor directly below on the list
-5. Determine a new seedKey with the following formula: ` key = Hash( key + actor1PublicKey )` where `actor1PublicKey` is the key determined in step 4
-6. Repeat steps 4 and 5 until all N servicers are found
-7. Do steps 3 - 6 for Fishermen as well
+_WIP: Run `TODO_SEARCH=utility/session_ make todo*search` to identify all the WIP related to session generation.*
 
-### FAQ
+## Interface
 
-- Q) why do we hash to find a newKey between every actor selection?
-- A) pseudo-random selection only works if each iteration is re-randomized or it would be subject to lexicographical proximity bias attacks
+`Pocket` satisfies the V1 Utility Specification's Session Protocol by implementing the following function from the [Utility Module Interface](../../shared/modules/utility_module.go) and returning a [Session Protobuf](../../shared/core/types/proto/session.proto):
 
-- Q) Why do we not use Golang's `rand.Intn` with the key as a seed for random node selection?
-- A) A proprietary randomization algorithm makes this approach language & library agnostic, so any client simply has to follow the specifications
+```go
+GetSession(appAddr string, sessionHeight int64, relayChain string, geoZone string) (*coreTypes.Session, error)
+```
 
-- Q) what is `WorldState`?
-- A) it represents a queryable view on the internal state of the network at a certain height.
+## Session Creation Flow
 
-- Q) Do Fishermen stake for a specific RelayChain?
-- A) Fishermen are only going to be applicable to Pocket Supported Relay Chains (where the protocol pays out for the relay chain). It is unclear at this time what the limitations and scoping will be for Fishermen RelayChain support.
+The following is a simplified flow of the session creation flow for illustrative purposes only.",utility/doc/PROTOCOL_SESSION.md,2023-04-25 07:42:15+00:00,2023-04-25T07:42:16Z,"```suggestion
The following is a simplification of the session creation flow for illustrative purposes only.
```",,,,,18,RIGHT,56,,line,https://api.github.com/repos/pokt-network/pocket/pulls/683,pokt-network/pocket,fb245bc027ae55aaee936daf9f85ecb2d9ad8b40
https://api.github.com/repos/pokt-network/pocket/pulls/683,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1176146190,bryanchriswhite,50d0c7174f166c4424631ca68fc3ed05fbb46ed6,e2864b82e0b52b527cf11e0a05062f4779fef9fe,"@@ -1,81 +1,54 @@
-## Protocols
-
-### Session Protocol
-
-`Pocket` implements the V1 Utility Specification's Session Protocol by satisfying the following interface:
-
-```golang
-type Session interface {
-    NewSession(sessionHeight int64, blockHash string, geoZone GeoZone, relayChain RelayChain, application *coreTypes.Actor) (Session, types.Error)
-    GetServicers() []*coreTypes.Actor // the Servicers providing Web3 access to the Application
-    GetFishermen() []*coreTypes.Actor    // the Fishermen monitoring the Servicers
-    GetApplication() *coreTypes.Actor    // the Application consuming Web3 access
-    GetRelayChain() RelayChain        // the identifier of the web3 Relay Chain
-    GetGeoZone() GeoZone              // the geolocation zone where the Application is registered
-    GetSessionHeight() int64          // the block height when the Session started
-}
-```
+# Session Protocol <!-- omit in toc -->
 
-#### Session Creation Flow
+- [Interface](#interface)
+- [Session Creation Flow](#session-creation-flow)
 
-1. Create a session object from the seed data (see #2)
-2. Create a key concatenating and hashing the seed data
-   - `key = Hash(sessionHeight + blockHash + geoZone + relayChain + appPublicKey)`
-3. Get an ordered list of the public keys of servicers who are:
-   - actively staked
-   - staked within geo-zone
-   - staked for relay-chain
-4. Pseudo-insert the session `key` string into the list and find the first actor directly below on the list
-5. Determine a new seedKey with the following formula: ` key = Hash( key + actor1PublicKey )` where `actor1PublicKey` is the key determined in step 4
-6. Repeat steps 4 and 5 until all N servicers are found
-7. Do steps 3 - 6 for Fishermen as well
+_WIP: Run `TODO_SEARCH=utility/session_ make todo*search` to identify all the WIP related to session generation.*
 
-### FAQ
+## Interface
 
-- Q) why do we hash to find a newKey between every actor selection?
-- A) pseudo-random selection only works if each iteration is re-randomized or it would be subject to lexicographical proximity bias attacks
+`Pocket` satisfies the V1 Utility Specification's Session Protocol by implementing the following function from the [Utility Module Interface](../../shared/modules/utility_module.go) and returning a [Session Protobuf](../../shared/core/types/proto/session.proto):
 
-- Q) Why do we not use Golang's `rand.Intn` with the key as a seed for random node selection?
-- A) A proprietary randomization algorithm makes this approach language & library agnostic, so any client simply has to follow the specifications
+```go
+GetSession(appAddr string, sessionHeight int64, relayChain string, geoZone string) (*coreTypes.Session, error)
+```
 
-- Q) what is `WorldState`?
-- A) it represents a queryable view on the internal state of the network at a certain height.
+## Session Creation Flow
 
-- Q) Do Fishermen stake for a specific RelayChain?
-- A) Fishermen are only going to be applicable to Pocket Supported Relay Chains (where the protocol pays out for the relay chain). It is unclear at this time what the limitations and scoping will be for Fishermen RelayChain support.
+The following is a simplified flow of the session creation flow for illustrative purposes only.
 
-- Q) What was the reasoning not to allow a list of geozones?
-- A) Each session is mono-chain and mono-geo. This is fundamental as it would create even more possible combinations of sessions and increase computational complexity during block production and servicing
+See [session.go](../session.go) and [session_test.go](../session_test.go) for the full implementation.
 
-### Session Flow
+1. Create a session object from the seed data
+2. Create a key concatenating and hashing the seed data
+   - `sessionId = Hash(sessionHeight + blockHash + geoZone + relayChain + appPublicKey)`
+3. Get an ordered list of the public keys of servicers and fishermen who are:
+   - actively staked
+   - staked within geo-zone
+   - staked for relay-chain
+4. Use a pseudo-random selection algorithm to retrieve the fishermen and servicers for for the sessionId
 
 ```mermaid
 sequenceDiagram
     autonumber",utility/doc/PROTOCOL_SESSION.md,2023-04-25 07:56:34+00:00,2023-04-25T07:56:35Z,"I'm noticing that the sequence numbers don't match up anymore. What do you think about dropping them and/or adding a heading to introduce the diagram section and/or distinguish it from the ""simplified flow"" outlined above?",,,,,33,RIGHT,74,,line,https://api.github.com/repos/pokt-network/pocket/pulls/683,pokt-network/pocket,fb245bc027ae55aaee936daf9f85ecb2d9ad8b40
https://api.github.com/repos/pokt-network/pocket/pulls/683,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1176208430,bryanchriswhite,50d0c7174f166c4424631ca68fc3ed05fbb46ed6,e2864b82e0b52b527cf11e0a05062f4779fef9fe,"@@ -0,0 +1,123 @@
+package utility
+
+import (
+	""log""
+	""os""
+	""testing""
+
+	""github.com/pokt-network/pocket/persistence""
+	""github.com/pokt-network/pocket/runtime""
+	""github.com/pokt-network/pocket/runtime/configs""
+	""github.com/pokt-network/pocket/runtime/test_artifacts""
+	""github.com/pokt-network/pocket/runtime/test_artifacts/keygen""
+	""github.com/pokt-network/pocket/shared/messaging""
+	""github.com/pokt-network/pocket/shared/modules""
+	""github.com/stretchr/testify/require""
+)
+
+var (
+	dbURL string
+)
+
+func TestMain(m *testing.M) {",utility/module_test.go,2023-04-25 08:49:48+00:00,2023-04-25T12:16:43Z,"I love how this `TestMain` naturally fits in with the other functions! :raised_hands: 

nit: I found the name `module_test.go` a bit misleading, I was expecting to see a test at some point but had to infer what's going on here. Wdyt about:
1. renaming it to something like `utils_test.go` or `helpers_test.go`?
2. opening an issue about establishing a convention for this?
3. adding a comment here which clarifies that this `TestMain` is serves all tests in the `utility` pkg?",,,,,22,RIGHT,22,,line,https://api.github.com/repos/pokt-network/pocket/pulls/683,pokt-network/pocket,fb245bc027ae55aaee936daf9f85ecb2d9ad8b40
https://api.github.com/repos/pokt-network/pocket/pulls/683,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1176216091,bryanchriswhite,50d0c7174f166c4424631ca68fc3ed05fbb46ed6,e2864b82e0b52b527cf11e0a05062f4779fef9fe,"@@ -0,0 +1,531 @@
+package utility
+
+import (
+	""fmt""
+	""math""
+	""testing""
+
+	""github.com/pokt-network/pocket/runtime/test_artifacts""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/crypto""
+	""github.com/pokt-network/pocket/shared/messaging""
+	""github.com/pokt-network/pocket/utility/types""
+	""github.com/stretchr/testify/assert""
+	""github.com/stretchr/testify/require""
+	""gonum.org/v1/gonum/stat/combin""
+)
+
+// TECHDEBT: Geozones are not current implemented, used or tested",utility/session_test.go,2023-04-25 08:56:02+00:00,2023-04-25T08:56:03Z,"Is there a more relevant issue?

```suggestion
// TECHDEBT(#697): Geozones are not current implemented, used or tested
```",,,,,18,RIGHT,18,,line,https://api.github.com/repos/pokt-network/pocket/pulls/683,pokt-network/pocket,fb245bc027ae55aaee936daf9f85ecb2d9ad8b40
https://api.github.com/repos/pokt-network/pocket/pulls/683,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1176231976,bryanchriswhite,50d0c7174f166c4424631ca68fc3ed05fbb46ed6,e2864b82e0b52b527cf11e0a05062f4779fef9fe,"@@ -0,0 +1,531 @@
+package utility
+
+import (
+	""fmt""
+	""math""
+	""testing""
+
+	""github.com/pokt-network/pocket/runtime/test_artifacts""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/crypto""
+	""github.com/pokt-network/pocket/shared/messaging""
+	""github.com/pokt-network/pocket/utility/types""
+	""github.com/stretchr/testify/assert""
+	""github.com/stretchr/testify/require""
+	""gonum.org/v1/gonum/stat/combin""
+)
+
+// TECHDEBT: Geozones are not current implemented, used or tested
+
+func TestSession_GetSession_SingleFishermanSingleServicerBaseCase(t *testing.T) {
+	// Test parameters
+	height := int64(1)
+	relayChain := test_artifacts.DefaultChains[0]
+	geoZone := ""unused_geo""
+	numFishermen := 1
+	numServicers := 1
+	expectedSessionId := ""5acf559f1a3faf3bea7eb692fe51bc1e2e5fb687ede0a6daa7d42399da4aa82b"" // needs to be manually updated if business logic changes",utility/session_test.go,2023-04-25 09:09:42+00:00,2023-04-25T09:09:43Z,nit: any reason the comment has to be the same line? It makes for quite a long line.,,,,,27,RIGHT,27,,line,https://api.github.com/repos/pokt-network/pocket/pulls/683,pokt-network/pocket,fb245bc027ae55aaee936daf9f85ecb2d9ad8b40
https://api.github.com/repos/pokt-network/pocket/pulls/683,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1176237963,bryanchriswhite,50d0c7174f166c4424631ca68fc3ed05fbb46ed6,e2864b82e0b52b527cf11e0a05062f4779fef9fe,"@@ -0,0 +1,531 @@
+package utility
+
+import (
+	""fmt""
+	""math""
+	""testing""
+
+	""github.com/pokt-network/pocket/runtime/test_artifacts""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/crypto""
+	""github.com/pokt-network/pocket/shared/messaging""
+	""github.com/pokt-network/pocket/utility/types""
+	""github.com/stretchr/testify/assert""
+	""github.com/stretchr/testify/require""
+	""gonum.org/v1/gonum/stat/combin""
+)
+
+// TECHDEBT: Geozones are not current implemented, used or tested
+
+func TestSession_GetSession_SingleFishermanSingleServicerBaseCase(t *testing.T) {
+	// Test parameters
+	height := int64(1)
+	relayChain := test_artifacts.DefaultChains[0]
+	geoZone := ""unused_geo""
+	numFishermen := 1
+	numServicers := 1
+	expectedSessionId := ""5acf559f1a3faf3bea7eb692fe51bc1e2e5fb687ede0a6daa7d42399da4aa82b"" // needs to be manually updated if business logic changes
+
+	runtimeCfg, utilityMod, _ := prepareEnvironment(t, 5, numServicers, 1, numFishermen)
+
+	// Sanity check genesis
+	require.Len(t, runtimeCfg.GetGenesis().Applications, 1)
+	app := runtimeCfg.GetGenesis().Applications[0]
+	require.Len(t, runtimeCfg.GetGenesis().Fishermen, 1)
+	fish := runtimeCfg.GetGenesis().Fishermen[0]",utility/session_test.go,2023-04-25 09:14:48+00:00,2023-04-25T09:14:48Z,"nit: I really liked @dylanlott's suggestion of `fisher` as an alternative for ""fisherman"" (singular). It has a similar length and reads a lot `servicer` while sufficiently disambiguating (but without making me laugh when I read it, unlike ""fish"" :joy:).",,,,,35,RIGHT,35,,line,https://api.github.com/repos/pokt-network/pocket/pulls/683,pokt-network/pocket,fb245bc027ae55aaee936daf9f85ecb2d9ad8b40
https://api.github.com/repos/pokt-network/pocket/pulls/683,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1176249989,bryanchriswhite,50d0c7174f166c4424631ca68fc3ed05fbb46ed6,e2864b82e0b52b527cf11e0a05062f4779fef9fe,"@@ -0,0 +1,531 @@
+package utility
+
+import (
+	""fmt""
+	""math""
+	""testing""
+
+	""github.com/pokt-network/pocket/runtime/test_artifacts""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/crypto""
+	""github.com/pokt-network/pocket/shared/messaging""
+	""github.com/pokt-network/pocket/utility/types""
+	""github.com/stretchr/testify/assert""
+	""github.com/stretchr/testify/require""
+	""gonum.org/v1/gonum/stat/combin""
+)
+
+// TECHDEBT: Geozones are not current implemented, used or tested
+
+func TestSession_GetSession_SingleFishermanSingleServicerBaseCase(t *testing.T) {
+	// Test parameters
+	height := int64(1)
+	relayChain := test_artifacts.DefaultChains[0]
+	geoZone := ""unused_geo""
+	numFishermen := 1
+	numServicers := 1
+	expectedSessionId := ""5acf559f1a3faf3bea7eb692fe51bc1e2e5fb687ede0a6daa7d42399da4aa82b"" // needs to be manually updated if business logic changes
+
+	runtimeCfg, utilityMod, _ := prepareEnvironment(t, 5, numServicers, 1, numFishermen)
+
+	// Sanity check genesis
+	require.Len(t, runtimeCfg.GetGenesis().Applications, 1)
+	app := runtimeCfg.GetGenesis().Applications[0]
+	require.Len(t, runtimeCfg.GetGenesis().Fishermen, 1)
+	fish := runtimeCfg.GetGenesis().Fishermen[0]
+	require.Len(t, runtimeCfg.GetGenesis().Servicers, 1)
+	servicer := runtimeCfg.GetGenesis().Servicers[0]
+
+	// Verify some of the session defaults
+	session, err := utilityMod.GetSession(app.Address, height, relayChain, geoZone)
+	require.NoError(t, err)
+	require.Equal(t, expectedSessionId, session.Id)
+	require.Equal(t, height, session.SessionHeight)
+	require.Equal(t, int64(1), session.SessionNumber)
+	require.Equal(t, int64(1), session.NumSessionBlocks)
+	require.Equal(t, relayChain, session.RelayChain)
+	require.Equal(t, geoZone, session.GeoZone)
+	require.Equal(t, app.Address, session.Application.Address)
+	require.Len(t, session.Servicers, numServicers)
+	require.Equal(t, servicer.Address, session.Servicers[0].Address)
+	require.Len(t, session.Fishermen, numFishermen)
+	require.Equal(t, fish.Address, session.Fishermen[0].Address)
+}
+
+func TestSession_GetSession_ApplicationInvalid(t *testing.T) {
+	runtimeCfg, utilityMod, _ := prepareEnvironment(t, 5, 1, 1, 1)
+
+	// Verify there's only 1 app
+	require.Len(t, runtimeCfg.GetGenesis().Applications, 1)
+	app := runtimeCfg.GetGenesis().Applications[0]
+
+	// Create a new app address
+	pk, err := crypto.GeneratePrivateKey()
+	require.NoError(t, err)
+
+	// Verify that the one app in the genesis is not the one we just generated
+	addr := pk.Address().String()
+	require.NotEqual(t, app.Address, addr)
+
+	// Expect no error trying to get a session for the real application
+	_, err = utilityMod.GetSession(app.Address, 1, test_artifacts.DefaultChains[0], ""unused_geo"")
+	require.NoError(t, err)
+
+	// Expect an error trying to get a session for an unstaked chain
+	_, err = utilityMod.GetSession(addr, 1, ""chain"", ""unused_geo"")
+	require.Error(t, err)
+
+	// Expect an error trying to get a session for a non-existent application
+	_, err = utilityMod.GetSession(addr, 1, test_artifacts.DefaultChains[0], ""unused_geo"")
+	require.Error(t, err)",utility/session_test.go,2023-04-25 09:25:11+00:00,2023-04-25T09:25:11Z,It looks like there are several kinds of errors which can be returned. Could you imagine a scenario where these assertions potentially pass for the wrong reason? Wdyt about either adding `TECHDEBT` comments or refactoring the error messages so they can be tested for by identity (until we potentially decide otherwise; #519)?,74.0,72.0,RIGHT,82.0,80,RIGHT,80,82.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/683,pokt-network/pocket,fb245bc027ae55aaee936daf9f85ecb2d9ad8b40
https://api.github.com/repos/pokt-network/pocket/pulls/683,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1176260474,bryanchriswhite,50d0c7174f166c4424631ca68fc3ed05fbb46ed6,e2864b82e0b52b527cf11e0a05062f4779fef9fe,"@@ -0,0 +1,531 @@
+package utility
+
+import (
+	""fmt""
+	""math""
+	""testing""
+
+	""github.com/pokt-network/pocket/runtime/test_artifacts""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/crypto""
+	""github.com/pokt-network/pocket/shared/messaging""
+	""github.com/pokt-network/pocket/utility/types""
+	""github.com/stretchr/testify/assert""
+	""github.com/stretchr/testify/require""
+	""gonum.org/v1/gonum/stat/combin""
+)
+
+// TECHDEBT: Geozones are not current implemented, used or tested
+
+func TestSession_GetSession_SingleFishermanSingleServicerBaseCase(t *testing.T) {
+	// Test parameters
+	height := int64(1)
+	relayChain := test_artifacts.DefaultChains[0]
+	geoZone := ""unused_geo""
+	numFishermen := 1
+	numServicers := 1
+	expectedSessionId := ""5acf559f1a3faf3bea7eb692fe51bc1e2e5fb687ede0a6daa7d42399da4aa82b"" // needs to be manually updated if business logic changes
+
+	runtimeCfg, utilityMod, _ := prepareEnvironment(t, 5, numServicers, 1, numFishermen)
+
+	// Sanity check genesis
+	require.Len(t, runtimeCfg.GetGenesis().Applications, 1)
+	app := runtimeCfg.GetGenesis().Applications[0]
+	require.Len(t, runtimeCfg.GetGenesis().Fishermen, 1)
+	fish := runtimeCfg.GetGenesis().Fishermen[0]
+	require.Len(t, runtimeCfg.GetGenesis().Servicers, 1)
+	servicer := runtimeCfg.GetGenesis().Servicers[0]
+
+	// Verify some of the session defaults
+	session, err := utilityMod.GetSession(app.Address, height, relayChain, geoZone)
+	require.NoError(t, err)
+	require.Equal(t, expectedSessionId, session.Id)
+	require.Equal(t, height, session.SessionHeight)
+	require.Equal(t, int64(1), session.SessionNumber)
+	require.Equal(t, int64(1), session.NumSessionBlocks)
+	require.Equal(t, relayChain, session.RelayChain)
+	require.Equal(t, geoZone, session.GeoZone)
+	require.Equal(t, app.Address, session.Application.Address)
+	require.Len(t, session.Servicers, numServicers)
+	require.Equal(t, servicer.Address, session.Servicers[0].Address)
+	require.Len(t, session.Fishermen, numFishermen)
+	require.Equal(t, fish.Address, session.Fishermen[0].Address)
+}
+
+func TestSession_GetSession_ApplicationInvalid(t *testing.T) {
+	runtimeCfg, utilityMod, _ := prepareEnvironment(t, 5, 1, 1, 1)
+
+	// Verify there's only 1 app
+	require.Len(t, runtimeCfg.GetGenesis().Applications, 1)
+	app := runtimeCfg.GetGenesis().Applications[0]
+
+	// Create a new app address
+	pk, err := crypto.GeneratePrivateKey()
+	require.NoError(t, err)
+
+	// Verify that the one app in the genesis is not the one we just generated
+	addr := pk.Address().String()
+	require.NotEqual(t, app.Address, addr)
+
+	// Expect no error trying to get a session for the real application
+	_, err = utilityMod.GetSession(app.Address, 1, test_artifacts.DefaultChains[0], ""unused_geo"")
+	require.NoError(t, err)
+
+	// Expect an error trying to get a session for an unstaked chain
+	_, err = utilityMod.GetSession(addr, 1, ""chain"", ""unused_geo"")
+	require.Error(t, err)
+
+	// Expect an error trying to get a session for a non-existent application
+	_, err = utilityMod.GetSession(addr, 1, test_artifacts.DefaultChains[0], ""unused_geo"")
+	require.Error(t, err)
+}
+
+func TestSession_GetSession_InvalidFutureSession(t *testing.T) {
+	runtimeCfg, utilityMod, persistenceMod := prepareEnvironment(t, 5, 1, 1, 1)
+
+	// Test parameters
+	relayChain := test_artifacts.DefaultChains[0]
+	geoZone := ""unused_geo""
+	app := runtimeCfg.GetGenesis().Applications[0]
+
+	// Local variable to keep track of the height we're getting a session for
+	currentHeight := int64(0)
+
+	// Successfully get a session for 1 block ahead of the latest committed height
+	session, err := utilityMod.GetSession(app.Address, currentHeight+1, relayChain, geoZone)
+	require.NoError(t, err)
+	require.Equal(t, currentHeight+1, session.SessionHeight)
+
+	// Expect an error for a few heights into the future
+	for height := currentHeight + 2; height < 10; height++ {
+		_, err := utilityMod.GetSession(app.Address, height, relayChain, geoZone)
+		require.Error(t, err)
+	}
+
+	// Commit new blocks for all the heights that failed above
+	for ; currentHeight < 10; currentHeight++ {
+		writeCtx, err := persistenceMod.NewRWContext(currentHeight + 1)
+		require.NoError(t, err)
+		err = writeCtx.Commit([]byte(fmt.Sprintf(""proposer_height_%d"", currentHeight)), []byte(fmt.Sprintf(""quorum_cert_height_%d"", currentHeight)))
+		require.NoError(t, err)
+		writeCtx.Release()
+	}
+
+	// Expect no errors since those blocks exist now
+	// Note that we can get the session for latest_committed + 1
+	for height := int64(1); height <= currentHeight+1; height++ {
+		_, err := utilityMod.GetSession(app.Address, height, relayChain, geoZone)
+		require.NoError(t, err)
+	}
+
+	// Verify that currentHeight + 2 fails
+	_, err = utilityMod.GetSession(app.Address, currentHeight+2, relayChain, geoZone)
+	require.Error(t, err)
+}
+
+func TestSession_GetSession_ServicersAndFishermenCounts_TotalAvailability(t *testing.T) {
+	// Prepare an environment with a lot of servicers and fishermen
+	numServicers := 100
+	numFishermen := 100
+	runtimeCfg, utilityMod, persistenceMod := prepareEnvironment(t, 5, numServicers, 1, numFishermen)
+
+	// Vary the number of actors per session using gov params and check that the session is populated with the correct number of actorss
+	tests := []struct {
+		name                   string
+		numServicersPerSession int64
+		numFishermanPerSession int64
+		wantServicerCount      int
+		wantFishermanCount     int
+	}{
+		{
+			name:                   ""more actors per session than available in network"",
+			numServicersPerSession: int64(numServicers) * 10,
+			numFishermanPerSession: int64(numFishermen) * 10,
+			wantServicerCount:      numServicers,
+			wantFishermanCount:     numFishermen,
+		},
+		{
+			name:                   ""less actors per session than available in network"",
+			numServicersPerSession: int64(numServicers) / 2,
+			numFishermanPerSession: int64(numFishermen) / 2,
+			wantServicerCount:      numServicers / 2,
+			wantFishermanCount:     numFishermen / 2,",utility/session_test.go,2023-04-25 09:34:29+00:00,2023-04-25T09:34:52Z,"Am I'm missing something subtle or is there a copy/pasta or something here? Isn't this equivalent to ""same number of actors..."", as written?",,148.0,RIGHT,,152,RIGHT,152,,line,https://api.github.com/repos/pokt-network/pocket/pulls/683,pokt-network/pocket,fb245bc027ae55aaee936daf9f85ecb2d9ad8b40
https://api.github.com/repos/pokt-network/pocket/pulls/683,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1176263657,bryanchriswhite,50d0c7174f166c4424631ca68fc3ed05fbb46ed6,e2864b82e0b52b527cf11e0a05062f4779fef9fe,"@@ -0,0 +1,531 @@
+package utility
+
+import (
+	""fmt""
+	""math""
+	""testing""
+
+	""github.com/pokt-network/pocket/runtime/test_artifacts""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/crypto""
+	""github.com/pokt-network/pocket/shared/messaging""
+	""github.com/pokt-network/pocket/utility/types""
+	""github.com/stretchr/testify/assert""
+	""github.com/stretchr/testify/require""
+	""gonum.org/v1/gonum/stat/combin""
+)
+
+// TECHDEBT: Geozones are not current implemented, used or tested
+
+func TestSession_GetSession_SingleFishermanSingleServicerBaseCase(t *testing.T) {
+	// Test parameters
+	height := int64(1)
+	relayChain := test_artifacts.DefaultChains[0]
+	geoZone := ""unused_geo""
+	numFishermen := 1
+	numServicers := 1
+	expectedSessionId := ""5acf559f1a3faf3bea7eb692fe51bc1e2e5fb687ede0a6daa7d42399da4aa82b"" // needs to be manually updated if business logic changes
+
+	runtimeCfg, utilityMod, _ := prepareEnvironment(t, 5, numServicers, 1, numFishermen)
+
+	// Sanity check genesis
+	require.Len(t, runtimeCfg.GetGenesis().Applications, 1)
+	app := runtimeCfg.GetGenesis().Applications[0]
+	require.Len(t, runtimeCfg.GetGenesis().Fishermen, 1)
+	fish := runtimeCfg.GetGenesis().Fishermen[0]
+	require.Len(t, runtimeCfg.GetGenesis().Servicers, 1)
+	servicer := runtimeCfg.GetGenesis().Servicers[0]
+
+	// Verify some of the session defaults
+	session, err := utilityMod.GetSession(app.Address, height, relayChain, geoZone)
+	require.NoError(t, err)
+	require.Equal(t, expectedSessionId, session.Id)
+	require.Equal(t, height, session.SessionHeight)
+	require.Equal(t, int64(1), session.SessionNumber)
+	require.Equal(t, int64(1), session.NumSessionBlocks)
+	require.Equal(t, relayChain, session.RelayChain)
+	require.Equal(t, geoZone, session.GeoZone)
+	require.Equal(t, app.Address, session.Application.Address)
+	require.Len(t, session.Servicers, numServicers)
+	require.Equal(t, servicer.Address, session.Servicers[0].Address)
+	require.Len(t, session.Fishermen, numFishermen)
+	require.Equal(t, fish.Address, session.Fishermen[0].Address)
+}
+
+func TestSession_GetSession_ApplicationInvalid(t *testing.T) {
+	runtimeCfg, utilityMod, _ := prepareEnvironment(t, 5, 1, 1, 1)
+
+	// Verify there's only 1 app
+	require.Len(t, runtimeCfg.GetGenesis().Applications, 1)
+	app := runtimeCfg.GetGenesis().Applications[0]
+
+	// Create a new app address
+	pk, err := crypto.GeneratePrivateKey()
+	require.NoError(t, err)
+
+	// Verify that the one app in the genesis is not the one we just generated
+	addr := pk.Address().String()
+	require.NotEqual(t, app.Address, addr)
+
+	// Expect no error trying to get a session for the real application
+	_, err = utilityMod.GetSession(app.Address, 1, test_artifacts.DefaultChains[0], ""unused_geo"")
+	require.NoError(t, err)
+
+	// Expect an error trying to get a session for an unstaked chain
+	_, err = utilityMod.GetSession(addr, 1, ""chain"", ""unused_geo"")
+	require.Error(t, err)
+
+	// Expect an error trying to get a session for a non-existent application
+	_, err = utilityMod.GetSession(addr, 1, test_artifacts.DefaultChains[0], ""unused_geo"")
+	require.Error(t, err)
+}
+
+func TestSession_GetSession_InvalidFutureSession(t *testing.T) {
+	runtimeCfg, utilityMod, persistenceMod := prepareEnvironment(t, 5, 1, 1, 1)
+
+	// Test parameters
+	relayChain := test_artifacts.DefaultChains[0]
+	geoZone := ""unused_geo""
+	app := runtimeCfg.GetGenesis().Applications[0]
+
+	// Local variable to keep track of the height we're getting a session for
+	currentHeight := int64(0)
+
+	// Successfully get a session for 1 block ahead of the latest committed height
+	session, err := utilityMod.GetSession(app.Address, currentHeight+1, relayChain, geoZone)
+	require.NoError(t, err)
+	require.Equal(t, currentHeight+1, session.SessionHeight)
+
+	// Expect an error for a few heights into the future
+	for height := currentHeight + 2; height < 10; height++ {
+		_, err := utilityMod.GetSession(app.Address, height, relayChain, geoZone)
+		require.Error(t, err)
+	}
+
+	// Commit new blocks for all the heights that failed above
+	for ; currentHeight < 10; currentHeight++ {
+		writeCtx, err := persistenceMod.NewRWContext(currentHeight + 1)
+		require.NoError(t, err)
+		err = writeCtx.Commit([]byte(fmt.Sprintf(""proposer_height_%d"", currentHeight)), []byte(fmt.Sprintf(""quorum_cert_height_%d"", currentHeight)))
+		require.NoError(t, err)
+		writeCtx.Release()
+	}
+
+	// Expect no errors since those blocks exist now
+	// Note that we can get the session for latest_committed + 1
+	for height := int64(1); height <= currentHeight+1; height++ {
+		_, err := utilityMod.GetSession(app.Address, height, relayChain, geoZone)
+		require.NoError(t, err)
+	}
+
+	// Verify that currentHeight + 2 fails
+	_, err = utilityMod.GetSession(app.Address, currentHeight+2, relayChain, geoZone)
+	require.Error(t, err)
+}
+
+func TestSession_GetSession_ServicersAndFishermenCounts_TotalAvailability(t *testing.T) {
+	// Prepare an environment with a lot of servicers and fishermen
+	numServicers := 100
+	numFishermen := 100
+	runtimeCfg, utilityMod, persistenceMod := prepareEnvironment(t, 5, numServicers, 1, numFishermen)
+
+	// Vary the number of actors per session using gov params and check that the session is populated with the correct number of actorss
+	tests := []struct {
+		name                   string
+		numServicersPerSession int64
+		numFishermanPerSession int64
+		wantServicerCount      int
+		wantFishermanCount     int
+	}{
+		{
+			name:                   ""more actors per session than available in network"",
+			numServicersPerSession: int64(numServicers) * 10,
+			numFishermanPerSession: int64(numFishermen) * 10,
+			wantServicerCount:      numServicers,
+			wantFishermanCount:     numFishermen,
+		},
+		{
+			name:                   ""less actors per session than available in network"",
+			numServicersPerSession: int64(numServicers) / 2,
+			numFishermanPerSession: int64(numFishermen) / 2,
+			wantServicerCount:      numServicers / 2,
+			wantFishermanCount:     numFishermen / 2,
+		},
+		{
+			name:                   ""same number of actors per session as available in network"",
+			numServicersPerSession: int64(numServicers),
+			numFishermanPerSession: int64(numFishermen),
+			wantServicerCount:      numServicers,
+			wantFishermanCount:     numFishermen,
+		},
+		{
+			name:                   ""more than enough servicers but not enough fishermen"",
+			numServicersPerSession: int64(numServicers) / 2,
+			numFishermanPerSession: int64(numFishermen) * 10,
+			wantServicerCount:      numServicers / 2,
+			wantFishermanCount:     numFishermen,
+		},
+		{
+			name:                   ""more than enough fishermen but not enough servicers"",
+			numServicersPerSession: int64(numServicers) * 10,
+			numFishermanPerSession: int64(numFishermen) / 2,
+			wantServicerCount:      numServicers,
+			wantFishermanCount:     numFishermen / 2,
+		},
+	}
+
+	// Test constant parameters",utility/session_test.go,2023-04-25 09:37:17+00:00,2023-04-25T10:18:19Z,"nit: the first time I read this, I read ""test"" as a verb.

Wdyt about declaring these as constants?

```suggestion
	// Constant test parameters
```",,,,,177,RIGHT,177,,line,https://api.github.com/repos/pokt-network/pocket/pulls/683,pokt-network/pocket,fb245bc027ae55aaee936daf9f85ecb2d9ad8b40
https://api.github.com/repos/pokt-network/pocket/pulls/683,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1176270533,bryanchriswhite,50d0c7174f166c4424631ca68fc3ed05fbb46ed6,e2864b82e0b52b527cf11e0a05062f4779fef9fe,"@@ -0,0 +1,531 @@
+package utility
+
+import (
+	""fmt""
+	""math""
+	""testing""
+
+	""github.com/pokt-network/pocket/runtime/test_artifacts""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/crypto""
+	""github.com/pokt-network/pocket/shared/messaging""
+	""github.com/pokt-network/pocket/utility/types""
+	""github.com/stretchr/testify/assert""
+	""github.com/stretchr/testify/require""
+	""gonum.org/v1/gonum/stat/combin""
+)
+
+// TECHDEBT: Geozones are not current implemented, used or tested
+
+func TestSession_GetSession_SingleFishermanSingleServicerBaseCase(t *testing.T) {
+	// Test parameters
+	height := int64(1)
+	relayChain := test_artifacts.DefaultChains[0]
+	geoZone := ""unused_geo""
+	numFishermen := 1
+	numServicers := 1
+	expectedSessionId := ""5acf559f1a3faf3bea7eb692fe51bc1e2e5fb687ede0a6daa7d42399da4aa82b"" // needs to be manually updated if business logic changes
+
+	runtimeCfg, utilityMod, _ := prepareEnvironment(t, 5, numServicers, 1, numFishermen)
+
+	// Sanity check genesis
+	require.Len(t, runtimeCfg.GetGenesis().Applications, 1)
+	app := runtimeCfg.GetGenesis().Applications[0]
+	require.Len(t, runtimeCfg.GetGenesis().Fishermen, 1)
+	fish := runtimeCfg.GetGenesis().Fishermen[0]
+	require.Len(t, runtimeCfg.GetGenesis().Servicers, 1)
+	servicer := runtimeCfg.GetGenesis().Servicers[0]
+
+	// Verify some of the session defaults
+	session, err := utilityMod.GetSession(app.Address, height, relayChain, geoZone)
+	require.NoError(t, err)
+	require.Equal(t, expectedSessionId, session.Id)
+	require.Equal(t, height, session.SessionHeight)
+	require.Equal(t, int64(1), session.SessionNumber)
+	require.Equal(t, int64(1), session.NumSessionBlocks)
+	require.Equal(t, relayChain, session.RelayChain)
+	require.Equal(t, geoZone, session.GeoZone)
+	require.Equal(t, app.Address, session.Application.Address)
+	require.Len(t, session.Servicers, numServicers)
+	require.Equal(t, servicer.Address, session.Servicers[0].Address)
+	require.Len(t, session.Fishermen, numFishermen)
+	require.Equal(t, fish.Address, session.Fishermen[0].Address)
+}
+
+func TestSession_GetSession_ApplicationInvalid(t *testing.T) {
+	runtimeCfg, utilityMod, _ := prepareEnvironment(t, 5, 1, 1, 1)
+
+	// Verify there's only 1 app
+	require.Len(t, runtimeCfg.GetGenesis().Applications, 1)
+	app := runtimeCfg.GetGenesis().Applications[0]
+
+	// Create a new app address
+	pk, err := crypto.GeneratePrivateKey()
+	require.NoError(t, err)
+
+	// Verify that the one app in the genesis is not the one we just generated
+	addr := pk.Address().String()
+	require.NotEqual(t, app.Address, addr)
+
+	// Expect no error trying to get a session for the real application
+	_, err = utilityMod.GetSession(app.Address, 1, test_artifacts.DefaultChains[0], ""unused_geo"")
+	require.NoError(t, err)
+
+	// Expect an error trying to get a session for an unstaked chain
+	_, err = utilityMod.GetSession(addr, 1, ""chain"", ""unused_geo"")
+	require.Error(t, err)
+
+	// Expect an error trying to get a session for a non-existent application
+	_, err = utilityMod.GetSession(addr, 1, test_artifacts.DefaultChains[0], ""unused_geo"")
+	require.Error(t, err)
+}
+
+func TestSession_GetSession_InvalidFutureSession(t *testing.T) {
+	runtimeCfg, utilityMod, persistenceMod := prepareEnvironment(t, 5, 1, 1, 1)
+
+	// Test parameters
+	relayChain := test_artifacts.DefaultChains[0]
+	geoZone := ""unused_geo""
+	app := runtimeCfg.GetGenesis().Applications[0]
+
+	// Local variable to keep track of the height we're getting a session for
+	currentHeight := int64(0)
+
+	// Successfully get a session for 1 block ahead of the latest committed height
+	session, err := utilityMod.GetSession(app.Address, currentHeight+1, relayChain, geoZone)
+	require.NoError(t, err)
+	require.Equal(t, currentHeight+1, session.SessionHeight)
+
+	// Expect an error for a few heights into the future
+	for height := currentHeight + 2; height < 10; height++ {
+		_, err := utilityMod.GetSession(app.Address, height, relayChain, geoZone)
+		require.Error(t, err)
+	}
+
+	// Commit new blocks for all the heights that failed above
+	for ; currentHeight < 10; currentHeight++ {
+		writeCtx, err := persistenceMod.NewRWContext(currentHeight + 1)
+		require.NoError(t, err)
+		err = writeCtx.Commit([]byte(fmt.Sprintf(""proposer_height_%d"", currentHeight)), []byte(fmt.Sprintf(""quorum_cert_height_%d"", currentHeight)))
+		require.NoError(t, err)
+		writeCtx.Release()
+	}
+
+	// Expect no errors since those blocks exist now
+	// Note that we can get the session for latest_committed + 1
+	for height := int64(1); height <= currentHeight+1; height++ {
+		_, err := utilityMod.GetSession(app.Address, height, relayChain, geoZone)
+		require.NoError(t, err)
+	}
+
+	// Verify that currentHeight + 2 fails
+	_, err = utilityMod.GetSession(app.Address, currentHeight+2, relayChain, geoZone)
+	require.Error(t, err)
+}
+
+func TestSession_GetSession_ServicersAndFishermenCounts_TotalAvailability(t *testing.T) {
+	// Prepare an environment with a lot of servicers and fishermen
+	numServicers := 100
+	numFishermen := 100
+	runtimeCfg, utilityMod, persistenceMod := prepareEnvironment(t, 5, numServicers, 1, numFishermen)
+
+	// Vary the number of actors per session using gov params and check that the session is populated with the correct number of actorss
+	tests := []struct {
+		name                   string
+		numServicersPerSession int64
+		numFishermanPerSession int64
+		wantServicerCount      int
+		wantFishermanCount     int
+	}{
+		{
+			name:                   ""more actors per session than available in network"",
+			numServicersPerSession: int64(numServicers) * 10,
+			numFishermanPerSession: int64(numFishermen) * 10,
+			wantServicerCount:      numServicers,
+			wantFishermanCount:     numFishermen,
+		},
+		{
+			name:                   ""less actors per session than available in network"",
+			numServicersPerSession: int64(numServicers) / 2,
+			numFishermanPerSession: int64(numFishermen) / 2,
+			wantServicerCount:      numServicers / 2,
+			wantFishermanCount:     numFishermen / 2,
+		},
+		{
+			name:                   ""same number of actors per session as available in network"",
+			numServicersPerSession: int64(numServicers),
+			numFishermanPerSession: int64(numFishermen),
+			wantServicerCount:      numServicers,
+			wantFishermanCount:     numFishermen,
+		},
+		{
+			name:                   ""more than enough servicers but not enough fishermen"",
+			numServicersPerSession: int64(numServicers) / 2,
+			numFishermanPerSession: int64(numFishermen) * 10,
+			wantServicerCount:      numServicers / 2,
+			wantFishermanCount:     numFishermen,
+		},
+		{
+			name:                   ""more than enough fishermen but not enough servicers"",
+			numServicersPerSession: int64(numServicers) * 10,
+			numFishermanPerSession: int64(numFishermen) / 2,
+			wantServicerCount:      numServicers,
+			wantFishermanCount:     numFishermen / 2,
+		},
+	}
+
+	// Test constant parameters
+	updateParamsHeight := int64(1)
+	querySessionHeight := int64(2)
+
+	app := runtimeCfg.GetGenesis().Applications[0]
+	relayChain := test_artifacts.DefaultChains[0]
+	geoZone := ""unused_geo""
+
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			// Reset to genesis
+			err := persistenceMod.HandleDebugMessage(&messaging.DebugMessage{
+				Action:  messaging.DebugMessageAction_DEBUG_PERSISTENCE_RESET_TO_GENESIS,
+				Message: nil,
+			})
+			require.NoError(t, err)
+
+			// Update the number of servicers and fishermen per session gov params
+			writeCtx, err := persistenceMod.NewRWContext(updateParamsHeight)
+			require.NoError(t, err)
+			defer writeCtx.Release()
+
+			err = writeCtx.SetParam(types.ServicersPerSessionParamName, tt.numServicersPerSession)
+			require.NoError(t, err)
+			err = writeCtx.SetParam(types.FishermanPerSessionParamName, tt.numFishermanPerSession)
+			require.NoError(t, err)
+			err = writeCtx.Commit([]byte(""empty_proposed_addr""), []byte(""empty_quorum_cert""))
+			require.NoError(t, err)
+
+			// Verify that the session is populated with the correct number of actors
+			session, err := utilityMod.GetSession(app.Address, querySessionHeight, relayChain, geoZone)
+			require.NoError(t, err)
+			require.Equal(t, tt.wantServicerCount, len(session.Servicers))
+			require.Equal(t, tt.wantFishermanCount, len(session.Fishermen))
+		})
+	}
+}
+
+func TestSession_GetSession_ServicersAndFishermenCounts_ChainAvailability(t *testing.T) {
+	// Test constant parameters",utility/session_test.go,2023-04-25 09:41:56+00:00,2023-04-25T09:42:06Z,nit: (^ same as above),,,,,216,RIGHT,216,,line,https://api.github.com/repos/pokt-network/pocket/pulls/683,pokt-network/pocket,fb245bc027ae55aaee936daf9f85ecb2d9ad8b40
https://api.github.com/repos/pokt-network/pocket/pulls/683,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1176323228,bryanchriswhite,50d0c7174f166c4424631ca68fc3ed05fbb46ed6,e2864b82e0b52b527cf11e0a05062f4779fef9fe,"@@ -0,0 +1,531 @@
+package utility
+
+import (
+	""fmt""
+	""math""
+	""testing""
+
+	""github.com/pokt-network/pocket/runtime/test_artifacts""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/crypto""
+	""github.com/pokt-network/pocket/shared/messaging""
+	""github.com/pokt-network/pocket/utility/types""
+	""github.com/stretchr/testify/assert""
+	""github.com/stretchr/testify/require""
+	""gonum.org/v1/gonum/stat/combin""
+)
+
+// TECHDEBT: Geozones are not current implemented, used or tested
+
+func TestSession_GetSession_SingleFishermanSingleServicerBaseCase(t *testing.T) {
+	// Test parameters
+	height := int64(1)
+	relayChain := test_artifacts.DefaultChains[0]
+	geoZone := ""unused_geo""
+	numFishermen := 1
+	numServicers := 1
+	expectedSessionId := ""5acf559f1a3faf3bea7eb692fe51bc1e2e5fb687ede0a6daa7d42399da4aa82b"" // needs to be manually updated if business logic changes
+
+	runtimeCfg, utilityMod, _ := prepareEnvironment(t, 5, numServicers, 1, numFishermen)
+
+	// Sanity check genesis
+	require.Len(t, runtimeCfg.GetGenesis().Applications, 1)
+	app := runtimeCfg.GetGenesis().Applications[0]
+	require.Len(t, runtimeCfg.GetGenesis().Fishermen, 1)
+	fish := runtimeCfg.GetGenesis().Fishermen[0]
+	require.Len(t, runtimeCfg.GetGenesis().Servicers, 1)
+	servicer := runtimeCfg.GetGenesis().Servicers[0]
+
+	// Verify some of the session defaults
+	session, err := utilityMod.GetSession(app.Address, height, relayChain, geoZone)
+	require.NoError(t, err)
+	require.Equal(t, expectedSessionId, session.Id)
+	require.Equal(t, height, session.SessionHeight)
+	require.Equal(t, int64(1), session.SessionNumber)
+	require.Equal(t, int64(1), session.NumSessionBlocks)
+	require.Equal(t, relayChain, session.RelayChain)
+	require.Equal(t, geoZone, session.GeoZone)
+	require.Equal(t, app.Address, session.Application.Address)
+	require.Len(t, session.Servicers, numServicers)
+	require.Equal(t, servicer.Address, session.Servicers[0].Address)
+	require.Len(t, session.Fishermen, numFishermen)
+	require.Equal(t, fish.Address, session.Fishermen[0].Address)
+}
+
+func TestSession_GetSession_ApplicationInvalid(t *testing.T) {
+	runtimeCfg, utilityMod, _ := prepareEnvironment(t, 5, 1, 1, 1)
+
+	// Verify there's only 1 app
+	require.Len(t, runtimeCfg.GetGenesis().Applications, 1)
+	app := runtimeCfg.GetGenesis().Applications[0]
+
+	// Create a new app address
+	pk, err := crypto.GeneratePrivateKey()
+	require.NoError(t, err)
+
+	// Verify that the one app in the genesis is not the one we just generated
+	addr := pk.Address().String()
+	require.NotEqual(t, app.Address, addr)
+
+	// Expect no error trying to get a session for the real application
+	_, err = utilityMod.GetSession(app.Address, 1, test_artifacts.DefaultChains[0], ""unused_geo"")
+	require.NoError(t, err)
+
+	// Expect an error trying to get a session for an unstaked chain
+	_, err = utilityMod.GetSession(addr, 1, ""chain"", ""unused_geo"")
+	require.Error(t, err)
+
+	// Expect an error trying to get a session for a non-existent application
+	_, err = utilityMod.GetSession(addr, 1, test_artifacts.DefaultChains[0], ""unused_geo"")
+	require.Error(t, err)
+}
+
+func TestSession_GetSession_InvalidFutureSession(t *testing.T) {
+	runtimeCfg, utilityMod, persistenceMod := prepareEnvironment(t, 5, 1, 1, 1)
+
+	// Test parameters
+	relayChain := test_artifacts.DefaultChains[0]
+	geoZone := ""unused_geo""
+	app := runtimeCfg.GetGenesis().Applications[0]
+
+	// Local variable to keep track of the height we're getting a session for
+	currentHeight := int64(0)
+
+	// Successfully get a session for 1 block ahead of the latest committed height
+	session, err := utilityMod.GetSession(app.Address, currentHeight+1, relayChain, geoZone)
+	require.NoError(t, err)
+	require.Equal(t, currentHeight+1, session.SessionHeight)
+
+	// Expect an error for a few heights into the future
+	for height := currentHeight + 2; height < 10; height++ {
+		_, err := utilityMod.GetSession(app.Address, height, relayChain, geoZone)
+		require.Error(t, err)
+	}
+
+	// Commit new blocks for all the heights that failed above
+	for ; currentHeight < 10; currentHeight++ {
+		writeCtx, err := persistenceMod.NewRWContext(currentHeight + 1)
+		require.NoError(t, err)
+		err = writeCtx.Commit([]byte(fmt.Sprintf(""proposer_height_%d"", currentHeight)), []byte(fmt.Sprintf(""quorum_cert_height_%d"", currentHeight)))
+		require.NoError(t, err)
+		writeCtx.Release()
+	}
+
+	// Expect no errors since those blocks exist now
+	// Note that we can get the session for latest_committed + 1
+	for height := int64(1); height <= currentHeight+1; height++ {
+		_, err := utilityMod.GetSession(app.Address, height, relayChain, geoZone)
+		require.NoError(t, err)
+	}
+
+	// Verify that currentHeight + 2 fails
+	_, err = utilityMod.GetSession(app.Address, currentHeight+2, relayChain, geoZone)
+	require.Error(t, err)
+}
+
+func TestSession_GetSession_ServicersAndFishermenCounts_TotalAvailability(t *testing.T) {
+	// Prepare an environment with a lot of servicers and fishermen
+	numServicers := 100
+	numFishermen := 100
+	runtimeCfg, utilityMod, persistenceMod := prepareEnvironment(t, 5, numServicers, 1, numFishermen)
+
+	// Vary the number of actors per session using gov params and check that the session is populated with the correct number of actorss
+	tests := []struct {
+		name                   string
+		numServicersPerSession int64
+		numFishermanPerSession int64
+		wantServicerCount      int
+		wantFishermanCount     int
+	}{
+		{
+			name:                   ""more actors per session than available in network"",
+			numServicersPerSession: int64(numServicers) * 10,
+			numFishermanPerSession: int64(numFishermen) * 10,
+			wantServicerCount:      numServicers,
+			wantFishermanCount:     numFishermen,
+		},
+		{
+			name:                   ""less actors per session than available in network"",
+			numServicersPerSession: int64(numServicers) / 2,
+			numFishermanPerSession: int64(numFishermen) / 2,
+			wantServicerCount:      numServicers / 2,
+			wantFishermanCount:     numFishermen / 2,
+		},
+		{
+			name:                   ""same number of actors per session as available in network"",
+			numServicersPerSession: int64(numServicers),
+			numFishermanPerSession: int64(numFishermen),
+			wantServicerCount:      numServicers,
+			wantFishermanCount:     numFishermen,
+		},
+		{
+			name:                   ""more than enough servicers but not enough fishermen"",
+			numServicersPerSession: int64(numServicers) / 2,
+			numFishermanPerSession: int64(numFishermen) * 10,
+			wantServicerCount:      numServicers / 2,
+			wantFishermanCount:     numFishermen,
+		},
+		{
+			name:                   ""more than enough fishermen but not enough servicers"",
+			numServicersPerSession: int64(numServicers) * 10,
+			numFishermanPerSession: int64(numFishermen) / 2,
+			wantServicerCount:      numServicers,
+			wantFishermanCount:     numFishermen / 2,
+		},
+	}
+
+	// Test constant parameters
+	updateParamsHeight := int64(1)
+	querySessionHeight := int64(2)
+
+	app := runtimeCfg.GetGenesis().Applications[0]
+	relayChain := test_artifacts.DefaultChains[0]
+	geoZone := ""unused_geo""
+
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			// Reset to genesis
+			err := persistenceMod.HandleDebugMessage(&messaging.DebugMessage{
+				Action:  messaging.DebugMessageAction_DEBUG_PERSISTENCE_RESET_TO_GENESIS,
+				Message: nil,
+			})
+			require.NoError(t, err)
+
+			// Update the number of servicers and fishermen per session gov params
+			writeCtx, err := persistenceMod.NewRWContext(updateParamsHeight)
+			require.NoError(t, err)
+			defer writeCtx.Release()
+
+			err = writeCtx.SetParam(types.ServicersPerSessionParamName, tt.numServicersPerSession)
+			require.NoError(t, err)
+			err = writeCtx.SetParam(types.FishermanPerSessionParamName, tt.numFishermanPerSession)
+			require.NoError(t, err)
+			err = writeCtx.Commit([]byte(""empty_proposed_addr""), []byte(""empty_quorum_cert""))
+			require.NoError(t, err)
+
+			// Verify that the session is populated with the correct number of actors
+			session, err := utilityMod.GetSession(app.Address, querySessionHeight, relayChain, geoZone)
+			require.NoError(t, err)
+			require.Equal(t, tt.wantServicerCount, len(session.Servicers))
+			require.Equal(t, tt.wantFishermanCount, len(session.Fishermen))
+		})
+	}
+}
+
+func TestSession_GetSession_ServicersAndFishermenCounts_ChainAvailability(t *testing.T) {
+	// Test constant parameters
+	numServicersPerSession := 10
+	numFishermenPerSession := 2
+
+	// Make sure there are MORE THAN ENOUGH servicers and fishermen in the network for each session for chain 1
+	servicersChain1, servicerKeysChain1 := test_artifacts.NewActors(coreTypes.ActorType_ACTOR_TYPE_SERVICER, numServicersPerSession*2, []string{""chn1""})
+	fishermenChain2, fishermenKeysChain2 := test_artifacts.NewActors(coreTypes.ActorType_ACTOR_TYPE_FISH, numFishermenPerSession*2, []string{""chn1""})
+
+	// Make sure there are NOT ENOUGH servicers and fishermen in the network for each session for chain 2
+	servicersChain2, servicerKeysChain2 := test_artifacts.NewActors(coreTypes.ActorType_ACTOR_TYPE_SERVICER, numServicersPerSession/2, []string{""chn2""})
+	fishermenChain1, fishermenKeysChain1 := test_artifacts.NewActors(coreTypes.ActorType_ACTOR_TYPE_FISH, numFishermenPerSession/2, []string{""chn2""})
+
+	application, applicationKey := test_artifacts.NewActors(coreTypes.ActorType_ACTOR_TYPE_APP, 1, []string{""chn1"", ""chn2"", ""chn3""})
+
+	//nolint:gocritic // intentionally not appending result to a new slice
+	actors := append(application, append(servicersChain1, append(servicersChain2, append(fishermenChain1, fishermenChain2...)...)...)...)
+	//nolint:gocritic // intentionally not appending result to a new slice
+	keys := append(applicationKey, append(servicerKeysChain1, append(servicerKeysChain2, append(fishermenKeysChain1, fishermenKeysChain2...)...)...)...)
+
+	// Prepare the environment
+	runtimeCfg, utilityMod, persistenceMod := prepareEnvironment(t, 5, 0, 0, 0, test_artifacts.WithActors(actors, keys))
+
+	// Vary the chain and check the number of fishermen and servicers returned for each one
+	tests := []struct {
+		name               string
+		chain              string
+		wantServicerCount  int
+		wantFishermanCount int
+	}{
+		{
+			name:               ""chn1 has enough servicers and fishermen"",
+			chain:              ""chn1"",
+			wantServicerCount:  numServicersPerSession,
+			wantFishermanCount: numFishermenPerSession,
+		},
+		{
+			name:               ""chn2 does not have enough servicers and fishermen"",
+			chain:              ""chn2"",
+			wantServicerCount:  numServicersPerSession / 2,
+			wantFishermanCount: numFishermenPerSession / 2,
+		},
+		{
+			name:               ""chn3 has no servicers and fishermen"",
+			chain:              ""chn3"",
+			wantServicerCount:  0,
+			wantFishermanCount: 0,
+		},
+	}
+
+	// Reset to genesis
+	err := persistenceMod.HandleDebugMessage(&messaging.DebugMessage{
+		Action:  messaging.DebugMessageAction_DEBUG_PERSISTENCE_RESET_TO_GENESIS,
+		Message: nil,
+	})
+	require.NoError(t, err)
+
+	// Update the number of servicers and fishermen per session gov params
+	writeCtx, err := persistenceMod.NewRWContext(1)
+	require.NoError(t, err)
+	err = writeCtx.SetParam(types.ServicersPerSessionParamName, numServicersPerSession)
+	require.NoError(t, err)
+	err = writeCtx.SetParam(types.FishermanPerSessionParamName, numFishermenPerSession)
+	require.NoError(t, err)
+	err = writeCtx.Commit([]byte(""empty_proposed_addr""), []byte(""empty_quorum_cert""))
+	require.NoError(t, err)
+	defer writeCtx.Release()
+
+	// Test parameters
+	app := runtimeCfg.GetGenesis().Applications[0]
+	geoZone := ""unused_geo""
+
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			session, err := utilityMod.GetSession(app.Address, 2, tt.chain, geoZone)
+			require.NoError(t, err)
+			require.Len(t, session.Servicers, tt.wantServicerCount)
+			require.Len(t, session.Fishermen, tt.wantFishermanCount)
+		})
+	}
+}
+
+func TestSession_GetSession_SessionHeightAndNumber_StaticBlocksPerSession(t *testing.T) {
+	// Prepare the environment
+	_, _, persistenceMod := prepareEnvironment(t, 5, 1, 1, 1)
+
+	// Note that we are using an ephemeral write context at the genesis block (height=0).
+	// This cannot be committed but useful for the test.
+	writeCtx, err := persistenceMod.NewRWContext(0)
+	require.NoError(t, err)
+	defer writeCtx.Release()
+
+	s := &sessionHydrator{
+		session: &coreTypes.Session{},
+		readCtx: writeCtx,
+	}
+
+	tests := []struct {
+		name                   string
+		setNumBlocksPerSession int64
+		provideBlockHeight     int64
+		wantSessionHeight      int64
+		wantSessionNumber      int64
+	}{
+		{
+			name:                   ""genesis block"",
+			setNumBlocksPerSession: 5,
+			provideBlockHeight:     0,
+			wantSessionHeight:      0,
+			wantSessionNumber:      0,
+		},
+		{
+			name:                   ""block is at start of first session"",
+			setNumBlocksPerSession: 5,
+			provideBlockHeight:     5,
+			wantSessionHeight:      5,
+			wantSessionNumber:      1,
+		},
+		{
+			name:                   ""block is right before start of first session"",
+			setNumBlocksPerSession: 5,
+			provideBlockHeight:     4,
+			wantSessionHeight:      0,
+			wantSessionNumber:      0,
+		},
+		{
+			name:                   ""block is right after start of first session"",
+			setNumBlocksPerSession: 5,
+			provideBlockHeight:     6,
+			wantSessionHeight:      5,
+			wantSessionNumber:      1,
+		},
+		{
+			name:                   ""block is at start of second session"",
+			setNumBlocksPerSession: 5,
+			provideBlockHeight:     10,
+			wantSessionHeight:      10,
+			wantSessionNumber:      2,
+		},
+	}
+
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			err := writeCtx.SetParam(types.BlocksPerSessionParamName, tt.setNumBlocksPerSession)
+			require.NoError(t, err)
+
+			s.blockHeight = tt.provideBlockHeight
+			err = s.hydrateSessionMetadata()
+			require.NoError(t, err)
+			require.Equal(t, tt.setNumBlocksPerSession, s.session.NumSessionBlocks)
+			require.Equal(t, tt.wantSessionHeight, s.session.SessionHeight)
+			require.Equal(t, tt.wantSessionNumber, s.session.SessionNumber)
+		})
+	}
+}
+
+func TestSession_GetSession_ServicersAndFishermanEntropy(t *testing.T) {
+	// Prepare an environment with a lot of servicers and fishermen
+	numServicers := 1000
+	numFishermen := 1000 // make them equal for simplicity
+	numServicersPerSession := 10
+	numFishermenPerSession := 10 // make them equal for simplicity
+	numApplications := 3
+	numBlocksPerSession := 2 // expect a different every other height
+
+	// Determine probability of overlap using combinatorics
+	numChoices := combin.GeneralizedBinomial(float64(numServicers), float64(numServicersPerSession))                                 // (numServicers) C (numServicersPerSession)",utility/session_test.go,2023-04-25 10:31:26+00:00,2023-04-25T10:32:19Z,"Great commenting and cool implementation! :sunglasses::raised_hands: 

nit: Wdyt about moving the in-line comment to either the same line as the other comment or it's own line? 

(Similar question for the line below.)",,380.0,RIGHT,,381,RIGHT,381,,line,https://api.github.com/repos/pokt-network/pocket/pulls/683,pokt-network/pocket,fb245bc027ae55aaee936daf9f85ecb2d9ad8b40
https://api.github.com/repos/pokt-network/pocket/pulls/683,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1176330909,bryanchriswhite,50d0c7174f166c4424631ca68fc3ed05fbb46ed6,e2864b82e0b52b527cf11e0a05062f4779fef9fe,"@@ -0,0 +1,531 @@
+package utility
+
+import (
+	""fmt""
+	""math""
+	""testing""
+
+	""github.com/pokt-network/pocket/runtime/test_artifacts""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/crypto""
+	""github.com/pokt-network/pocket/shared/messaging""
+	""github.com/pokt-network/pocket/utility/types""
+	""github.com/stretchr/testify/assert""
+	""github.com/stretchr/testify/require""
+	""gonum.org/v1/gonum/stat/combin""
+)
+
+// TECHDEBT: Geozones are not current implemented, used or tested
+
+func TestSession_GetSession_SingleFishermanSingleServicerBaseCase(t *testing.T) {
+	// Test parameters
+	height := int64(1)
+	relayChain := test_artifacts.DefaultChains[0]
+	geoZone := ""unused_geo""
+	numFishermen := 1
+	numServicers := 1
+	expectedSessionId := ""5acf559f1a3faf3bea7eb692fe51bc1e2e5fb687ede0a6daa7d42399da4aa82b"" // needs to be manually updated if business logic changes
+
+	runtimeCfg, utilityMod, _ := prepareEnvironment(t, 5, numServicers, 1, numFishermen)
+
+	// Sanity check genesis
+	require.Len(t, runtimeCfg.GetGenesis().Applications, 1)
+	app := runtimeCfg.GetGenesis().Applications[0]
+	require.Len(t, runtimeCfg.GetGenesis().Fishermen, 1)
+	fish := runtimeCfg.GetGenesis().Fishermen[0]
+	require.Len(t, runtimeCfg.GetGenesis().Servicers, 1)
+	servicer := runtimeCfg.GetGenesis().Servicers[0]
+
+	// Verify some of the session defaults
+	session, err := utilityMod.GetSession(app.Address, height, relayChain, geoZone)
+	require.NoError(t, err)
+	require.Equal(t, expectedSessionId, session.Id)
+	require.Equal(t, height, session.SessionHeight)
+	require.Equal(t, int64(1), session.SessionNumber)
+	require.Equal(t, int64(1), session.NumSessionBlocks)
+	require.Equal(t, relayChain, session.RelayChain)
+	require.Equal(t, geoZone, session.GeoZone)
+	require.Equal(t, app.Address, session.Application.Address)
+	require.Len(t, session.Servicers, numServicers)
+	require.Equal(t, servicer.Address, session.Servicers[0].Address)
+	require.Len(t, session.Fishermen, numFishermen)
+	require.Equal(t, fish.Address, session.Fishermen[0].Address)
+}
+
+func TestSession_GetSession_ApplicationInvalid(t *testing.T) {
+	runtimeCfg, utilityMod, _ := prepareEnvironment(t, 5, 1, 1, 1)
+
+	// Verify there's only 1 app
+	require.Len(t, runtimeCfg.GetGenesis().Applications, 1)
+	app := runtimeCfg.GetGenesis().Applications[0]
+
+	// Create a new app address
+	pk, err := crypto.GeneratePrivateKey()
+	require.NoError(t, err)
+
+	// Verify that the one app in the genesis is not the one we just generated
+	addr := pk.Address().String()
+	require.NotEqual(t, app.Address, addr)
+
+	// Expect no error trying to get a session for the real application
+	_, err = utilityMod.GetSession(app.Address, 1, test_artifacts.DefaultChains[0], ""unused_geo"")
+	require.NoError(t, err)
+
+	// Expect an error trying to get a session for an unstaked chain
+	_, err = utilityMod.GetSession(addr, 1, ""chain"", ""unused_geo"")
+	require.Error(t, err)
+
+	// Expect an error trying to get a session for a non-existent application
+	_, err = utilityMod.GetSession(addr, 1, test_artifacts.DefaultChains[0], ""unused_geo"")
+	require.Error(t, err)
+}
+
+func TestSession_GetSession_InvalidFutureSession(t *testing.T) {
+	runtimeCfg, utilityMod, persistenceMod := prepareEnvironment(t, 5, 1, 1, 1)
+
+	// Test parameters
+	relayChain := test_artifacts.DefaultChains[0]
+	geoZone := ""unused_geo""
+	app := runtimeCfg.GetGenesis().Applications[0]
+
+	// Local variable to keep track of the height we're getting a session for
+	currentHeight := int64(0)
+
+	// Successfully get a session for 1 block ahead of the latest committed height
+	session, err := utilityMod.GetSession(app.Address, currentHeight+1, relayChain, geoZone)
+	require.NoError(t, err)
+	require.Equal(t, currentHeight+1, session.SessionHeight)
+
+	// Expect an error for a few heights into the future
+	for height := currentHeight + 2; height < 10; height++ {
+		_, err := utilityMod.GetSession(app.Address, height, relayChain, geoZone)
+		require.Error(t, err)
+	}
+
+	// Commit new blocks for all the heights that failed above
+	for ; currentHeight < 10; currentHeight++ {
+		writeCtx, err := persistenceMod.NewRWContext(currentHeight + 1)
+		require.NoError(t, err)
+		err = writeCtx.Commit([]byte(fmt.Sprintf(""proposer_height_%d"", currentHeight)), []byte(fmt.Sprintf(""quorum_cert_height_%d"", currentHeight)))
+		require.NoError(t, err)
+		writeCtx.Release()
+	}
+
+	// Expect no errors since those blocks exist now
+	// Note that we can get the session for latest_committed + 1
+	for height := int64(1); height <= currentHeight+1; height++ {
+		_, err := utilityMod.GetSession(app.Address, height, relayChain, geoZone)
+		require.NoError(t, err)
+	}
+
+	// Verify that currentHeight + 2 fails
+	_, err = utilityMod.GetSession(app.Address, currentHeight+2, relayChain, geoZone)
+	require.Error(t, err)
+}
+
+func TestSession_GetSession_ServicersAndFishermenCounts_TotalAvailability(t *testing.T) {
+	// Prepare an environment with a lot of servicers and fishermen
+	numServicers := 100
+	numFishermen := 100
+	runtimeCfg, utilityMod, persistenceMod := prepareEnvironment(t, 5, numServicers, 1, numFishermen)
+
+	// Vary the number of actors per session using gov params and check that the session is populated with the correct number of actorss
+	tests := []struct {
+		name                   string
+		numServicersPerSession int64
+		numFishermanPerSession int64
+		wantServicerCount      int
+		wantFishermanCount     int
+	}{
+		{
+			name:                   ""more actors per session than available in network"",
+			numServicersPerSession: int64(numServicers) * 10,
+			numFishermanPerSession: int64(numFishermen) * 10,
+			wantServicerCount:      numServicers,
+			wantFishermanCount:     numFishermen,
+		},
+		{
+			name:                   ""less actors per session than available in network"",
+			numServicersPerSession: int64(numServicers) / 2,
+			numFishermanPerSession: int64(numFishermen) / 2,
+			wantServicerCount:      numServicers / 2,
+			wantFishermanCount:     numFishermen / 2,
+		},
+		{
+			name:                   ""same number of actors per session as available in network"",
+			numServicersPerSession: int64(numServicers),
+			numFishermanPerSession: int64(numFishermen),
+			wantServicerCount:      numServicers,
+			wantFishermanCount:     numFishermen,
+		},
+		{
+			name:                   ""more than enough servicers but not enough fishermen"",
+			numServicersPerSession: int64(numServicers) / 2,
+			numFishermanPerSession: int64(numFishermen) * 10,
+			wantServicerCount:      numServicers / 2,
+			wantFishermanCount:     numFishermen,
+		},
+		{
+			name:                   ""more than enough fishermen but not enough servicers"",
+			numServicersPerSession: int64(numServicers) * 10,
+			numFishermanPerSession: int64(numFishermen) / 2,
+			wantServicerCount:      numServicers,
+			wantFishermanCount:     numFishermen / 2,
+		},
+	}
+
+	// Test constant parameters
+	updateParamsHeight := int64(1)
+	querySessionHeight := int64(2)
+
+	app := runtimeCfg.GetGenesis().Applications[0]
+	relayChain := test_artifacts.DefaultChains[0]
+	geoZone := ""unused_geo""
+
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			// Reset to genesis
+			err := persistenceMod.HandleDebugMessage(&messaging.DebugMessage{
+				Action:  messaging.DebugMessageAction_DEBUG_PERSISTENCE_RESET_TO_GENESIS,
+				Message: nil,
+			})
+			require.NoError(t, err)
+
+			// Update the number of servicers and fishermen per session gov params
+			writeCtx, err := persistenceMod.NewRWContext(updateParamsHeight)
+			require.NoError(t, err)
+			defer writeCtx.Release()
+
+			err = writeCtx.SetParam(types.ServicersPerSessionParamName, tt.numServicersPerSession)
+			require.NoError(t, err)
+			err = writeCtx.SetParam(types.FishermanPerSessionParamName, tt.numFishermanPerSession)
+			require.NoError(t, err)
+			err = writeCtx.Commit([]byte(""empty_proposed_addr""), []byte(""empty_quorum_cert""))
+			require.NoError(t, err)
+
+			// Verify that the session is populated with the correct number of actors
+			session, err := utilityMod.GetSession(app.Address, querySessionHeight, relayChain, geoZone)
+			require.NoError(t, err)
+			require.Equal(t, tt.wantServicerCount, len(session.Servicers))
+			require.Equal(t, tt.wantFishermanCount, len(session.Fishermen))
+		})
+	}
+}
+
+func TestSession_GetSession_ServicersAndFishermenCounts_ChainAvailability(t *testing.T) {
+	// Test constant parameters
+	numServicersPerSession := 10
+	numFishermenPerSession := 2
+
+	// Make sure there are MORE THAN ENOUGH servicers and fishermen in the network for each session for chain 1
+	servicersChain1, servicerKeysChain1 := test_artifacts.NewActors(coreTypes.ActorType_ACTOR_TYPE_SERVICER, numServicersPerSession*2, []string{""chn1""})
+	fishermenChain2, fishermenKeysChain2 := test_artifacts.NewActors(coreTypes.ActorType_ACTOR_TYPE_FISH, numFishermenPerSession*2, []string{""chn1""})
+
+	// Make sure there are NOT ENOUGH servicers and fishermen in the network for each session for chain 2
+	servicersChain2, servicerKeysChain2 := test_artifacts.NewActors(coreTypes.ActorType_ACTOR_TYPE_SERVICER, numServicersPerSession/2, []string{""chn2""})
+	fishermenChain1, fishermenKeysChain1 := test_artifacts.NewActors(coreTypes.ActorType_ACTOR_TYPE_FISH, numFishermenPerSession/2, []string{""chn2""})
+
+	application, applicationKey := test_artifacts.NewActors(coreTypes.ActorType_ACTOR_TYPE_APP, 1, []string{""chn1"", ""chn2"", ""chn3""})
+
+	//nolint:gocritic // intentionally not appending result to a new slice
+	actors := append(application, append(servicersChain1, append(servicersChain2, append(fishermenChain1, fishermenChain2...)...)...)...)
+	//nolint:gocritic // intentionally not appending result to a new slice
+	keys := append(applicationKey, append(servicerKeysChain1, append(servicerKeysChain2, append(fishermenKeysChain1, fishermenKeysChain2...)...)...)...)
+
+	// Prepare the environment
+	runtimeCfg, utilityMod, persistenceMod := prepareEnvironment(t, 5, 0, 0, 0, test_artifacts.WithActors(actors, keys))
+
+	// Vary the chain and check the number of fishermen and servicers returned for each one
+	tests := []struct {
+		name               string
+		chain              string
+		wantServicerCount  int
+		wantFishermanCount int
+	}{
+		{
+			name:               ""chn1 has enough servicers and fishermen"",
+			chain:              ""chn1"",
+			wantServicerCount:  numServicersPerSession,
+			wantFishermanCount: numFishermenPerSession,
+		},
+		{
+			name:               ""chn2 does not have enough servicers and fishermen"",
+			chain:              ""chn2"",
+			wantServicerCount:  numServicersPerSession / 2,
+			wantFishermanCount: numFishermenPerSession / 2,
+		},
+		{
+			name:               ""chn3 has no servicers and fishermen"",
+			chain:              ""chn3"",
+			wantServicerCount:  0,
+			wantFishermanCount: 0,
+		},
+	}
+
+	// Reset to genesis
+	err := persistenceMod.HandleDebugMessage(&messaging.DebugMessage{
+		Action:  messaging.DebugMessageAction_DEBUG_PERSISTENCE_RESET_TO_GENESIS,
+		Message: nil,
+	})
+	require.NoError(t, err)
+
+	// Update the number of servicers and fishermen per session gov params
+	writeCtx, err := persistenceMod.NewRWContext(1)
+	require.NoError(t, err)
+	err = writeCtx.SetParam(types.ServicersPerSessionParamName, numServicersPerSession)
+	require.NoError(t, err)
+	err = writeCtx.SetParam(types.FishermanPerSessionParamName, numFishermenPerSession)
+	require.NoError(t, err)
+	err = writeCtx.Commit([]byte(""empty_proposed_addr""), []byte(""empty_quorum_cert""))
+	require.NoError(t, err)
+	defer writeCtx.Release()
+
+	// Test parameters
+	app := runtimeCfg.GetGenesis().Applications[0]
+	geoZone := ""unused_geo""
+
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			session, err := utilityMod.GetSession(app.Address, 2, tt.chain, geoZone)
+			require.NoError(t, err)
+			require.Len(t, session.Servicers, tt.wantServicerCount)
+			require.Len(t, session.Fishermen, tt.wantFishermanCount)
+		})
+	}
+}
+
+func TestSession_GetSession_SessionHeightAndNumber_StaticBlocksPerSession(t *testing.T) {
+	// Prepare the environment
+	_, _, persistenceMod := prepareEnvironment(t, 5, 1, 1, 1)
+
+	// Note that we are using an ephemeral write context at the genesis block (height=0).
+	// This cannot be committed but useful for the test.
+	writeCtx, err := persistenceMod.NewRWContext(0)
+	require.NoError(t, err)
+	defer writeCtx.Release()
+
+	s := &sessionHydrator{
+		session: &coreTypes.Session{},
+		readCtx: writeCtx,
+	}
+
+	tests := []struct {
+		name                   string
+		setNumBlocksPerSession int64
+		provideBlockHeight     int64
+		wantSessionHeight      int64
+		wantSessionNumber      int64
+	}{
+		{
+			name:                   ""genesis block"",
+			setNumBlocksPerSession: 5,
+			provideBlockHeight:     0,
+			wantSessionHeight:      0,
+			wantSessionNumber:      0,
+		},
+		{
+			name:                   ""block is at start of first session"",
+			setNumBlocksPerSession: 5,
+			provideBlockHeight:     5,
+			wantSessionHeight:      5,
+			wantSessionNumber:      1,
+		},
+		{
+			name:                   ""block is right before start of first session"",
+			setNumBlocksPerSession: 5,
+			provideBlockHeight:     4,
+			wantSessionHeight:      0,
+			wantSessionNumber:      0,
+		},
+		{
+			name:                   ""block is right after start of first session"",
+			setNumBlocksPerSession: 5,
+			provideBlockHeight:     6,
+			wantSessionHeight:      5,
+			wantSessionNumber:      1,
+		},
+		{
+			name:                   ""block is at start of second session"",
+			setNumBlocksPerSession: 5,
+			provideBlockHeight:     10,
+			wantSessionHeight:      10,
+			wantSessionNumber:      2,
+		},
+	}
+
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			err := writeCtx.SetParam(types.BlocksPerSessionParamName, tt.setNumBlocksPerSession)
+			require.NoError(t, err)
+
+			s.blockHeight = tt.provideBlockHeight
+			err = s.hydrateSessionMetadata()
+			require.NoError(t, err)
+			require.Equal(t, tt.setNumBlocksPerSession, s.session.NumSessionBlocks)
+			require.Equal(t, tt.wantSessionHeight, s.session.SessionHeight)
+			require.Equal(t, tt.wantSessionNumber, s.session.SessionNumber)
+		})
+	}
+}
+
+func TestSession_GetSession_ServicersAndFishermanEntropy(t *testing.T) {
+	// Prepare an environment with a lot of servicers and fishermen
+	numServicers := 1000
+	numFishermen := 1000 // make them equal for simplicity
+	numServicersPerSession := 10
+	numFishermenPerSession := 10 // make them equal for simplicity
+	numApplications := 3
+	numBlocksPerSession := 2 // expect a different every other height
+
+	// Determine probability of overlap using combinatorics
+	numChoices := combin.GeneralizedBinomial(float64(numServicers), float64(numServicersPerSession))                                 // (numServicers) C (numServicersPerSession)
+	numChoicesRemaining := combin.GeneralizedBinomial(float64(numServicers-numServicersPerSession), float64(numServicersPerSession)) // (numServicers - numServicersPerSession) C (numServicersPerSession)
+	probabilityOfOverlap := (numChoices - numChoicesRemaining) / numChoices
+
+	// Prepare the environment
+	runtimeCfg, utilityMod, persistenceMod := prepareEnvironment(t, 5, numServicers, numApplications, numFishermen)
+
+	// Set the number of servicers and fishermen per session gov params
+	writeCtx, err := persistenceMod.NewRWContext(1)
+	require.NoError(t, err)
+	err = writeCtx.SetParam(types.ServicersPerSessionParamName, numServicersPerSession)
+	require.NoError(t, err)
+	err = writeCtx.SetParam(types.FishermanPerSessionParamName, numFishermenPerSession)
+	require.NoError(t, err)
+	err = writeCtx.SetParam(types.BlocksPerSessionParamName, numBlocksPerSession)
+	require.NoError(t, err)
+	err = writeCtx.Commit([]byte(fmt.Sprintf(""proposer_height_%d"", 1)), []byte(fmt.Sprintf(""quorum_cert_height_%d"", 1)))
+	require.NoError(t, err)
+	writeCtx.Release()
+
+	// Keep the relay chain and geoZone static, but vary the app and height to verify that the servicers and fishermen vary
+	relayChain := test_artifacts.DefaultChains[0]
+	geoZone := ""unused_geo""
+
+	// Sanity check we have 3 apps
+	require.Len(t, runtimeCfg.GetGenesis().Applications, numApplications)
+	app1 := runtimeCfg.GetGenesis().Applications[0]
+	app2 := runtimeCfg.GetGenesis().Applications[1]
+	app3 := runtimeCfg.GetGenesis().Applications[2]
+
+	// Keep track of the actors from the session at the previous height to verify a delta
+	var app1PrevServicers, app2PrevServicers, app3PrevServicers []*coreTypes.Actor
+	var app1PrevFishermen, app2PrevFishermen, app3PrevFishermen []*coreTypes.Actor
+
+	// The number of blocks to increase until we expect a different set of servicers and fishermen; see numBlocksPerSession
+	numBlocksUntilChange := 0
+
+	// Commit new blocks for all the heights that failed above
+	for height := int64(2); height < 10; height++ {
+		session1, err := utilityMod.GetSession(app1.Address, height, relayChain, geoZone)
+		require.NoError(t, err)
+		session2, err := utilityMod.GetSession(app2.Address, height, relayChain, geoZone)
+		require.NoError(t, err)
+		session3, err := utilityMod.GetSession(app3.Address, height, relayChain, geoZone)
+		require.NoError(t, err)
+
+		// All the sessions have the same number of servicers
+		require.Len(t, session1.Servicers, numServicersPerSession)
+		require.Equal(t, len(session1.Servicers), len(session2.Servicers))
+		require.Equal(t, len(session1.Servicers), len(session3.Servicers))
+
+		// All the sessions have the same number of fishermen
+		require.Len(t, session1.Fishermen, numFishermenPerSession)
+		require.Equal(t, len(session1.Fishermen), len(session2.Fishermen))
+		require.Equal(t, len(session1.Fishermen), len(session3.Fishermen))
+
+		// Assert different services between apps
+		assertActorsDifference(t, session1.Servicers, session2.Servicers, probabilityOfOverlap)
+		assertActorsDifference(t, session1.Servicers, session3.Servicers, probabilityOfOverlap)
+
+		// Assert different fishermen between apps
+		assertActorsDifference(t, session1.Fishermen, session2.Fishermen, probabilityOfOverlap)
+		assertActorsDifference(t, session1.Fishermen, session3.Fishermen, probabilityOfOverlap)
+
+		if numBlocksUntilChange == 0 {
+			// Assert different servicers between heights for the same app
+			assertActorsDifference(t, app1PrevServicers, session1.Servicers, probabilityOfOverlap)
+			assertActorsDifference(t, app2PrevServicers, session2.Servicers, probabilityOfOverlap)
+			assertActorsDifference(t, app3PrevServicers, session3.Servicers, probabilityOfOverlap)
+
+			// Assert different fishermen between heights for the same app
+			assertActorsDifference(t, app1PrevFishermen, session1.Fishermen, probabilityOfOverlap)
+			assertActorsDifference(t, app2PrevFishermen, session2.Fishermen, probabilityOfOverlap)
+			assertActorsDifference(t, app3PrevFishermen, session3.Fishermen, probabilityOfOverlap)
+
+			// Store the new servicers and fishermen for the next height
+			app1PrevServicers = session1.Servicers
+			app2PrevServicers = session2.Servicers
+			app3PrevServicers = session3.Servicers
+			app1PrevFishermen = session1.Fishermen
+			app2PrevFishermen = session2.Fishermen
+			app3PrevFishermen = session3.Fishermen
+
+			// Reset the number of blocks until we expect a different set of servicers and fishermen
+			numBlocksUntilChange = numBlocksPerSession - 1
+		} else {
+			// Assert the same servicers between heights for the same app
+			require.ElementsMatch(t, app1PrevServicers, session1.Servicers)
+			require.ElementsMatch(t, app2PrevServicers, session2.Servicers)
+			require.ElementsMatch(t, app3PrevServicers, session3.Servicers)
+
+			// Assert the same fishermen between heights for the same app
+			require.ElementsMatch(t, app1PrevFishermen, session1.Fishermen)
+			require.ElementsMatch(t, app2PrevFishermen, session2.Fishermen)
+			require.ElementsMatch(t, app3PrevFishermen, session3.Fishermen)
+
+			numBlocksUntilChange--
+		}
+
+		// Advance block height
+		writeCtx, err := persistenceMod.NewRWContext(height)
+		require.NoError(t, err)
+		err = writeCtx.Commit([]byte(fmt.Sprintf(""proposer_height_%d"", height)), []byte(fmt.Sprintf(""quorum_cert_height_%d"", height)))
+		require.NoError(t, err)
+		writeCtx.Release()
+	}
+}
+
+func TestSession_GetSession_ApplicationUnbonds(t *testing.T) {
+	// TODO: What if an Application unbonds (unstaking period elapses) mid session?
+}
+
+func TestSession_GetSession_ServicersAndFishermenCounts_GeoZoneAvailability(t *testing.T) {
+	// TODO: Once GeoZones are implemented, the tests need to be added as well",utility/session_test.go,2023-04-25 10:38:20+00:00,2023-04-27T07:12:48Z,"Is there a more relevant issue?

```suggestion
	// TECHDEBT(#697): Once GeoZones are implemented, the tests need to be added as well
```",,,,,494,RIGHT,494,,line,https://api.github.com/repos/pokt-network/pocket/pulls/683,pokt-network/pocket,fb245bc027ae55aaee936daf9f85ecb2d9ad8b40
https://api.github.com/repos/pokt-network/pocket/pulls/683,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1176330991,bryanchriswhite,50d0c7174f166c4424631ca68fc3ed05fbb46ed6,e2864b82e0b52b527cf11e0a05062f4779fef9fe,"@@ -0,0 +1,531 @@
+package utility
+
+import (
+	""fmt""
+	""math""
+	""testing""
+
+	""github.com/pokt-network/pocket/runtime/test_artifacts""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/crypto""
+	""github.com/pokt-network/pocket/shared/messaging""
+	""github.com/pokt-network/pocket/utility/types""
+	""github.com/stretchr/testify/assert""
+	""github.com/stretchr/testify/require""
+	""gonum.org/v1/gonum/stat/combin""
+)
+
+// TECHDEBT: Geozones are not current implemented, used or tested
+
+func TestSession_GetSession_SingleFishermanSingleServicerBaseCase(t *testing.T) {
+	// Test parameters
+	height := int64(1)
+	relayChain := test_artifacts.DefaultChains[0]
+	geoZone := ""unused_geo""
+	numFishermen := 1
+	numServicers := 1
+	expectedSessionId := ""5acf559f1a3faf3bea7eb692fe51bc1e2e5fb687ede0a6daa7d42399da4aa82b"" // needs to be manually updated if business logic changes
+
+	runtimeCfg, utilityMod, _ := prepareEnvironment(t, 5, numServicers, 1, numFishermen)
+
+	// Sanity check genesis
+	require.Len(t, runtimeCfg.GetGenesis().Applications, 1)
+	app := runtimeCfg.GetGenesis().Applications[0]
+	require.Len(t, runtimeCfg.GetGenesis().Fishermen, 1)
+	fish := runtimeCfg.GetGenesis().Fishermen[0]
+	require.Len(t, runtimeCfg.GetGenesis().Servicers, 1)
+	servicer := runtimeCfg.GetGenesis().Servicers[0]
+
+	// Verify some of the session defaults
+	session, err := utilityMod.GetSession(app.Address, height, relayChain, geoZone)
+	require.NoError(t, err)
+	require.Equal(t, expectedSessionId, session.Id)
+	require.Equal(t, height, session.SessionHeight)
+	require.Equal(t, int64(1), session.SessionNumber)
+	require.Equal(t, int64(1), session.NumSessionBlocks)
+	require.Equal(t, relayChain, session.RelayChain)
+	require.Equal(t, geoZone, session.GeoZone)
+	require.Equal(t, app.Address, session.Application.Address)
+	require.Len(t, session.Servicers, numServicers)
+	require.Equal(t, servicer.Address, session.Servicers[0].Address)
+	require.Len(t, session.Fishermen, numFishermen)
+	require.Equal(t, fish.Address, session.Fishermen[0].Address)
+}
+
+func TestSession_GetSession_ApplicationInvalid(t *testing.T) {
+	runtimeCfg, utilityMod, _ := prepareEnvironment(t, 5, 1, 1, 1)
+
+	// Verify there's only 1 app
+	require.Len(t, runtimeCfg.GetGenesis().Applications, 1)
+	app := runtimeCfg.GetGenesis().Applications[0]
+
+	// Create a new app address
+	pk, err := crypto.GeneratePrivateKey()
+	require.NoError(t, err)
+
+	// Verify that the one app in the genesis is not the one we just generated
+	addr := pk.Address().String()
+	require.NotEqual(t, app.Address, addr)
+
+	// Expect no error trying to get a session for the real application
+	_, err = utilityMod.GetSession(app.Address, 1, test_artifacts.DefaultChains[0], ""unused_geo"")
+	require.NoError(t, err)
+
+	// Expect an error trying to get a session for an unstaked chain
+	_, err = utilityMod.GetSession(addr, 1, ""chain"", ""unused_geo"")
+	require.Error(t, err)
+
+	// Expect an error trying to get a session for a non-existent application
+	_, err = utilityMod.GetSession(addr, 1, test_artifacts.DefaultChains[0], ""unused_geo"")
+	require.Error(t, err)
+}
+
+func TestSession_GetSession_InvalidFutureSession(t *testing.T) {
+	runtimeCfg, utilityMod, persistenceMod := prepareEnvironment(t, 5, 1, 1, 1)
+
+	// Test parameters
+	relayChain := test_artifacts.DefaultChains[0]
+	geoZone := ""unused_geo""
+	app := runtimeCfg.GetGenesis().Applications[0]
+
+	// Local variable to keep track of the height we're getting a session for
+	currentHeight := int64(0)
+
+	// Successfully get a session for 1 block ahead of the latest committed height
+	session, err := utilityMod.GetSession(app.Address, currentHeight+1, relayChain, geoZone)
+	require.NoError(t, err)
+	require.Equal(t, currentHeight+1, session.SessionHeight)
+
+	// Expect an error for a few heights into the future
+	for height := currentHeight + 2; height < 10; height++ {
+		_, err := utilityMod.GetSession(app.Address, height, relayChain, geoZone)
+		require.Error(t, err)
+	}
+
+	// Commit new blocks for all the heights that failed above
+	for ; currentHeight < 10; currentHeight++ {
+		writeCtx, err := persistenceMod.NewRWContext(currentHeight + 1)
+		require.NoError(t, err)
+		err = writeCtx.Commit([]byte(fmt.Sprintf(""proposer_height_%d"", currentHeight)), []byte(fmt.Sprintf(""quorum_cert_height_%d"", currentHeight)))
+		require.NoError(t, err)
+		writeCtx.Release()
+	}
+
+	// Expect no errors since those blocks exist now
+	// Note that we can get the session for latest_committed + 1
+	for height := int64(1); height <= currentHeight+1; height++ {
+		_, err := utilityMod.GetSession(app.Address, height, relayChain, geoZone)
+		require.NoError(t, err)
+	}
+
+	// Verify that currentHeight + 2 fails
+	_, err = utilityMod.GetSession(app.Address, currentHeight+2, relayChain, geoZone)
+	require.Error(t, err)
+}
+
+func TestSession_GetSession_ServicersAndFishermenCounts_TotalAvailability(t *testing.T) {
+	// Prepare an environment with a lot of servicers and fishermen
+	numServicers := 100
+	numFishermen := 100
+	runtimeCfg, utilityMod, persistenceMod := prepareEnvironment(t, 5, numServicers, 1, numFishermen)
+
+	// Vary the number of actors per session using gov params and check that the session is populated with the correct number of actorss
+	tests := []struct {
+		name                   string
+		numServicersPerSession int64
+		numFishermanPerSession int64
+		wantServicerCount      int
+		wantFishermanCount     int
+	}{
+		{
+			name:                   ""more actors per session than available in network"",
+			numServicersPerSession: int64(numServicers) * 10,
+			numFishermanPerSession: int64(numFishermen) * 10,
+			wantServicerCount:      numServicers,
+			wantFishermanCount:     numFishermen,
+		},
+		{
+			name:                   ""less actors per session than available in network"",
+			numServicersPerSession: int64(numServicers) / 2,
+			numFishermanPerSession: int64(numFishermen) / 2,
+			wantServicerCount:      numServicers / 2,
+			wantFishermanCount:     numFishermen / 2,
+		},
+		{
+			name:                   ""same number of actors per session as available in network"",
+			numServicersPerSession: int64(numServicers),
+			numFishermanPerSession: int64(numFishermen),
+			wantServicerCount:      numServicers,
+			wantFishermanCount:     numFishermen,
+		},
+		{
+			name:                   ""more than enough servicers but not enough fishermen"",
+			numServicersPerSession: int64(numServicers) / 2,
+			numFishermanPerSession: int64(numFishermen) * 10,
+			wantServicerCount:      numServicers / 2,
+			wantFishermanCount:     numFishermen,
+		},
+		{
+			name:                   ""more than enough fishermen but not enough servicers"",
+			numServicersPerSession: int64(numServicers) * 10,
+			numFishermanPerSession: int64(numFishermen) / 2,
+			wantServicerCount:      numServicers,
+			wantFishermanCount:     numFishermen / 2,
+		},
+	}
+
+	// Test constant parameters
+	updateParamsHeight := int64(1)
+	querySessionHeight := int64(2)
+
+	app := runtimeCfg.GetGenesis().Applications[0]
+	relayChain := test_artifacts.DefaultChains[0]
+	geoZone := ""unused_geo""
+
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			// Reset to genesis
+			err := persistenceMod.HandleDebugMessage(&messaging.DebugMessage{
+				Action:  messaging.DebugMessageAction_DEBUG_PERSISTENCE_RESET_TO_GENESIS,
+				Message: nil,
+			})
+			require.NoError(t, err)
+
+			// Update the number of servicers and fishermen per session gov params
+			writeCtx, err := persistenceMod.NewRWContext(updateParamsHeight)
+			require.NoError(t, err)
+			defer writeCtx.Release()
+
+			err = writeCtx.SetParam(types.ServicersPerSessionParamName, tt.numServicersPerSession)
+			require.NoError(t, err)
+			err = writeCtx.SetParam(types.FishermanPerSessionParamName, tt.numFishermanPerSession)
+			require.NoError(t, err)
+			err = writeCtx.Commit([]byte(""empty_proposed_addr""), []byte(""empty_quorum_cert""))
+			require.NoError(t, err)
+
+			// Verify that the session is populated with the correct number of actors
+			session, err := utilityMod.GetSession(app.Address, querySessionHeight, relayChain, geoZone)
+			require.NoError(t, err)
+			require.Equal(t, tt.wantServicerCount, len(session.Servicers))
+			require.Equal(t, tt.wantFishermanCount, len(session.Fishermen))
+		})
+	}
+}
+
+func TestSession_GetSession_ServicersAndFishermenCounts_ChainAvailability(t *testing.T) {
+	// Test constant parameters
+	numServicersPerSession := 10
+	numFishermenPerSession := 2
+
+	// Make sure there are MORE THAN ENOUGH servicers and fishermen in the network for each session for chain 1
+	servicersChain1, servicerKeysChain1 := test_artifacts.NewActors(coreTypes.ActorType_ACTOR_TYPE_SERVICER, numServicersPerSession*2, []string{""chn1""})
+	fishermenChain2, fishermenKeysChain2 := test_artifacts.NewActors(coreTypes.ActorType_ACTOR_TYPE_FISH, numFishermenPerSession*2, []string{""chn1""})
+
+	// Make sure there are NOT ENOUGH servicers and fishermen in the network for each session for chain 2
+	servicersChain2, servicerKeysChain2 := test_artifacts.NewActors(coreTypes.ActorType_ACTOR_TYPE_SERVICER, numServicersPerSession/2, []string{""chn2""})
+	fishermenChain1, fishermenKeysChain1 := test_artifacts.NewActors(coreTypes.ActorType_ACTOR_TYPE_FISH, numFishermenPerSession/2, []string{""chn2""})
+
+	application, applicationKey := test_artifacts.NewActors(coreTypes.ActorType_ACTOR_TYPE_APP, 1, []string{""chn1"", ""chn2"", ""chn3""})
+
+	//nolint:gocritic // intentionally not appending result to a new slice
+	actors := append(application, append(servicersChain1, append(servicersChain2, append(fishermenChain1, fishermenChain2...)...)...)...)
+	//nolint:gocritic // intentionally not appending result to a new slice
+	keys := append(applicationKey, append(servicerKeysChain1, append(servicerKeysChain2, append(fishermenKeysChain1, fishermenKeysChain2...)...)...)...)
+
+	// Prepare the environment
+	runtimeCfg, utilityMod, persistenceMod := prepareEnvironment(t, 5, 0, 0, 0, test_artifacts.WithActors(actors, keys))
+
+	// Vary the chain and check the number of fishermen and servicers returned for each one
+	tests := []struct {
+		name               string
+		chain              string
+		wantServicerCount  int
+		wantFishermanCount int
+	}{
+		{
+			name:               ""chn1 has enough servicers and fishermen"",
+			chain:              ""chn1"",
+			wantServicerCount:  numServicersPerSession,
+			wantFishermanCount: numFishermenPerSession,
+		},
+		{
+			name:               ""chn2 does not have enough servicers and fishermen"",
+			chain:              ""chn2"",
+			wantServicerCount:  numServicersPerSession / 2,
+			wantFishermanCount: numFishermenPerSession / 2,
+		},
+		{
+			name:               ""chn3 has no servicers and fishermen"",
+			chain:              ""chn3"",
+			wantServicerCount:  0,
+			wantFishermanCount: 0,
+		},
+	}
+
+	// Reset to genesis
+	err := persistenceMod.HandleDebugMessage(&messaging.DebugMessage{
+		Action:  messaging.DebugMessageAction_DEBUG_PERSISTENCE_RESET_TO_GENESIS,
+		Message: nil,
+	})
+	require.NoError(t, err)
+
+	// Update the number of servicers and fishermen per session gov params
+	writeCtx, err := persistenceMod.NewRWContext(1)
+	require.NoError(t, err)
+	err = writeCtx.SetParam(types.ServicersPerSessionParamName, numServicersPerSession)
+	require.NoError(t, err)
+	err = writeCtx.SetParam(types.FishermanPerSessionParamName, numFishermenPerSession)
+	require.NoError(t, err)
+	err = writeCtx.Commit([]byte(""empty_proposed_addr""), []byte(""empty_quorum_cert""))
+	require.NoError(t, err)
+	defer writeCtx.Release()
+
+	// Test parameters
+	app := runtimeCfg.GetGenesis().Applications[0]
+	geoZone := ""unused_geo""
+
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			session, err := utilityMod.GetSession(app.Address, 2, tt.chain, geoZone)
+			require.NoError(t, err)
+			require.Len(t, session.Servicers, tt.wantServicerCount)
+			require.Len(t, session.Fishermen, tt.wantFishermanCount)
+		})
+	}
+}
+
+func TestSession_GetSession_SessionHeightAndNumber_StaticBlocksPerSession(t *testing.T) {
+	// Prepare the environment
+	_, _, persistenceMod := prepareEnvironment(t, 5, 1, 1, 1)
+
+	// Note that we are using an ephemeral write context at the genesis block (height=0).
+	// This cannot be committed but useful for the test.
+	writeCtx, err := persistenceMod.NewRWContext(0)
+	require.NoError(t, err)
+	defer writeCtx.Release()
+
+	s := &sessionHydrator{
+		session: &coreTypes.Session{},
+		readCtx: writeCtx,
+	}
+
+	tests := []struct {
+		name                   string
+		setNumBlocksPerSession int64
+		provideBlockHeight     int64
+		wantSessionHeight      int64
+		wantSessionNumber      int64
+	}{
+		{
+			name:                   ""genesis block"",
+			setNumBlocksPerSession: 5,
+			provideBlockHeight:     0,
+			wantSessionHeight:      0,
+			wantSessionNumber:      0,
+		},
+		{
+			name:                   ""block is at start of first session"",
+			setNumBlocksPerSession: 5,
+			provideBlockHeight:     5,
+			wantSessionHeight:      5,
+			wantSessionNumber:      1,
+		},
+		{
+			name:                   ""block is right before start of first session"",
+			setNumBlocksPerSession: 5,
+			provideBlockHeight:     4,
+			wantSessionHeight:      0,
+			wantSessionNumber:      0,
+		},
+		{
+			name:                   ""block is right after start of first session"",
+			setNumBlocksPerSession: 5,
+			provideBlockHeight:     6,
+			wantSessionHeight:      5,
+			wantSessionNumber:      1,
+		},
+		{
+			name:                   ""block is at start of second session"",
+			setNumBlocksPerSession: 5,
+			provideBlockHeight:     10,
+			wantSessionHeight:      10,
+			wantSessionNumber:      2,
+		},
+	}
+
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			err := writeCtx.SetParam(types.BlocksPerSessionParamName, tt.setNumBlocksPerSession)
+			require.NoError(t, err)
+
+			s.blockHeight = tt.provideBlockHeight
+			err = s.hydrateSessionMetadata()
+			require.NoError(t, err)
+			require.Equal(t, tt.setNumBlocksPerSession, s.session.NumSessionBlocks)
+			require.Equal(t, tt.wantSessionHeight, s.session.SessionHeight)
+			require.Equal(t, tt.wantSessionNumber, s.session.SessionNumber)
+		})
+	}
+}
+
+func TestSession_GetSession_ServicersAndFishermanEntropy(t *testing.T) {
+	// Prepare an environment with a lot of servicers and fishermen
+	numServicers := 1000
+	numFishermen := 1000 // make them equal for simplicity
+	numServicersPerSession := 10
+	numFishermenPerSession := 10 // make them equal for simplicity
+	numApplications := 3
+	numBlocksPerSession := 2 // expect a different every other height
+
+	// Determine probability of overlap using combinatorics
+	numChoices := combin.GeneralizedBinomial(float64(numServicers), float64(numServicersPerSession))                                 // (numServicers) C (numServicersPerSession)
+	numChoicesRemaining := combin.GeneralizedBinomial(float64(numServicers-numServicersPerSession), float64(numServicersPerSession)) // (numServicers - numServicersPerSession) C (numServicersPerSession)
+	probabilityOfOverlap := (numChoices - numChoicesRemaining) / numChoices
+
+	// Prepare the environment
+	runtimeCfg, utilityMod, persistenceMod := prepareEnvironment(t, 5, numServicers, numApplications, numFishermen)
+
+	// Set the number of servicers and fishermen per session gov params
+	writeCtx, err := persistenceMod.NewRWContext(1)
+	require.NoError(t, err)
+	err = writeCtx.SetParam(types.ServicersPerSessionParamName, numServicersPerSession)
+	require.NoError(t, err)
+	err = writeCtx.SetParam(types.FishermanPerSessionParamName, numFishermenPerSession)
+	require.NoError(t, err)
+	err = writeCtx.SetParam(types.BlocksPerSessionParamName, numBlocksPerSession)
+	require.NoError(t, err)
+	err = writeCtx.Commit([]byte(fmt.Sprintf(""proposer_height_%d"", 1)), []byte(fmt.Sprintf(""quorum_cert_height_%d"", 1)))
+	require.NoError(t, err)
+	writeCtx.Release()
+
+	// Keep the relay chain and geoZone static, but vary the app and height to verify that the servicers and fishermen vary
+	relayChain := test_artifacts.DefaultChains[0]
+	geoZone := ""unused_geo""
+
+	// Sanity check we have 3 apps
+	require.Len(t, runtimeCfg.GetGenesis().Applications, numApplications)
+	app1 := runtimeCfg.GetGenesis().Applications[0]
+	app2 := runtimeCfg.GetGenesis().Applications[1]
+	app3 := runtimeCfg.GetGenesis().Applications[2]
+
+	// Keep track of the actors from the session at the previous height to verify a delta
+	var app1PrevServicers, app2PrevServicers, app3PrevServicers []*coreTypes.Actor
+	var app1PrevFishermen, app2PrevFishermen, app3PrevFishermen []*coreTypes.Actor
+
+	// The number of blocks to increase until we expect a different set of servicers and fishermen; see numBlocksPerSession
+	numBlocksUntilChange := 0
+
+	// Commit new blocks for all the heights that failed above
+	for height := int64(2); height < 10; height++ {
+		session1, err := utilityMod.GetSession(app1.Address, height, relayChain, geoZone)
+		require.NoError(t, err)
+		session2, err := utilityMod.GetSession(app2.Address, height, relayChain, geoZone)
+		require.NoError(t, err)
+		session3, err := utilityMod.GetSession(app3.Address, height, relayChain, geoZone)
+		require.NoError(t, err)
+
+		// All the sessions have the same number of servicers
+		require.Len(t, session1.Servicers, numServicersPerSession)
+		require.Equal(t, len(session1.Servicers), len(session2.Servicers))
+		require.Equal(t, len(session1.Servicers), len(session3.Servicers))
+
+		// All the sessions have the same number of fishermen
+		require.Len(t, session1.Fishermen, numFishermenPerSession)
+		require.Equal(t, len(session1.Fishermen), len(session2.Fishermen))
+		require.Equal(t, len(session1.Fishermen), len(session3.Fishermen))
+
+		// Assert different services between apps
+		assertActorsDifference(t, session1.Servicers, session2.Servicers, probabilityOfOverlap)
+		assertActorsDifference(t, session1.Servicers, session3.Servicers, probabilityOfOverlap)
+
+		// Assert different fishermen between apps
+		assertActorsDifference(t, session1.Fishermen, session2.Fishermen, probabilityOfOverlap)
+		assertActorsDifference(t, session1.Fishermen, session3.Fishermen, probabilityOfOverlap)
+
+		if numBlocksUntilChange == 0 {
+			// Assert different servicers between heights for the same app
+			assertActorsDifference(t, app1PrevServicers, session1.Servicers, probabilityOfOverlap)
+			assertActorsDifference(t, app2PrevServicers, session2.Servicers, probabilityOfOverlap)
+			assertActorsDifference(t, app3PrevServicers, session3.Servicers, probabilityOfOverlap)
+
+			// Assert different fishermen between heights for the same app
+			assertActorsDifference(t, app1PrevFishermen, session1.Fishermen, probabilityOfOverlap)
+			assertActorsDifference(t, app2PrevFishermen, session2.Fishermen, probabilityOfOverlap)
+			assertActorsDifference(t, app3PrevFishermen, session3.Fishermen, probabilityOfOverlap)
+
+			// Store the new servicers and fishermen for the next height
+			app1PrevServicers = session1.Servicers
+			app2PrevServicers = session2.Servicers
+			app3PrevServicers = session3.Servicers
+			app1PrevFishermen = session1.Fishermen
+			app2PrevFishermen = session2.Fishermen
+			app3PrevFishermen = session3.Fishermen
+
+			// Reset the number of blocks until we expect a different set of servicers and fishermen
+			numBlocksUntilChange = numBlocksPerSession - 1
+		} else {
+			// Assert the same servicers between heights for the same app
+			require.ElementsMatch(t, app1PrevServicers, session1.Servicers)
+			require.ElementsMatch(t, app2PrevServicers, session2.Servicers)
+			require.ElementsMatch(t, app3PrevServicers, session3.Servicers)
+
+			// Assert the same fishermen between heights for the same app
+			require.ElementsMatch(t, app1PrevFishermen, session1.Fishermen)
+			require.ElementsMatch(t, app2PrevFishermen, session2.Fishermen)
+			require.ElementsMatch(t, app3PrevFishermen, session3.Fishermen)
+
+			numBlocksUntilChange--
+		}
+
+		// Advance block height
+		writeCtx, err := persistenceMod.NewRWContext(height)
+		require.NoError(t, err)
+		err = writeCtx.Commit([]byte(fmt.Sprintf(""proposer_height_%d"", height)), []byte(fmt.Sprintf(""quorum_cert_height_%d"", height)))
+		require.NoError(t, err)
+		writeCtx.Release()
+	}
+}
+
+func TestSession_GetSession_ApplicationUnbonds(t *testing.T) {
+	// TODO: What if an Application unbonds (unstaking period elapses) mid session?
+}
+
+func TestSession_GetSession_ServicersAndFishermenCounts_GeoZoneAvailability(t *testing.T) {
+	// TODO: Once GeoZones are implemented, the tests need to be added as well",utility/session_test.go,2023-04-25 10:38:25+00:00,2023-04-27T07:12:58Z,"Is there a more relevant issue?

```suggestion
	// TECHDEBT(#697): Once GeoZones are implemented, the tests need to be added as well
```",,,,,494,RIGHT,494,,line,https://api.github.com/repos/pokt-network/pocket/pulls/683,pokt-network/pocket,fb245bc027ae55aaee936daf9f85ecb2d9ad8b40
https://api.github.com/repos/pokt-network/pocket/pulls/683,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1176333813,bryanchriswhite,50d0c7174f166c4424631ca68fc3ed05fbb46ed6,e2864b82e0b52b527cf11e0a05062f4779fef9fe,"@@ -0,0 +1,531 @@
+package utility
+
+import (
+	""fmt""
+	""math""
+	""testing""
+
+	""github.com/pokt-network/pocket/runtime/test_artifacts""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/crypto""
+	""github.com/pokt-network/pocket/shared/messaging""
+	""github.com/pokt-network/pocket/utility/types""
+	""github.com/stretchr/testify/assert""
+	""github.com/stretchr/testify/require""
+	""gonum.org/v1/gonum/stat/combin""
+)
+
+// TECHDEBT: Geozones are not current implemented, used or tested
+
+func TestSession_GetSession_SingleFishermanSingleServicerBaseCase(t *testing.T) {
+	// Test parameters
+	height := int64(1)
+	relayChain := test_artifacts.DefaultChains[0]
+	geoZone := ""unused_geo""
+	numFishermen := 1
+	numServicers := 1
+	expectedSessionId := ""5acf559f1a3faf3bea7eb692fe51bc1e2e5fb687ede0a6daa7d42399da4aa82b"" // needs to be manually updated if business logic changes
+
+	runtimeCfg, utilityMod, _ := prepareEnvironment(t, 5, numServicers, 1, numFishermen)
+
+	// Sanity check genesis
+	require.Len(t, runtimeCfg.GetGenesis().Applications, 1)
+	app := runtimeCfg.GetGenesis().Applications[0]
+	require.Len(t, runtimeCfg.GetGenesis().Fishermen, 1)
+	fish := runtimeCfg.GetGenesis().Fishermen[0]
+	require.Len(t, runtimeCfg.GetGenesis().Servicers, 1)
+	servicer := runtimeCfg.GetGenesis().Servicers[0]
+
+	// Verify some of the session defaults
+	session, err := utilityMod.GetSession(app.Address, height, relayChain, geoZone)
+	require.NoError(t, err)
+	require.Equal(t, expectedSessionId, session.Id)
+	require.Equal(t, height, session.SessionHeight)
+	require.Equal(t, int64(1), session.SessionNumber)
+	require.Equal(t, int64(1), session.NumSessionBlocks)
+	require.Equal(t, relayChain, session.RelayChain)
+	require.Equal(t, geoZone, session.GeoZone)
+	require.Equal(t, app.Address, session.Application.Address)
+	require.Len(t, session.Servicers, numServicers)
+	require.Equal(t, servicer.Address, session.Servicers[0].Address)
+	require.Len(t, session.Fishermen, numFishermen)
+	require.Equal(t, fish.Address, session.Fishermen[0].Address)
+}
+
+func TestSession_GetSession_ApplicationInvalid(t *testing.T) {
+	runtimeCfg, utilityMod, _ := prepareEnvironment(t, 5, 1, 1, 1)
+
+	// Verify there's only 1 app
+	require.Len(t, runtimeCfg.GetGenesis().Applications, 1)
+	app := runtimeCfg.GetGenesis().Applications[0]
+
+	// Create a new app address
+	pk, err := crypto.GeneratePrivateKey()
+	require.NoError(t, err)
+
+	// Verify that the one app in the genesis is not the one we just generated
+	addr := pk.Address().String()
+	require.NotEqual(t, app.Address, addr)
+
+	// Expect no error trying to get a session for the real application
+	_, err = utilityMod.GetSession(app.Address, 1, test_artifacts.DefaultChains[0], ""unused_geo"")
+	require.NoError(t, err)
+
+	// Expect an error trying to get a session for an unstaked chain
+	_, err = utilityMod.GetSession(addr, 1, ""chain"", ""unused_geo"")
+	require.Error(t, err)
+
+	// Expect an error trying to get a session for a non-existent application
+	_, err = utilityMod.GetSession(addr, 1, test_artifacts.DefaultChains[0], ""unused_geo"")
+	require.Error(t, err)
+}
+
+func TestSession_GetSession_InvalidFutureSession(t *testing.T) {
+	runtimeCfg, utilityMod, persistenceMod := prepareEnvironment(t, 5, 1, 1, 1)
+
+	// Test parameters
+	relayChain := test_artifacts.DefaultChains[0]
+	geoZone := ""unused_geo""
+	app := runtimeCfg.GetGenesis().Applications[0]
+
+	// Local variable to keep track of the height we're getting a session for
+	currentHeight := int64(0)
+
+	// Successfully get a session for 1 block ahead of the latest committed height
+	session, err := utilityMod.GetSession(app.Address, currentHeight+1, relayChain, geoZone)
+	require.NoError(t, err)
+	require.Equal(t, currentHeight+1, session.SessionHeight)
+
+	// Expect an error for a few heights into the future
+	for height := currentHeight + 2; height < 10; height++ {
+		_, err := utilityMod.GetSession(app.Address, height, relayChain, geoZone)
+		require.Error(t, err)
+	}
+
+	// Commit new blocks for all the heights that failed above
+	for ; currentHeight < 10; currentHeight++ {
+		writeCtx, err := persistenceMod.NewRWContext(currentHeight + 1)
+		require.NoError(t, err)
+		err = writeCtx.Commit([]byte(fmt.Sprintf(""proposer_height_%d"", currentHeight)), []byte(fmt.Sprintf(""quorum_cert_height_%d"", currentHeight)))
+		require.NoError(t, err)
+		writeCtx.Release()
+	}
+
+	// Expect no errors since those blocks exist now
+	// Note that we can get the session for latest_committed + 1
+	for height := int64(1); height <= currentHeight+1; height++ {
+		_, err := utilityMod.GetSession(app.Address, height, relayChain, geoZone)
+		require.NoError(t, err)
+	}
+
+	// Verify that currentHeight + 2 fails
+	_, err = utilityMod.GetSession(app.Address, currentHeight+2, relayChain, geoZone)
+	require.Error(t, err)
+}
+
+func TestSession_GetSession_ServicersAndFishermenCounts_TotalAvailability(t *testing.T) {
+	// Prepare an environment with a lot of servicers and fishermen
+	numServicers := 100
+	numFishermen := 100
+	runtimeCfg, utilityMod, persistenceMod := prepareEnvironment(t, 5, numServicers, 1, numFishermen)
+
+	// Vary the number of actors per session using gov params and check that the session is populated with the correct number of actorss
+	tests := []struct {
+		name                   string
+		numServicersPerSession int64
+		numFishermanPerSession int64
+		wantServicerCount      int
+		wantFishermanCount     int
+	}{
+		{
+			name:                   ""more actors per session than available in network"",
+			numServicersPerSession: int64(numServicers) * 10,
+			numFishermanPerSession: int64(numFishermen) * 10,
+			wantServicerCount:      numServicers,
+			wantFishermanCount:     numFishermen,
+		},
+		{
+			name:                   ""less actors per session than available in network"",
+			numServicersPerSession: int64(numServicers) / 2,
+			numFishermanPerSession: int64(numFishermen) / 2,
+			wantServicerCount:      numServicers / 2,
+			wantFishermanCount:     numFishermen / 2,
+		},
+		{
+			name:                   ""same number of actors per session as available in network"",
+			numServicersPerSession: int64(numServicers),
+			numFishermanPerSession: int64(numFishermen),
+			wantServicerCount:      numServicers,
+			wantFishermanCount:     numFishermen,
+		},
+		{
+			name:                   ""more than enough servicers but not enough fishermen"",
+			numServicersPerSession: int64(numServicers) / 2,
+			numFishermanPerSession: int64(numFishermen) * 10,
+			wantServicerCount:      numServicers / 2,
+			wantFishermanCount:     numFishermen,
+		},
+		{
+			name:                   ""more than enough fishermen but not enough servicers"",
+			numServicersPerSession: int64(numServicers) * 10,
+			numFishermanPerSession: int64(numFishermen) / 2,
+			wantServicerCount:      numServicers,
+			wantFishermanCount:     numFishermen / 2,
+		},
+	}
+
+	// Test constant parameters
+	updateParamsHeight := int64(1)
+	querySessionHeight := int64(2)
+
+	app := runtimeCfg.GetGenesis().Applications[0]
+	relayChain := test_artifacts.DefaultChains[0]
+	geoZone := ""unused_geo""
+
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			// Reset to genesis
+			err := persistenceMod.HandleDebugMessage(&messaging.DebugMessage{
+				Action:  messaging.DebugMessageAction_DEBUG_PERSISTENCE_RESET_TO_GENESIS,
+				Message: nil,
+			})
+			require.NoError(t, err)
+
+			// Update the number of servicers and fishermen per session gov params
+			writeCtx, err := persistenceMod.NewRWContext(updateParamsHeight)
+			require.NoError(t, err)
+			defer writeCtx.Release()
+
+			err = writeCtx.SetParam(types.ServicersPerSessionParamName, tt.numServicersPerSession)
+			require.NoError(t, err)
+			err = writeCtx.SetParam(types.FishermanPerSessionParamName, tt.numFishermanPerSession)
+			require.NoError(t, err)
+			err = writeCtx.Commit([]byte(""empty_proposed_addr""), []byte(""empty_quorum_cert""))
+			require.NoError(t, err)
+
+			// Verify that the session is populated with the correct number of actors
+			session, err := utilityMod.GetSession(app.Address, querySessionHeight, relayChain, geoZone)
+			require.NoError(t, err)
+			require.Equal(t, tt.wantServicerCount, len(session.Servicers))
+			require.Equal(t, tt.wantFishermanCount, len(session.Fishermen))
+		})
+	}
+}
+
+func TestSession_GetSession_ServicersAndFishermenCounts_ChainAvailability(t *testing.T) {
+	// Test constant parameters
+	numServicersPerSession := 10
+	numFishermenPerSession := 2
+
+	// Make sure there are MORE THAN ENOUGH servicers and fishermen in the network for each session for chain 1
+	servicersChain1, servicerKeysChain1 := test_artifacts.NewActors(coreTypes.ActorType_ACTOR_TYPE_SERVICER, numServicersPerSession*2, []string{""chn1""})
+	fishermenChain2, fishermenKeysChain2 := test_artifacts.NewActors(coreTypes.ActorType_ACTOR_TYPE_FISH, numFishermenPerSession*2, []string{""chn1""})
+
+	// Make sure there are NOT ENOUGH servicers and fishermen in the network for each session for chain 2
+	servicersChain2, servicerKeysChain2 := test_artifacts.NewActors(coreTypes.ActorType_ACTOR_TYPE_SERVICER, numServicersPerSession/2, []string{""chn2""})
+	fishermenChain1, fishermenKeysChain1 := test_artifacts.NewActors(coreTypes.ActorType_ACTOR_TYPE_FISH, numFishermenPerSession/2, []string{""chn2""})
+
+	application, applicationKey := test_artifacts.NewActors(coreTypes.ActorType_ACTOR_TYPE_APP, 1, []string{""chn1"", ""chn2"", ""chn3""})
+
+	//nolint:gocritic // intentionally not appending result to a new slice
+	actors := append(application, append(servicersChain1, append(servicersChain2, append(fishermenChain1, fishermenChain2...)...)...)...)
+	//nolint:gocritic // intentionally not appending result to a new slice
+	keys := append(applicationKey, append(servicerKeysChain1, append(servicerKeysChain2, append(fishermenKeysChain1, fishermenKeysChain2...)...)...)...)
+
+	// Prepare the environment
+	runtimeCfg, utilityMod, persistenceMod := prepareEnvironment(t, 5, 0, 0, 0, test_artifacts.WithActors(actors, keys))
+
+	// Vary the chain and check the number of fishermen and servicers returned for each one
+	tests := []struct {
+		name               string
+		chain              string
+		wantServicerCount  int
+		wantFishermanCount int
+	}{
+		{
+			name:               ""chn1 has enough servicers and fishermen"",
+			chain:              ""chn1"",
+			wantServicerCount:  numServicersPerSession,
+			wantFishermanCount: numFishermenPerSession,
+		},
+		{
+			name:               ""chn2 does not have enough servicers and fishermen"",
+			chain:              ""chn2"",
+			wantServicerCount:  numServicersPerSession / 2,
+			wantFishermanCount: numFishermenPerSession / 2,
+		},
+		{
+			name:               ""chn3 has no servicers and fishermen"",
+			chain:              ""chn3"",
+			wantServicerCount:  0,
+			wantFishermanCount: 0,
+		},
+	}
+
+	// Reset to genesis
+	err := persistenceMod.HandleDebugMessage(&messaging.DebugMessage{
+		Action:  messaging.DebugMessageAction_DEBUG_PERSISTENCE_RESET_TO_GENESIS,
+		Message: nil,
+	})
+	require.NoError(t, err)
+
+	// Update the number of servicers and fishermen per session gov params
+	writeCtx, err := persistenceMod.NewRWContext(1)
+	require.NoError(t, err)
+	err = writeCtx.SetParam(types.ServicersPerSessionParamName, numServicersPerSession)
+	require.NoError(t, err)
+	err = writeCtx.SetParam(types.FishermanPerSessionParamName, numFishermenPerSession)
+	require.NoError(t, err)
+	err = writeCtx.Commit([]byte(""empty_proposed_addr""), []byte(""empty_quorum_cert""))
+	require.NoError(t, err)
+	defer writeCtx.Release()
+
+	// Test parameters
+	app := runtimeCfg.GetGenesis().Applications[0]
+	geoZone := ""unused_geo""
+
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			session, err := utilityMod.GetSession(app.Address, 2, tt.chain, geoZone)
+			require.NoError(t, err)
+			require.Len(t, session.Servicers, tt.wantServicerCount)
+			require.Len(t, session.Fishermen, tt.wantFishermanCount)
+		})
+	}
+}
+
+func TestSession_GetSession_SessionHeightAndNumber_StaticBlocksPerSession(t *testing.T) {
+	// Prepare the environment
+	_, _, persistenceMod := prepareEnvironment(t, 5, 1, 1, 1)
+
+	// Note that we are using an ephemeral write context at the genesis block (height=0).
+	// This cannot be committed but useful for the test.
+	writeCtx, err := persistenceMod.NewRWContext(0)
+	require.NoError(t, err)
+	defer writeCtx.Release()
+
+	s := &sessionHydrator{
+		session: &coreTypes.Session{},
+		readCtx: writeCtx,
+	}
+
+	tests := []struct {
+		name                   string
+		setNumBlocksPerSession int64
+		provideBlockHeight     int64
+		wantSessionHeight      int64
+		wantSessionNumber      int64
+	}{
+		{
+			name:                   ""genesis block"",
+			setNumBlocksPerSession: 5,
+			provideBlockHeight:     0,
+			wantSessionHeight:      0,
+			wantSessionNumber:      0,
+		},
+		{
+			name:                   ""block is at start of first session"",
+			setNumBlocksPerSession: 5,
+			provideBlockHeight:     5,
+			wantSessionHeight:      5,
+			wantSessionNumber:      1,
+		},
+		{
+			name:                   ""block is right before start of first session"",
+			setNumBlocksPerSession: 5,
+			provideBlockHeight:     4,
+			wantSessionHeight:      0,
+			wantSessionNumber:      0,
+		},
+		{
+			name:                   ""block is right after start of first session"",
+			setNumBlocksPerSession: 5,
+			provideBlockHeight:     6,
+			wantSessionHeight:      5,
+			wantSessionNumber:      1,
+		},
+		{
+			name:                   ""block is at start of second session"",
+			setNumBlocksPerSession: 5,
+			provideBlockHeight:     10,
+			wantSessionHeight:      10,
+			wantSessionNumber:      2,
+		},
+	}
+
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			err := writeCtx.SetParam(types.BlocksPerSessionParamName, tt.setNumBlocksPerSession)
+			require.NoError(t, err)
+
+			s.blockHeight = tt.provideBlockHeight
+			err = s.hydrateSessionMetadata()
+			require.NoError(t, err)
+			require.Equal(t, tt.setNumBlocksPerSession, s.session.NumSessionBlocks)
+			require.Equal(t, tt.wantSessionHeight, s.session.SessionHeight)
+			require.Equal(t, tt.wantSessionNumber, s.session.SessionNumber)
+		})
+	}
+}
+
+func TestSession_GetSession_ServicersAndFishermanEntropy(t *testing.T) {
+	// Prepare an environment with a lot of servicers and fishermen
+	numServicers := 1000
+	numFishermen := 1000 // make them equal for simplicity
+	numServicersPerSession := 10
+	numFishermenPerSession := 10 // make them equal for simplicity
+	numApplications := 3
+	numBlocksPerSession := 2 // expect a different every other height
+
+	// Determine probability of overlap using combinatorics
+	numChoices := combin.GeneralizedBinomial(float64(numServicers), float64(numServicersPerSession))                                 // (numServicers) C (numServicersPerSession)
+	numChoicesRemaining := combin.GeneralizedBinomial(float64(numServicers-numServicersPerSession), float64(numServicersPerSession)) // (numServicers - numServicersPerSession) C (numServicersPerSession)
+	probabilityOfOverlap := (numChoices - numChoicesRemaining) / numChoices
+
+	// Prepare the environment
+	runtimeCfg, utilityMod, persistenceMod := prepareEnvironment(t, 5, numServicers, numApplications, numFishermen)
+
+	// Set the number of servicers and fishermen per session gov params
+	writeCtx, err := persistenceMod.NewRWContext(1)
+	require.NoError(t, err)
+	err = writeCtx.SetParam(types.ServicersPerSessionParamName, numServicersPerSession)
+	require.NoError(t, err)
+	err = writeCtx.SetParam(types.FishermanPerSessionParamName, numFishermenPerSession)
+	require.NoError(t, err)
+	err = writeCtx.SetParam(types.BlocksPerSessionParamName, numBlocksPerSession)
+	require.NoError(t, err)
+	err = writeCtx.Commit([]byte(fmt.Sprintf(""proposer_height_%d"", 1)), []byte(fmt.Sprintf(""quorum_cert_height_%d"", 1)))
+	require.NoError(t, err)
+	writeCtx.Release()
+
+	// Keep the relay chain and geoZone static, but vary the app and height to verify that the servicers and fishermen vary
+	relayChain := test_artifacts.DefaultChains[0]
+	geoZone := ""unused_geo""
+
+	// Sanity check we have 3 apps
+	require.Len(t, runtimeCfg.GetGenesis().Applications, numApplications)
+	app1 := runtimeCfg.GetGenesis().Applications[0]
+	app2 := runtimeCfg.GetGenesis().Applications[1]
+	app3 := runtimeCfg.GetGenesis().Applications[2]
+
+	// Keep track of the actors from the session at the previous height to verify a delta
+	var app1PrevServicers, app2PrevServicers, app3PrevServicers []*coreTypes.Actor
+	var app1PrevFishermen, app2PrevFishermen, app3PrevFishermen []*coreTypes.Actor
+
+	// The number of blocks to increase until we expect a different set of servicers and fishermen; see numBlocksPerSession
+	numBlocksUntilChange := 0
+
+	// Commit new blocks for all the heights that failed above
+	for height := int64(2); height < 10; height++ {
+		session1, err := utilityMod.GetSession(app1.Address, height, relayChain, geoZone)
+		require.NoError(t, err)
+		session2, err := utilityMod.GetSession(app2.Address, height, relayChain, geoZone)
+		require.NoError(t, err)
+		session3, err := utilityMod.GetSession(app3.Address, height, relayChain, geoZone)
+		require.NoError(t, err)
+
+		// All the sessions have the same number of servicers
+		require.Len(t, session1.Servicers, numServicersPerSession)
+		require.Equal(t, len(session1.Servicers), len(session2.Servicers))
+		require.Equal(t, len(session1.Servicers), len(session3.Servicers))
+
+		// All the sessions have the same number of fishermen
+		require.Len(t, session1.Fishermen, numFishermenPerSession)
+		require.Equal(t, len(session1.Fishermen), len(session2.Fishermen))
+		require.Equal(t, len(session1.Fishermen), len(session3.Fishermen))
+
+		// Assert different services between apps
+		assertActorsDifference(t, session1.Servicers, session2.Servicers, probabilityOfOverlap)
+		assertActorsDifference(t, session1.Servicers, session3.Servicers, probabilityOfOverlap)
+
+		// Assert different fishermen between apps
+		assertActorsDifference(t, session1.Fishermen, session2.Fishermen, probabilityOfOverlap)
+		assertActorsDifference(t, session1.Fishermen, session3.Fishermen, probabilityOfOverlap)
+
+		if numBlocksUntilChange == 0 {
+			// Assert different servicers between heights for the same app
+			assertActorsDifference(t, app1PrevServicers, session1.Servicers, probabilityOfOverlap)
+			assertActorsDifference(t, app2PrevServicers, session2.Servicers, probabilityOfOverlap)
+			assertActorsDifference(t, app3PrevServicers, session3.Servicers, probabilityOfOverlap)
+
+			// Assert different fishermen between heights for the same app
+			assertActorsDifference(t, app1PrevFishermen, session1.Fishermen, probabilityOfOverlap)
+			assertActorsDifference(t, app2PrevFishermen, session2.Fishermen, probabilityOfOverlap)
+			assertActorsDifference(t, app3PrevFishermen, session3.Fishermen, probabilityOfOverlap)
+
+			// Store the new servicers and fishermen for the next height
+			app1PrevServicers = session1.Servicers
+			app2PrevServicers = session2.Servicers
+			app3PrevServicers = session3.Servicers
+			app1PrevFishermen = session1.Fishermen
+			app2PrevFishermen = session2.Fishermen
+			app3PrevFishermen = session3.Fishermen
+
+			// Reset the number of blocks until we expect a different set of servicers and fishermen
+			numBlocksUntilChange = numBlocksPerSession - 1
+		} else {
+			// Assert the same servicers between heights for the same app
+			require.ElementsMatch(t, app1PrevServicers, session1.Servicers)
+			require.ElementsMatch(t, app2PrevServicers, session2.Servicers)
+			require.ElementsMatch(t, app3PrevServicers, session3.Servicers)
+
+			// Assert the same fishermen between heights for the same app
+			require.ElementsMatch(t, app1PrevFishermen, session1.Fishermen)
+			require.ElementsMatch(t, app2PrevFishermen, session2.Fishermen)
+			require.ElementsMatch(t, app3PrevFishermen, session3.Fishermen)
+
+			numBlocksUntilChange--
+		}
+
+		// Advance block height
+		writeCtx, err := persistenceMod.NewRWContext(height)
+		require.NoError(t, err)
+		err = writeCtx.Commit([]byte(fmt.Sprintf(""proposer_height_%d"", height)), []byte(fmt.Sprintf(""quorum_cert_height_%d"", height)))
+		require.NoError(t, err)
+		writeCtx.Release()
+	}
+}
+
+func TestSession_GetSession_ApplicationUnbonds(t *testing.T) {
+	// TODO: What if an Application unbonds (unstaking period elapses) mid session?
+}
+
+func TestSession_GetSession_ServicersAndFishermenCounts_GeoZoneAvailability(t *testing.T) {
+	// TODO: Once GeoZones are implemented, the tests need to be added as well
+	// Cases: Invalid, unused, non-existent, empty, insufficiently complete, etc...
+}
+
+func TestSession_GetSession_ActorReplacement(t *testing.T) {
+	// TODO: Since sessions last multiple blocks, we need to design what happens when an actor is (un)jailed, (un)stakes, (un)bonds, (un)pauses
+	// mid session. There are open design questions that need to be made.
+}
+
+func TestSession_GetSession_SessionHeightAndNumber_ModifiedBlocksPerSession(t *testing.T) {
+	// RESEARCH: Need to design what happens (actor replacement, session numbers, etc...) when the number
+	// of blocks per session changes mid session. For example, all existing sessions could go to completion
+	// until the new parameter takes effect. There are open design questions that need to be made.
+}
+
+func assertActorsDifference(t *testing.T, actors1, actors2 []*coreTypes.Actor, maxSimilarityThreshold float64) {
+	slice1 := actorsToAdds(actors1)
+	slice2 := actorsToAdds(actors2)
+	var commonCount float64
+	for _, s1 := range slice1 {
+		for _, s2 := range slice2 {
+			if s1 == s2 {
+				commonCount++
+				break
+			}
+		}
+	}
+	maxCommonCount := math.Round(maxSimilarityThreshold * float64(len(slice1)))
+	assert.LessOrEqual(t, commonCount, maxCommonCount, ""Slices have more similarity than expected: %v vs max %v"", slice1, slice2)
+}
+
+func actorsToAdds(actors []*coreTypes.Actor) []string {",utility/session_test.go,2023-04-25 10:41:08+00:00,2023-04-25T10:41:09Z,"nit:

```suggestion
func actorsToAddrs(actors []*coreTypes.Actor) []string {
```",,,,,525,RIGHT,525,,line,https://api.github.com/repos/pokt-network/pocket/pulls/683,pokt-network/pocket,fb245bc027ae55aaee936daf9f85ecb2d9ad8b40
https://api.github.com/repos/pokt-network/pocket/pulls/683,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1176337216,bryanchriswhite,50d0c7174f166c4424631ca68fc3ed05fbb46ed6,e2864b82e0b52b527cf11e0a05062f4779fef9fe,"@@ -1,157 +1,266 @@
 package utility
 
-// IMPORTANT: The interface and implementation defined in this file are for illustrative purposes only
-// and need to be revisited before any implementation commences.
-
 import (
 	""encoding/binary""
+	""encoding/hex""
+	""fmt""
+	""math""
+	""math/rand""
 
+	""github.com/pokt-network/pocket/logger""
 	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
 	""github.com/pokt-network/pocket/shared/crypto""
+	""github.com/pokt-network/pocket/shared/modules""
 	""github.com/pokt-network/pocket/utility/types""
+	""golang.org/x/exp/slices""
 )
 
-// TODO: When implementing please review if block height tolerance (+,-1) is included in the session protocol: pokt-network/pocket-core#1464 CC @Olshansk
-
-// REFACTOR: Move these into `utility/types` and consider creating an enum
-type RelayChain string
-type GeoZone string
-
-type Session interface {
-	NewSession(sessionHeight int64, relayChain RelayChain, geoZone GeoZone, application *coreTypes.Actor) (Session, types.Error)
-	GetSessionID() []byte             // the identifier of the dispatched session
-	GetSessionHeight() int64          // the block height when the session started
-	GetRelayChain() RelayChain        // the web3 chain identifier
-	GetGeoZone() GeoZone              // the geo-location zone where the application is intending to operate during the session
-	GetApplication() *coreTypes.Actor // the Application consuming the web3 access
-	GetServicers() []*coreTypes.Actor // the Servicers providing Web3 to the application
-	GetFishermen() []*coreTypes.Actor // the Fishermen monitoring the servicers
-}
+// GetSession implements of the exposed `UtilityModule.GetSession` function
+func (m *utilityModule) GetSession(appAddr string, height int64, relayChain, geoZone string) (*coreTypes.Session, error) {
+	persistenceModule := m.GetBus().GetPersistenceModule()
+	readCtx, err := persistenceModule.NewReadContext(height)
+	if err != nil {
+		return nil, err
+	}
+	defer readCtx.Release()
 
-var _ Session = &session{}
+	session := &coreTypes.Session{
+		RelayChain: relayChain,
+		GeoZone:    geoZone,
+	}
 
-type session struct {
-	sessionId   []byte
-	height      int64
-	relayChain  RelayChain
-	geoZone     GeoZone
-	application *coreTypes.Actor
-	servicers   []*coreTypes.Actor
-	fishermen   []*coreTypes.Actor
-}
+	sessionHydrator := &sessionHydrator{
+		logger:      m.logger.With().Str(""source"", ""sessionHydrator"").Logger(),",utility/session.go,2023-04-25 10:44:04+00:00,2023-04-25T10:44:04Z,Nice! I didn't know this was a thing. :raised_hands: ,,,,35.0,33,RIGHT,62,64.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/683,pokt-network/pocket,fb245bc027ae55aaee936daf9f85ecb2d9ad8b40
https://api.github.com/repos/pokt-network/pocket/pulls/683,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1176342090,bryanchriswhite,50d0c7174f166c4424631ca68fc3ed05fbb46ed6,e2864b82e0b52b527cf11e0a05062f4779fef9fe,"@@ -1,157 +1,266 @@
 package utility
 
-// IMPORTANT: The interface and implementation defined in this file are for illustrative purposes only
-// and need to be revisited before any implementation commences.
-
 import (
 	""encoding/binary""
+	""encoding/hex""
+	""fmt""
+	""math""
+	""math/rand""
 
+	""github.com/pokt-network/pocket/logger""
 	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
 	""github.com/pokt-network/pocket/shared/crypto""
+	""github.com/pokt-network/pocket/shared/modules""
 	""github.com/pokt-network/pocket/utility/types""
+	""golang.org/x/exp/slices""
 )
 
-// TODO: When implementing please review if block height tolerance (+,-1) is included in the session protocol: pokt-network/pocket-core#1464 CC @Olshansk
-
-// REFACTOR: Move these into `utility/types` and consider creating an enum
-type RelayChain string
-type GeoZone string
-
-type Session interface {
-	NewSession(sessionHeight int64, relayChain RelayChain, geoZone GeoZone, application *coreTypes.Actor) (Session, types.Error)
-	GetSessionID() []byte             // the identifier of the dispatched session
-	GetSessionHeight() int64          // the block height when the session started
-	GetRelayChain() RelayChain        // the web3 chain identifier
-	GetGeoZone() GeoZone              // the geo-location zone where the application is intending to operate during the session
-	GetApplication() *coreTypes.Actor // the Application consuming the web3 access
-	GetServicers() []*coreTypes.Actor // the Servicers providing Web3 to the application
-	GetFishermen() []*coreTypes.Actor // the Fishermen monitoring the servicers
-}
+// GetSession implements of the exposed `UtilityModule.GetSession` function
+func (m *utilityModule) GetSession(appAddr string, height int64, relayChain, geoZone string) (*coreTypes.Session, error) {
+	persistenceModule := m.GetBus().GetPersistenceModule()
+	readCtx, err := persistenceModule.NewReadContext(height)
+	if err != nil {
+		return nil, err
+	}
+	defer readCtx.Release()
 
-var _ Session = &session{}
+	session := &coreTypes.Session{
+		RelayChain: relayChain,
+		GeoZone:    geoZone,
+	}
 
-type session struct {
-	sessionId   []byte
-	height      int64
-	relayChain  RelayChain
-	geoZone     GeoZone
-	application *coreTypes.Actor
-	servicers   []*coreTypes.Actor
-	fishermen   []*coreTypes.Actor
-}
+	sessionHydrator := &sessionHydrator{
+		logger:      m.logger.With().Str(""source"", ""sessionHydrator"").Logger(),
+		session:     session,
+		blockHeight: height,
+		readCtx:     readCtx,
+	}
 
-func (*session) NewSession(
-	sessionHeight int64,
-	relayChain RelayChain,
-	geoZone GeoZone,
-	application *coreTypes.Actor,
-) (Session, types.Error) {
-	s := &session{
-		height:      sessionHeight,
-		relayChain:  relayChain,
-		geoZone:     geoZone,
-		application: application,
-	}
-
-	// TODO: make these configurable or based on governance params
-	numServicers := 1
-	numFisherman := 1
-
-	var err types.Error
-	if s.servicers, err = s.selectSessionServicers(numServicers); err != nil {
-		return nil, err
+	if err := sessionHydrator.hydrateSessionMetadata(); err != nil {
+		return nil, fmt.Errorf(""failed to hydrate session metadata: %w"", err)
 	}
-	if s.fishermen, err = s.selectSessionFishermen(numFisherman); err != nil {
-		return nil, err
+
+	if err := sessionHydrator.hydrateSessionApplication(appAddr); err != nil {
+		return nil, fmt.Errorf(""failed to hydrate session application: %w"", err)
 	}
-	if s.sessionId, err = s.getSessionId(); err != nil {
-		return nil, err
+
+	if err := sessionHydrator.validateApplicationSession(); err != nil {
+		return nil, fmt.Errorf(""failed to validate application session: %w"", err)
 	}
-	return s, nil
-}
 
-func (s *session) GetSessionID() []byte {
-	return s.sessionId
-}
+	if err := sessionHydrator.hydrateSessionID(); err != nil {
+		return nil, fmt.Errorf(""failed to hydrate session ID: %w"", err)
+	}
 
-func (s *session) GetSessionHeight() int64 {
-	return s.height
-}
+	if err := sessionHydrator.hydrateSessionServicers(); err != nil {
+		return nil, fmt.Errorf(""failed to hydrate session servicers: %w"", err)
+	}
+
+	if err := sessionHydrator.hydrateSessionFishermen(); err != nil {
+		return nil, fmt.Errorf(""failed to hydrate session fishermen: %w"", err)
+	}
 
-func (s *session) GetRelayChain() RelayChain {
-	return s.relayChain
+	return sessionHydrator.session, nil
 }
 
-func (s *session) GetGeoZone() GeoZone {
-	return s.geoZone
+type sessionHydrator struct {
+	logger modules.Logger
+
+	// The session being hydrated and returned
+	session *coreTypes.Session
+
+	// The height at which the request is being made to get session information
+	blockHeight int64
+
+	// Caches a readCtx to avoid draining too many connections to the database
+	readCtx modules.PersistenceReadContext
+
+	// A redundant helper that maintains a hex decoded copy of `session.Id` used for session hydration
+	sessionIdBz []byte
 }
 
-func (s *session) GetApplication() *coreTypes.Actor {
-	return s.application
+// hydrateSessionMetadata hydrates the height at which the session started, its number, and the number of blocks per session
+func (s *sessionHydrator) hydrateSessionMetadata() error {
+	numBlocksPerSession, err := s.readCtx.GetIntParam(types.BlocksPerSessionParamName, s.blockHeight)
+	if err != nil {
+		return err
+	}
+	numBlocksAheadOfSession := s.blockHeight % int64(numBlocksPerSession)
+
+	s.session.NumSessionBlocks = int64(numBlocksPerSession)
+	s.session.SessionNumber = int64(s.blockHeight / int64(numBlocksPerSession))
+	s.session.SessionHeight = s.blockHeight - numBlocksAheadOfSession
+	return nil
 }
 
-func (s *session) GetFishermen() []*coreTypes.Actor {
-	return s.fishermen
+// hydrateSessionApplication hydrates the full Application actor based on the address provided
+func (s *sessionHydrator) hydrateSessionApplication(appAddr string) error {
+	// TECHDEBT: We can remove this decoding process once we use `strings` instead of `[]byte` for addresses",utility/session.go,2023-04-25 10:49:08+00:00,2023-04-25T12:19:12Z,Is there an issue related to this? Do we expect this to be impacted by pokt-network/pocket-network-protocol#32 (I'm assuming so)?,,,,,98,RIGHT,167,,line,https://api.github.com/repos/pokt-network/pocket/pulls/683,pokt-network/pocket,fb245bc027ae55aaee936daf9f85ecb2d9ad8b40
https://api.github.com/repos/pokt-network/pocket/pulls/683,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1176345887,bryanchriswhite,50d0c7174f166c4424631ca68fc3ed05fbb46ed6,e2864b82e0b52b527cf11e0a05062f4779fef9fe,"@@ -1,157 +1,266 @@
 package utility
 
-// IMPORTANT: The interface and implementation defined in this file are for illustrative purposes only
-// and need to be revisited before any implementation commences.
-
 import (
 	""encoding/binary""
+	""encoding/hex""
+	""fmt""
+	""math""
+	""math/rand""
 
+	""github.com/pokt-network/pocket/logger""
 	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
 	""github.com/pokt-network/pocket/shared/crypto""
+	""github.com/pokt-network/pocket/shared/modules""
 	""github.com/pokt-network/pocket/utility/types""
+	""golang.org/x/exp/slices""
 )
 
-// TODO: When implementing please review if block height tolerance (+,-1) is included in the session protocol: pokt-network/pocket-core#1464 CC @Olshansk
-
-// REFACTOR: Move these into `utility/types` and consider creating an enum
-type RelayChain string
-type GeoZone string
-
-type Session interface {
-	NewSession(sessionHeight int64, relayChain RelayChain, geoZone GeoZone, application *coreTypes.Actor) (Session, types.Error)
-	GetSessionID() []byte             // the identifier of the dispatched session
-	GetSessionHeight() int64          // the block height when the session started
-	GetRelayChain() RelayChain        // the web3 chain identifier
-	GetGeoZone() GeoZone              // the geo-location zone where the application is intending to operate during the session
-	GetApplication() *coreTypes.Actor // the Application consuming the web3 access
-	GetServicers() []*coreTypes.Actor // the Servicers providing Web3 to the application
-	GetFishermen() []*coreTypes.Actor // the Fishermen monitoring the servicers
-}
+// GetSession implements of the exposed `UtilityModule.GetSession` function
+func (m *utilityModule) GetSession(appAddr string, height int64, relayChain, geoZone string) (*coreTypes.Session, error) {
+	persistenceModule := m.GetBus().GetPersistenceModule()
+	readCtx, err := persistenceModule.NewReadContext(height)
+	if err != nil {
+		return nil, err
+	}
+	defer readCtx.Release()
 
-var _ Session = &session{}
+	session := &coreTypes.Session{
+		RelayChain: relayChain,
+		GeoZone:    geoZone,
+	}
 
-type session struct {
-	sessionId   []byte
-	height      int64
-	relayChain  RelayChain
-	geoZone     GeoZone
-	application *coreTypes.Actor
-	servicers   []*coreTypes.Actor
-	fishermen   []*coreTypes.Actor
-}
+	sessionHydrator := &sessionHydrator{
+		logger:      m.logger.With().Str(""source"", ""sessionHydrator"").Logger(),
+		session:     session,
+		blockHeight: height,
+		readCtx:     readCtx,
+	}
 
-func (*session) NewSession(
-	sessionHeight int64,
-	relayChain RelayChain,
-	geoZone GeoZone,
-	application *coreTypes.Actor,
-) (Session, types.Error) {
-	s := &session{
-		height:      sessionHeight,
-		relayChain:  relayChain,
-		geoZone:     geoZone,
-		application: application,
-	}
-
-	// TODO: make these configurable or based on governance params
-	numServicers := 1
-	numFisherman := 1
-
-	var err types.Error
-	if s.servicers, err = s.selectSessionServicers(numServicers); err != nil {
-		return nil, err
+	if err := sessionHydrator.hydrateSessionMetadata(); err != nil {
+		return nil, fmt.Errorf(""failed to hydrate session metadata: %w"", err)
 	}
-	if s.fishermen, err = s.selectSessionFishermen(numFisherman); err != nil {
-		return nil, err
+
+	if err := sessionHydrator.hydrateSessionApplication(appAddr); err != nil {
+		return nil, fmt.Errorf(""failed to hydrate session application: %w"", err)
 	}
-	if s.sessionId, err = s.getSessionId(); err != nil {
-		return nil, err
+
+	if err := sessionHydrator.validateApplicationSession(); err != nil {
+		return nil, fmt.Errorf(""failed to validate application session: %w"", err)
 	}
-	return s, nil
-}
 
-func (s *session) GetSessionID() []byte {
-	return s.sessionId
-}
+	if err := sessionHydrator.hydrateSessionID(); err != nil {
+		return nil, fmt.Errorf(""failed to hydrate session ID: %w"", err)
+	}
 
-func (s *session) GetSessionHeight() int64 {
-	return s.height
-}
+	if err := sessionHydrator.hydrateSessionServicers(); err != nil {
+		return nil, fmt.Errorf(""failed to hydrate session servicers: %w"", err)
+	}
+
+	if err := sessionHydrator.hydrateSessionFishermen(); err != nil {
+		return nil, fmt.Errorf(""failed to hydrate session fishermen: %w"", err)
+	}
 
-func (s *session) GetRelayChain() RelayChain {
-	return s.relayChain
+	return sessionHydrator.session, nil
 }
 
-func (s *session) GetGeoZone() GeoZone {
-	return s.geoZone
+type sessionHydrator struct {
+	logger modules.Logger
+
+	// The session being hydrated and returned
+	session *coreTypes.Session
+
+	// The height at which the request is being made to get session information
+	blockHeight int64
+
+	// Caches a readCtx to avoid draining too many connections to the database
+	readCtx modules.PersistenceReadContext
+
+	// A redundant helper that maintains a hex decoded copy of `session.Id` used for session hydration
+	sessionIdBz []byte
 }
 
-func (s *session) GetApplication() *coreTypes.Actor {
-	return s.application
+// hydrateSessionMetadata hydrates the height at which the session started, its number, and the number of blocks per session
+func (s *sessionHydrator) hydrateSessionMetadata() error {
+	numBlocksPerSession, err := s.readCtx.GetIntParam(types.BlocksPerSessionParamName, s.blockHeight)
+	if err != nil {
+		return err
+	}
+	numBlocksAheadOfSession := s.blockHeight % int64(numBlocksPerSession)
+
+	s.session.NumSessionBlocks = int64(numBlocksPerSession)
+	s.session.SessionNumber = int64(s.blockHeight / int64(numBlocksPerSession))
+	s.session.SessionHeight = s.blockHeight - numBlocksAheadOfSession
+	return nil
 }
 
-func (s *session) GetFishermen() []*coreTypes.Actor {
-	return s.fishermen
+// hydrateSessionApplication hydrates the full Application actor based on the address provided
+func (s *sessionHydrator) hydrateSessionApplication(appAddr string) error {
+	// TECHDEBT: We can remove this decoding process once we use `strings` instead of `[]byte` for addresses
+	addr, err := hex.DecodeString(appAddr)
+	if err != nil {
+		return err
+	}
+	s.session.Application, err = s.readCtx.GetActor(coreTypes.ActorType_ACTOR_TYPE_APP, addr, s.session.SessionHeight)
+	return err
 }
 
-func (s *session) GetServicers() []*coreTypes.Actor {
-	return s.servicers
+// validateApplicationSession validates that the application can have a valid session for the provided relay chain and geo zone
+func (s *sessionHydrator) validateApplicationSession() error {
+	app := s.session.Application
+
+	if !slices.Contains(app.Chains, s.session.RelayChain) {
+		return fmt.Errorf(""application %s does not stake for relay chain %s"", app.Address, s.session.RelayChain)
+	}
+
+	if !(app.PausedHeight == -1 && app.UnstakingHeight == -1) {",utility/session.go,2023-04-25 10:53:13+00:00,2023-04-25T10:53:44Z,"Simplify for readability:

```suggestion
	if app.PausedHeight == -1 || app.UnstakingHeight == -1 {
```",,,,,115,RIGHT,186,,line,https://api.github.com/repos/pokt-network/pocket/pulls/683,pokt-network/pocket,fb245bc027ae55aaee936daf9f85ecb2d9ad8b40
https://api.github.com/repos/pokt-network/pocket/pulls/683,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1176368503,bryanchriswhite,50d0c7174f166c4424631ca68fc3ed05fbb46ed6,e2864b82e0b52b527cf11e0a05062f4779fef9fe,"@@ -1,157 +1,266 @@
 package utility
 
-// IMPORTANT: The interface and implementation defined in this file are for illustrative purposes only
-// and need to be revisited before any implementation commences.
-
 import (
 	""encoding/binary""
+	""encoding/hex""
+	""fmt""
+	""math""
+	""math/rand""
 
+	""github.com/pokt-network/pocket/logger""
 	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
 	""github.com/pokt-network/pocket/shared/crypto""
+	""github.com/pokt-network/pocket/shared/modules""
 	""github.com/pokt-network/pocket/utility/types""
+	""golang.org/x/exp/slices""
 )
 
-// TODO: When implementing please review if block height tolerance (+,-1) is included in the session protocol: pokt-network/pocket-core#1464 CC @Olshansk
-
-// REFACTOR: Move these into `utility/types` and consider creating an enum
-type RelayChain string
-type GeoZone string
-
-type Session interface {
-	NewSession(sessionHeight int64, relayChain RelayChain, geoZone GeoZone, application *coreTypes.Actor) (Session, types.Error)
-	GetSessionID() []byte             // the identifier of the dispatched session
-	GetSessionHeight() int64          // the block height when the session started
-	GetRelayChain() RelayChain        // the web3 chain identifier
-	GetGeoZone() GeoZone              // the geo-location zone where the application is intending to operate during the session
-	GetApplication() *coreTypes.Actor // the Application consuming the web3 access
-	GetServicers() []*coreTypes.Actor // the Servicers providing Web3 to the application
-	GetFishermen() []*coreTypes.Actor // the Fishermen monitoring the servicers
-}
+// GetSession implements of the exposed `UtilityModule.GetSession` function
+func (m *utilityModule) GetSession(appAddr string, height int64, relayChain, geoZone string) (*coreTypes.Session, error) {
+	persistenceModule := m.GetBus().GetPersistenceModule()
+	readCtx, err := persistenceModule.NewReadContext(height)
+	if err != nil {
+		return nil, err
+	}
+	defer readCtx.Release()
 
-var _ Session = &session{}
+	session := &coreTypes.Session{
+		RelayChain: relayChain,
+		GeoZone:    geoZone,
+	}
 
-type session struct {
-	sessionId   []byte
-	height      int64
-	relayChain  RelayChain
-	geoZone     GeoZone
-	application *coreTypes.Actor
-	servicers   []*coreTypes.Actor
-	fishermen   []*coreTypes.Actor
-}
+	sessionHydrator := &sessionHydrator{
+		logger:      m.logger.With().Str(""source"", ""sessionHydrator"").Logger(),
+		session:     session,
+		blockHeight: height,
+		readCtx:     readCtx,
+	}
 
-func (*session) NewSession(
-	sessionHeight int64,
-	relayChain RelayChain,
-	geoZone GeoZone,
-	application *coreTypes.Actor,
-) (Session, types.Error) {
-	s := &session{
-		height:      sessionHeight,
-		relayChain:  relayChain,
-		geoZone:     geoZone,
-		application: application,
-	}
-
-	// TODO: make these configurable or based on governance params
-	numServicers := 1
-	numFisherman := 1
-
-	var err types.Error
-	if s.servicers, err = s.selectSessionServicers(numServicers); err != nil {
-		return nil, err
+	if err := sessionHydrator.hydrateSessionMetadata(); err != nil {
+		return nil, fmt.Errorf(""failed to hydrate session metadata: %w"", err)
 	}
-	if s.fishermen, err = s.selectSessionFishermen(numFisherman); err != nil {
-		return nil, err
+
+	if err := sessionHydrator.hydrateSessionApplication(appAddr); err != nil {
+		return nil, fmt.Errorf(""failed to hydrate session application: %w"", err)
 	}
-	if s.sessionId, err = s.getSessionId(); err != nil {
-		return nil, err
+
+	if err := sessionHydrator.validateApplicationSession(); err != nil {
+		return nil, fmt.Errorf(""failed to validate application session: %w"", err)
 	}
-	return s, nil
-}
 
-func (s *session) GetSessionID() []byte {
-	return s.sessionId
-}
+	if err := sessionHydrator.hydrateSessionID(); err != nil {
+		return nil, fmt.Errorf(""failed to hydrate session ID: %w"", err)
+	}
 
-func (s *session) GetSessionHeight() int64 {
-	return s.height
-}
+	if err := sessionHydrator.hydrateSessionServicers(); err != nil {
+		return nil, fmt.Errorf(""failed to hydrate session servicers: %w"", err)
+	}
+
+	if err := sessionHydrator.hydrateSessionFishermen(); err != nil {
+		return nil, fmt.Errorf(""failed to hydrate session fishermen: %w"", err)
+	}
 
-func (s *session) GetRelayChain() RelayChain {
-	return s.relayChain
+	return sessionHydrator.session, nil
 }
 
-func (s *session) GetGeoZone() GeoZone {
-	return s.geoZone
+type sessionHydrator struct {
+	logger modules.Logger
+
+	// The session being hydrated and returned
+	session *coreTypes.Session
+
+	// The height at which the request is being made to get session information
+	blockHeight int64
+
+	// Caches a readCtx to avoid draining too many connections to the database
+	readCtx modules.PersistenceReadContext
+
+	// A redundant helper that maintains a hex decoded copy of `session.Id` used for session hydration
+	sessionIdBz []byte
 }
 
-func (s *session) GetApplication() *coreTypes.Actor {
-	return s.application
+// hydrateSessionMetadata hydrates the height at which the session started, its number, and the number of blocks per session
+func (s *sessionHydrator) hydrateSessionMetadata() error {
+	numBlocksPerSession, err := s.readCtx.GetIntParam(types.BlocksPerSessionParamName, s.blockHeight)
+	if err != nil {
+		return err
+	}
+	numBlocksAheadOfSession := s.blockHeight % int64(numBlocksPerSession)
+
+	s.session.NumSessionBlocks = int64(numBlocksPerSession)
+	s.session.SessionNumber = int64(s.blockHeight / int64(numBlocksPerSession))
+	s.session.SessionHeight = s.blockHeight - numBlocksAheadOfSession
+	return nil
 }
 
-func (s *session) GetFishermen() []*coreTypes.Actor {
-	return s.fishermen
+// hydrateSessionApplication hydrates the full Application actor based on the address provided
+func (s *sessionHydrator) hydrateSessionApplication(appAddr string) error {
+	// TECHDEBT: We can remove this decoding process once we use `strings` instead of `[]byte` for addresses
+	addr, err := hex.DecodeString(appAddr)
+	if err != nil {
+		return err
+	}
+	s.session.Application, err = s.readCtx.GetActor(coreTypes.ActorType_ACTOR_TYPE_APP, addr, s.session.SessionHeight)
+	return err
 }
 
-func (s *session) GetServicers() []*coreTypes.Actor {
-	return s.servicers
+// validateApplicationSession validates that the application can have a valid session for the provided relay chain and geo zone
+func (s *sessionHydrator) validateApplicationSession() error {
+	app := s.session.Application
+
+	if !slices.Contains(app.Chains, s.session.RelayChain) {
+		return fmt.Errorf(""application %s does not stake for relay chain %s"", app.Address, s.session.RelayChain)
+	}
+
+	if !(app.PausedHeight == -1 && app.UnstakingHeight == -1) {
+		return fmt.Errorf(""application %s is either unstaked or paused"", app.Address)
+	}
+
+	// TODO(#697): Filter by geo-zone
+
+	// INVESTIGATE: Consider what else we should validate for here (e.g. Application stake amount, etc.)
+
+	return nil
 }
 
-// use the seed information to determine a SHA3Hash that is used to find the closest N actors based
-// by comparing the sessionKey with the actors' public key
-func (s *session) getSessionId() ([]byte, types.Error) {
+// hydrateSessionID use both session and on-chain data to determine a unique session ID
+func (s *sessionHydrator) hydrateSessionID() error {
 	sessionHeightBz := make([]byte, 8)
-	binary.LittleEndian.PutUint64(sessionHeightBz, uint64(s.height))
+	binary.LittleEndian.PutUint64(sessionHeightBz, uint64(s.session.SessionHeight))
 
-	blockHashBz := []byte(""get block hash bytes at s.sessionHeight from persistence module"")
+	prevHashHeight := int64(math.Max(float64(s.session.SessionHeight)-1, 0))
+	prevHash, err := s.readCtx.GetBlockHash(prevHashHeight)
+	if err != nil {
+		return err
+	}
+	prevHashBz, err := hex.DecodeString(prevHash)",utility/session.go,2023-04-25 11:17:39+00:00,2023-04-25T11:18:10Z,I think what the linter means to say is that this error isn't being checked nor returned.,,,,138.0,136,RIGHT,212,213.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/683,pokt-network/pocket,fb245bc027ae55aaee936daf9f85ecb2d9ad8b40
https://api.github.com/repos/pokt-network/pocket/pulls/683,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1176372826,bryanchriswhite,50d0c7174f166c4424631ca68fc3ed05fbb46ed6,e2864b82e0b52b527cf11e0a05062f4779fef9fe,"@@ -1,157 +1,266 @@
 package utility
 
-// IMPORTANT: The interface and implementation defined in this file are for illustrative purposes only
-// and need to be revisited before any implementation commences.
-
 import (
 	""encoding/binary""
+	""encoding/hex""
+	""fmt""
+	""math""
+	""math/rand""
 
+	""github.com/pokt-network/pocket/logger""
 	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
 	""github.com/pokt-network/pocket/shared/crypto""
+	""github.com/pokt-network/pocket/shared/modules""
 	""github.com/pokt-network/pocket/utility/types""
+	""golang.org/x/exp/slices""
 )
 
-// TODO: When implementing please review if block height tolerance (+,-1) is included in the session protocol: pokt-network/pocket-core#1464 CC @Olshansk
-
-// REFACTOR: Move these into `utility/types` and consider creating an enum
-type RelayChain string
-type GeoZone string
-
-type Session interface {
-	NewSession(sessionHeight int64, relayChain RelayChain, geoZone GeoZone, application *coreTypes.Actor) (Session, types.Error)
-	GetSessionID() []byte             // the identifier of the dispatched session
-	GetSessionHeight() int64          // the block height when the session started
-	GetRelayChain() RelayChain        // the web3 chain identifier
-	GetGeoZone() GeoZone              // the geo-location zone where the application is intending to operate during the session
-	GetApplication() *coreTypes.Actor // the Application consuming the web3 access
-	GetServicers() []*coreTypes.Actor // the Servicers providing Web3 to the application
-	GetFishermen() []*coreTypes.Actor // the Fishermen monitoring the servicers
-}
+// GetSession implements of the exposed `UtilityModule.GetSession` function
+func (m *utilityModule) GetSession(appAddr string, height int64, relayChain, geoZone string) (*coreTypes.Session, error) {
+	persistenceModule := m.GetBus().GetPersistenceModule()
+	readCtx, err := persistenceModule.NewReadContext(height)
+	if err != nil {
+		return nil, err
+	}
+	defer readCtx.Release()
 
-var _ Session = &session{}
+	session := &coreTypes.Session{
+		RelayChain: relayChain,
+		GeoZone:    geoZone,
+	}
 
-type session struct {
-	sessionId   []byte
-	height      int64
-	relayChain  RelayChain
-	geoZone     GeoZone
-	application *coreTypes.Actor
-	servicers   []*coreTypes.Actor
-	fishermen   []*coreTypes.Actor
-}
+	sessionHydrator := &sessionHydrator{
+		logger:      m.logger.With().Str(""source"", ""sessionHydrator"").Logger(),
+		session:     session,
+		blockHeight: height,
+		readCtx:     readCtx,
+	}
 
-func (*session) NewSession(
-	sessionHeight int64,
-	relayChain RelayChain,
-	geoZone GeoZone,
-	application *coreTypes.Actor,
-) (Session, types.Error) {
-	s := &session{
-		height:      sessionHeight,
-		relayChain:  relayChain,
-		geoZone:     geoZone,
-		application: application,
-	}
-
-	// TODO: make these configurable or based on governance params
-	numServicers := 1
-	numFisherman := 1
-
-	var err types.Error
-	if s.servicers, err = s.selectSessionServicers(numServicers); err != nil {
-		return nil, err
+	if err := sessionHydrator.hydrateSessionMetadata(); err != nil {
+		return nil, fmt.Errorf(""failed to hydrate session metadata: %w"", err)
 	}
-	if s.fishermen, err = s.selectSessionFishermen(numFisherman); err != nil {
-		return nil, err
+
+	if err := sessionHydrator.hydrateSessionApplication(appAddr); err != nil {
+		return nil, fmt.Errorf(""failed to hydrate session application: %w"", err)
 	}
-	if s.sessionId, err = s.getSessionId(); err != nil {
-		return nil, err
+
+	if err := sessionHydrator.validateApplicationSession(); err != nil {
+		return nil, fmt.Errorf(""failed to validate application session: %w"", err)
 	}
-	return s, nil
-}
 
-func (s *session) GetSessionID() []byte {
-	return s.sessionId
-}
+	if err := sessionHydrator.hydrateSessionID(); err != nil {
+		return nil, fmt.Errorf(""failed to hydrate session ID: %w"", err)
+	}
 
-func (s *session) GetSessionHeight() int64 {
-	return s.height
-}
+	if err := sessionHydrator.hydrateSessionServicers(); err != nil {
+		return nil, fmt.Errorf(""failed to hydrate session servicers: %w"", err)
+	}
+
+	if err := sessionHydrator.hydrateSessionFishermen(); err != nil {
+		return nil, fmt.Errorf(""failed to hydrate session fishermen: %w"", err)
+	}
 
-func (s *session) GetRelayChain() RelayChain {
-	return s.relayChain
+	return sessionHydrator.session, nil
 }
 
-func (s *session) GetGeoZone() GeoZone {
-	return s.geoZone
+type sessionHydrator struct {
+	logger modules.Logger
+
+	// The session being hydrated and returned
+	session *coreTypes.Session
+
+	// The height at which the request is being made to get session information
+	blockHeight int64
+
+	// Caches a readCtx to avoid draining too many connections to the database
+	readCtx modules.PersistenceReadContext
+
+	// A redundant helper that maintains a hex decoded copy of `session.Id` used for session hydration
+	sessionIdBz []byte
 }
 
-func (s *session) GetApplication() *coreTypes.Actor {
-	return s.application
+// hydrateSessionMetadata hydrates the height at which the session started, its number, and the number of blocks per session
+func (s *sessionHydrator) hydrateSessionMetadata() error {
+	numBlocksPerSession, err := s.readCtx.GetIntParam(types.BlocksPerSessionParamName, s.blockHeight)
+	if err != nil {
+		return err
+	}
+	numBlocksAheadOfSession := s.blockHeight % int64(numBlocksPerSession)
+
+	s.session.NumSessionBlocks = int64(numBlocksPerSession)
+	s.session.SessionNumber = int64(s.blockHeight / int64(numBlocksPerSession))
+	s.session.SessionHeight = s.blockHeight - numBlocksAheadOfSession
+	return nil
 }
 
-func (s *session) GetFishermen() []*coreTypes.Actor {
-	return s.fishermen
+// hydrateSessionApplication hydrates the full Application actor based on the address provided
+func (s *sessionHydrator) hydrateSessionApplication(appAddr string) error {
+	// TECHDEBT: We can remove this decoding process once we use `strings` instead of `[]byte` for addresses
+	addr, err := hex.DecodeString(appAddr)
+	if err != nil {
+		return err
+	}
+	s.session.Application, err = s.readCtx.GetActor(coreTypes.ActorType_ACTOR_TYPE_APP, addr, s.session.SessionHeight)
+	return err
 }
 
-func (s *session) GetServicers() []*coreTypes.Actor {
-	return s.servicers
+// validateApplicationSession validates that the application can have a valid session for the provided relay chain and geo zone
+func (s *sessionHydrator) validateApplicationSession() error {
+	app := s.session.Application
+
+	if !slices.Contains(app.Chains, s.session.RelayChain) {
+		return fmt.Errorf(""application %s does not stake for relay chain %s"", app.Address, s.session.RelayChain)
+	}
+
+	if !(app.PausedHeight == -1 && app.UnstakingHeight == -1) {
+		return fmt.Errorf(""application %s is either unstaked or paused"", app.Address)
+	}
+
+	// TODO(#697): Filter by geo-zone
+
+	// INVESTIGATE: Consider what else we should validate for here (e.g. Application stake amount, etc.)
+
+	return nil
 }
 
-// use the seed information to determine a SHA3Hash that is used to find the closest N actors based
-// by comparing the sessionKey with the actors' public key
-func (s *session) getSessionId() ([]byte, types.Error) {
+// hydrateSessionID use both session and on-chain data to determine a unique session ID
+func (s *sessionHydrator) hydrateSessionID() error {
 	sessionHeightBz := make([]byte, 8)
-	binary.LittleEndian.PutUint64(sessionHeightBz, uint64(s.height))
+	binary.LittleEndian.PutUint64(sessionHeightBz, uint64(s.session.SessionHeight))
 
-	blockHashBz := []byte(""get block hash bytes at s.sessionHeight from persistence module"")
+	prevHashHeight := int64(math.Max(float64(s.session.SessionHeight)-1, 0))
+	prevHash, err := s.readCtx.GetBlockHash(prevHashHeight)
+	if err != nil {
+		return err
+	}
+	prevHashBz, err := hex.DecodeString(prevHash)
+
+	appPubKeyBz := []byte(s.session.Application.PublicKey)
+	relayChainBz := []byte(string(s.session.RelayChain))
+	geoZoneBz := []byte(s.session.GeoZone)
+
+	s.sessionIdBz = concat(sessionHeightBz, prevHashBz, geoZoneBz, relayChainBz, appPubKeyBz)
+	s.session.Id = crypto.GetHashStringFromBytes(s.sessionIdBz)
+
+	return nil
+}
 
-	appPubKey, err := crypto.NewPublicKey(s.application.GetPublicKey())
+// hydrateSessionServicers finds the servicers that are staked at the session height and populates the session with them
+func (s *sessionHydrator) hydrateSessionServicers() error {
+	// number of servicers per session at this height
+	numServicers, err := s.readCtx.GetIntParam(types.ServicersPerSessionParamName, s.session.SessionHeight)
 	if err != nil {
-		return nil, types.ErrNewPublicKeyFromBytes(err)
+		return err
 	}
 
-	return concat(sessionHeightBz, blockHashBz, []byte(s.geoZone), []byte(s.relayChain), appPubKey.Bytes()), nil
+	// returns all the staked servicers at this session height
+	servicers, err := s.readCtx.GetAllServicers(s.session.SessionHeight)
+	if err != nil {
+		return err
+	}
+
+	// OPTIMIZE: Consider updating the persistence module so a single SQL query can retrieve all of the actors at once.
+	candidateServicers := make([]*coreTypes.Actor, 0)
+	for _, servicer := range servicers {
+		// Sanity check the servicer is not paused, jailed or unstaking
+		if !(servicer.PausedHeight == -1 && servicer.UnstakingHeight == -1) {
+			return fmt.Errorf(""hydrateSessionServicers should not have encountered a paused or unstaking servicer: %s"", servicer.Address)
+		}
+
+		// TODO(#697): Filter by geo-zone",utility/session.go,2023-04-25 11:22:15+00:00,2023-04-25T11:22:15Z,"Nice call out :sunglasses::+1: 

nit: 
```suggestion
		// TECHDEBT(#697): Filter by geo-zone
```",,,,,170,RIGHT,249,,line,https://api.github.com/repos/pokt-network/pocket/pulls/683,pokt-network/pocket,fb245bc027ae55aaee936daf9f85ecb2d9ad8b40
https://api.github.com/repos/pokt-network/pocket/pulls/683,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1176376072,bryanchriswhite,50d0c7174f166c4424631ca68fc3ed05fbb46ed6,e2864b82e0b52b527cf11e0a05062f4779fef9fe,"@@ -1,157 +1,266 @@
 package utility
 
-// IMPORTANT: The interface and implementation defined in this file are for illustrative purposes only
-// and need to be revisited before any implementation commences.
-
 import (
 	""encoding/binary""
+	""encoding/hex""
+	""fmt""
+	""math""
+	""math/rand""
 
+	""github.com/pokt-network/pocket/logger""
 	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
 	""github.com/pokt-network/pocket/shared/crypto""
+	""github.com/pokt-network/pocket/shared/modules""
 	""github.com/pokt-network/pocket/utility/types""
+	""golang.org/x/exp/slices""
 )
 
-// TODO: When implementing please review if block height tolerance (+,-1) is included in the session protocol: pokt-network/pocket-core#1464 CC @Olshansk
-
-// REFACTOR: Move these into `utility/types` and consider creating an enum
-type RelayChain string
-type GeoZone string
-
-type Session interface {
-	NewSession(sessionHeight int64, relayChain RelayChain, geoZone GeoZone, application *coreTypes.Actor) (Session, types.Error)
-	GetSessionID() []byte             // the identifier of the dispatched session
-	GetSessionHeight() int64          // the block height when the session started
-	GetRelayChain() RelayChain        // the web3 chain identifier
-	GetGeoZone() GeoZone              // the geo-location zone where the application is intending to operate during the session
-	GetApplication() *coreTypes.Actor // the Application consuming the web3 access
-	GetServicers() []*coreTypes.Actor // the Servicers providing Web3 to the application
-	GetFishermen() []*coreTypes.Actor // the Fishermen monitoring the servicers
-}
+// GetSession implements of the exposed `UtilityModule.GetSession` function
+func (m *utilityModule) GetSession(appAddr string, height int64, relayChain, geoZone string) (*coreTypes.Session, error) {
+	persistenceModule := m.GetBus().GetPersistenceModule()
+	readCtx, err := persistenceModule.NewReadContext(height)
+	if err != nil {
+		return nil, err
+	}
+	defer readCtx.Release()
 
-var _ Session = &session{}
+	session := &coreTypes.Session{
+		RelayChain: relayChain,
+		GeoZone:    geoZone,
+	}
 
-type session struct {
-	sessionId   []byte
-	height      int64
-	relayChain  RelayChain
-	geoZone     GeoZone
-	application *coreTypes.Actor
-	servicers   []*coreTypes.Actor
-	fishermen   []*coreTypes.Actor
-}
+	sessionHydrator := &sessionHydrator{
+		logger:      m.logger.With().Str(""source"", ""sessionHydrator"").Logger(),
+		session:     session,
+		blockHeight: height,
+		readCtx:     readCtx,
+	}
 
-func (*session) NewSession(
-	sessionHeight int64,
-	relayChain RelayChain,
-	geoZone GeoZone,
-	application *coreTypes.Actor,
-) (Session, types.Error) {
-	s := &session{
-		height:      sessionHeight,
-		relayChain:  relayChain,
-		geoZone:     geoZone,
-		application: application,
-	}
-
-	// TODO: make these configurable or based on governance params
-	numServicers := 1
-	numFisherman := 1
-
-	var err types.Error
-	if s.servicers, err = s.selectSessionServicers(numServicers); err != nil {
-		return nil, err
+	if err := sessionHydrator.hydrateSessionMetadata(); err != nil {
+		return nil, fmt.Errorf(""failed to hydrate session metadata: %w"", err)
 	}
-	if s.fishermen, err = s.selectSessionFishermen(numFisherman); err != nil {
-		return nil, err
+
+	if err := sessionHydrator.hydrateSessionApplication(appAddr); err != nil {
+		return nil, fmt.Errorf(""failed to hydrate session application: %w"", err)
 	}
-	if s.sessionId, err = s.getSessionId(); err != nil {
-		return nil, err
+
+	if err := sessionHydrator.validateApplicationSession(); err != nil {
+		return nil, fmt.Errorf(""failed to validate application session: %w"", err)
 	}
-	return s, nil
-}
 
-func (s *session) GetSessionID() []byte {
-	return s.sessionId
-}
+	if err := sessionHydrator.hydrateSessionID(); err != nil {
+		return nil, fmt.Errorf(""failed to hydrate session ID: %w"", err)
+	}
 
-func (s *session) GetSessionHeight() int64 {
-	return s.height
-}
+	if err := sessionHydrator.hydrateSessionServicers(); err != nil {
+		return nil, fmt.Errorf(""failed to hydrate session servicers: %w"", err)
+	}
+
+	if err := sessionHydrator.hydrateSessionFishermen(); err != nil {
+		return nil, fmt.Errorf(""failed to hydrate session fishermen: %w"", err)
+	}
 
-func (s *session) GetRelayChain() RelayChain {
-	return s.relayChain
+	return sessionHydrator.session, nil
 }
 
-func (s *session) GetGeoZone() GeoZone {
-	return s.geoZone
+type sessionHydrator struct {
+	logger modules.Logger
+
+	// The session being hydrated and returned
+	session *coreTypes.Session
+
+	// The height at which the request is being made to get session information
+	blockHeight int64
+
+	// Caches a readCtx to avoid draining too many connections to the database
+	readCtx modules.PersistenceReadContext
+
+	// A redundant helper that maintains a hex decoded copy of `session.Id` used for session hydration
+	sessionIdBz []byte
 }
 
-func (s *session) GetApplication() *coreTypes.Actor {
-	return s.application
+// hydrateSessionMetadata hydrates the height at which the session started, its number, and the number of blocks per session
+func (s *sessionHydrator) hydrateSessionMetadata() error {
+	numBlocksPerSession, err := s.readCtx.GetIntParam(types.BlocksPerSessionParamName, s.blockHeight)
+	if err != nil {
+		return err
+	}
+	numBlocksAheadOfSession := s.blockHeight % int64(numBlocksPerSession)
+
+	s.session.NumSessionBlocks = int64(numBlocksPerSession)
+	s.session.SessionNumber = int64(s.blockHeight / int64(numBlocksPerSession))
+	s.session.SessionHeight = s.blockHeight - numBlocksAheadOfSession
+	return nil
 }
 
-func (s *session) GetFishermen() []*coreTypes.Actor {
-	return s.fishermen
+// hydrateSessionApplication hydrates the full Application actor based on the address provided
+func (s *sessionHydrator) hydrateSessionApplication(appAddr string) error {
+	// TECHDEBT: We can remove this decoding process once we use `strings` instead of `[]byte` for addresses
+	addr, err := hex.DecodeString(appAddr)
+	if err != nil {
+		return err
+	}
+	s.session.Application, err = s.readCtx.GetActor(coreTypes.ActorType_ACTOR_TYPE_APP, addr, s.session.SessionHeight)
+	return err
 }
 
-func (s *session) GetServicers() []*coreTypes.Actor {
-	return s.servicers
+// validateApplicationSession validates that the application can have a valid session for the provided relay chain and geo zone
+func (s *sessionHydrator) validateApplicationSession() error {
+	app := s.session.Application
+
+	if !slices.Contains(app.Chains, s.session.RelayChain) {
+		return fmt.Errorf(""application %s does not stake for relay chain %s"", app.Address, s.session.RelayChain)
+	}
+
+	if !(app.PausedHeight == -1 && app.UnstakingHeight == -1) {
+		return fmt.Errorf(""application %s is either unstaked or paused"", app.Address)
+	}
+
+	// TODO(#697): Filter by geo-zone
+
+	// INVESTIGATE: Consider what else we should validate for here (e.g. Application stake amount, etc.)
+
+	return nil
 }
 
-// use the seed information to determine a SHA3Hash that is used to find the closest N actors based
-// by comparing the sessionKey with the actors' public key
-func (s *session) getSessionId() ([]byte, types.Error) {
+// hydrateSessionID use both session and on-chain data to determine a unique session ID
+func (s *sessionHydrator) hydrateSessionID() error {
 	sessionHeightBz := make([]byte, 8)
-	binary.LittleEndian.PutUint64(sessionHeightBz, uint64(s.height))
+	binary.LittleEndian.PutUint64(sessionHeightBz, uint64(s.session.SessionHeight))
 
-	blockHashBz := []byte(""get block hash bytes at s.sessionHeight from persistence module"")
+	prevHashHeight := int64(math.Max(float64(s.session.SessionHeight)-1, 0))
+	prevHash, err := s.readCtx.GetBlockHash(prevHashHeight)
+	if err != nil {
+		return err
+	}
+	prevHashBz, err := hex.DecodeString(prevHash)
+
+	appPubKeyBz := []byte(s.session.Application.PublicKey)
+	relayChainBz := []byte(string(s.session.RelayChain))
+	geoZoneBz := []byte(s.session.GeoZone)
+
+	s.sessionIdBz = concat(sessionHeightBz, prevHashBz, geoZoneBz, relayChainBz, appPubKeyBz)
+	s.session.Id = crypto.GetHashStringFromBytes(s.sessionIdBz)
+
+	return nil
+}
 
-	appPubKey, err := crypto.NewPublicKey(s.application.GetPublicKey())
+// hydrateSessionServicers finds the servicers that are staked at the session height and populates the session with them
+func (s *sessionHydrator) hydrateSessionServicers() error {
+	// number of servicers per session at this height
+	numServicers, err := s.readCtx.GetIntParam(types.ServicersPerSessionParamName, s.session.SessionHeight)
 	if err != nil {
-		return nil, types.ErrNewPublicKeyFromBytes(err)
+		return err
 	}
 
-	return concat(sessionHeightBz, blockHashBz, []byte(s.geoZone), []byte(s.relayChain), appPubKey.Bytes()), nil
+	// returns all the staked servicers at this session height
+	servicers, err := s.readCtx.GetAllServicers(s.session.SessionHeight)
+	if err != nil {
+		return err
+	}
+
+	// OPTIMIZE: Consider updating the persistence module so a single SQL query can retrieve all of the actors at once.
+	candidateServicers := make([]*coreTypes.Actor, 0)
+	for _, servicer := range servicers {
+		// Sanity check the servicer is not paused, jailed or unstaking
+		if !(servicer.PausedHeight == -1 && servicer.UnstakingHeight == -1) {
+			return fmt.Errorf(""hydrateSessionServicers should not have encountered a paused or unstaking servicer: %s"", servicer.Address)
+		}
+
+		// TODO(#697): Filter by geo-zone
+
+		// OPTIMIZE: If this was a map[string]struct{}, we could have avoided the loop",utility/session.go,2023-04-25 11:25:54+00:00,2023-04-25T11:25:54Z,"Did I interpret this correctly?

nit:
```suggestion
		// OPTIMIZE: If `servicer.Chains` was a map[string]struct{}, we could eliminate `slices.Contains()`'s loop
```",,,,,172,RIGHT,251,,line,https://api.github.com/repos/pokt-network/pocket/pulls/683,pokt-network/pocket,fb245bc027ae55aaee936daf9f85ecb2d9ad8b40
https://api.github.com/repos/pokt-network/pocket/pulls/683,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1176383940,bryanchriswhite,50d0c7174f166c4424631ca68fc3ed05fbb46ed6,e2864b82e0b52b527cf11e0a05062f4779fef9fe,"@@ -1,157 +1,266 @@
 package utility
 
-// IMPORTANT: The interface and implementation defined in this file are for illustrative purposes only
-// and need to be revisited before any implementation commences.
-
 import (
 	""encoding/binary""
+	""encoding/hex""
+	""fmt""
+	""math""
+	""math/rand""
 
+	""github.com/pokt-network/pocket/logger""
 	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
 	""github.com/pokt-network/pocket/shared/crypto""
+	""github.com/pokt-network/pocket/shared/modules""
 	""github.com/pokt-network/pocket/utility/types""
+	""golang.org/x/exp/slices""
 )
 
-// TODO: When implementing please review if block height tolerance (+,-1) is included in the session protocol: pokt-network/pocket-core#1464 CC @Olshansk
-
-// REFACTOR: Move these into `utility/types` and consider creating an enum
-type RelayChain string
-type GeoZone string
-
-type Session interface {
-	NewSession(sessionHeight int64, relayChain RelayChain, geoZone GeoZone, application *coreTypes.Actor) (Session, types.Error)
-	GetSessionID() []byte             // the identifier of the dispatched session
-	GetSessionHeight() int64          // the block height when the session started
-	GetRelayChain() RelayChain        // the web3 chain identifier
-	GetGeoZone() GeoZone              // the geo-location zone where the application is intending to operate during the session
-	GetApplication() *coreTypes.Actor // the Application consuming the web3 access
-	GetServicers() []*coreTypes.Actor // the Servicers providing Web3 to the application
-	GetFishermen() []*coreTypes.Actor // the Fishermen monitoring the servicers
-}
+// GetSession implements of the exposed `UtilityModule.GetSession` function
+func (m *utilityModule) GetSession(appAddr string, height int64, relayChain, geoZone string) (*coreTypes.Session, error) {
+	persistenceModule := m.GetBus().GetPersistenceModule()
+	readCtx, err := persistenceModule.NewReadContext(height)
+	if err != nil {
+		return nil, err
+	}
+	defer readCtx.Release()
 
-var _ Session = &session{}
+	session := &coreTypes.Session{
+		RelayChain: relayChain,
+		GeoZone:    geoZone,
+	}
 
-type session struct {
-	sessionId   []byte
-	height      int64
-	relayChain  RelayChain
-	geoZone     GeoZone
-	application *coreTypes.Actor
-	servicers   []*coreTypes.Actor
-	fishermen   []*coreTypes.Actor
-}
+	sessionHydrator := &sessionHydrator{
+		logger:      m.logger.With().Str(""source"", ""sessionHydrator"").Logger(),
+		session:     session,
+		blockHeight: height,
+		readCtx:     readCtx,
+	}
 
-func (*session) NewSession(
-	sessionHeight int64,
-	relayChain RelayChain,
-	geoZone GeoZone,
-	application *coreTypes.Actor,
-) (Session, types.Error) {
-	s := &session{
-		height:      sessionHeight,
-		relayChain:  relayChain,
-		geoZone:     geoZone,
-		application: application,
-	}
-
-	// TODO: make these configurable or based on governance params
-	numServicers := 1
-	numFisherman := 1
-
-	var err types.Error
-	if s.servicers, err = s.selectSessionServicers(numServicers); err != nil {
-		return nil, err
+	if err := sessionHydrator.hydrateSessionMetadata(); err != nil {
+		return nil, fmt.Errorf(""failed to hydrate session metadata: %w"", err)
 	}
-	if s.fishermen, err = s.selectSessionFishermen(numFisherman); err != nil {
-		return nil, err
+
+	if err := sessionHydrator.hydrateSessionApplication(appAddr); err != nil {
+		return nil, fmt.Errorf(""failed to hydrate session application: %w"", err)
 	}
-	if s.sessionId, err = s.getSessionId(); err != nil {
-		return nil, err
+
+	if err := sessionHydrator.validateApplicationSession(); err != nil {
+		return nil, fmt.Errorf(""failed to validate application session: %w"", err)
 	}
-	return s, nil
-}
 
-func (s *session) GetSessionID() []byte {
-	return s.sessionId
-}
+	if err := sessionHydrator.hydrateSessionID(); err != nil {
+		return nil, fmt.Errorf(""failed to hydrate session ID: %w"", err)
+	}
 
-func (s *session) GetSessionHeight() int64 {
-	return s.height
-}
+	if err := sessionHydrator.hydrateSessionServicers(); err != nil {
+		return nil, fmt.Errorf(""failed to hydrate session servicers: %w"", err)
+	}
+
+	if err := sessionHydrator.hydrateSessionFishermen(); err != nil {
+		return nil, fmt.Errorf(""failed to hydrate session fishermen: %w"", err)
+	}
 
-func (s *session) GetRelayChain() RelayChain {
-	return s.relayChain
+	return sessionHydrator.session, nil
 }
 
-func (s *session) GetGeoZone() GeoZone {
-	return s.geoZone
+type sessionHydrator struct {
+	logger modules.Logger
+
+	// The session being hydrated and returned
+	session *coreTypes.Session
+
+	// The height at which the request is being made to get session information
+	blockHeight int64
+
+	// Caches a readCtx to avoid draining too many connections to the database
+	readCtx modules.PersistenceReadContext
+
+	// A redundant helper that maintains a hex decoded copy of `session.Id` used for session hydration
+	sessionIdBz []byte
 }
 
-func (s *session) GetApplication() *coreTypes.Actor {
-	return s.application
+// hydrateSessionMetadata hydrates the height at which the session started, its number, and the number of blocks per session
+func (s *sessionHydrator) hydrateSessionMetadata() error {
+	numBlocksPerSession, err := s.readCtx.GetIntParam(types.BlocksPerSessionParamName, s.blockHeight)
+	if err != nil {
+		return err
+	}
+	numBlocksAheadOfSession := s.blockHeight % int64(numBlocksPerSession)
+
+	s.session.NumSessionBlocks = int64(numBlocksPerSession)
+	s.session.SessionNumber = int64(s.blockHeight / int64(numBlocksPerSession))
+	s.session.SessionHeight = s.blockHeight - numBlocksAheadOfSession
+	return nil
 }
 
-func (s *session) GetFishermen() []*coreTypes.Actor {
-	return s.fishermen
+// hydrateSessionApplication hydrates the full Application actor based on the address provided
+func (s *sessionHydrator) hydrateSessionApplication(appAddr string) error {
+	// TECHDEBT: We can remove this decoding process once we use `strings` instead of `[]byte` for addresses
+	addr, err := hex.DecodeString(appAddr)
+	if err != nil {
+		return err
+	}
+	s.session.Application, err = s.readCtx.GetActor(coreTypes.ActorType_ACTOR_TYPE_APP, addr, s.session.SessionHeight)
+	return err
 }
 
-func (s *session) GetServicers() []*coreTypes.Actor {
-	return s.servicers
+// validateApplicationSession validates that the application can have a valid session for the provided relay chain and geo zone
+func (s *sessionHydrator) validateApplicationSession() error {
+	app := s.session.Application
+
+	if !slices.Contains(app.Chains, s.session.RelayChain) {
+		return fmt.Errorf(""application %s does not stake for relay chain %s"", app.Address, s.session.RelayChain)
+	}
+
+	if !(app.PausedHeight == -1 && app.UnstakingHeight == -1) {
+		return fmt.Errorf(""application %s is either unstaked or paused"", app.Address)
+	}
+
+	// TODO(#697): Filter by geo-zone
+
+	// INVESTIGATE: Consider what else we should validate for here (e.g. Application stake amount, etc.)
+
+	return nil
 }
 
-// use the seed information to determine a SHA3Hash that is used to find the closest N actors based
-// by comparing the sessionKey with the actors' public key
-func (s *session) getSessionId() ([]byte, types.Error) {
+// hydrateSessionID use both session and on-chain data to determine a unique session ID
+func (s *sessionHydrator) hydrateSessionID() error {
 	sessionHeightBz := make([]byte, 8)
-	binary.LittleEndian.PutUint64(sessionHeightBz, uint64(s.height))
+	binary.LittleEndian.PutUint64(sessionHeightBz, uint64(s.session.SessionHeight))
 
-	blockHashBz := []byte(""get block hash bytes at s.sessionHeight from persistence module"")
+	prevHashHeight := int64(math.Max(float64(s.session.SessionHeight)-1, 0))
+	prevHash, err := s.readCtx.GetBlockHash(prevHashHeight)
+	if err != nil {
+		return err
+	}
+	prevHashBz, err := hex.DecodeString(prevHash)
+
+	appPubKeyBz := []byte(s.session.Application.PublicKey)
+	relayChainBz := []byte(string(s.session.RelayChain))
+	geoZoneBz := []byte(s.session.GeoZone)
+
+	s.sessionIdBz = concat(sessionHeightBz, prevHashBz, geoZoneBz, relayChainBz, appPubKeyBz)
+	s.session.Id = crypto.GetHashStringFromBytes(s.sessionIdBz)
+
+	return nil
+}
 
-	appPubKey, err := crypto.NewPublicKey(s.application.GetPublicKey())
+// hydrateSessionServicers finds the servicers that are staked at the session height and populates the session with them
+func (s *sessionHydrator) hydrateSessionServicers() error {
+	// number of servicers per session at this height
+	numServicers, err := s.readCtx.GetIntParam(types.ServicersPerSessionParamName, s.session.SessionHeight)
 	if err != nil {
-		return nil, types.ErrNewPublicKeyFromBytes(err)
+		return err
 	}
 
-	return concat(sessionHeightBz, blockHashBz, []byte(s.geoZone), []byte(s.relayChain), appPubKey.Bytes()), nil
+	// returns all the staked servicers at this session height
+	servicers, err := s.readCtx.GetAllServicers(s.session.SessionHeight)
+	if err != nil {
+		return err
+	}
+
+	// OPTIMIZE: Consider updating the persistence module so a single SQL query can retrieve all of the actors at once.
+	candidateServicers := make([]*coreTypes.Actor, 0)
+	for _, servicer := range servicers {
+		// Sanity check the servicer is not paused, jailed or unstaking
+		if !(servicer.PausedHeight == -1 && servicer.UnstakingHeight == -1) {
+			return fmt.Errorf(""hydrateSessionServicers should not have encountered a paused or unstaking servicer: %s"", servicer.Address)
+		}
+
+		// TODO(#697): Filter by geo-zone
+
+		// OPTIMIZE: If this was a map[string]struct{}, we could have avoided the loop
+		if slices.Contains(servicer.Chains, s.session.RelayChain) {
+			candidateServicers = append(candidateServicers, servicer)
+		}
+	}
+
+	s.session.Servicers = pseudoRandomSelection(candidateServicers, numServicers, s.sessionIdBz)
+	return nil
 }
 
-// uses the current 'world state' to determine the servicers in the session
-// 1) get an ordered list of the public keys of servicers who are:
-//   - actively staked
-//   - staked within geo-zone (or closest geo-zones)
-//   - staked for relay-chain
-//
-// 2) calls `pseudoRandomSelection(servicers, numberOfNodesPerSession)`
-func (s *session) selectSessionServicers(numServicers int) ([]*coreTypes.Actor, types.Error) {
-	// IMPORTANT: This function is for behaviour illustrative purposes only and implementation may differ.
-	return nil, nil
+// hydrateSessionFishermen finds the fishermen that are staked at the session height and populates the session with them
+func (s *sessionHydrator) hydrateSessionFishermen() error {
+	// number of fishermen per session at this height
+	numFishermen, err := s.readCtx.GetIntParam(types.FishermanPerSessionParamName, s.session.SessionHeight)
+	if err != nil {
+		return err
+	}
+
+	// returns all the staked fishermen at this session height
+	fishermen, err := s.readCtx.GetAllFishermen(s.session.SessionHeight)
+	if err != nil {
+		return err
+	}
+
+	// OPTIMIZE: Consider updating the persistence module so a single SQL query can retrieve all of the actors at once.
+	candidateFishermen := make([]*coreTypes.Actor, 0)
+	for _, fisher := range fishermen {
+		// Sanity check the fisher is not paused, jailed or unstaking
+		if !(fisher.PausedHeight == -1 && fisher.UnstakingHeight == -1) {
+			return fmt.Errorf(""hydrateSessionFishermen should not have encountered a paused or unstaking fisherman: %s"", fisher.Address)",utility/session.go,2023-04-25 11:33:51+00:00,2023-04-25T11:33:51Z,":fishing_pole_and_fish::smile::+1:  <(""fisher"")",,198.0,RIGHT,,201,RIGHT,290,,line,https://api.github.com/repos/pokt-network/pocket/pulls/683,pokt-network/pocket,fb245bc027ae55aaee936daf9f85ecb2d9ad8b40
https://api.github.com/repos/pokt-network/pocket/pulls/683,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1176390423,bryanchriswhite,50d0c7174f166c4424631ca68fc3ed05fbb46ed6,e2864b82e0b52b527cf11e0a05062f4779fef9fe,"@@ -1,157 +1,266 @@
 package utility
 
-// IMPORTANT: The interface and implementation defined in this file are for illustrative purposes only
-// and need to be revisited before any implementation commences.
-
 import (
 	""encoding/binary""
+	""encoding/hex""
+	""fmt""
+	""math""
+	""math/rand""
 
+	""github.com/pokt-network/pocket/logger""
 	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
 	""github.com/pokt-network/pocket/shared/crypto""
+	""github.com/pokt-network/pocket/shared/modules""
 	""github.com/pokt-network/pocket/utility/types""
+	""golang.org/x/exp/slices""
 )
 
-// TODO: When implementing please review if block height tolerance (+,-1) is included in the session protocol: pokt-network/pocket-core#1464 CC @Olshansk
-
-// REFACTOR: Move these into `utility/types` and consider creating an enum
-type RelayChain string
-type GeoZone string
-
-type Session interface {
-	NewSession(sessionHeight int64, relayChain RelayChain, geoZone GeoZone, application *coreTypes.Actor) (Session, types.Error)
-	GetSessionID() []byte             // the identifier of the dispatched session
-	GetSessionHeight() int64          // the block height when the session started
-	GetRelayChain() RelayChain        // the web3 chain identifier
-	GetGeoZone() GeoZone              // the geo-location zone where the application is intending to operate during the session
-	GetApplication() *coreTypes.Actor // the Application consuming the web3 access
-	GetServicers() []*coreTypes.Actor // the Servicers providing Web3 to the application
-	GetFishermen() []*coreTypes.Actor // the Fishermen monitoring the servicers
-}
+// GetSession implements of the exposed `UtilityModule.GetSession` function
+func (m *utilityModule) GetSession(appAddr string, height int64, relayChain, geoZone string) (*coreTypes.Session, error) {
+	persistenceModule := m.GetBus().GetPersistenceModule()
+	readCtx, err := persistenceModule.NewReadContext(height)
+	if err != nil {
+		return nil, err
+	}
+	defer readCtx.Release()
 
-var _ Session = &session{}
+	session := &coreTypes.Session{
+		RelayChain: relayChain,
+		GeoZone:    geoZone,
+	}
 
-type session struct {
-	sessionId   []byte
-	height      int64
-	relayChain  RelayChain
-	geoZone     GeoZone
-	application *coreTypes.Actor
-	servicers   []*coreTypes.Actor
-	fishermen   []*coreTypes.Actor
-}
+	sessionHydrator := &sessionHydrator{
+		logger:      m.logger.With().Str(""source"", ""sessionHydrator"").Logger(),
+		session:     session,
+		blockHeight: height,
+		readCtx:     readCtx,
+	}
 
-func (*session) NewSession(
-	sessionHeight int64,
-	relayChain RelayChain,
-	geoZone GeoZone,
-	application *coreTypes.Actor,
-) (Session, types.Error) {
-	s := &session{
-		height:      sessionHeight,
-		relayChain:  relayChain,
-		geoZone:     geoZone,
-		application: application,
-	}
-
-	// TODO: make these configurable or based on governance params
-	numServicers := 1
-	numFisherman := 1
-
-	var err types.Error
-	if s.servicers, err = s.selectSessionServicers(numServicers); err != nil {
-		return nil, err
+	if err := sessionHydrator.hydrateSessionMetadata(); err != nil {
+		return nil, fmt.Errorf(""failed to hydrate session metadata: %w"", err)
 	}
-	if s.fishermen, err = s.selectSessionFishermen(numFisherman); err != nil {
-		return nil, err
+
+	if err := sessionHydrator.hydrateSessionApplication(appAddr); err != nil {
+		return nil, fmt.Errorf(""failed to hydrate session application: %w"", err)
 	}
-	if s.sessionId, err = s.getSessionId(); err != nil {
-		return nil, err
+
+	if err := sessionHydrator.validateApplicationSession(); err != nil {
+		return nil, fmt.Errorf(""failed to validate application session: %w"", err)
 	}
-	return s, nil
-}
 
-func (s *session) GetSessionID() []byte {
-	return s.sessionId
-}
+	if err := sessionHydrator.hydrateSessionID(); err != nil {
+		return nil, fmt.Errorf(""failed to hydrate session ID: %w"", err)
+	}
 
-func (s *session) GetSessionHeight() int64 {
-	return s.height
-}
+	if err := sessionHydrator.hydrateSessionServicers(); err != nil {
+		return nil, fmt.Errorf(""failed to hydrate session servicers: %w"", err)
+	}
+
+	if err := sessionHydrator.hydrateSessionFishermen(); err != nil {
+		return nil, fmt.Errorf(""failed to hydrate session fishermen: %w"", err)
+	}
 
-func (s *session) GetRelayChain() RelayChain {
-	return s.relayChain
+	return sessionHydrator.session, nil
 }
 
-func (s *session) GetGeoZone() GeoZone {
-	return s.geoZone
+type sessionHydrator struct {
+	logger modules.Logger
+
+	// The session being hydrated and returned
+	session *coreTypes.Session
+
+	// The height at which the request is being made to get session information
+	blockHeight int64
+
+	// Caches a readCtx to avoid draining too many connections to the database
+	readCtx modules.PersistenceReadContext
+
+	// A redundant helper that maintains a hex decoded copy of `session.Id` used for session hydration
+	sessionIdBz []byte
 }
 
-func (s *session) GetApplication() *coreTypes.Actor {
-	return s.application
+// hydrateSessionMetadata hydrates the height at which the session started, its number, and the number of blocks per session
+func (s *sessionHydrator) hydrateSessionMetadata() error {
+	numBlocksPerSession, err := s.readCtx.GetIntParam(types.BlocksPerSessionParamName, s.blockHeight)
+	if err != nil {
+		return err
+	}
+	numBlocksAheadOfSession := s.blockHeight % int64(numBlocksPerSession)
+
+	s.session.NumSessionBlocks = int64(numBlocksPerSession)
+	s.session.SessionNumber = int64(s.blockHeight / int64(numBlocksPerSession))
+	s.session.SessionHeight = s.blockHeight - numBlocksAheadOfSession
+	return nil
 }
 
-func (s *session) GetFishermen() []*coreTypes.Actor {
-	return s.fishermen
+// hydrateSessionApplication hydrates the full Application actor based on the address provided
+func (s *sessionHydrator) hydrateSessionApplication(appAddr string) error {
+	// TECHDEBT: We can remove this decoding process once we use `strings` instead of `[]byte` for addresses
+	addr, err := hex.DecodeString(appAddr)
+	if err != nil {
+		return err
+	}
+	s.session.Application, err = s.readCtx.GetActor(coreTypes.ActorType_ACTOR_TYPE_APP, addr, s.session.SessionHeight)
+	return err
 }
 
-func (s *session) GetServicers() []*coreTypes.Actor {
-	return s.servicers
+// validateApplicationSession validates that the application can have a valid session for the provided relay chain and geo zone
+func (s *sessionHydrator) validateApplicationSession() error {
+	app := s.session.Application
+
+	if !slices.Contains(app.Chains, s.session.RelayChain) {
+		return fmt.Errorf(""application %s does not stake for relay chain %s"", app.Address, s.session.RelayChain)
+	}
+
+	if !(app.PausedHeight == -1 && app.UnstakingHeight == -1) {
+		return fmt.Errorf(""application %s is either unstaked or paused"", app.Address)
+	}
+
+	// TODO(#697): Filter by geo-zone
+
+	// INVESTIGATE: Consider what else we should validate for here (e.g. Application stake amount, etc.)
+
+	return nil
 }
 
-// use the seed information to determine a SHA3Hash that is used to find the closest N actors based
-// by comparing the sessionKey with the actors' public key
-func (s *session) getSessionId() ([]byte, types.Error) {
+// hydrateSessionID use both session and on-chain data to determine a unique session ID
+func (s *sessionHydrator) hydrateSessionID() error {
 	sessionHeightBz := make([]byte, 8)
-	binary.LittleEndian.PutUint64(sessionHeightBz, uint64(s.height))
+	binary.LittleEndian.PutUint64(sessionHeightBz, uint64(s.session.SessionHeight))
 
-	blockHashBz := []byte(""get block hash bytes at s.sessionHeight from persistence module"")
+	prevHashHeight := int64(math.Max(float64(s.session.SessionHeight)-1, 0))
+	prevHash, err := s.readCtx.GetBlockHash(prevHashHeight)
+	if err != nil {
+		return err
+	}
+	prevHashBz, err := hex.DecodeString(prevHash)
+
+	appPubKeyBz := []byte(s.session.Application.PublicKey)
+	relayChainBz := []byte(string(s.session.RelayChain))
+	geoZoneBz := []byte(s.session.GeoZone)
+
+	s.sessionIdBz = concat(sessionHeightBz, prevHashBz, geoZoneBz, relayChainBz, appPubKeyBz)
+	s.session.Id = crypto.GetHashStringFromBytes(s.sessionIdBz)
+
+	return nil
+}
 
-	appPubKey, err := crypto.NewPublicKey(s.application.GetPublicKey())
+// hydrateSessionServicers finds the servicers that are staked at the session height and populates the session with them
+func (s *sessionHydrator) hydrateSessionServicers() error {
+	// number of servicers per session at this height
+	numServicers, err := s.readCtx.GetIntParam(types.ServicersPerSessionParamName, s.session.SessionHeight)
 	if err != nil {
-		return nil, types.ErrNewPublicKeyFromBytes(err)
+		return err
 	}
 
-	return concat(sessionHeightBz, blockHashBz, []byte(s.geoZone), []byte(s.relayChain), appPubKey.Bytes()), nil
+	// returns all the staked servicers at this session height
+	servicers, err := s.readCtx.GetAllServicers(s.session.SessionHeight)
+	if err != nil {
+		return err
+	}
+
+	// OPTIMIZE: Consider updating the persistence module so a single SQL query can retrieve all of the actors at once.
+	candidateServicers := make([]*coreTypes.Actor, 0)
+	for _, servicer := range servicers {
+		// Sanity check the servicer is not paused, jailed or unstaking
+		if !(servicer.PausedHeight == -1 && servicer.UnstakingHeight == -1) {
+			return fmt.Errorf(""hydrateSessionServicers should not have encountered a paused or unstaking servicer: %s"", servicer.Address)
+		}
+
+		// TODO(#697): Filter by geo-zone
+
+		// OPTIMIZE: If this was a map[string]struct{}, we could have avoided the loop
+		if slices.Contains(servicer.Chains, s.session.RelayChain) {
+			candidateServicers = append(candidateServicers, servicer)
+		}
+	}
+
+	s.session.Servicers = pseudoRandomSelection(candidateServicers, numServicers, s.sessionIdBz)
+	return nil
 }
 
-// uses the current 'world state' to determine the servicers in the session
-// 1) get an ordered list of the public keys of servicers who are:
-//   - actively staked
-//   - staked within geo-zone (or closest geo-zones)
-//   - staked for relay-chain
-//
-// 2) calls `pseudoRandomSelection(servicers, numberOfNodesPerSession)`
-func (s *session) selectSessionServicers(numServicers int) ([]*coreTypes.Actor, types.Error) {
-	// IMPORTANT: This function is for behaviour illustrative purposes only and implementation may differ.
-	return nil, nil
+// hydrateSessionFishermen finds the fishermen that are staked at the session height and populates the session with them
+func (s *sessionHydrator) hydrateSessionFishermen() error {
+	// number of fishermen per session at this height
+	numFishermen, err := s.readCtx.GetIntParam(types.FishermanPerSessionParamName, s.session.SessionHeight)
+	if err != nil {
+		return err
+	}
+
+	// returns all the staked fishermen at this session height
+	fishermen, err := s.readCtx.GetAllFishermen(s.session.SessionHeight)
+	if err != nil {
+		return err
+	}
+
+	// OPTIMIZE: Consider updating the persistence module so a single SQL query can retrieve all of the actors at once.
+	candidateFishermen := make([]*coreTypes.Actor, 0)
+	for _, fisher := range fishermen {
+		// Sanity check the fisher is not paused, jailed or unstaking
+		if !(fisher.PausedHeight == -1 && fisher.UnstakingHeight == -1) {
+			return fmt.Errorf(""hydrateSessionFishermen should not have encountered a paused or unstaking fisherman: %s"", fisher.Address)
+		}
+
+		// TODO(#697): Filter by geo-zone
+
+		// OPTIMIZE: If this was a map[string]struct{}, we could have avoided the loop
+		if slices.Contains(fisher.Chains, s.session.RelayChain) {
+			candidateFishermen = append(candidateFishermen, fisher)
+		}
+	}
+
+	s.session.Fishermen = pseudoRandomSelection(candidateFishermen, numFishermen, s.sessionIdBz)
+	return nil
 }
 
-// uses the current 'world state' to determine the fishermen in the session
-// 1) get an ordered list of the public keys of fishermen who are:
-//   - actively staked
-//   - staked within geo-zone  (or closest geo-zones)
-//   - staked for relay-chain
-//
-// 2) calls `pseudoRandomSelection(fishermen, numberOfFishPerSession)`
-func (s *session) selectSessionFishermen(numFishermen int) ([]*coreTypes.Actor, types.Error) {
-	// IMPORTANT: This function is for behaviour illustrative purposes only and implementation may differ.
-	return nil, nil
+// pseudoRandomSelection returns a random subset of the candidates.
+// DECIDE: We are using a `Go` native implementation for a pseudo-random number generator. In order
+// for it to be language agnostic, a general purpose algorithm needs ot be used.",utility/session.go,2023-04-25 11:40:47+00:00,2023-04-25T11:50:11Z,"Nice call out! :100: 

super nit: Wdyt about adopting [rfc2119 style requirement keywords](https://www.rfc-editor.org/rfc/rfc2119) (e.g. `MUST`, `SHOULD`, `MAY`, `... NOT`) (not sure if I chose the right one in my suggestion)
```suggestion
// DECIDE: We are using a `Go` native implementation for a pseudo-random number generator. In order
// for it to be language agnostic, a general purpose algorithm MUST be used.
```

---

Alternatively there's a typo  - I think that's what @dylanlott was commenting on:
```suggestion
// DECIDE: We are using a `Go` native implementation for a pseudo-random number generator. In order
// for it to be language agnostic, a general purpose algorithm needs to be used.
```
",,217.0,RIGHT,,218,RIGHT,317,,line,https://api.github.com/repos/pokt-network/pocket/pulls/683,pokt-network/pocket,fb245bc027ae55aaee936daf9f85ecb2d9ad8b40
https://api.github.com/repos/pokt-network/pocket/pulls/683,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1176410098,bryanchriswhite,50d0c7174f166c4424631ca68fc3ed05fbb46ed6,e2864b82e0b52b527cf11e0a05062f4779fef9fe,"@@ -1,157 +1,266 @@
 package utility
 
-// IMPORTANT: The interface and implementation defined in this file are for illustrative purposes only
-// and need to be revisited before any implementation commences.
-
 import (
 	""encoding/binary""
+	""encoding/hex""
+	""fmt""
+	""math""
+	""math/rand""
 
+	""github.com/pokt-network/pocket/logger""
 	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
 	""github.com/pokt-network/pocket/shared/crypto""
+	""github.com/pokt-network/pocket/shared/modules""
 	""github.com/pokt-network/pocket/utility/types""
+	""golang.org/x/exp/slices""
 )
 
-// TODO: When implementing please review if block height tolerance (+,-1) is included in the session protocol: pokt-network/pocket-core#1464 CC @Olshansk
-
-// REFACTOR: Move these into `utility/types` and consider creating an enum
-type RelayChain string
-type GeoZone string
-
-type Session interface {
-	NewSession(sessionHeight int64, relayChain RelayChain, geoZone GeoZone, application *coreTypes.Actor) (Session, types.Error)
-	GetSessionID() []byte             // the identifier of the dispatched session
-	GetSessionHeight() int64          // the block height when the session started
-	GetRelayChain() RelayChain        // the web3 chain identifier
-	GetGeoZone() GeoZone              // the geo-location zone where the application is intending to operate during the session
-	GetApplication() *coreTypes.Actor // the Application consuming the web3 access
-	GetServicers() []*coreTypes.Actor // the Servicers providing Web3 to the application
-	GetFishermen() []*coreTypes.Actor // the Fishermen monitoring the servicers
-}
+// GetSession implements of the exposed `UtilityModule.GetSession` function
+func (m *utilityModule) GetSession(appAddr string, height int64, relayChain, geoZone string) (*coreTypes.Session, error) {
+	persistenceModule := m.GetBus().GetPersistenceModule()
+	readCtx, err := persistenceModule.NewReadContext(height)
+	if err != nil {
+		return nil, err
+	}
+	defer readCtx.Release()
 
-var _ Session = &session{}
+	session := &coreTypes.Session{
+		RelayChain: relayChain,
+		GeoZone:    geoZone,
+	}
 
-type session struct {
-	sessionId   []byte
-	height      int64
-	relayChain  RelayChain
-	geoZone     GeoZone
-	application *coreTypes.Actor
-	servicers   []*coreTypes.Actor
-	fishermen   []*coreTypes.Actor
-}
+	sessionHydrator := &sessionHydrator{
+		logger:      m.logger.With().Str(""source"", ""sessionHydrator"").Logger(),
+		session:     session,
+		blockHeight: height,
+		readCtx:     readCtx,
+	}
 
-func (*session) NewSession(
-	sessionHeight int64,
-	relayChain RelayChain,
-	geoZone GeoZone,
-	application *coreTypes.Actor,
-) (Session, types.Error) {
-	s := &session{
-		height:      sessionHeight,
-		relayChain:  relayChain,
-		geoZone:     geoZone,
-		application: application,
-	}
-
-	// TODO: make these configurable or based on governance params
-	numServicers := 1
-	numFisherman := 1
-
-	var err types.Error
-	if s.servicers, err = s.selectSessionServicers(numServicers); err != nil {
-		return nil, err
+	if err := sessionHydrator.hydrateSessionMetadata(); err != nil {
+		return nil, fmt.Errorf(""failed to hydrate session metadata: %w"", err)
 	}
-	if s.fishermen, err = s.selectSessionFishermen(numFisherman); err != nil {
-		return nil, err
+
+	if err := sessionHydrator.hydrateSessionApplication(appAddr); err != nil {
+		return nil, fmt.Errorf(""failed to hydrate session application: %w"", err)
 	}
-	if s.sessionId, err = s.getSessionId(); err != nil {
-		return nil, err
+
+	if err := sessionHydrator.validateApplicationSession(); err != nil {
+		return nil, fmt.Errorf(""failed to validate application session: %w"", err)
 	}
-	return s, nil
-}
 
-func (s *session) GetSessionID() []byte {
-	return s.sessionId
-}
+	if err := sessionHydrator.hydrateSessionID(); err != nil {
+		return nil, fmt.Errorf(""failed to hydrate session ID: %w"", err)
+	}
 
-func (s *session) GetSessionHeight() int64 {
-	return s.height
-}
+	if err := sessionHydrator.hydrateSessionServicers(); err != nil {
+		return nil, fmt.Errorf(""failed to hydrate session servicers: %w"", err)
+	}
+
+	if err := sessionHydrator.hydrateSessionFishermen(); err != nil {
+		return nil, fmt.Errorf(""failed to hydrate session fishermen: %w"", err)
+	}
 
-func (s *session) GetRelayChain() RelayChain {
-	return s.relayChain
+	return sessionHydrator.session, nil
 }
 
-func (s *session) GetGeoZone() GeoZone {
-	return s.geoZone
+type sessionHydrator struct {
+	logger modules.Logger
+
+	// The session being hydrated and returned
+	session *coreTypes.Session
+
+	// The height at which the request is being made to get session information
+	blockHeight int64
+
+	// Caches a readCtx to avoid draining too many connections to the database
+	readCtx modules.PersistenceReadContext
+
+	// A redundant helper that maintains a hex decoded copy of `session.Id` used for session hydration
+	sessionIdBz []byte
 }
 
-func (s *session) GetApplication() *coreTypes.Actor {
-	return s.application
+// hydrateSessionMetadata hydrates the height at which the session started, its number, and the number of blocks per session
+func (s *sessionHydrator) hydrateSessionMetadata() error {
+	numBlocksPerSession, err := s.readCtx.GetIntParam(types.BlocksPerSessionParamName, s.blockHeight)
+	if err != nil {
+		return err
+	}
+	numBlocksAheadOfSession := s.blockHeight % int64(numBlocksPerSession)
+
+	s.session.NumSessionBlocks = int64(numBlocksPerSession)
+	s.session.SessionNumber = int64(s.blockHeight / int64(numBlocksPerSession))
+	s.session.SessionHeight = s.blockHeight - numBlocksAheadOfSession
+	return nil
 }
 
-func (s *session) GetFishermen() []*coreTypes.Actor {
-	return s.fishermen
+// hydrateSessionApplication hydrates the full Application actor based on the address provided
+func (s *sessionHydrator) hydrateSessionApplication(appAddr string) error {
+	// TECHDEBT: We can remove this decoding process once we use `strings` instead of `[]byte` for addresses
+	addr, err := hex.DecodeString(appAddr)
+	if err != nil {
+		return err
+	}
+	s.session.Application, err = s.readCtx.GetActor(coreTypes.ActorType_ACTOR_TYPE_APP, addr, s.session.SessionHeight)
+	return err
 }
 
-func (s *session) GetServicers() []*coreTypes.Actor {
-	return s.servicers
+// validateApplicationSession validates that the application can have a valid session for the provided relay chain and geo zone
+func (s *sessionHydrator) validateApplicationSession() error {
+	app := s.session.Application
+
+	if !slices.Contains(app.Chains, s.session.RelayChain) {
+		return fmt.Errorf(""application %s does not stake for relay chain %s"", app.Address, s.session.RelayChain)
+	}
+
+	if !(app.PausedHeight == -1 && app.UnstakingHeight == -1) {
+		return fmt.Errorf(""application %s is either unstaked or paused"", app.Address)
+	}
+
+	// TODO(#697): Filter by geo-zone
+
+	// INVESTIGATE: Consider what else we should validate for here (e.g. Application stake amount, etc.)
+
+	return nil
 }
 
-// use the seed information to determine a SHA3Hash that is used to find the closest N actors based
-// by comparing the sessionKey with the actors' public key
-func (s *session) getSessionId() ([]byte, types.Error) {
+// hydrateSessionID use both session and on-chain data to determine a unique session ID
+func (s *sessionHydrator) hydrateSessionID() error {
 	sessionHeightBz := make([]byte, 8)
-	binary.LittleEndian.PutUint64(sessionHeightBz, uint64(s.height))
+	binary.LittleEndian.PutUint64(sessionHeightBz, uint64(s.session.SessionHeight))
 
-	blockHashBz := []byte(""get block hash bytes at s.sessionHeight from persistence module"")
+	prevHashHeight := int64(math.Max(float64(s.session.SessionHeight)-1, 0))
+	prevHash, err := s.readCtx.GetBlockHash(prevHashHeight)
+	if err != nil {
+		return err
+	}
+	prevHashBz, err := hex.DecodeString(prevHash)
+
+	appPubKeyBz := []byte(s.session.Application.PublicKey)
+	relayChainBz := []byte(string(s.session.RelayChain))
+	geoZoneBz := []byte(s.session.GeoZone)
+
+	s.sessionIdBz = concat(sessionHeightBz, prevHashBz, geoZoneBz, relayChainBz, appPubKeyBz)
+	s.session.Id = crypto.GetHashStringFromBytes(s.sessionIdBz)
+
+	return nil
+}
 
-	appPubKey, err := crypto.NewPublicKey(s.application.GetPublicKey())
+// hydrateSessionServicers finds the servicers that are staked at the session height and populates the session with them
+func (s *sessionHydrator) hydrateSessionServicers() error {
+	// number of servicers per session at this height
+	numServicers, err := s.readCtx.GetIntParam(types.ServicersPerSessionParamName, s.session.SessionHeight)
 	if err != nil {
-		return nil, types.ErrNewPublicKeyFromBytes(err)
+		return err
 	}
 
-	return concat(sessionHeightBz, blockHashBz, []byte(s.geoZone), []byte(s.relayChain), appPubKey.Bytes()), nil
+	// returns all the staked servicers at this session height
+	servicers, err := s.readCtx.GetAllServicers(s.session.SessionHeight)
+	if err != nil {
+		return err
+	}
+
+	// OPTIMIZE: Consider updating the persistence module so a single SQL query can retrieve all of the actors at once.
+	candidateServicers := make([]*coreTypes.Actor, 0)
+	for _, servicer := range servicers {
+		// Sanity check the servicer is not paused, jailed or unstaking
+		if !(servicer.PausedHeight == -1 && servicer.UnstakingHeight == -1) {
+			return fmt.Errorf(""hydrateSessionServicers should not have encountered a paused or unstaking servicer: %s"", servicer.Address)
+		}
+
+		// TODO(#697): Filter by geo-zone
+
+		// OPTIMIZE: If this was a map[string]struct{}, we could have avoided the loop
+		if slices.Contains(servicer.Chains, s.session.RelayChain) {
+			candidateServicers = append(candidateServicers, servicer)
+		}
+	}
+
+	s.session.Servicers = pseudoRandomSelection(candidateServicers, numServicers, s.sessionIdBz)
+	return nil
 }
 
-// uses the current 'world state' to determine the servicers in the session
-// 1) get an ordered list of the public keys of servicers who are:
-//   - actively staked
-//   - staked within geo-zone (or closest geo-zones)
-//   - staked for relay-chain
-//
-// 2) calls `pseudoRandomSelection(servicers, numberOfNodesPerSession)`
-func (s *session) selectSessionServicers(numServicers int) ([]*coreTypes.Actor, types.Error) {
-	// IMPORTANT: This function is for behaviour illustrative purposes only and implementation may differ.
-	return nil, nil
+// hydrateSessionFishermen finds the fishermen that are staked at the session height and populates the session with them
+func (s *sessionHydrator) hydrateSessionFishermen() error {
+	// number of fishermen per session at this height
+	numFishermen, err := s.readCtx.GetIntParam(types.FishermanPerSessionParamName, s.session.SessionHeight)
+	if err != nil {
+		return err
+	}
+
+	// returns all the staked fishermen at this session height
+	fishermen, err := s.readCtx.GetAllFishermen(s.session.SessionHeight)
+	if err != nil {
+		return err
+	}
+
+	// OPTIMIZE: Consider updating the persistence module so a single SQL query can retrieve all of the actors at once.
+	candidateFishermen := make([]*coreTypes.Actor, 0)
+	for _, fisher := range fishermen {
+		// Sanity check the fisher is not paused, jailed or unstaking
+		if !(fisher.PausedHeight == -1 && fisher.UnstakingHeight == -1) {
+			return fmt.Errorf(""hydrateSessionFishermen should not have encountered a paused or unstaking fisherman: %s"", fisher.Address)
+		}
+
+		// TODO(#697): Filter by geo-zone
+
+		// OPTIMIZE: If this was a map[string]struct{}, we could have avoided the loop
+		if slices.Contains(fisher.Chains, s.session.RelayChain) {
+			candidateFishermen = append(candidateFishermen, fisher)
+		}
+	}
+
+	s.session.Fishermen = pseudoRandomSelection(candidateFishermen, numFishermen, s.sessionIdBz)
+	return nil
 }
 
-// uses the current 'world state' to determine the fishermen in the session
-// 1) get an ordered list of the public keys of fishermen who are:
-//   - actively staked
-//   - staked within geo-zone  (or closest geo-zones)
-//   - staked for relay-chain
-//
-// 2) calls `pseudoRandomSelection(fishermen, numberOfFishPerSession)`
-func (s *session) selectSessionFishermen(numFishermen int) ([]*coreTypes.Actor, types.Error) {
-	// IMPORTANT: This function is for behaviour illustrative purposes only and implementation may differ.
-	return nil, nil
+// pseudoRandomSelection returns a random subset of the candidates.
+// DECIDE: We are using a `Go` native implementation for a pseudo-random number generator. In order
+// for it to be language agnostic, a general purpose algorithm needs ot be used.
+func pseudoRandomSelection(candidates []*coreTypes.Actor, numTarget int, sessionId []byte) []*coreTypes.Actor {
+	// If there aren't enough candidates, return all of them
+	if numTarget > len(candidates) {
+		logger.Global.Warn().Msgf(""pseudoRandomSelection: numTarget (%d) is greater than the number of candidates (%d)"", numTarget, len(candidates))
+		return candidates
+	}
+
+	// Take the first 8 bytes of sessionId to use as the seed
+	seed := int64(binary.BigEndian.Uint64(crypto.SHA3Hash(sessionId)[:8]))",utility/session.go,2023-04-25 11:59:28+00:00,2023-04-25T11:59:28Z,"Is there a specific reason why `BitEndian` here and `LittleEndian` when serializing the height? Is this part of a specification?

(I always forget which is conventional in which context. A quick skim of [Endianness](https://en.wikipedia.org/wiki/Endianness) leads me to believe networking is conventionally big-endian, and my recollection is that the dichotomy was  between networking and memory.)",,,,233.0,227,RIGHT,326,332.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/683,pokt-network/pocket,fb245bc027ae55aaee936daf9f85ecb2d9ad8b40
https://api.github.com/repos/pokt-network/pocket/pulls/683,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1176418040,bryanchriswhite,50d0c7174f166c4424631ca68fc3ed05fbb46ed6,e2864b82e0b52b527cf11e0a05062f4779fef9fe,"@@ -1,157 +1,266 @@
 package utility
 
-// IMPORTANT: The interface and implementation defined in this file are for illustrative purposes only
-// and need to be revisited before any implementation commences.
-
 import (
 	""encoding/binary""
+	""encoding/hex""
+	""fmt""
+	""math""
+	""math/rand""
 
+	""github.com/pokt-network/pocket/logger""
 	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
 	""github.com/pokt-network/pocket/shared/crypto""
+	""github.com/pokt-network/pocket/shared/modules""
 	""github.com/pokt-network/pocket/utility/types""
+	""golang.org/x/exp/slices""
 )
 
-// TODO: When implementing please review if block height tolerance (+,-1) is included in the session protocol: pokt-network/pocket-core#1464 CC @Olshansk
-
-// REFACTOR: Move these into `utility/types` and consider creating an enum
-type RelayChain string
-type GeoZone string
-
-type Session interface {
-	NewSession(sessionHeight int64, relayChain RelayChain, geoZone GeoZone, application *coreTypes.Actor) (Session, types.Error)
-	GetSessionID() []byte             // the identifier of the dispatched session
-	GetSessionHeight() int64          // the block height when the session started
-	GetRelayChain() RelayChain        // the web3 chain identifier
-	GetGeoZone() GeoZone              // the geo-location zone where the application is intending to operate during the session
-	GetApplication() *coreTypes.Actor // the Application consuming the web3 access
-	GetServicers() []*coreTypes.Actor // the Servicers providing Web3 to the application
-	GetFishermen() []*coreTypes.Actor // the Fishermen monitoring the servicers
-}
+// GetSession implements of the exposed `UtilityModule.GetSession` function
+func (m *utilityModule) GetSession(appAddr string, height int64, relayChain, geoZone string) (*coreTypes.Session, error) {
+	persistenceModule := m.GetBus().GetPersistenceModule()
+	readCtx, err := persistenceModule.NewReadContext(height)
+	if err != nil {
+		return nil, err
+	}
+	defer readCtx.Release()
 
-var _ Session = &session{}
+	session := &coreTypes.Session{
+		RelayChain: relayChain,
+		GeoZone:    geoZone,
+	}
 
-type session struct {
-	sessionId   []byte
-	height      int64
-	relayChain  RelayChain
-	geoZone     GeoZone
-	application *coreTypes.Actor
-	servicers   []*coreTypes.Actor
-	fishermen   []*coreTypes.Actor
-}
+	sessionHydrator := &sessionHydrator{
+		logger:      m.logger.With().Str(""source"", ""sessionHydrator"").Logger(),
+		session:     session,
+		blockHeight: height,
+		readCtx:     readCtx,
+	}
 
-func (*session) NewSession(
-	sessionHeight int64,
-	relayChain RelayChain,
-	geoZone GeoZone,
-	application *coreTypes.Actor,
-) (Session, types.Error) {
-	s := &session{
-		height:      sessionHeight,
-		relayChain:  relayChain,
-		geoZone:     geoZone,
-		application: application,
-	}
-
-	// TODO: make these configurable or based on governance params
-	numServicers := 1
-	numFisherman := 1
-
-	var err types.Error
-	if s.servicers, err = s.selectSessionServicers(numServicers); err != nil {
-		return nil, err
+	if err := sessionHydrator.hydrateSessionMetadata(); err != nil {
+		return nil, fmt.Errorf(""failed to hydrate session metadata: %w"", err)
 	}
-	if s.fishermen, err = s.selectSessionFishermen(numFisherman); err != nil {
-		return nil, err
+
+	if err := sessionHydrator.hydrateSessionApplication(appAddr); err != nil {
+		return nil, fmt.Errorf(""failed to hydrate session application: %w"", err)
 	}
-	if s.sessionId, err = s.getSessionId(); err != nil {
-		return nil, err
+
+	if err := sessionHydrator.validateApplicationSession(); err != nil {
+		return nil, fmt.Errorf(""failed to validate application session: %w"", err)
 	}
-	return s, nil
-}
 
-func (s *session) GetSessionID() []byte {
-	return s.sessionId
-}
+	if err := sessionHydrator.hydrateSessionID(); err != nil {
+		return nil, fmt.Errorf(""failed to hydrate session ID: %w"", err)
+	}
 
-func (s *session) GetSessionHeight() int64 {
-	return s.height
-}
+	if err := sessionHydrator.hydrateSessionServicers(); err != nil {
+		return nil, fmt.Errorf(""failed to hydrate session servicers: %w"", err)
+	}
+
+	if err := sessionHydrator.hydrateSessionFishermen(); err != nil {
+		return nil, fmt.Errorf(""failed to hydrate session fishermen: %w"", err)
+	}
 
-func (s *session) GetRelayChain() RelayChain {
-	return s.relayChain
+	return sessionHydrator.session, nil
 }
 
-func (s *session) GetGeoZone() GeoZone {
-	return s.geoZone
+type sessionHydrator struct {
+	logger modules.Logger
+
+	// The session being hydrated and returned
+	session *coreTypes.Session
+
+	// The height at which the request is being made to get session information
+	blockHeight int64
+
+	// Caches a readCtx to avoid draining too many connections to the database
+	readCtx modules.PersistenceReadContext
+
+	// A redundant helper that maintains a hex decoded copy of `session.Id` used for session hydration
+	sessionIdBz []byte
 }
 
-func (s *session) GetApplication() *coreTypes.Actor {
-	return s.application
+// hydrateSessionMetadata hydrates the height at which the session started, its number, and the number of blocks per session
+func (s *sessionHydrator) hydrateSessionMetadata() error {
+	numBlocksPerSession, err := s.readCtx.GetIntParam(types.BlocksPerSessionParamName, s.blockHeight)
+	if err != nil {
+		return err
+	}
+	numBlocksAheadOfSession := s.blockHeight % int64(numBlocksPerSession)
+
+	s.session.NumSessionBlocks = int64(numBlocksPerSession)
+	s.session.SessionNumber = int64(s.blockHeight / int64(numBlocksPerSession))
+	s.session.SessionHeight = s.blockHeight - numBlocksAheadOfSession
+	return nil
 }
 
-func (s *session) GetFishermen() []*coreTypes.Actor {
-	return s.fishermen
+// hydrateSessionApplication hydrates the full Application actor based on the address provided
+func (s *sessionHydrator) hydrateSessionApplication(appAddr string) error {
+	// TECHDEBT: We can remove this decoding process once we use `strings` instead of `[]byte` for addresses
+	addr, err := hex.DecodeString(appAddr)
+	if err != nil {
+		return err
+	}
+	s.session.Application, err = s.readCtx.GetActor(coreTypes.ActorType_ACTOR_TYPE_APP, addr, s.session.SessionHeight)
+	return err
 }
 
-func (s *session) GetServicers() []*coreTypes.Actor {
-	return s.servicers
+// validateApplicationSession validates that the application can have a valid session for the provided relay chain and geo zone
+func (s *sessionHydrator) validateApplicationSession() error {
+	app := s.session.Application
+
+	if !slices.Contains(app.Chains, s.session.RelayChain) {
+		return fmt.Errorf(""application %s does not stake for relay chain %s"", app.Address, s.session.RelayChain)
+	}
+
+	if !(app.PausedHeight == -1 && app.UnstakingHeight == -1) {
+		return fmt.Errorf(""application %s is either unstaked or paused"", app.Address)
+	}
+
+	// TODO(#697): Filter by geo-zone
+
+	// INVESTIGATE: Consider what else we should validate for here (e.g. Application stake amount, etc.)
+
+	return nil
 }
 
-// use the seed information to determine a SHA3Hash that is used to find the closest N actors based
-// by comparing the sessionKey with the actors' public key
-func (s *session) getSessionId() ([]byte, types.Error) {
+// hydrateSessionID use both session and on-chain data to determine a unique session ID
+func (s *sessionHydrator) hydrateSessionID() error {
 	sessionHeightBz := make([]byte, 8)
-	binary.LittleEndian.PutUint64(sessionHeightBz, uint64(s.height))
+	binary.LittleEndian.PutUint64(sessionHeightBz, uint64(s.session.SessionHeight))
 
-	blockHashBz := []byte(""get block hash bytes at s.sessionHeight from persistence module"")
+	prevHashHeight := int64(math.Max(float64(s.session.SessionHeight)-1, 0))
+	prevHash, err := s.readCtx.GetBlockHash(prevHashHeight)
+	if err != nil {
+		return err
+	}
+	prevHashBz, err := hex.DecodeString(prevHash)
+
+	appPubKeyBz := []byte(s.session.Application.PublicKey)
+	relayChainBz := []byte(string(s.session.RelayChain))
+	geoZoneBz := []byte(s.session.GeoZone)
+
+	s.sessionIdBz = concat(sessionHeightBz, prevHashBz, geoZoneBz, relayChainBz, appPubKeyBz)
+	s.session.Id = crypto.GetHashStringFromBytes(s.sessionIdBz)
+
+	return nil
+}
 
-	appPubKey, err := crypto.NewPublicKey(s.application.GetPublicKey())
+// hydrateSessionServicers finds the servicers that are staked at the session height and populates the session with them
+func (s *sessionHydrator) hydrateSessionServicers() error {
+	// number of servicers per session at this height
+	numServicers, err := s.readCtx.GetIntParam(types.ServicersPerSessionParamName, s.session.SessionHeight)
 	if err != nil {
-		return nil, types.ErrNewPublicKeyFromBytes(err)
+		return err
 	}
 
-	return concat(sessionHeightBz, blockHashBz, []byte(s.geoZone), []byte(s.relayChain), appPubKey.Bytes()), nil
+	// returns all the staked servicers at this session height
+	servicers, err := s.readCtx.GetAllServicers(s.session.SessionHeight)
+	if err != nil {
+		return err
+	}
+
+	// OPTIMIZE: Consider updating the persistence module so a single SQL query can retrieve all of the actors at once.
+	candidateServicers := make([]*coreTypes.Actor, 0)
+	for _, servicer := range servicers {
+		// Sanity check the servicer is not paused, jailed or unstaking
+		if !(servicer.PausedHeight == -1 && servicer.UnstakingHeight == -1) {
+			return fmt.Errorf(""hydrateSessionServicers should not have encountered a paused or unstaking servicer: %s"", servicer.Address)
+		}
+
+		// TODO(#697): Filter by geo-zone
+
+		// OPTIMIZE: If this was a map[string]struct{}, we could have avoided the loop
+		if slices.Contains(servicer.Chains, s.session.RelayChain) {
+			candidateServicers = append(candidateServicers, servicer)
+		}
+	}
+
+	s.session.Servicers = pseudoRandomSelection(candidateServicers, numServicers, s.sessionIdBz)
+	return nil
 }
 
-// uses the current 'world state' to determine the servicers in the session
-// 1) get an ordered list of the public keys of servicers who are:
-//   - actively staked
-//   - staked within geo-zone (or closest geo-zones)
-//   - staked for relay-chain
-//
-// 2) calls `pseudoRandomSelection(servicers, numberOfNodesPerSession)`
-func (s *session) selectSessionServicers(numServicers int) ([]*coreTypes.Actor, types.Error) {
-	// IMPORTANT: This function is for behaviour illustrative purposes only and implementation may differ.
-	return nil, nil
+// hydrateSessionFishermen finds the fishermen that are staked at the session height and populates the session with them
+func (s *sessionHydrator) hydrateSessionFishermen() error {
+	// number of fishermen per session at this height
+	numFishermen, err := s.readCtx.GetIntParam(types.FishermanPerSessionParamName, s.session.SessionHeight)
+	if err != nil {
+		return err
+	}
+
+	// returns all the staked fishermen at this session height
+	fishermen, err := s.readCtx.GetAllFishermen(s.session.SessionHeight)
+	if err != nil {
+		return err
+	}
+
+	// OPTIMIZE: Consider updating the persistence module so a single SQL query can retrieve all of the actors at once.
+	candidateFishermen := make([]*coreTypes.Actor, 0)
+	for _, fisher := range fishermen {
+		// Sanity check the fisher is not paused, jailed or unstaking
+		if !(fisher.PausedHeight == -1 && fisher.UnstakingHeight == -1) {
+			return fmt.Errorf(""hydrateSessionFishermen should not have encountered a paused or unstaking fisherman: %s"", fisher.Address)
+		}
+
+		// TODO(#697): Filter by geo-zone
+
+		// OPTIMIZE: If this was a map[string]struct{}, we could have avoided the loop
+		if slices.Contains(fisher.Chains, s.session.RelayChain) {
+			candidateFishermen = append(candidateFishermen, fisher)
+		}
+	}
+
+	s.session.Fishermen = pseudoRandomSelection(candidateFishermen, numFishermen, s.sessionIdBz)
+	return nil
 }
 
-// uses the current 'world state' to determine the fishermen in the session
-// 1) get an ordered list of the public keys of fishermen who are:
-//   - actively staked
-//   - staked within geo-zone  (or closest geo-zones)
-//   - staked for relay-chain
-//
-// 2) calls `pseudoRandomSelection(fishermen, numberOfFishPerSession)`
-func (s *session) selectSessionFishermen(numFishermen int) ([]*coreTypes.Actor, types.Error) {
-	// IMPORTANT: This function is for behaviour illustrative purposes only and implementation may differ.
-	return nil, nil
+// pseudoRandomSelection returns a random subset of the candidates.
+// DECIDE: We are using a `Go` native implementation for a pseudo-random number generator. In order
+// for it to be language agnostic, a general purpose algorithm needs ot be used.
+func pseudoRandomSelection(candidates []*coreTypes.Actor, numTarget int, sessionId []byte) []*coreTypes.Actor {
+	// If there aren't enough candidates, return all of them
+	if numTarget > len(candidates) {
+		logger.Global.Warn().Msgf(""pseudoRandomSelection: numTarget (%d) is greater than the number of candidates (%d)"", numTarget, len(candidates))
+		return candidates
+	}
+
+	// Take the first 8 bytes of sessionId to use as the seed
+	seed := int64(binary.BigEndian.Uint64(crypto.SHA3Hash(sessionId)[:8]))
+
+	// Retrieve the indices for the candidates
+	actors := make([]*coreTypes.Actor, 0)
+	uniqueIndices := uniqueRandomIndices(seed, int64(len(candidates)), int64(numTarget))
+	for idx := range uniqueIndices {
+		actors = append(actors, candidates[idx])
+	}
+
+	return actors
 }
 
-// 1) passed an ordered list of the public keys of actors and number of nodes
-// 2) pseudo-insert the session `key` string into the list and find the first actor directly below
-// 3) newKey = Hash( key + actor1PublicKey )
-// 4) repeat steps 2 and 3 until all N actor are found
-// FAQ:
-// Q) why do we hash to find a newKey between every actor selection?
-// A) pseudo-random selection only works if each iteration is re-randomized
-//
-//	or it would be subject to lexicographical proximity bias attacks
-//
-//nolint:unused // This is a demonstratable function
-func (s *session) pseudoRandomSelection(orderedListOfPublicKeys []string, numActorsToSelect int) []*coreTypes.Actor {
-	// IMPORTANT: This function is for behaviour illustrative purposes only and implementation may differ.
-	return nil
+// OPTIMIZE: Postgres uses a `Twisted Mersenne Twister (TMT)` randomness algorithm.
+// We could potentially look into changing everything into a single SQL query but
+// would nee dto verify that it can be implemented in a platform agnostic way.
+
+// uniqueRandomIndices returns a map of `numIndices` unique random numbers less than `maxIndex`
+// seeded by `seed`.
+// NB: A map pointing to empty structs is used to simulate set behaviour.",utility/session.go,2023-04-25 12:07:17+00:00,2023-04-26T05:20:44Z,"nit: Wdyt about mentioning that it will panic if `numIndicies > maxIndex` in the godoc comment? I realize it's not exported but the godoc comment may be presented separate from the code in more contexts than just documentation (e.g. IDE integration):

![image](https://user-images.githubusercontent.com/600733/234271948-082527d1-a879-4e08-9c1d-d4324a5eda06.png)
",,243.0,RIGHT,,245,RIGHT,358,,line,https://api.github.com/repos/pokt-network/pocket/pulls/683,pokt-network/pocket,fb245bc027ae55aaee936daf9f85ecb2d9ad8b40
https://api.github.com/repos/pokt-network/pocket/pulls/683,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1180711571,bryanchriswhite,cf2f6e070a07004e4e36ae84b414ecbd8161a0f9,e2864b82e0b52b527cf11e0a05062f4779fef9fe,"@@ -128,6 +129,24 @@ func (m *sweetModule) Start() error {
 }
 ```
 
+## Submodule / Subcontext Logging",logger/docs/README.md,2023-04-28 18:38:33+00:00,2023-04-28T18:38:34Z,:100: :pray: ,,,,132.0,132,RIGHT,12,12.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/683,pokt-network/pocket,fb245bc027ae55aaee936daf9f85ecb2d9ad8b40
https://api.github.com/repos/pokt-network/pocket/pulls/683,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1180713147,bryanchriswhite,cf2f6e070a07004e4e36ae84b414ecbd8161a0f9,e2864b82e0b52b527cf11e0a05062f4779fef9fe,"@@ -453,7 +455,7 @@ benchmark_p2p_peerstore: ## Run P2P peerstore benchmarks
 # BUG           - There is a known existing bug in this code
 # DISCUSS_IN_THIS_COMMIT - SHOULD NEVER BE COMMITTED TO MASTER. It is a way for the reviewer of a PR to start / reply to a discussion.
 # TODO_IN_THIS_COMMIT    - SHOULD NEVER BE COMMITTED TO MASTER. It is a way to start the review process while non-critical changes are still in progress
-TODO_KEYWORDS = -e ""TODO"" -e ""TECHDEBT"" -e ""IMPROVE"" -e ""DISCUSS"" -e ""INCOMPLETE"" -e ""INVESTIGATE"" -e ""CLEANUP"" -e ""HACK"" -e ""REFACTOR"" -e ""CONSIDERATION"" -e ""TODO_IN_THIS_COMMIT"" -e ""DISCUSS_IN_THIS_COMMIT"" -e ""CONSOLIDATE"" -e ""DEPRECATE"" -e ""ADDTEST"" -e ""RESEARCH"" -e ""BUG""
+TODO_KEYWORDS = -e ""TODO"" -e ""ADR"" -e ""TECHDEBT"" -e ""IMPROVE"" -e ""OPTIMIZE"" -e ""DISCUSS"" -e ""INCOMPLETE"" -e ""INVESTIGATE"" -e ""CLEANUP"" -e ""HACK"" -e ""REFACTOR"" -e ""CONSIDERATION"" -e ""TODO_IN_THIS_COMMIT"" -e ""DISCUSS_IN_THIS_COMMIT"" -e ""CONSOLIDATE"" -e ""DEPRECATE"" -e ""ADDTEST"" -e ""RESEARCH"" -e ""BUG""",Makefile,2023-04-28 18:40:35+00:00,2023-04-28T18:40:36Z,"```suggestion
TODO_KEYWORDS = -e ""TODO"" -e ""DECIDE"" -e ""TECHDEBT"" -e ""IMPROVE"" -e ""OPTIMIZE"" -e ""DISCUSS"" -e ""INCOMPLETE"" -e ""INVESTIGATE"" -e ""CLEANUP"" -e ""HACK"" -e ""REFACTOR"" -e ""CONSIDERATION"" -e ""TODO_IN_THIS_COMMIT"" -e ""DISCUSS_IN_THIS_COMMIT"" -e ""CONSOLIDATE"" -e ""DEPRECATE"" -e ""ADDTEST"" -e ""RESEARCH"" -e ""BUG""
```",,,,,458,RIGHT,16,,line,https://api.github.com/repos/pokt-network/pocket/pulls/683,pokt-network/pocket,fb245bc027ae55aaee936daf9f85ecb2d9ad8b40
https://api.github.com/repos/pokt-network/pocket/pulls/683,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1180713439,bryanchriswhite,cf2f6e070a07004e4e36ae84b414ecbd8161a0f9,e2864b82e0b52b527cf11e0a05062f4779fef9fe,"@@ -470,6 +472,13 @@ TODO_KEYWORDS = -e ""TODO"" -e ""TECHDEBT"" -e ""IMPROVE"" -e ""DISCUSS"" -e ""INCOMPLETE
 todo_list: ## List all the TODOs in the project (excludes vendor and prototype directories)
 	grep --exclude-dir={.git,vendor,prototype} -r ${TODO_KEYWORDS}  .
 
+
+TODO_SEARCH ?= $(shell pwd)
+
+.PHONY: todo_search
+todo_search: ## List all the TODOs in a specific directory specific by `TODO_SEARCH`",Makefile,2023-04-28 18:41:02+00:00,2023-04-28T18:41:02Z,Cool!,,,,479.0,479,RIGHT,28,28.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/683,pokt-network/pocket,fb245bc027ae55aaee936daf9f85ecb2d9ad8b40
https://api.github.com/repos/pokt-network/pocket/pulls/683,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1180838572,bryanchriswhite,d06787e78227b872e61af15b05f8414b4d4be31a,e2864b82e0b52b527cf11e0a05062f4779fef9fe,"@@ -0,0 +1,535 @@
+package utility
+
+import (
+	""fmt""
+	""math""
+	""testing""
+
+	""github.com/stretchr/testify/assert""
+	""github.com/stretchr/testify/require""
+	""gonum.org/v1/gonum/stat/combin""
+
+	""github.com/pokt-network/pocket/runtime/test_artifacts""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/crypto""
+	""github.com/pokt-network/pocket/shared/messaging""
+	""github.com/pokt-network/pocket/utility/types""
+)
+
+// TECHDEBT(#697): Geozones are not current implemented, used or tested
+
+func TestSession_GetSession_SingleFishermanSingleServicerBaseCase(t *testing.T) {
+	// Test parameters
+	height := int64(1)
+	relayChain := test_artifacts.DefaultChains[0]
+	geoZone := ""unused_geo""
+	numFishermen := 1
+	numServicers := 1
+	// needs to be manually updated if business logic changes
+	expectedSessionId := ""5acf559f1a3faf3bea7eb692fe51bc1e2e5fb687ede0a6daa7d42399da4aa82b""
+
+	runtimeCfg, utilityMod, _ := prepareEnvironment(t, 5, numServicers, 1, numFishermen)
+
+	// Sanity check genesis
+	require.Len(t, runtimeCfg.GetGenesis().Applications, 1)
+	app := runtimeCfg.GetGenesis().Applications[0]
+	require.Len(t, runtimeCfg.GetGenesis().Fishermen, 1)
+	fisher := runtimeCfg.GetGenesis().Fishermen[0]
+	require.Len(t, runtimeCfg.GetGenesis().Servicers, 1)
+	servicer := runtimeCfg.GetGenesis().Servicers[0]
+
+	// Verify some of the session defaults
+	session, err := utilityMod.GetSession(app.Address, height, relayChain, geoZone)
+	require.NoError(t, err)
+	require.Equal(t, expectedSessionId, session.Id)
+	require.Equal(t, height, session.SessionHeight)
+	require.Equal(t, int64(1), session.SessionNumber)
+	require.Equal(t, int64(1), session.NumSessionBlocks)
+	require.Equal(t, relayChain, session.RelayChain)
+	require.Equal(t, geoZone, session.GeoZone)
+	require.Equal(t, app.Address, session.Application.Address)
+	require.Len(t, session.Servicers, numServicers)
+	require.Equal(t, servicer.Address, session.Servicers[0].Address)
+	require.Len(t, session.Fishermen, numFishermen)
+	require.Equal(t, fisher.Address, session.Fishermen[0].Address)
+}
+
+func TestSession_GetSession_ApplicationInvalid(t *testing.T) {
+	runtimeCfg, utilityMod, _ := prepareEnvironment(t, 5, 1, 1, 1)
+
+	// Verify there's only 1 app
+	require.Len(t, runtimeCfg.GetGenesis().Applications, 1)
+	app := runtimeCfg.GetGenesis().Applications[0]
+
+	// Create a new app address
+	pk, err := crypto.GeneratePrivateKey()
+	require.NoError(t, err)
+
+	// Verify that the one app in the genesis is not the one we just generated
+	addr := pk.Address().String()
+	require.NotEqual(t, app.Address, addr)
+
+	// Expect no error trying to get a session for the real application
+	_, err = utilityMod.GetSession(app.Address, 1, test_artifacts.DefaultChains[0], ""unused_geo"")
+	require.NoError(t, err)
+
+	// Expect an error trying to get a session for an unstaked chain
+	_, err = utilityMod.GetSession(addr, 1, ""chain"", ""unused_geo"")
+	require.Error(t, err)
+
+	// Expect an error trying to get a session for a non-existent application
+	_, err = utilityMod.GetSession(addr, 1, test_artifacts.DefaultChains[0], ""unused_geo"")
+	require.Error(t, err)
+}
+
+func TestSession_GetSession_InvalidFutureSession(t *testing.T) {
+	runtimeCfg, utilityMod, persistenceMod := prepareEnvironment(t, 5, 1, 1, 1)
+
+	// Test parameters
+	relayChain := test_artifacts.DefaultChains[0]
+	geoZone := ""unused_geo""
+	app := runtimeCfg.GetGenesis().Applications[0]
+
+	// Local variable to keep track of the height we're getting a session for
+	currentHeight := int64(0)
+
+	// Successfully get a session for 1 block ahead of the latest committed height
+	session, err := utilityMod.GetSession(app.Address, currentHeight+1, relayChain, geoZone)
+	require.NoError(t, err)
+	require.Equal(t, currentHeight+1, session.SessionHeight)
+
+	// Expect an error for a few heights into the future
+	for height := currentHeight + 2; height < 10; height++ {
+		_, err := utilityMod.GetSession(app.Address, height, relayChain, geoZone)
+		require.Error(t, err)
+	}
+
+	// Commit new blocks for all the heights that failed above
+	for ; currentHeight < 10; currentHeight++ {
+		writeCtx, err := persistenceMod.NewRWContext(currentHeight + 1)
+		require.NoError(t, err)
+		err = writeCtx.Commit([]byte(fmt.Sprintf(""proposer_height_%d"", currentHeight)), []byte(fmt.Sprintf(""quorum_cert_height_%d"", currentHeight)))
+		require.NoError(t, err)
+		writeCtx.Release()
+	}
+
+	// Expect no errors since those blocks exist now
+	// Note that we can get the session for latest_committed + 1
+	for height := int64(1); height <= currentHeight+1; height++ {
+		_, err := utilityMod.GetSession(app.Address, height, relayChain, geoZone)
+		require.NoError(t, err)
+	}
+
+	// Verify that currentHeight + 2 fails
+	_, err = utilityMod.GetSession(app.Address, currentHeight+2, relayChain, geoZone)
+	require.Error(t, err)
+}
+
+func TestSession_GetSession_ServicersAndFishermenCounts_TotalAvailability(t *testing.T) {
+	// Prepare an environment with a lot of servicers and fishermen
+	numStakedServicers := 100
+	numStakedFishermen := 100
+	runtimeCfg, utilityMod, persistenceMod := prepareEnvironment(t, 5, numStakedServicers, 1, numStakedFishermen)
+
+	// Vary the number of actors per session using gov params and check that the session is populated with the correct number of actorss
+	tests := []struct {
+		name                   string
+		numServicersPerSession int64
+		numFishermanPerSession int64
+		wantServicerCount      int
+		wantFishermanCount     int
+	}{
+		{
+			name:                   ""more actors per session than available in network"",
+			numServicersPerSession: int64(numStakedServicers) * 10,
+			numFishermanPerSession: int64(numStakedFishermen) * 10,
+			wantServicerCount:      numStakedServicers,
+			wantFishermanCount:     numStakedFishermen,
+		},
+		{
+			name:                   ""less actors per session than available in network"",
+			numServicersPerSession: int64(numStakedServicers) / 2,
+			numFishermanPerSession: int64(numStakedFishermen) / 2,
+			wantServicerCount:      numStakedServicers / 2,
+			wantFishermanCount:     numStakedFishermen / 2,
+		},
+		{
+			name:                   ""same number of actors per session as available in network"",
+			numServicersPerSession: int64(numStakedServicers),
+			numFishermanPerSession: int64(numStakedFishermen),
+			wantServicerCount:      numStakedServicers,
+			wantFishermanCount:     numStakedFishermen,
+		},
+		{
+			name:                   ""more than enough servicers but not enough fishermen"",
+			numServicersPerSession: int64(numStakedServicers) / 2,
+			numFishermanPerSession: int64(numStakedFishermen) * 10,
+			wantServicerCount:      numStakedServicers / 2,
+			wantFishermanCount:     numStakedFishermen,
+		},
+		{
+			name:                   ""more than enough fishermen but not enough servicers"",
+			numServicersPerSession: int64(numStakedServicers) * 10,
+			numFishermanPerSession: int64(numStakedFishermen) / 2,
+			wantServicerCount:      numStakedServicers,
+			wantFishermanCount:     numStakedFishermen / 2,
+		},
+	}
+
+	// Constant parameters for testing
+	updateParamsHeight := int64(1)
+	querySessionHeight := int64(2)
+
+	app := runtimeCfg.GetGenesis().Applications[0]
+	relayChain := test_artifacts.DefaultChains[0]
+	geoZone := ""unused_geo""
+
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			// Reset to genesis
+			err := persistenceMod.HandleDebugMessage(&messaging.DebugMessage{
+				Action:  messaging.DebugMessageAction_DEBUG_PERSISTENCE_RESET_TO_GENESIS,
+				Message: nil,
+			})
+			require.NoError(t, err)
+
+			// Update the number of servicers and fishermen per session gov params
+			writeCtx, err := persistenceMod.NewRWContext(updateParamsHeight)
+			require.NoError(t, err)
+			defer writeCtx.Release()
+
+			err = writeCtx.SetParam(types.ServicersPerSessionParamName, tt.numServicersPerSession)
+			require.NoError(t, err)
+			err = writeCtx.SetParam(types.FishermanPerSessionParamName, tt.numFishermanPerSession)
+			require.NoError(t, err)
+			err = writeCtx.Commit([]byte(""empty_proposed_addr""), []byte(""empty_quorum_cert""))
+			require.NoError(t, err)
+
+			// Verify that the session is populated with the correct number of actors
+			session, err := utilityMod.GetSession(app.Address, querySessionHeight, relayChain, geoZone)
+			require.NoError(t, err)
+			require.Equal(t, tt.wantServicerCount, len(session.Servicers))
+			require.Equal(t, tt.wantFishermanCount, len(session.Fishermen))
+		})
+	}
+}
+
+func TestSession_GetSession_ServicersAndFishermenCounts_ChainAvailability(t *testing.T) {
+	// Constant parameters for testing
+	numServicersPerSession := 10
+	numFishermenPerSession := 2
+
+	// Make sure there are MORE THAN ENOUGH servicers and fishermen in the network for each session for chain 1
+	servicersChain1, servicerKeysChain1 := test_artifacts.NewActors(coreTypes.ActorType_ACTOR_TYPE_SERVICER, numServicersPerSession*2, []string{""chn1""})
+	fishermenChain1, fishermenKeysChain1 := test_artifacts.NewActors(coreTypes.ActorType_ACTOR_TYPE_FISH, numFishermenPerSession*2, []string{""chn1""})
+
+	// Make sure there are NOT ENOUGH servicers and fishermen in the network for each session for chain 2
+	servicersChain2, servicerKeysChain2 := test_artifacts.NewActors(coreTypes.ActorType_ACTOR_TYPE_SERVICER, numServicersPerSession/2, []string{""chn2""})
+	fishermenChain2, fishermenKeysChain2 := test_artifacts.NewActors(coreTypes.ActorType_ACTOR_TYPE_FISH, numFishermenPerSession/2, []string{""chn2""})
+
+	application, applicationKey := test_artifacts.NewActors(coreTypes.ActorType_ACTOR_TYPE_APP, 1, []string{""chn1"", ""chn2"", ""chn3""})
+
+	//nolint:gocritic // intentionally not appending result to a new slice
+	actors := append(application, append(servicersChain1, append(servicersChain2, append(fishermenChain1, fishermenChain2...)...)...)...)
+	//nolint:gocritic // intentionally not appending result to a new slice
+	keys := append(applicationKey, append(servicerKeysChain1, append(servicerKeysChain2, append(fishermenKeysChain1, fishermenKeysChain2...)...)...)...)
+
+	// Prepare the environment
+	runtimeCfg, utilityMod, persistenceMod := prepareEnvironment(t, 5, 0, 0, 0, test_artifacts.WithActors(actors, keys))
+
+	// Vary the chain and check the number of fishermen and servicers returned for each one
+	tests := []struct {
+		name               string
+		chain              string
+		wantServicerCount  int
+		wantFishermanCount int
+	}{
+		{
+			name:               ""chn1 has enough servicers and fishermen"",
+			chain:              ""chn1"",
+			wantServicerCount:  numServicersPerSession,
+			wantFishermanCount: numFishermenPerSession,
+		},
+		{
+			name:               ""chn2 does not have enough servicers and fishermen"",
+			chain:              ""chn2"",
+			wantServicerCount:  numServicersPerSession / 2,
+			wantFishermanCount: numFishermenPerSession / 2,
+		},
+		{
+			name:               ""chn3 has no servicers and fishermen"",
+			chain:              ""chn3"",
+			wantServicerCount:  0,
+			wantFishermanCount: 0,
+		},
+	}
+
+	// Reset to genesis
+	err := persistenceMod.HandleDebugMessage(&messaging.DebugMessage{
+		Action:  messaging.DebugMessageAction_DEBUG_PERSISTENCE_RESET_TO_GENESIS,
+		Message: nil,
+	})
+	require.NoError(t, err)
+
+	// Update the number of servicers and fishermen per session gov params
+	writeCtx, err := persistenceMod.NewRWContext(1)
+	require.NoError(t, err)
+	err = writeCtx.SetParam(types.ServicersPerSessionParamName, numServicersPerSession)
+	require.NoError(t, err)
+	err = writeCtx.SetParam(types.FishermanPerSessionParamName, numFishermenPerSession)
+	require.NoError(t, err)
+	err = writeCtx.Commit([]byte(""empty_proposed_addr""), []byte(""empty_quorum_cert""))
+	require.NoError(t, err)
+	defer writeCtx.Release()
+
+	// Test parameters
+	app := runtimeCfg.GetGenesis().Applications[0]
+	geoZone := ""unused_geo""
+
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			session, err := utilityMod.GetSession(app.Address, 2, tt.chain, geoZone)
+			require.NoError(t, err)
+			require.Len(t, session.Servicers, tt.wantServicerCount)
+			require.Len(t, session.Fishermen, tt.wantFishermanCount)
+		})
+	}
+}
+
+func TestSession_GetSession_SessionHeightAndNumber_StaticBlocksPerSession(t *testing.T) {
+	// Prepare the environment
+	_, _, persistenceMod := prepareEnvironment(t, 5, 1, 1, 1)
+
+	// Note that we are using an ephemeral write context at the genesis block (height=0).
+	// This cannot be committed but useful for the test.
+	writeCtx, err := persistenceMod.NewRWContext(0)
+	require.NoError(t, err)
+	defer writeCtx.Release()
+
+	s := &sessionHydrator{
+		session: &coreTypes.Session{},
+		readCtx: writeCtx,
+	}
+
+	tests := []struct {
+		name                   string
+		setNumBlocksPerSession int64
+		provideBlockHeight     int64
+		wantSessionHeight      int64
+		wantSessionNumber      int64
+	}{
+		{
+			name:                   ""genesis block"",
+			setNumBlocksPerSession: 5,
+			provideBlockHeight:     0,
+			wantSessionHeight:      0,
+			wantSessionNumber:      0,
+		},
+		{
+			name:                   ""block is at start of first session"",
+			setNumBlocksPerSession: 5,
+			provideBlockHeight:     5,
+			wantSessionHeight:      5,
+			wantSessionNumber:      1,
+		},
+		{
+			name:                   ""block is right before start of first session"",
+			setNumBlocksPerSession: 5,
+			provideBlockHeight:     4,
+			wantSessionHeight:      0,
+			wantSessionNumber:      0,
+		},
+		{
+			name:                   ""block is right after start of first session"",
+			setNumBlocksPerSession: 5,
+			provideBlockHeight:     6,
+			wantSessionHeight:      5,
+			wantSessionNumber:      1,
+		},
+		{
+			name:                   ""block is at start of second session"",
+			setNumBlocksPerSession: 5,
+			provideBlockHeight:     10,
+			wantSessionHeight:      10,
+			wantSessionNumber:      2,
+		},
+	}
+
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			err := writeCtx.SetParam(types.BlocksPerSessionParamName, tt.setNumBlocksPerSession)
+			require.NoError(t, err)
+
+			s.blockHeight = tt.provideBlockHeight
+			err = s.hydrateSessionMetadata()
+			require.NoError(t, err)
+			require.Equal(t, tt.setNumBlocksPerSession, s.session.NumSessionBlocks)
+			require.Equal(t, tt.wantSessionHeight, s.session.SessionHeight)
+			require.Equal(t, tt.wantSessionNumber, s.session.SessionNumber)
+		})
+	}
+}
+
+func TestSession_GetSession_ServicersAndFishermanEntropy(t *testing.T) {
+	// Prepare an environment with a lot of servicers and fishermen
+	numServicers := 1000
+	numFishermen := 1000 // make them equal for simplicity
+	numServicersPerSession := 10
+	numFishermenPerSession := 10 // make them equal for simplicity
+	numApplications := 3
+	numBlocksPerSession := 2 // expect a different every other height
+
+	// Determine probability of overlap using combinatorics
+	// numChoices = (numServicers) C (numServicersPerSession)
+	numChoices := combin.GeneralizedBinomial(float64(numServicers), float64(numServicersPerSession))
+	// numChoicesRemaining = (numServicers - numServicersPerSession) C (numServicersPerSession)
+	numChoicesRemaining := combin.GeneralizedBinomial(float64(numServicers-numServicersPerSession), float64(numServicersPerSession))
+	probabilityOfOverlap := (numChoices - numChoicesRemaining) / numChoices
+
+	// Prepare the environment
+	runtimeCfg, utilityMod, persistenceMod := prepareEnvironment(t, 5, numServicers, numApplications, numFishermen)
+
+	// Set the number of servicers and fishermen per session gov params
+	writeCtx, err := persistenceMod.NewRWContext(1)
+	require.NoError(t, err)
+	err = writeCtx.SetParam(types.ServicersPerSessionParamName, numServicersPerSession)
+	require.NoError(t, err)
+	err = writeCtx.SetParam(types.FishermanPerSessionParamName, numFishermenPerSession)
+	require.NoError(t, err)
+	err = writeCtx.SetParam(types.BlocksPerSessionParamName, numBlocksPerSession)
+	require.NoError(t, err)
+	err = writeCtx.Commit([]byte(fmt.Sprintf(""proposer_height_%d"", 1)), []byte(fmt.Sprintf(""quorum_cert_height_%d"", 1)))
+	require.NoError(t, err)
+	writeCtx.Release()
+
+	// Keep the relay chain and geoZone static, but vary the app and height to verify that the servicers and fishermen vary
+	relayChain := test_artifacts.DefaultChains[0]
+	geoZone := ""unused_geo""
+
+	// Sanity check we have 3 apps
+	require.Len(t, runtimeCfg.GetGenesis().Applications, numApplications)
+	app1 := runtimeCfg.GetGenesis().Applications[0]
+	app2 := runtimeCfg.GetGenesis().Applications[1]
+	app3 := runtimeCfg.GetGenesis().Applications[2]
+
+	// Keep track of the actors from the session at the previous height to verify a delta
+	var app1PrevServicers, app2PrevServicers, app3PrevServicers []*coreTypes.Actor
+	var app1PrevFishermen, app2PrevFishermen, app3PrevFishermen []*coreTypes.Actor
+
+	// The number of blocks to increase until we expect a different set of servicers and fishermen; see numBlocksPerSession
+	numBlocksUntilChange := 0
+
+	// Commit new blocks for all the heights that failed above
+	for height := int64(2); height < 10; height++ {
+		session1, err := utilityMod.GetSession(app1.Address, height, relayChain, geoZone)
+		require.NoError(t, err)
+		session2, err := utilityMod.GetSession(app2.Address, height, relayChain, geoZone)
+		require.NoError(t, err)
+		session3, err := utilityMod.GetSession(app3.Address, height, relayChain, geoZone)
+		require.NoError(t, err)
+
+		// All the sessions have the same number of servicers
+		require.Len(t, session1.Servicers, numServicersPerSession)
+		require.Equal(t, len(session1.Servicers), len(session2.Servicers))
+		require.Equal(t, len(session1.Servicers), len(session3.Servicers))
+
+		// All the sessions have the same number of fishermen
+		require.Len(t, session1.Fishermen, numFishermenPerSession)
+		require.Equal(t, len(session1.Fishermen), len(session2.Fishermen))
+		require.Equal(t, len(session1.Fishermen), len(session3.Fishermen))
+
+		// Assert different services between apps
+		assertActorsDifference(t, session1.Servicers, session2.Servicers, probabilityOfOverlap)
+		assertActorsDifference(t, session1.Servicers, session3.Servicers, probabilityOfOverlap)
+
+		// Assert different fishermen between apps
+		assertActorsDifference(t, session1.Fishermen, session2.Fishermen, probabilityOfOverlap)
+		assertActorsDifference(t, session1.Fishermen, session3.Fishermen, probabilityOfOverlap)
+
+		if numBlocksUntilChange == 0 {
+			// Assert different servicers between heights for the same app
+			assertActorsDifference(t, app1PrevServicers, session1.Servicers, probabilityOfOverlap)
+			assertActorsDifference(t, app2PrevServicers, session2.Servicers, probabilityOfOverlap)
+			assertActorsDifference(t, app3PrevServicers, session3.Servicers, probabilityOfOverlap)
+
+			// Assert different fishermen between heights for the same app
+			assertActorsDifference(t, app1PrevFishermen, session1.Fishermen, probabilityOfOverlap)
+			assertActorsDifference(t, app2PrevFishermen, session2.Fishermen, probabilityOfOverlap)
+			assertActorsDifference(t, app3PrevFishermen, session3.Fishermen, probabilityOfOverlap)
+
+			// Store the new servicers and fishermen for the next height
+			app1PrevServicers = session1.Servicers
+			app2PrevServicers = session2.Servicers
+			app3PrevServicers = session3.Servicers
+			app1PrevFishermen = session1.Fishermen
+			app2PrevFishermen = session2.Fishermen
+			app3PrevFishermen = session3.Fishermen
+
+			// Reset the number of blocks until we expect a different set of servicers and fishermen
+			numBlocksUntilChange = numBlocksPerSession - 1
+		} else {
+			// Assert the same servicers between heights for the same app
+			require.ElementsMatch(t, app1PrevServicers, session1.Servicers)
+			require.ElementsMatch(t, app2PrevServicers, session2.Servicers)
+			require.ElementsMatch(t, app3PrevServicers, session3.Servicers)
+
+			// Assert the same fishermen between heights for the same app
+			require.ElementsMatch(t, app1PrevFishermen, session1.Fishermen)
+			require.ElementsMatch(t, app2PrevFishermen, session2.Fishermen)
+			require.ElementsMatch(t, app3PrevFishermen, session3.Fishermen)
+
+			numBlocksUntilChange--
+		}
+
+		// Advance block height
+		writeCtx, err := persistenceMod.NewRWContext(height)
+		require.NoError(t, err)
+		err = writeCtx.Commit([]byte(fmt.Sprintf(""proposer_height_%d"", height)), []byte(fmt.Sprintf(""quorum_cert_height_%d"", height)))
+		require.NoError(t, err)
+		writeCtx.Release()
+	}
+}
+
+func TestSession_GetSession_ApplicationUnbonds(t *testing.T) {
+	// TODO: What if an Application unbonds (unstaking period elapses) mid session?
+}
+
+func TestSession_GetSession_ServicersAndFishermenCounts_GeoZoneAvailability(t *testing.T) {
+	// TECHDEBT(#697): Once GeoZones are implemented, the tests need to be added as well
+	// Cases: Invalid, unused, non-existent, empty, insufficiently complete, etc...
+}
+
+func TestSession_GetSession_ActorReplacement(t *testing.T) {
+	// TODO: Since sessions last multiple blocks, we need to design what happens when an actor is (un)jailed, (un)stakes, (un)bonds, (un)pauses
+	// mid session. There are open design questions that need to be made.
+}
+
+func TestSession_GetSession_SessionHeightAndNumber_ModifiedBlocksPerSession(t *testing.T) {
+	// RESEARCH: Need to design what happens (actor replacement, session numbers, etc...) when the number
+	// of blocks per session changes mid session. For example, all existing sessions could go to completion
+	// until the new parameter takes effect. There are open design questions that need to be made.
+}
+
+func assertActorsDifference(t *testing.T, actors1, actors2 []*coreTypes.Actor, maxSimilarityThreshold float64) {",utility/session_test.go,2023-04-28 21:42:27+00:00,2023-04-28T21:42:28Z,"See: https://pkg.go.dev/testing#T.Helper

```suggestion
func assertActorsDifference(t *testing.T, actors1, actors2 []*coreTypes.Actor, maxSimilarityThreshold float64) {
  t.Helper()
```",,,,513.0,513,RIGHT,513,513.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/683,pokt-network/pocket,fb245bc027ae55aaee936daf9f85ecb2d9ad8b40
https://api.github.com/repos/pokt-network/pocket/pulls/683,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1180839305,bryanchriswhite,d06787e78227b872e61af15b05f8414b4d4be31a,e2864b82e0b52b527cf11e0a05062f4779fef9fe,"@@ -0,0 +1,535 @@
+package utility
+
+import (
+	""fmt""
+	""math""
+	""testing""
+
+	""github.com/stretchr/testify/assert""
+	""github.com/stretchr/testify/require""
+	""gonum.org/v1/gonum/stat/combin""
+
+	""github.com/pokt-network/pocket/runtime/test_artifacts""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/crypto""
+	""github.com/pokt-network/pocket/shared/messaging""
+	""github.com/pokt-network/pocket/utility/types""
+)
+
+// TECHDEBT(#697): Geozones are not current implemented, used or tested
+
+func TestSession_GetSession_SingleFishermanSingleServicerBaseCase(t *testing.T) {
+	// Test parameters
+	height := int64(1)
+	relayChain := test_artifacts.DefaultChains[0]
+	geoZone := ""unused_geo""
+	numFishermen := 1
+	numServicers := 1
+	// needs to be manually updated if business logic changes
+	expectedSessionId := ""5acf559f1a3faf3bea7eb692fe51bc1e2e5fb687ede0a6daa7d42399da4aa82b""
+
+	runtimeCfg, utilityMod, _ := prepareEnvironment(t, 5, numServicers, 1, numFishermen)
+
+	// Sanity check genesis
+	require.Len(t, runtimeCfg.GetGenesis().Applications, 1)
+	app := runtimeCfg.GetGenesis().Applications[0]
+	require.Len(t, runtimeCfg.GetGenesis().Fishermen, 1)
+	fisher := runtimeCfg.GetGenesis().Fishermen[0]
+	require.Len(t, runtimeCfg.GetGenesis().Servicers, 1)
+	servicer := runtimeCfg.GetGenesis().Servicers[0]
+
+	// Verify some of the session defaults
+	session, err := utilityMod.GetSession(app.Address, height, relayChain, geoZone)
+	require.NoError(t, err)
+	require.Equal(t, expectedSessionId, session.Id)
+	require.Equal(t, height, session.SessionHeight)
+	require.Equal(t, int64(1), session.SessionNumber)
+	require.Equal(t, int64(1), session.NumSessionBlocks)
+	require.Equal(t, relayChain, session.RelayChain)
+	require.Equal(t, geoZone, session.GeoZone)
+	require.Equal(t, app.Address, session.Application.Address)
+	require.Len(t, session.Servicers, numServicers)
+	require.Equal(t, servicer.Address, session.Servicers[0].Address)
+	require.Len(t, session.Fishermen, numFishermen)
+	require.Equal(t, fisher.Address, session.Fishermen[0].Address)
+}
+
+func TestSession_GetSession_ApplicationInvalid(t *testing.T) {
+	runtimeCfg, utilityMod, _ := prepareEnvironment(t, 5, 1, 1, 1)
+
+	// Verify there's only 1 app
+	require.Len(t, runtimeCfg.GetGenesis().Applications, 1)
+	app := runtimeCfg.GetGenesis().Applications[0]
+
+	// Create a new app address
+	pk, err := crypto.GeneratePrivateKey()
+	require.NoError(t, err)
+
+	// Verify that the one app in the genesis is not the one we just generated
+	addr := pk.Address().String()
+	require.NotEqual(t, app.Address, addr)
+
+	// Expect no error trying to get a session for the real application
+	_, err = utilityMod.GetSession(app.Address, 1, test_artifacts.DefaultChains[0], ""unused_geo"")
+	require.NoError(t, err)
+
+	// Expect an error trying to get a session for an unstaked chain
+	_, err = utilityMod.GetSession(addr, 1, ""chain"", ""unused_geo"")
+	require.Error(t, err)
+
+	// Expect an error trying to get a session for a non-existent application
+	_, err = utilityMod.GetSession(addr, 1, test_artifacts.DefaultChains[0], ""unused_geo"")
+	require.Error(t, err)
+}
+
+func TestSession_GetSession_InvalidFutureSession(t *testing.T) {
+	runtimeCfg, utilityMod, persistenceMod := prepareEnvironment(t, 5, 1, 1, 1)
+
+	// Test parameters
+	relayChain := test_artifacts.DefaultChains[0]
+	geoZone := ""unused_geo""
+	app := runtimeCfg.GetGenesis().Applications[0]
+
+	// Local variable to keep track of the height we're getting a session for
+	currentHeight := int64(0)
+
+	// Successfully get a session for 1 block ahead of the latest committed height
+	session, err := utilityMod.GetSession(app.Address, currentHeight+1, relayChain, geoZone)
+	require.NoError(t, err)
+	require.Equal(t, currentHeight+1, session.SessionHeight)
+
+	// Expect an error for a few heights into the future
+	for height := currentHeight + 2; height < 10; height++ {
+		_, err := utilityMod.GetSession(app.Address, height, relayChain, geoZone)
+		require.Error(t, err)
+	}
+
+	// Commit new blocks for all the heights that failed above
+	for ; currentHeight < 10; currentHeight++ {
+		writeCtx, err := persistenceMod.NewRWContext(currentHeight + 1)
+		require.NoError(t, err)
+		err = writeCtx.Commit([]byte(fmt.Sprintf(""proposer_height_%d"", currentHeight)), []byte(fmt.Sprintf(""quorum_cert_height_%d"", currentHeight)))
+		require.NoError(t, err)
+		writeCtx.Release()
+	}
+
+	// Expect no errors since those blocks exist now
+	// Note that we can get the session for latest_committed + 1
+	for height := int64(1); height <= currentHeight+1; height++ {
+		_, err := utilityMod.GetSession(app.Address, height, relayChain, geoZone)
+		require.NoError(t, err)
+	}
+
+	// Verify that currentHeight + 2 fails
+	_, err = utilityMod.GetSession(app.Address, currentHeight+2, relayChain, geoZone)
+	require.Error(t, err)
+}
+
+func TestSession_GetSession_ServicersAndFishermenCounts_TotalAvailability(t *testing.T) {
+	// Prepare an environment with a lot of servicers and fishermen
+	numStakedServicers := 100
+	numStakedFishermen := 100
+	runtimeCfg, utilityMod, persistenceMod := prepareEnvironment(t, 5, numStakedServicers, 1, numStakedFishermen)
+
+	// Vary the number of actors per session using gov params and check that the session is populated with the correct number of actorss
+	tests := []struct {
+		name                   string
+		numServicersPerSession int64
+		numFishermanPerSession int64
+		wantServicerCount      int
+		wantFishermanCount     int
+	}{
+		{
+			name:                   ""more actors per session than available in network"",
+			numServicersPerSession: int64(numStakedServicers) * 10,
+			numFishermanPerSession: int64(numStakedFishermen) * 10,
+			wantServicerCount:      numStakedServicers,
+			wantFishermanCount:     numStakedFishermen,
+		},
+		{
+			name:                   ""less actors per session than available in network"",
+			numServicersPerSession: int64(numStakedServicers) / 2,
+			numFishermanPerSession: int64(numStakedFishermen) / 2,
+			wantServicerCount:      numStakedServicers / 2,
+			wantFishermanCount:     numStakedFishermen / 2,
+		},
+		{
+			name:                   ""same number of actors per session as available in network"",
+			numServicersPerSession: int64(numStakedServicers),
+			numFishermanPerSession: int64(numStakedFishermen),
+			wantServicerCount:      numStakedServicers,
+			wantFishermanCount:     numStakedFishermen,
+		},
+		{
+			name:                   ""more than enough servicers but not enough fishermen"",
+			numServicersPerSession: int64(numStakedServicers) / 2,
+			numFishermanPerSession: int64(numStakedFishermen) * 10,
+			wantServicerCount:      numStakedServicers / 2,
+			wantFishermanCount:     numStakedFishermen,
+		},
+		{
+			name:                   ""more than enough fishermen but not enough servicers"",
+			numServicersPerSession: int64(numStakedServicers) * 10,
+			numFishermanPerSession: int64(numStakedFishermen) / 2,
+			wantServicerCount:      numStakedServicers,
+			wantFishermanCount:     numStakedFishermen / 2,
+		},
+	}
+
+	// Constant parameters for testing
+	updateParamsHeight := int64(1)
+	querySessionHeight := int64(2)
+
+	app := runtimeCfg.GetGenesis().Applications[0]
+	relayChain := test_artifacts.DefaultChains[0]
+	geoZone := ""unused_geo""
+
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			// Reset to genesis
+			err := persistenceMod.HandleDebugMessage(&messaging.DebugMessage{
+				Action:  messaging.DebugMessageAction_DEBUG_PERSISTENCE_RESET_TO_GENESIS,
+				Message: nil,
+			})
+			require.NoError(t, err)
+
+			// Update the number of servicers and fishermen per session gov params
+			writeCtx, err := persistenceMod.NewRWContext(updateParamsHeight)
+			require.NoError(t, err)
+			defer writeCtx.Release()
+
+			err = writeCtx.SetParam(types.ServicersPerSessionParamName, tt.numServicersPerSession)
+			require.NoError(t, err)
+			err = writeCtx.SetParam(types.FishermanPerSessionParamName, tt.numFishermanPerSession)
+			require.NoError(t, err)
+			err = writeCtx.Commit([]byte(""empty_proposed_addr""), []byte(""empty_quorum_cert""))
+			require.NoError(t, err)
+
+			// Verify that the session is populated with the correct number of actors
+			session, err := utilityMod.GetSession(app.Address, querySessionHeight, relayChain, geoZone)
+			require.NoError(t, err)
+			require.Equal(t, tt.wantServicerCount, len(session.Servicers))
+			require.Equal(t, tt.wantFishermanCount, len(session.Fishermen))
+		})
+	}
+}
+
+func TestSession_GetSession_ServicersAndFishermenCounts_ChainAvailability(t *testing.T) {
+	// Constant parameters for testing
+	numServicersPerSession := 10
+	numFishermenPerSession := 2
+
+	// Make sure there are MORE THAN ENOUGH servicers and fishermen in the network for each session for chain 1
+	servicersChain1, servicerKeysChain1 := test_artifacts.NewActors(coreTypes.ActorType_ACTOR_TYPE_SERVICER, numServicersPerSession*2, []string{""chn1""})
+	fishermenChain1, fishermenKeysChain1 := test_artifacts.NewActors(coreTypes.ActorType_ACTOR_TYPE_FISH, numFishermenPerSession*2, []string{""chn1""})
+
+	// Make sure there are NOT ENOUGH servicers and fishermen in the network for each session for chain 2
+	servicersChain2, servicerKeysChain2 := test_artifacts.NewActors(coreTypes.ActorType_ACTOR_TYPE_SERVICER, numServicersPerSession/2, []string{""chn2""})
+	fishermenChain2, fishermenKeysChain2 := test_artifacts.NewActors(coreTypes.ActorType_ACTOR_TYPE_FISH, numFishermenPerSession/2, []string{""chn2""})
+
+	application, applicationKey := test_artifacts.NewActors(coreTypes.ActorType_ACTOR_TYPE_APP, 1, []string{""chn1"", ""chn2"", ""chn3""})
+
+	//nolint:gocritic // intentionally not appending result to a new slice
+	actors := append(application, append(servicersChain1, append(servicersChain2, append(fishermenChain1, fishermenChain2...)...)...)...)
+	//nolint:gocritic // intentionally not appending result to a new slice
+	keys := append(applicationKey, append(servicerKeysChain1, append(servicerKeysChain2, append(fishermenKeysChain1, fishermenKeysChain2...)...)...)...)
+
+	// Prepare the environment
+	runtimeCfg, utilityMod, persistenceMod := prepareEnvironment(t, 5, 0, 0, 0, test_artifacts.WithActors(actors, keys))
+
+	// Vary the chain and check the number of fishermen and servicers returned for each one
+	tests := []struct {
+		name               string
+		chain              string
+		wantServicerCount  int
+		wantFishermanCount int
+	}{
+		{
+			name:               ""chn1 has enough servicers and fishermen"",
+			chain:              ""chn1"",
+			wantServicerCount:  numServicersPerSession,
+			wantFishermanCount: numFishermenPerSession,
+		},
+		{
+			name:               ""chn2 does not have enough servicers and fishermen"",
+			chain:              ""chn2"",
+			wantServicerCount:  numServicersPerSession / 2,
+			wantFishermanCount: numFishermenPerSession / 2,
+		},
+		{
+			name:               ""chn3 has no servicers and fishermen"",
+			chain:              ""chn3"",
+			wantServicerCount:  0,
+			wantFishermanCount: 0,
+		},
+	}
+
+	// Reset to genesis
+	err := persistenceMod.HandleDebugMessage(&messaging.DebugMessage{
+		Action:  messaging.DebugMessageAction_DEBUG_PERSISTENCE_RESET_TO_GENESIS,
+		Message: nil,
+	})
+	require.NoError(t, err)
+
+	// Update the number of servicers and fishermen per session gov params
+	writeCtx, err := persistenceMod.NewRWContext(1)
+	require.NoError(t, err)
+	err = writeCtx.SetParam(types.ServicersPerSessionParamName, numServicersPerSession)
+	require.NoError(t, err)
+	err = writeCtx.SetParam(types.FishermanPerSessionParamName, numFishermenPerSession)
+	require.NoError(t, err)
+	err = writeCtx.Commit([]byte(""empty_proposed_addr""), []byte(""empty_quorum_cert""))
+	require.NoError(t, err)
+	defer writeCtx.Release()
+
+	// Test parameters
+	app := runtimeCfg.GetGenesis().Applications[0]
+	geoZone := ""unused_geo""
+
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			session, err := utilityMod.GetSession(app.Address, 2, tt.chain, geoZone)
+			require.NoError(t, err)
+			require.Len(t, session.Servicers, tt.wantServicerCount)
+			require.Len(t, session.Fishermen, tt.wantFishermanCount)
+		})
+	}
+}
+
+func TestSession_GetSession_SessionHeightAndNumber_StaticBlocksPerSession(t *testing.T) {
+	// Prepare the environment
+	_, _, persistenceMod := prepareEnvironment(t, 5, 1, 1, 1)
+
+	// Note that we are using an ephemeral write context at the genesis block (height=0).
+	// This cannot be committed but useful for the test.
+	writeCtx, err := persistenceMod.NewRWContext(0)
+	require.NoError(t, err)
+	defer writeCtx.Release()
+
+	s := &sessionHydrator{
+		session: &coreTypes.Session{},
+		readCtx: writeCtx,
+	}
+
+	tests := []struct {
+		name                   string
+		setNumBlocksPerSession int64
+		provideBlockHeight     int64
+		wantSessionHeight      int64
+		wantSessionNumber      int64
+	}{
+		{
+			name:                   ""genesis block"",
+			setNumBlocksPerSession: 5,
+			provideBlockHeight:     0,
+			wantSessionHeight:      0,
+			wantSessionNumber:      0,
+		},
+		{
+			name:                   ""block is at start of first session"",
+			setNumBlocksPerSession: 5,
+			provideBlockHeight:     5,
+			wantSessionHeight:      5,
+			wantSessionNumber:      1,
+		},
+		{
+			name:                   ""block is right before start of first session"",
+			setNumBlocksPerSession: 5,
+			provideBlockHeight:     4,
+			wantSessionHeight:      0,
+			wantSessionNumber:      0,
+		},
+		{
+			name:                   ""block is right after start of first session"",
+			setNumBlocksPerSession: 5,
+			provideBlockHeight:     6,
+			wantSessionHeight:      5,
+			wantSessionNumber:      1,
+		},
+		{
+			name:                   ""block is at start of second session"",
+			setNumBlocksPerSession: 5,
+			provideBlockHeight:     10,
+			wantSessionHeight:      10,
+			wantSessionNumber:      2,
+		},
+	}
+
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			err := writeCtx.SetParam(types.BlocksPerSessionParamName, tt.setNumBlocksPerSession)
+			require.NoError(t, err)
+
+			s.blockHeight = tt.provideBlockHeight
+			err = s.hydrateSessionMetadata()
+			require.NoError(t, err)
+			require.Equal(t, tt.setNumBlocksPerSession, s.session.NumSessionBlocks)
+			require.Equal(t, tt.wantSessionHeight, s.session.SessionHeight)
+			require.Equal(t, tt.wantSessionNumber, s.session.SessionNumber)
+		})
+	}
+}
+
+func TestSession_GetSession_ServicersAndFishermanEntropy(t *testing.T) {
+	// Prepare an environment with a lot of servicers and fishermen
+	numServicers := 1000
+	numFishermen := 1000 // make them equal for simplicity
+	numServicersPerSession := 10
+	numFishermenPerSession := 10 // make them equal for simplicity
+	numApplications := 3
+	numBlocksPerSession := 2 // expect a different every other height
+
+	// Determine probability of overlap using combinatorics
+	// numChoices = (numServicers) C (numServicersPerSession)
+	numChoices := combin.GeneralizedBinomial(float64(numServicers), float64(numServicersPerSession))
+	// numChoicesRemaining = (numServicers - numServicersPerSession) C (numServicersPerSession)
+	numChoicesRemaining := combin.GeneralizedBinomial(float64(numServicers-numServicersPerSession), float64(numServicersPerSession))
+	probabilityOfOverlap := (numChoices - numChoicesRemaining) / numChoices
+
+	// Prepare the environment
+	runtimeCfg, utilityMod, persistenceMod := prepareEnvironment(t, 5, numServicers, numApplications, numFishermen)
+
+	// Set the number of servicers and fishermen per session gov params
+	writeCtx, err := persistenceMod.NewRWContext(1)
+	require.NoError(t, err)
+	err = writeCtx.SetParam(types.ServicersPerSessionParamName, numServicersPerSession)
+	require.NoError(t, err)
+	err = writeCtx.SetParam(types.FishermanPerSessionParamName, numFishermenPerSession)
+	require.NoError(t, err)
+	err = writeCtx.SetParam(types.BlocksPerSessionParamName, numBlocksPerSession)
+	require.NoError(t, err)
+	err = writeCtx.Commit([]byte(fmt.Sprintf(""proposer_height_%d"", 1)), []byte(fmt.Sprintf(""quorum_cert_height_%d"", 1)))
+	require.NoError(t, err)
+	writeCtx.Release()
+
+	// Keep the relay chain and geoZone static, but vary the app and height to verify that the servicers and fishermen vary
+	relayChain := test_artifacts.DefaultChains[0]
+	geoZone := ""unused_geo""
+
+	// Sanity check we have 3 apps
+	require.Len(t, runtimeCfg.GetGenesis().Applications, numApplications)
+	app1 := runtimeCfg.GetGenesis().Applications[0]
+	app2 := runtimeCfg.GetGenesis().Applications[1]
+	app3 := runtimeCfg.GetGenesis().Applications[2]
+
+	// Keep track of the actors from the session at the previous height to verify a delta
+	var app1PrevServicers, app2PrevServicers, app3PrevServicers []*coreTypes.Actor
+	var app1PrevFishermen, app2PrevFishermen, app3PrevFishermen []*coreTypes.Actor
+
+	// The number of blocks to increase until we expect a different set of servicers and fishermen; see numBlocksPerSession
+	numBlocksUntilChange := 0
+
+	// Commit new blocks for all the heights that failed above
+	for height := int64(2); height < 10; height++ {
+		session1, err := utilityMod.GetSession(app1.Address, height, relayChain, geoZone)
+		require.NoError(t, err)
+		session2, err := utilityMod.GetSession(app2.Address, height, relayChain, geoZone)
+		require.NoError(t, err)
+		session3, err := utilityMod.GetSession(app3.Address, height, relayChain, geoZone)
+		require.NoError(t, err)
+
+		// All the sessions have the same number of servicers
+		require.Len(t, session1.Servicers, numServicersPerSession)
+		require.Equal(t, len(session1.Servicers), len(session2.Servicers))
+		require.Equal(t, len(session1.Servicers), len(session3.Servicers))
+
+		// All the sessions have the same number of fishermen
+		require.Len(t, session1.Fishermen, numFishermenPerSession)
+		require.Equal(t, len(session1.Fishermen), len(session2.Fishermen))
+		require.Equal(t, len(session1.Fishermen), len(session3.Fishermen))
+
+		// Assert different services between apps
+		assertActorsDifference(t, session1.Servicers, session2.Servicers, probabilityOfOverlap)
+		assertActorsDifference(t, session1.Servicers, session3.Servicers, probabilityOfOverlap)
+
+		// Assert different fishermen between apps
+		assertActorsDifference(t, session1.Fishermen, session2.Fishermen, probabilityOfOverlap)
+		assertActorsDifference(t, session1.Fishermen, session3.Fishermen, probabilityOfOverlap)
+
+		if numBlocksUntilChange == 0 {
+			// Assert different servicers between heights for the same app
+			assertActorsDifference(t, app1PrevServicers, session1.Servicers, probabilityOfOverlap)
+			assertActorsDifference(t, app2PrevServicers, session2.Servicers, probabilityOfOverlap)
+			assertActorsDifference(t, app3PrevServicers, session3.Servicers, probabilityOfOverlap)
+
+			// Assert different fishermen between heights for the same app
+			assertActorsDifference(t, app1PrevFishermen, session1.Fishermen, probabilityOfOverlap)
+			assertActorsDifference(t, app2PrevFishermen, session2.Fishermen, probabilityOfOverlap)
+			assertActorsDifference(t, app3PrevFishermen, session3.Fishermen, probabilityOfOverlap)
+
+			// Store the new servicers and fishermen for the next height
+			app1PrevServicers = session1.Servicers
+			app2PrevServicers = session2.Servicers
+			app3PrevServicers = session3.Servicers
+			app1PrevFishermen = session1.Fishermen
+			app2PrevFishermen = session2.Fishermen
+			app3PrevFishermen = session3.Fishermen
+
+			// Reset the number of blocks until we expect a different set of servicers and fishermen
+			numBlocksUntilChange = numBlocksPerSession - 1
+		} else {
+			// Assert the same servicers between heights for the same app
+			require.ElementsMatch(t, app1PrevServicers, session1.Servicers)
+			require.ElementsMatch(t, app2PrevServicers, session2.Servicers)
+			require.ElementsMatch(t, app3PrevServicers, session3.Servicers)
+
+			// Assert the same fishermen between heights for the same app
+			require.ElementsMatch(t, app1PrevFishermen, session1.Fishermen)
+			require.ElementsMatch(t, app2PrevFishermen, session2.Fishermen)
+			require.ElementsMatch(t, app3PrevFishermen, session3.Fishermen)
+
+			numBlocksUntilChange--
+		}
+
+		// Advance block height
+		writeCtx, err := persistenceMod.NewRWContext(height)
+		require.NoError(t, err)
+		err = writeCtx.Commit([]byte(fmt.Sprintf(""proposer_height_%d"", height)), []byte(fmt.Sprintf(""quorum_cert_height_%d"", height)))
+		require.NoError(t, err)
+		writeCtx.Release()
+	}
+}
+
+func TestSession_GetSession_ApplicationUnbonds(t *testing.T) {
+	// TODO: What if an Application unbonds (unstaking period elapses) mid session?
+}
+
+func TestSession_GetSession_ServicersAndFishermenCounts_GeoZoneAvailability(t *testing.T) {
+	// TECHDEBT(#697): Once GeoZones are implemented, the tests need to be added as well
+	// Cases: Invalid, unused, non-existent, empty, insufficiently complete, etc...
+}
+
+func TestSession_GetSession_ActorReplacement(t *testing.T) {
+	// TODO: Since sessions last multiple blocks, we need to design what happens when an actor is (un)jailed, (un)stakes, (un)bonds, (un)pauses
+	// mid session. There are open design questions that need to be made.
+}
+
+func TestSession_GetSession_SessionHeightAndNumber_ModifiedBlocksPerSession(t *testing.T) {
+	// RESEARCH: Need to design what happens (actor replacement, session numbers, etc...) when the number
+	// of blocks per session changes mid session. For example, all existing sessions could go to completion
+	// until the new parameter takes effect. There are open design questions that need to be made.
+}
+
+func assertActorsDifference(t *testing.T, actors1, actors2 []*coreTypes.Actor, maxSimilarityThreshold float64) {
+	slice1 := actorsToAddrs(actors1)
+	slice2 := actorsToAddrs(actors2)
+	var commonCount float64
+	for _, s1 := range slice1 {
+		for _, s2 := range slice2 {
+			if s1 == s2 {
+				commonCount++
+				break
+			}
+		}
+	}
+	maxCommonCount := math.Round(maxSimilarityThreshold * float64(len(slice1)))
+	assert.LessOrEqual(t, commonCount, maxCommonCount, ""Slices have more similarity than expected: %v vs max %v"", slice1, slice2)
+}
+
+func actorsToAddrs(actors []*coreTypes.Actor) []string {",utility/session_test.go,2023-04-28 21:43:57+00:00,2023-04-28T21:43:57Z,"nit: I think we should start doing this - apologies for not noticing earlier
```suggestion
func actorsToAddrs(actors []*coreTypes.Actor) []string {
  t.Helper()
```",,,,,529,RIGHT,529,,line,https://api.github.com/repos/pokt-network/pocket/pulls/683,pokt-network/pocket,fb245bc027ae55aaee936daf9f85ecb2d9ad8b40
https://api.github.com/repos/pokt-network/pocket/pulls/699,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1175886046,okdas,741fe4940f23e7d20a5a2a0de549d5858790cec9,98d2d6b5c7da1f2e3fc213a5ea087681559910d1,"@@ -67,7 +66,7 @@ func dumpKeybase(privateKeysYamlBytes []byte, targetFilePath string) {
 	defer os.RemoveAll(tmpDir)
 
 	kb, err := keybase.NewKeybase(&configs.KeybaseConfig{
-		FilePath: defaults.DefaultRootDirectory + ""/keys"",
+		FilePath: tmpDir,",build/debug_keybase/main.go,2023-04-24 23:45:28+00:00,2023-04-24T23:45:28Z,"@h5law `tmpDir` above seems to be created for that purpose and it is not used anywhere else. Please lmk if you think that's not the case - we can remove `tmpDir` and keep `FilePath` pointed to `defaults.DefaultRootDirectory + ""/keys""`.",,,,,69,RIGHT,13,,line,https://api.github.com/repos/pokt-network/pocket/pulls/699,pokt-network/pocket,37bc0a72df29bb6524cbd6b8274a82ad366e84f8
https://api.github.com/repos/pokt-network/pocket/pulls/699,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1179706048,dylanlott,3f3609683964db22399882fbba4fcc0c3fcb3a09,98d2d6b5c7da1f2e3fc213a5ea087681559910d1,"@@ -2,18 +2,34 @@ package k8s
 
 import (
 	""context""
+	""fmt""
+	""os""
 
+	""github.com/pokt-network/pocket/logger""
 	metav1 ""k8s.io/apimachinery/pkg/apis/meta/v1""
 	""k8s.io/client-go/kubernetes""
 )
 
 //nolint:gosec // G101 Not a credential
-const privateKeysSecretResourceName = ""v1-localnet-validators-private-keys""
+const privateKeysSecretResourceName = ""validators-private-keys""
+
+var CurrentNamespace = """"
+
+func init() {
+	var err error
+	CurrentNamespace, err = getNamespace()
+	if err != nil {
+		logger.Global.Err(err).Msg(""could not get namespace, using default"")
+		CurrentNamespace = ""default""
+	}
+
+	logger.Global.Info().Str(""namespace"", CurrentNamespace).Msg(""using namespace"")
+}
 
 func FetchValidatorPrivateKeys(clientset *kubernetes.Clientset) (map[string]string, error) {
 	validatorKeysMap := make(map[string]string)
 
-	privateKeysSecret, err := clientset.CoreV1().Secrets(""default"").Get(context.TODO(), privateKeysSecretResourceName, metav1.GetOptions{})
+	privateKeysSecret, err := clientset.CoreV1().Secrets(CurrentNamespace).Get(context.TODO(), privateKeysSecretResourceName, metav1.GetOptions{})",shared/k8s/debug.go,2023-04-27 21:39:22+00:00,2023-04-27T21:41:31Z,This was a change that was going to be necessary for later Byzantine test network stuff so good to see it going in anyway! 🙌,,,,35.0,32,RIGHT,33,37.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/699,pokt-network/pocket,37bc0a72df29bb6524cbd6b8274a82ad366e84f8
https://api.github.com/repos/pokt-network/pocket/pulls/699,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1179898362,Olshansk,3f3609683964db22399882fbba4fcc0c3fcb3a09,98d2d6b5c7da1f2e3fc213a5ea087681559910d1,"@@ -2,18 +2,34 @@ package k8s
 ",shared/k8s/debug.go,2023-04-28 03:40:06+00:00,2023-04-28T03:42:37Z,Can you add a `CONSIDERATION: Add a debug tag`,,,,3.0,2,RIGHT,1,3.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/699,pokt-network/pocket,37bc0a72df29bb6524cbd6b8274a82ad366e84f8
https://api.github.com/repos/pokt-network/pocket/pulls/699,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1179898656,Olshansk,3f3609683964db22399882fbba4fcc0c3fcb3a09,98d2d6b5c7da1f2e3fc213a5ea087681559910d1,"@@ -2,18 +2,34 @@ package k8s
 
 import (
 	""context""
+	""fmt""
+	""os""
 
+	""github.com/pokt-network/pocket/logger""
 	metav1 ""k8s.io/apimachinery/pkg/apis/meta/v1""
 	""k8s.io/client-go/kubernetes""
 )
 
 //nolint:gosec // G101 Not a credential
-const privateKeysSecretResourceName = ""v1-localnet-validators-private-keys""
+const privateKeysSecretResourceName = ""validators-private-keys""
+
+var CurrentNamespace = """"
+
+func init() {
+	var err error
+	CurrentNamespace, err = getNamespace()
+	if err != nil {
+		logger.Global.Err(err).Msg(""could not get namespace, using default"")
+		CurrentNamespace = ""default""
+	}
+
+	logger.Global.Info().Str(""namespace"", CurrentNamespace).Msg(""using namespace"")",shared/k8s/debug.go,2023-04-28 03:40:43+00:00,2023-04-28T03:42:37Z,"```suggestion
	logger.Global.Info().Str(""namespace"", CurrentNamespace).Msg(""got new namespace"")
```",,,,,26,RIGHT,26,,line,https://api.github.com/repos/pokt-network/pocket/pulls/699,pokt-network/pocket,37bc0a72df29bb6524cbd6b8274a82ad366e84f8
https://api.github.com/repos/pokt-network/pocket/pulls/699,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1179898814,Olshansk,3f3609683964db22399882fbba4fcc0c3fcb3a09,98d2d6b5c7da1f2e3fc213a5ea087681559910d1,"@@ -2,18 +2,34 @@ package k8s
 
 import (
 	""context""
+	""fmt""
+	""os""
 
+	""github.com/pokt-network/pocket/logger""
 	metav1 ""k8s.io/apimachinery/pkg/apis/meta/v1""
 	""k8s.io/client-go/kubernetes""
 )
 
 //nolint:gosec // G101 Not a credential
-const privateKeysSecretResourceName = ""v1-localnet-validators-private-keys""
+const privateKeysSecretResourceName = ""validators-private-keys""
+
+var CurrentNamespace = """"
+
+func init() {
+	var err error
+	CurrentNamespace, err = getNamespace()
+	if err != nil {
+		logger.Global.Err(err).Msg(""could not get namespace, using default"")",shared/k8s/debug.go,2023-04-28 03:41:08+00:00,2023-04-28T03:42:37Z,"```suggestion
		logger.Global.Err(err).Msg(""could not get namespace, using \""default\"""")
```",,,,,22,RIGHT,22,,line,https://api.github.com/repos/pokt-network/pocket/pulls/699,pokt-network/pocket,37bc0a72df29bb6524cbd6b8274a82ad366e84f8
https://api.github.com/repos/pokt-network/pocket/pulls/699,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1179898995,Olshansk,3f3609683964db22399882fbba4fcc0c3fcb3a09,98d2d6b5c7da1f2e3fc213a5ea087681559910d1,"@@ -24,3 +40,17 @@ func FetchValidatorPrivateKeys(clientset *kubernetes.Clientset) (map[string]stri
 	}
 	return validatorKeysMap, nil
 }
+
+func getNamespace() (string, error) {
+	nsFile := ""/var/run/secrets/kubernetes.io/serviceaccount/namespace""",shared/k8s/debug.go,2023-04-28 03:41:35+00:00,2023-04-28T03:42:38Z,Move into a constant,,,,,45,RIGHT,43,,line,https://api.github.com/repos/pokt-network/pocket/pulls/699,pokt-network/pocket,37bc0a72df29bb6524cbd6b8274a82ad366e84f8
https://api.github.com/repos/pokt-network/pocket/pulls/699,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1179899064,Olshansk,3f3609683964db22399882fbba4fcc0c3fcb3a09,98d2d6b5c7da1f2e3fc213a5ea087681559910d1,"@@ -24,3 +40,17 @@ func FetchValidatorPrivateKeys(clientset *kubernetes.Clientset) (map[string]stri
 	}
 	return validatorKeysMap, nil
 }
+
+func getNamespace() (string, error) {
+	nsFile := ""/var/run/secrets/kubernetes.io/serviceaccount/namespace""
+
+	if _, err := os.Stat(nsFile); err == nil {
+		nsBytes, err := os.ReadFile(nsFile)
+		if err != nil {
+			return """", fmt.Errorf(""could not read namespace file: %v"", err)
+		}
+		return string(nsBytes), nil
+	}
+
+	return ""default"", nil",shared/k8s/debug.go,2023-04-28 03:41:49+00:00,2023-04-28T03:42:38Z,"Consider creating a ""derfault"" constant and using it where appropriate",,,,,55,RIGHT,53,,line,https://api.github.com/repos/pokt-network/pocket/pulls/699,pokt-network/pocket,37bc0a72df29bb6524cbd6b8274a82ad366e84f8
https://api.github.com/repos/pokt-network/pocket/pulls/699,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1179899283,Olshansk,3f3609683964db22399882fbba4fcc0c3fcb3a09,98d2d6b5c7da1f2e3fc213a5ea087681559910d1,"@@ -24,3 +40,17 @@ func FetchValidatorPrivateKeys(clientset *kubernetes.Clientset) (map[string]stri
 	}
 	return validatorKeysMap, nil
 }
+
+func getNamespace() (string, error) {
+	nsFile := ""/var/run/secrets/kubernetes.io/serviceaccount/namespace""
+
+	if _, err := os.Stat(nsFile); err == nil {",shared/k8s/debug.go,2023-04-28 03:42:24+00:00,2023-04-28T03:42:38Z,"NIT: Easier codepath is to do a ""err !=nil; return ""default"" so you're indenting less code.",,,,,47,RIGHT,45,,line,https://api.github.com/repos/pokt-network/pocket/pulls/699,pokt-network/pocket,37bc0a72df29bb6524cbd6b8274a82ad366e84f8
https://api.github.com/repos/pokt-network/pocket/pulls/702,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1178445145,okdas,99030f5ea4170876be9d3e72591bbc4fbdb56c8e,e508506fd303e7f2d2fe7d4a92b08d82ac620fc3,"@@ -10,8 +10,12 @@ import (
 	""github.com/pokt-network/pocket/runtime/defaults""
 )
 
-// rpcURL of the pod that the test harness drives
-var rpcURL string
+var (
+	// rpcURL of the pod that the test harness drives
+	rpcURL string
+	// targetPod is the name of pod used for E2E tests
+	targetPod string = ""deploy/pocket-v1-cli-client""",e2e/tests/validator.go,2023-04-26 22:10:03+00:00,2023-04-26T22:10:04Z,"Do you think it would be better to have `""deploy/dev-cli-client""` here and just rename the deployment on LocalNet? 

https://github.com/pokt-network/pocket/blob/main/build/localnet/manifests/cli-client.yaml#L4",,,,,17,RIGHT,10,,line,https://api.github.com/repos/pokt-network/pocket/pulls/702,pokt-network/pocket,3e24e4c11ebf35ff5e82782ea2a2d851cfa40dcb
https://api.github.com/repos/pokt-network/pocket/pulls/702,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1178494301,okdas,0cafc0208a1c4b4f02120ebb0b4a5b2d56a4397a,e508506fd303e7f2d2fe7d4a92b08d82ac620fc3,"@@ -498,7 +498,7 @@ localnet_up: ## Starts up a k8s LocalNet with all necessary dependencies (tl;dr
 
 .PHONY: localnet_client_debug
 localnet_client_debug: ## Opens a `client debug` cli to interact with blockchain (e.g. change pacemaker mode, reset to genesis, etc). Though the node binary updates automatiacally on every code change (i.e. hot reloads), if client is already open you need to re-run this command to execute freshly compiled binary.
-	kubectl exec -it deploy/pocket-v1-cli-client --container pocket -- client debug
+	kubectl exec -it deploy/dev-cli-client --container pocket -- client debug
 
 .PHONY: localnet_shell
 localnet_shell: ## Opens a shell in the pod that has the `client` cli available. The binary updates automatically whenever the code changes (i.e. hot reloads).",Makefile,2023-04-26 23:45:06+00:00,2023-04-26T23:47:15Z,"There's one left on L#505 (sorry - can't comment under it) 

```
	kubectl exec -it deploy/pocket-v1-cli-client --container pocket -- /bin/bash
```
needs to be changed to
```
	kubectl exec -it deploy/dev-cli-client --container pocket -- /bin/bash
```


",,,,504.0,504,RIGHT,8,8.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/702,pokt-network/pocket,3e24e4c11ebf35ff5e82782ea2a2d851cfa40dcb
https://api.github.com/repos/pokt-network/pocket/pulls/684,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1174184228,Olshansk,33fefdfbfb6dbfb6107ab93e63c3abca7951a012,9fb091614f1874101a5e3f3b35e5eadb67fa32ea,"@@ -23,38 +30,856 @@ func NewQueryCommand() *cobra.Command {
 		Args:    cobra.ExactArgs(0),
 	}
 
-	cmd.AddCommand(queryCommands()...)
+	heightCmds := queryHeightCommands()
+	heightPaginatedCmds := queryHeightPaginatedCommands()
+	heightPaginatedSortedCmds := queryHeightPaginatedSortedCommands()
+	paginatedSortedCmds := queryPaginatedSortedCommands()
+	getCmds := queryCommands()
+
+	// attach --height flag
+	applySubcommandOptions(heightCmds, attachHeightFlagToSubcommands())
+	applySubcommandOptions(heightPaginatedCmds, attachHeightFlagToSubcommands())
+	applySubcommandOptions(heightPaginatedSortedCmds, attachHeightFlagToSubcommands())
+
+	// attach --page, --per_page flags
+	applySubcommandOptions(heightPaginatedCmds, attachPaginationFlagsToSubcommands())
+	applySubcommandOptions(paginatedSortedCmds, attachPaginationFlagsToSubcommands())
+	applySubcommandOptions(heightPaginatedSortedCmds, attachPaginationFlagsToSubcommands())
+
+	// attach --sort flag
+	applySubcommandOptions(paginatedSortedCmds, attachSortFlagToSubcommands())
+	applySubcommandOptions(heightPaginatedSortedCmds, attachSortFlagToSubcommands())
+
+	cmd.AddCommand(heightCmds...)
+	cmd.AddCommand(heightPaginatedCmds...)
+	cmd.AddCommand(heightPaginatedSortedCmds...)
+	cmd.AddCommand(paginatedSortedCmds...)
+	cmd.AddCommand(getCmds...)
 
 	return cmd
 }
 
-func queryCommands() []*cobra.Command {
+func queryHeightCommands() []*cobra.Command {
 	cmds := []*cobra.Command{
 		{
-			Use:     ""AllChainParams"",
-			Short:   ""Get current values of all node parameters"",
-			Long:    ""Queries the node RPC to obtain the current values of all the governance parameters"",
-			Aliases: []string{""allparams""},
+			Use:     ""Account <address> [--height]"",
+			Short:   ""Get the account data of an address at a specified height"",
+			Long:    ""Queries the node RPC to obtain the account data of the speicifed account at the given height"",",app/client/cli/query.go,2023-04-21 21:49:28+00:00,2023-04-21T23:47:01Z,"```suggestion
			Short:   ""Get the account data of an address"",
			Long:    ""Queries the node RPC to obtain the account data of the speicifed account at the given (or latest if unspecified) height"",
```",,66.0,RIGHT,,67,RIGHT,58,,line,https://api.github.com/repos/pokt-network/pocket/pulls/684,pokt-network/pocket,9359cdf1837fa6bf84632f6ccc8dfb05de0f7296
https://api.github.com/repos/pokt-network/pocket/pulls/684,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1174184939,Olshansk,33fefdfbfb6dbfb6107ab93e63c3abca7951a012,9fb091614f1874101a5e3f3b35e5eadb67fa32ea,"@@ -23,38 +30,856 @@ func NewQueryCommand() *cobra.Command {
 		Args:    cobra.ExactArgs(0),
 	}
 
-	cmd.AddCommand(queryCommands()...)
+	heightCmds := queryHeightCommands()
+	heightPaginatedCmds := queryHeightPaginatedCommands()
+	heightPaginatedSortedCmds := queryHeightPaginatedSortedCommands()
+	paginatedSortedCmds := queryPaginatedSortedCommands()
+	getCmds := queryCommands()
+
+	// attach --height flag
+	applySubcommandOptions(heightCmds, attachHeightFlagToSubcommands())
+	applySubcommandOptions(heightPaginatedCmds, attachHeightFlagToSubcommands())
+	applySubcommandOptions(heightPaginatedSortedCmds, attachHeightFlagToSubcommands())
+
+	// attach --page, --per_page flags
+	applySubcommandOptions(heightPaginatedCmds, attachPaginationFlagsToSubcommands())
+	applySubcommandOptions(paginatedSortedCmds, attachPaginationFlagsToSubcommands())
+	applySubcommandOptions(heightPaginatedSortedCmds, attachPaginationFlagsToSubcommands())
+
+	// attach --sort flag
+	applySubcommandOptions(paginatedSortedCmds, attachSortFlagToSubcommands())
+	applySubcommandOptions(heightPaginatedSortedCmds, attachSortFlagToSubcommands())
+
+	cmd.AddCommand(heightCmds...)
+	cmd.AddCommand(heightPaginatedCmds...)
+	cmd.AddCommand(heightPaginatedSortedCmds...)
+	cmd.AddCommand(paginatedSortedCmds...)
+	cmd.AddCommand(getCmds...)
 
 	return cmd
 }
 
-func queryCommands() []*cobra.Command {
+func queryHeightCommands() []*cobra.Command {
 	cmds := []*cobra.Command{
 		{
-			Use:     ""AllChainParams"",
-			Short:   ""Get current values of all node parameters"",
-			Long:    ""Queries the node RPC to obtain the current values of all the governance parameters"",
-			Aliases: []string{""allparams""},
+			Use:     ""Account <address> [--height]"",
+			Short:   ""Get the account data of an address at a specified height"",
+			Long:    ""Queries the node RPC to obtain the account data of the speicifed account at the given height"",
+			Args:    cobra.ExactArgs(1),
+			Aliases: []string{""account""},
 			RunE: func(cmd *cobra.Command, args []string) error {
 				client, err := rpc.NewClientWithResponses(remoteCLIURL)
 				if err != nil {
 					return err
 				}
-				response, err := client.GetV1QueryAllChainParams(cmd.Context())
+
+				body := rpc.QueryAddressHeight{
+					Address: args[0],
+					Height:  height,",app/client/cli/query.go,2023-04-21 21:51:08+00:00,2023-04-21T23:47:01Z,"This would default to 0 if the flag isn't provided, right?

I'm thinking if we should omit putting it in te request if it's not specified, but I think that might be overkill.",,,,78.0,78,RIGHT,70,70.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/684,pokt-network/pocket,9359cdf1837fa6bf84632f6ccc8dfb05de0f7296
https://api.github.com/repos/pokt-network/pocket/pulls/684,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1174188738,Olshansk,33fefdfbfb6dbfb6107ab93e63c3abca7951a012,9fb091614f1874101a5e3f3b35e5eadb67fa32ea,"@@ -249,6 +249,25 @@ func attachChildPwdFlagToSubcommands() []cmdOption {
 	}}
 }
 
+func attachHeightFlagToSubcommands() []cmdOption {
+	return []cmdOption{func(c *cobra.Command) {
+		c.Flags().Int64Var(&height, ""height"", 0, ""block height to query, (default = 0, latest)"")
+	}}
+}
+
+func attachPaginationFlagsToSubcommands() []cmdOption {
+	return []cmdOption{func(c *cobra.Command) {
+		c.Flags().Int64Var(&page, ""page"", 1, ""page number to return of paginated query"")",app/client/cli/utils.go,2023-04-21 22:00:10+00:00,2023-04-21T23:47:01Z,Let's add te defaults in the text,,,,,260,RIGHT,12,,line,https://api.github.com/repos/pokt-network/pocket/pulls/684,pokt-network/pocket,9359cdf1837fa6bf84632f6ccc8dfb05de0f7296
https://api.github.com/repos/pokt-network/pocket/pulls/684,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1174190864,Olshansk,33fefdfbfb6dbfb6107ab93e63c3abca7951a012,9fb091614f1874101a5e3f3b35e5eadb67fa32ea,"@@ -0,0 +1,643 @@
+#!/bin/sh",get-docker.sh,2023-04-21 22:05:24+00:00,2023-04-21T23:47:01Z,Do you think this should be committed to main at root? Maybe just a gitub gist and link to it in te README?,,,,,1,RIGHT,1,,line,https://api.github.com/repos/pokt-network/pocket/pulls/684,pokt-network/pocket,9359cdf1837fa6bf84632f6ccc8dfb05de0f7296
https://api.github.com/repos/pokt-network/pocket/pulls/684,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1174192451,Olshansk,33fefdfbfb6dbfb6107ab93e63c3abca7951a012,9fb091614f1874101a5e3f3b35e5eadb67fa32ea,"@@ -13,6 +13,18 @@ import (
 	""github.com/pokt-network/pocket/runtime/genesis""
 )
 
+// TODO: Implement this function
+func (p *PostgresContext) GetVersionAtHeight(height int64) (string, error) {
+	// This is a placeholder function for the RPC endpoint ""v1/query/upgrade""
+	return """", nil
+}
+
+// TODO: Implement this function
+func (p *PostgresContext) GetSupportedChains(height int64) ([]string, error) {
+	// This is a placeholder function for the RPC endpoint ""v1/query/upgrade""",persistence/gov.go,2023-04-21 22:09:13+00:00,2023-04-21T23:47:01Z,wrong endpoint in commets,,,,,24,RIGHT,12,,line,https://api.github.com/repos/pokt-network/pocket/pulls/684,pokt-network/pocket,9359cdf1837fa6bf84632f6ccc8dfb05de0f7296
https://api.github.com/repos/pokt-network/pocket/pulls/684,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1174208660,Olshansk,33fefdfbfb6dbfb6107ab93e63c3abca7951a012,9fb091614f1874101a5e3f3b35e5eadb67fa32ea,"@@ -8,17 +8,33 @@ import (
 
 	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
 	""github.com/pokt-network/pocket/shared/crypto""
-	""github.com/pokt-network/pocket/utility/types""
 )
 
+// TODO: Implement this
+func (u *utilityModule) GetSession(appAddr string, sessionHeight int64, relayChain, geoZone string) (*coreTypes.Session, error) {
+	return nil, nil",utility/session.go,2023-04-21 22:44:50+00:00,2023-04-21T23:47:01Z,"Just FYI, I'm going to link into this VERY soon: https://github.com/pokt-network/pocket/pull/683",,,,,15,RIGHT,9,,line,https://api.github.com/repos/pokt-network/pocket/pulls/684,pokt-network/pocket,9359cdf1837fa6bf84632f6ccc8dfb05de0f7296
https://api.github.com/repos/pokt-network/pocket/pulls/684,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1174210944,Olshansk,33fefdfbfb6dbfb6107ab93e63c3abca7951a012,9fb091614f1874101a5e3f3b35e5eadb67fa32ea,"@@ -0,0 +1,643 @@
+#!/bin/sh
+set -e",test-docker.sh,2023-04-21 22:47:52+00:00,2023-04-21T23:47:01Z,"Definitely shouldn't be at the root level. If you really want to commit it to main, let's put it under `build/scripts`",,,,,2,RIGHT,2,,line,https://api.github.com/repos/pokt-network/pocket/pulls/684,pokt-network/pocket,9359cdf1837fa6bf84632f6ccc8dfb05de0f7296
https://api.github.com/repos/pokt-network/pocket/pulls/684,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1174211882,Olshansk,33fefdfbfb6dbfb6107ab93e63c3abca7951a012,9fb091614f1874101a5e3f3b35e5eadb67fa32ea,"@@ -0,0 +1,17 @@
+syntax = ""proto3"";
+
+package core;
+
+option go_package = ""github.com/pokt-network/pocket/shared/core/types"";
+
+import ""actor.proto"";
+
+message Session {",shared/core/types/proto/session.proto,2023-04-21 22:50:25+00:00,2023-04-21T23:47:01Z,"```suggestion
// TODO(#683): Replace the session structure with the data type updated in #683
message Session {
```",,,,,9,RIGHT,9,,line,https://api.github.com/repos/pokt-network/pocket/pulls/684,pokt-network/pocket,9359cdf1837fa6bf84632f6ccc8dfb05de0f7296
https://api.github.com/repos/pokt-network/pocket/pulls/684,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1174212150,Olshansk,33fefdfbfb6dbfb6107ab93e63c3abca7951a012,9fb091614f1874101a5e3f3b35e5eadb67fa32ea,"@@ -0,0 +1,43 @@
+syntax = ""proto3"";
+
+package core;
+
+option go_package = ""github.com/pokt-network/pocket/shared/core/types"";
+
+message Relay {",shared/core/types/proto/relay.proto,2023-04-21 22:51:24+00:00,2023-04-21T23:47:01Z,Can you add a `TECHDEBT: These structures were copied as placeholders from v0 and need to be updated to reflect changes in v1; <insert_link_her>`,,,,8.0,7,RIGHT,7,8.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/684,pokt-network/pocket,9359cdf1837fa6bf84632f6ccc8dfb05de0f7296
https://api.github.com/repos/pokt-network/pocket/pulls/684,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1174212285,Olshansk,33fefdfbfb6dbfb6107ab93e63c3abca7951a012,9fb091614f1874101a5e3f3b35e5eadb67fa32ea,"@@ -98,6 +98,32 @@ func (g *GenericFIFOSet[TIdx, TData]) Remove(item TData) {
 	}
 }
 
+func (g *GenericFIFOSet[TIdx, TData]) GetAll() (v []TData) {
+	g.m.Lock()
+	defer g.m.Unlock()
+
+	values := make([]TData, 0)
+	for e := g.queue.Front(); e != nil; e = e.Next() {
+		values = append(values, e.Value.(TData))
+	}
+
+	return values
+}
+
+func (g *GenericFIFOSet[TIdx, TData]) Get(index TIdx) (v TData) {
+	g.m.Lock()
+	defer g.m.Unlock()
+
+	for e := g.queue.Front(); e != nil; e = e.Next() {
+		fmt.Println(g.indexerFn(e.Value.(TData)))",shared/mempool/generic_fifo_set.go,2023-04-21 22:51:54+00:00,2023-04-21T23:47:01Z,Remove?,,,,,118,RIGHT,21,,line,https://api.github.com/repos/pokt-network/pocket/pulls/684,pokt-network/pocket,9359cdf1837fa6bf84632f6ccc8dfb05de0f7296
https://api.github.com/repos/pokt-network/pocket/pulls/684,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1174214651,Olshansk,33fefdfbfb6dbfb6107ab93e63c3abca7951a012,9fb091614f1874101a5e3f3b35e5eadb67fa32ea,"@@ -26,6 +26,15 @@ func init() {
 	}
 }
 
+func PoolAddressToFriendlyName(address string) string {",shared/core/types/pools.go,2023-04-21 23:00:05+00:00,2023-04-21T23:47:01Z,"Rather than having a loop and checking this every time, I suggest adding a map (similar to the approach above) that only gets compiled once.",,,,40.0,29,RIGHT,4,24.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/684,pokt-network/pocket,9359cdf1837fa6bf84632f6ccc8dfb05de0f7296
https://api.github.com/repos/pokt-network/pocket/pulls/684,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1174214813,Olshansk,33fefdfbfb6dbfb6107ab93e63c3abca7951a012,9fb091614f1874101a5e3f3b35e5eadb67fa32ea,"@@ -0,0 +1,19 @@
+syntax = ""proto3"";
+
+package core;
+
+option go_package = ""github.com/pokt-network/pocket/shared/core/types"";
+
+import ""relay.proto"";
+
+message Challenge {",shared/core/types/proto/challenge.proto,2023-04-21 23:00:41+00:00,2023-04-21T23:47:01Z,Can you add a `TECHDEBT: These structures were copied as placeholders from v0 and need to be updated to reflect changes in v1; <insert_link_to_v0_ref_here>`,,,,11.0,9,RIGHT,9,11.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/684,pokt-network/pocket,9359cdf1837fa6bf84632f6ccc8dfb05de0f7296
https://api.github.com/repos/pokt-network/pocket/pulls/684,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1174217139,Olshansk,33fefdfbfb6dbfb6107ab93e63c3abca7951a012,9fb091614f1874101a5e3f3b35e5eadb67fa32ea,"@@ -80,13 +83,21 @@ func (p *PostgresContext) prepareBlock(proposerAddr, quorumCert []byte) (*coreTy
 		txs[i] = txResult.GetTx()
 	}
 
+	// Retrieve the network id from the config
+	networkId := viper.GetString(""network_id"")
+
+	// Get the current timestamp
+	timestamp := timestamppb.Now()",persistence/block.go,2023-04-21 23:08:25+00:00,2023-04-21T23:47:01Z,"```suggestion
	// TECHDEBT: This will lead to different timestamp in each node's block store because `prepareBlock` is called locally. Needs to be revisisted and decided on a proper implementation.
	timestamp := timestamppb.Now()
```",,,,87.0,90,RIGHT,25,22.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/684,pokt-network/pocket,9359cdf1837fa6bf84632f6ccc8dfb05de0f7296
https://api.github.com/repos/pokt-network/pocket/pulls/684,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1174217232,Olshansk,33fefdfbfb6dbfb6107ab93e63c3abca7951a012,9fb091614f1874101a5e3f3b35e5eadb67fa32ea,"@@ -80,13 +83,21 @@ func (p *PostgresContext) prepareBlock(proposerAddr, quorumCert []byte) (*coreTy
 		txs[i] = txResult.GetTx()
 	}
 
+	// Retrieve the network id from the config
+	networkId := viper.GetString(""network_id"")",persistence/block.go,2023-04-21 23:08:42+00:00,2023-04-21T23:47:01Z,viper should never be exposed outside of `runtime_configs`. You need to propagate it via `Config` and store it locally in `Create`,,,,,87,RIGHT,22,,line,https://api.github.com/repos/pokt-network/pocket/pulls/684,pokt-network/pocket,9359cdf1837fa6bf84632f6ccc8dfb05de0f7296
https://api.github.com/repos/pokt-network/pocket/pulls/684,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1174218702,Olshansk,33fefdfbfb6dbfb6107ab93e63c3abca7951a012,9fb091614f1874101a5e3f3b35e5eadb67fa32ea,"@@ -43,6 +47,143 @@ func (s *rpcServer) PostV1ClientBroadcastTxSync(ctx echo.Context) error {
 	return nil
 }
 
+// DISCUSSION: This may need to be changed when the GetSession function is actually implemented",rpc/handlers.go,2023-04-21 23:13:26+00:00,2023-04-21T23:47:01Z,"We'll literally integrate this with my work next week, no worries",,,,,50,RIGHT,24,,line,https://api.github.com/repos/pokt-network/pocket/pulls/684,pokt-network/pocket,9359cdf1837fa6bf84632f6ccc8dfb05de0f7296
https://api.github.com/repos/pokt-network/pocket/pulls/684,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1174219013,Olshansk,33fefdfbfb6dbfb6107ab93e63c3abca7951a012,9fb091614f1874101a5e3f3b35e5eadb67fa32ea,"@@ -43,6 +47,143 @@ func (s *rpcServer) PostV1ClientBroadcastTxSync(ctx echo.Context) error {
 	return nil
 }
 
+// DISCUSSION: This may need to be changed when the GetSession function is actually implemented
+func (s *rpcServer) PostV1ClientDispatch(ctx echo.Context) error {
+	var body DispatchRequest
+	if err := ctx.Bind(&body); err != nil {
+		return ctx.String(http.StatusBadRequest, ""bad request"")
+	}
+
+	session, err := s.GetBus().GetUtilityModule().GetSession(body.AppAddress, body.SessionHeight, body.Chain, body.Geozone)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+
+	application := session.GetApplication()
+	rpcApp := protocolActorToRPCProtocolActor(application)
+
+	rpcServicers := make([]ProtocolActor, 0)
+	for _, serv := range session.GetServicers() {",rpc/handlers.go,2023-04-21 23:14:37+00:00,2023-04-21T23:47:02Z,"Let's use `servicer` instead of `serv`. I think` serv` is way to close to `srv` in CS land.

Ditto elsewhere",,,,,66,RIGHT,40,,line,https://api.github.com/repos/pokt-network/pocket/pulls/684,pokt-network/pocket,9359cdf1837fa6bf84632f6ccc8dfb05de0f7296
https://api.github.com/repos/pokt-network/pocket/pulls/684,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1174221070,Olshansk,33fefdfbfb6dbfb6107ab93e63c3abca7951a012,9fb091614f1874101a5e3f3b35e5eadb67fa32ea,"@@ -43,6 +47,143 @@ func (s *rpcServer) PostV1ClientBroadcastTxSync(ctx echo.Context) error {
 	return nil
 }
 
+// DISCUSSION: This may need to be changed when the GetSession function is actually implemented
+func (s *rpcServer) PostV1ClientDispatch(ctx echo.Context) error {
+	var body DispatchRequest
+	if err := ctx.Bind(&body); err != nil {
+		return ctx.String(http.StatusBadRequest, ""bad request"")
+	}
+
+	session, err := s.GetBus().GetUtilityModule().GetSession(body.AppAddress, body.SessionHeight, body.Chain, body.Geozone)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+
+	application := session.GetApplication()
+	rpcApp := protocolActorToRPCProtocolActor(application)
+
+	rpcServicers := make([]ProtocolActor, 0)
+	for _, serv := range session.GetServicers() {
+		actor := protocolActorToRPCProtocolActor(serv)
+		rpcServicers = append(rpcServicers, actor)
+	}
+
+	rpcFishermen := make([]ProtocolActor, 0)
+	for _, fm := range session.GetFishermen() {",rpc/handlers.go,2023-04-21 23:22:03+00:00,2023-04-21T23:47:02Z,"s/fm/fisher

Ditto elsewhere",,,,,72,RIGHT,46,,line,https://api.github.com/repos/pokt-network/pocket/pulls/684,pokt-network/pocket,9359cdf1837fa6bf84632f6ccc8dfb05de0f7296
https://api.github.com/repos/pokt-network/pocket/pulls/684,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1174221326,Olshansk,33fefdfbfb6dbfb6107ab93e63c3abca7951a012,9fb091614f1874101a5e3f3b35e5eadb67fa32ea,"@@ -43,6 +47,143 @@ func (s *rpcServer) PostV1ClientBroadcastTxSync(ctx echo.Context) error {
 	return nil
 }
 
+// DISCUSSION: This may need to be changed when the GetSession function is actually implemented
+func (s *rpcServer) PostV1ClientDispatch(ctx echo.Context) error {
+	var body DispatchRequest
+	if err := ctx.Bind(&body); err != nil {
+		return ctx.String(http.StatusBadRequest, ""bad request"")
+	}
+
+	session, err := s.GetBus().GetUtilityModule().GetSession(body.AppAddress, body.SessionHeight, body.Chain, body.Geozone)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+
+	application := session.GetApplication()
+	rpcApp := protocolActorToRPCProtocolActor(application)
+
+	rpcServicers := make([]ProtocolActor, 0)
+	for _, serv := range session.GetServicers() {
+		actor := protocolActorToRPCProtocolActor(serv)
+		rpcServicers = append(rpcServicers, actor)
+	}
+
+	rpcFishermen := make([]ProtocolActor, 0)
+	for _, fm := range session.GetFishermen() {
+		actor := protocolActorToRPCProtocolActor(fm)
+		rpcFishermen = append(rpcFishermen, actor)
+	}
+
+	return ctx.JSON(http.StatusOK, Session{
+		SessionId:   session.GetId(),
+		Height:      session.GetHeight(),
+		Chain:       string(session.GetRelayChain()),
+		Geozone:     string(session.GetGeoZone()),
+		Application: rpcApp,
+		Servicers:   rpcServicers,
+		Fishermen:   rpcFishermen,
+	})
+}
+
+// DISCUSSION: This may need to be changed when the SendRelay function is actually implemented
+func (s *rpcServer) PostV1ClientRelay(ctx echo.Context) error {
+	var body RelayRequest
+	if err := ctx.Bind(&body); err != nil {
+		return ctx.String(http.StatusBadRequest, ""bad request"")
+	}
+
+	// Parse body into the protobuf messages
+	chain := &coreTypes.Identifiable{
+		Id:   body.Meta.Chain.Id,
+		Name: body.Meta.Chain.Name,
+	}
+	geozone := &coreTypes.Identifiable{
+		Id:   body.Meta.Geozone.Id,
+		Name: body.Meta.Geozone.Name,
+	}
+	aat := &coreTypes.AAT{
+		Version:              body.Meta.Token.Version,
+		ApplicationPublicKey: body.Meta.Token.AppPubKey,
+		ClientPublicKey:      body.Meta.Token.ClientPubKey,
+		ApplicationSignature: body.Meta.Token.AppSignature,
+	}
+	relayMeta := &coreTypes.RelayMeta{
+		BlockHeight:       body.Meta.BlockHeight,
+		ServicerPublicKey: body.Meta.ServicerPubKey,
+		RelayChain:        chain,
+		GeoZone:           geozone,
+		Token:             aat,
+		Signature:         body.Meta.Signature,
+	}
+
+	payload := &coreTypes.RelayPayload{
+		Data:     body.Payload.Data,
+		Method:   body.Payload.Method,
+		HttpPath: body.Payload.Path,
+	}
+
+	headers := make(map[string]string)
+	for _, header := range body.Payload.Headers {
+		headers[header.Name] = header.Value
+	}
+	payload.Headers = headers
+
+	relayRequest := &coreTypes.Relay{
+		Payload: payload,
+		Meta:    relayMeta,
+	}
+
+	relayResponse, err := s.GetBus().GetUtilityModule().SendRelay(relayRequest)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+
+	return ctx.JSON(http.StatusOK, RelayResponse{
+		Payload:           relayResponse.Payload,
+		ServicerSignature: relayResponse.ServicerSignature,
+	})
+}
+
+// DISCUSSION: This may need to be changed when the SendRelay function is actually implemented",rpc/handlers.go,2023-04-21 23:22:47+00:00,2023-04-21T23:47:02Z,"```suggestion
// DISCUSSION: This may need to be changed when the HandleChallenge function is actually implemented
```",,,,,147,RIGHT,121,,line,https://api.github.com/repos/pokt-network/pocket/pulls/684,pokt-network/pocket,9359cdf1837fa6bf84632f6ccc8dfb05de0f7296
https://api.github.com/repos/pokt-network/pocket/pulls/684,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1174221617,Olshansk,33fefdfbfb6dbfb6107ab93e63c3abca7951a012,9fb091614f1874101a5e3f3b35e5eadb67fa32ea,"@@ -52,9 +193,138 @@ func (s *rpcServer) GetV1ConsensusState(ctx echo.Context) error {
 	})
 }
 
+// Queries
+
+func (s *rpcServer) PostV1QueryAccount(ctx echo.Context) error {
+	var body QueryAddressHeight
+	if err := ctx.Bind(&body); err != nil {
+		return ctx.String(http.StatusBadRequest, ""bad request"")
+	}
+
+	// Get latest stored block height
+	currentHeight := int64(s.GetBus().GetConsensusModule().CurrentHeight())
+	if currentHeight > 0 {
+		currentHeight -= 1
+	}
+	height := body.Height
+	if height == 0 {
+		height = currentHeight
+	}
+	readCtx, err := s.GetBus().GetPersistenceModule().NewReadContext(currentHeight)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}",rpc/handlers.go,2023-04-21 23:23:52+00:00,2023-04-21T23:47:02Z,"```suggestion
	}
	defer readCtx.Release()
```

Ditto everywhere else",,,,,216,RIGHT,188,,line,https://api.github.com/repos/pokt-network/pocket/pulls/684,pokt-network/pocket,9359cdf1837fa6bf84632f6ccc8dfb05de0f7296
https://api.github.com/repos/pokt-network/pocket/pulls/684,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1174221889,Olshansk,33fefdfbfb6dbfb6107ab93e63c3abca7951a012,9fb091614f1874101a5e3f3b35e5eadb67fa32ea,"@@ -52,9 +193,138 @@ func (s *rpcServer) GetV1ConsensusState(ctx echo.Context) error {
 	})
 }
 
+// Queries
+
+func (s *rpcServer) PostV1QueryAccount(ctx echo.Context) error {
+	var body QueryAddressHeight
+	if err := ctx.Bind(&body); err != nil {
+		return ctx.String(http.StatusBadRequest, ""bad request"")
+	}
+
+	// Get latest stored block height
+	currentHeight := int64(s.GetBus().GetConsensusModule().CurrentHeight())
+	if currentHeight > 0 {
+		currentHeight -= 1
+	}
+	height := body.Height
+	if height == 0 {
+		height = currentHeight
+	}
+	readCtx, err := s.GetBus().GetPersistenceModule().NewReadContext(currentHeight)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+	accBz, err := hex.DecodeString(body.Address)
+	if err != nil {
+		return ctx.String(http.StatusBadRequest, err.Error())
+	}
+	amount, err := readCtx.GetAccountAmount(accBz, height)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+
+	return ctx.JSON(http.StatusOK, Account{
+		Address: body.Address,
+		Coins:   []Coin{{Amount: amount, Denom: ""upokt""}},
+	})
+}
+
+func (s *rpcServer) PostV1QueryAccounts(ctx echo.Context) error {
+	var body QueryHeightPaginated
+	if err := ctx.Bind(&body); err != nil {
+		return ctx.String(http.StatusBadRequest, ""bad request"")
+	}
+
+	// Get latest stored block height
+	currentHeight := int64(s.GetBus().GetConsensusModule().CurrentHeight())
+	if currentHeight > 0 {
+		currentHeight -= 1
+	}
+	height := body.Height
+	if height == 0 {
+		height = currentHeight
+	}
+	readCtx, err := s.GetBus().GetPersistenceModule().NewReadContext(currentHeight)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+	allAccounts, err := readCtx.GetAllAccounts(height)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+
+	start, end, totalPages, err := getPageIndexes(len(allAccounts), int(body.Page), int(body.PerPage))
+	if err != nil && !errors.Is(err, errNoItems) {
+		return ctx.String(http.StatusBadRequest, err.Error())
+	}
+	if totalPages == 0 || errors.Is(err, errNoItems) {
+		return ctx.JSON(http.StatusOK, QueryAccountsResponse{})
+	}
+
+	accounts := make([]Account, 0)
+	for _, account := range allAccounts[start : end+1] {
+		accounts = append(accounts, Account{
+			Address: account.Address,
+			Coins:   []Coin{{Amount: account.Amount, Denom: ""upokt""}},
+		})
+	}
+
+	return ctx.JSON(http.StatusOK, QueryAccountsResponse{
+		Result:     accounts,
+		Page:       body.Page,
+		TotalPages: int64(totalPages),
+	})
+}
+
+func (s *rpcServer) PostV1QueryAccounttxs(ctx echo.Context) error {",rpc/handlers.go,2023-04-21 23:24:41+00:00,2023-04-21T23:47:02Z,"```suggestion
func (s *rpcServer) PostV1QueryAccountTxs(ctx echo.Context) error {
```",,,,,279,RIGHT,251,,line,https://api.github.com/repos/pokt-network/pocket/pulls/684,pokt-network/pocket,9359cdf1837fa6bf84632f6ccc8dfb05de0f7296
https://api.github.com/repos/pokt-network/pocket/pulls/684,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1174222233,Olshansk,33fefdfbfb6dbfb6107ab93e63c3abca7951a012,9fb091614f1874101a5e3f3b35e5eadb67fa32ea,"@@ -0,0 +1,458 @@
+package rpc
+
+import (
+	""encoding/base64""
+	""encoding/hex""
+	""fmt""
+	""math""
+	""regexp""
+	""strings""
+
+	conTypes ""github.com/pokt-network/pocket/consensus/types""
+	""github.com/pokt-network/pocket/shared/codec""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/modules""
+	""github.com/pokt-network/pocket/utility""
+	utilTypes ""github.com/pokt-network/pocket/utility/types""
+)
+
+var (
+	paramValueRegex *regexp.Regexp
+	errNoItems      = fmt.Errorf(""no items found"")
+)
+
+func init() {
+	paramValueRegex = regexp.MustCompile(`value:""(.+)""`)
+}
+
+// Broadcast to the entire validator set
+func (s *rpcServer) broadcastMessage(msgBz []byte) error {
+	utilityMsg, err := utility.PrepareTxGossipMessage(msgBz)
+	if err != nil {
+		s.logger.Error().Err(err).Msg(""Failed to prepare transaction gossip message"")
+		return err
+	}
+
+	if err := s.GetBus().GetP2PModule().Broadcast(utilityMsg); err != nil {
+		s.logger.Error().Err(err).Msg(""Failed to broadcast utility message"")
+		return err
+	}
+
+	return nil
+}
+
+func checkSort(sort string) string {
+	switch strings.ToLower(sort) {
+	case ""asc"":
+		return ""asc""
+	case ""desc"":
+		return ""desc""
+	default:
+		return ""desc""
+	}",rpc/utils.go,2023-04-21 23:25:58+00:00,2023-04-21T23:47:02Z,"```suggestion
	if strings.ToLower(sort) == ""asc"" {
		return ""asc""
	}
	return ""desc""
```",,45.0,RIGHT,,52,RIGHT,52,,line,https://api.github.com/repos/pokt-network/pocket/pulls/684,pokt-network/pocket,9359cdf1837fa6bf84632f6ccc8dfb05de0f7296
https://api.github.com/repos/pokt-network/pocket/pulls/684,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1174222632,Olshansk,33fefdfbfb6dbfb6107ab93e63c3abca7951a012,9fb091614f1874101a5e3f3b35e5eadb67fa32ea,"@@ -0,0 +1,458 @@
+package rpc
+
+import (
+	""encoding/base64""
+	""encoding/hex""
+	""fmt""
+	""math""
+	""regexp""
+	""strings""
+
+	conTypes ""github.com/pokt-network/pocket/consensus/types""
+	""github.com/pokt-network/pocket/shared/codec""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/modules""
+	""github.com/pokt-network/pocket/utility""
+	utilTypes ""github.com/pokt-network/pocket/utility/types""
+)
+
+var (
+	paramValueRegex *regexp.Regexp
+	errNoItems      = fmt.Errorf(""no items found"")
+)
+
+func init() {
+	paramValueRegex = regexp.MustCompile(`value:""(.+)""`)
+}
+
+// Broadcast to the entire validator set
+func (s *rpcServer) broadcastMessage(msgBz []byte) error {
+	utilityMsg, err := utility.PrepareTxGossipMessage(msgBz)
+	if err != nil {
+		s.logger.Error().Err(err).Msg(""Failed to prepare transaction gossip message"")
+		return err
+	}
+
+	if err := s.GetBus().GetP2PModule().Broadcast(utilityMsg); err != nil {
+		s.logger.Error().Err(err).Msg(""Failed to broadcast utility message"")
+		return err
+	}
+
+	return nil
+}
+
+func checkSort(sort string) string {
+	switch strings.ToLower(sort) {
+	case ""asc"":
+		return ""asc""
+	case ""desc"":
+		return ""desc""
+	default:
+		return ""desc""
+	}
+}
+
+func getPageIndexes(totalItems, page, per_page int) (startIdx, endIdx, totalPages int, err error) {
+	if totalItems == 0 {
+		err = errNoItems
+		return
+	}
+	if per_page > 1000 {",rpc/utils.go,2023-04-21 23:27:26+00:00,2023-04-21T23:47:02Z,Move `1000` into a constant. Make sure to update comment here too,,,,,60,RIGHT,60,,line,https://api.github.com/repos/pokt-network/pocket/pulls/684,pokt-network/pocket,9359cdf1837fa6bf84632f6ccc8dfb05de0f7296
https://api.github.com/repos/pokt-network/pocket/pulls/684,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1174223078,Olshansk,33fefdfbfb6dbfb6107ab93e63c3abca7951a012,9fb091614f1874101a5e3f3b35e5eadb67fa32ea,"@@ -0,0 +1,458 @@
+package rpc
+
+import (
+	""encoding/base64""
+	""encoding/hex""
+	""fmt""
+	""math""
+	""regexp""
+	""strings""
+
+	conTypes ""github.com/pokt-network/pocket/consensus/types""
+	""github.com/pokt-network/pocket/shared/codec""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/modules""
+	""github.com/pokt-network/pocket/utility""
+	utilTypes ""github.com/pokt-network/pocket/utility/types""
+)
+
+var (
+	paramValueRegex *regexp.Regexp
+	errNoItems      = fmt.Errorf(""no items found"")
+)
+
+func init() {
+	paramValueRegex = regexp.MustCompile(`value:""(.+)""`)
+}
+
+// Broadcast to the entire validator set
+func (s *rpcServer) broadcastMessage(msgBz []byte) error {
+	utilityMsg, err := utility.PrepareTxGossipMessage(msgBz)
+	if err != nil {
+		s.logger.Error().Err(err).Msg(""Failed to prepare transaction gossip message"")
+		return err
+	}
+
+	if err := s.GetBus().GetP2PModule().Broadcast(utilityMsg); err != nil {
+		s.logger.Error().Err(err).Msg(""Failed to broadcast utility message"")
+		return err
+	}
+
+	return nil
+}
+
+func checkSort(sort string) string {
+	switch strings.ToLower(sort) {
+	case ""asc"":
+		return ""asc""
+	case ""desc"":
+		return ""desc""
+	default:
+		return ""desc""
+	}
+}
+
+func getPageIndexes(totalItems, page, per_page int) (startIdx, endIdx, totalPages int, err error) {
+	if totalItems == 0 {
+		err = errNoItems
+		return
+	}
+	if per_page > 1000 {
+		err = fmt.Errorf(""per_page has a max value of 1000"")
+		return
+	}
+	if page == 0 || per_page == 0 {
+		err = fmt.Errorf(""page and per_page must both be greater than 0"")
+		return
+	}
+
+	totalPages = int(math.Ceil(float64(totalItems) / float64(per_page)))
+	startIdx = (page - 1) * per_page
+	if startIdx > totalItems-1 {
+		err = fmt.Errorf(""starting page too high: got %d, total pages: %d"", page, totalPages)
+		return
+	}
+	endIdx = (page * per_page) - 1
+	if endIdx >= totalItems {
+		endIdx = totalItems - 1 //  Last Index
+	}
+
+	return startIdx, endIdx, totalPages, nil
+}
+
+// protocolActorToRPCProtocolActor converts the coreTypes.Actor to an RPC ProtocolActor
+func protocolActorToRPCProtocolActor(actor *coreTypes.Actor) ProtocolActor {
+	return ProtocolActor{
+		Address:         actor.Address,
+		ActorType:       protocolActorToRPCActorTypeEnum(actor.ActorType),
+		PublicKey:       actor.PublicKey,
+		Chains:          actor.Chains,
+		ServiceUrl:      actor.ServiceUrl,
+		StakedAmount:    actor.StakedAmount,
+		PausedHeight:    actor.PausedHeight,
+		UnstakingHeight: actor.UnstakingHeight,
+		OutputAddr:      actor.Output,
+	}
+}
+
+// txResultToRPCTransaction converts the txResult protobuf into the RPC Transaction type
+func (s *rpcServer) txResultToRPCTransaction(txResult *coreTypes.TxResult) (*Transaction, error) {
+	hash := coreTypes.TxHash(txResult.GetTx())
+	txStr := base64.StdEncoding.EncodeToString(txResult.GetTx())
+	stdTx, err := s.transactionBytesToRPCStdTx(txResult.GetTx(), txResult.GetMessageType())
+	if err != nil {
+		return nil, err
+	}
+	return &Transaction{
+		Hash:   hash,
+		Height: txResult.GetHeight(),
+		Index:  txResult.GetIndex(),
+		TxResult: TxResult{
+			Tx:            txStr,
+			Height:        txResult.GetHeight(),
+			Index:         txResult.GetIndex(),
+			ResultCode:    txResult.GetResultCode(),
+			SignerAddr:    txResult.GetSignerAddr(),
+			RecipientAddr: txResult.GetRecipientAddr(),
+			MessageType:   txResult.GetMessageType(),
+		},
+		StdTx: *stdTx,
+	}, nil
+}
+
+// transactionBytesToRPCStdTx generates a StdTx from a serialised byte slice of a Transaction protobuf and message type
+func (s *rpcServer) transactionBytesToRPCStdTx(txBz []byte, messageType string) (*StdTx, error) {
+	tx, err := coreTypes.TxFromBytes(txBz)
+	if err != nil {
+		return nil, err
+	}
+	sig := tx.GetSignature()
+	txMsg, err := tx.GetMessage()
+	if err != nil {
+		return nil, err
+	}
+	anypb, err := codec.GetCodec().ToAny(txMsg)
+	if err != nil {
+		return nil, err
+	}
+	stdTx := StdTx{
+		Nonce: tx.GetNonce(),
+		Signature: Signature{
+			PublicKey: hex.EncodeToString(sig.GetPublicKey()),
+			Signature: hex.EncodeToString(sig.GetSignature()),
+		},
+	}
+	switch messageType {
+	case ""MessageSend"":
+		m := new(utilTypes.MessageSend)
+		if err := anypb.UnmarshalTo(m); err != nil {
+			return nil, err
+		}
+		fee, err := s.calculateMessageFeeForActor(m.GetActorType(), messageType)
+		if err != nil {
+			return nil, err
+		}
+		stdTx.Fee = Fee{
+			Amount: fee,
+			Denom:  ""upokt"",
+		}
+		stdTx.Message = MessageSend{
+			FromAddr: hex.EncodeToString(m.GetFromAddress()),
+			ToAddr:   hex.EncodeToString(m.GetToAddress()),
+			Amount:   m.Amount,
+			Denom:    ""upokt"",
+		}
+	case ""MessageStake"":
+		m := new(utilTypes.MessageStake)
+		if err := anypb.UnmarshalTo(m); err != nil {
+			return nil, err
+		}
+		fee, err := s.calculateMessageFeeForActor(m.GetActorType(), messageType)
+		if err != nil {
+			return nil, err
+		}
+		stdTx.Fee = Fee{
+			Amount: fee,
+			Denom:  ""upokt"",
+		}
+		stdTx.Message = MessageStake{
+			ActorType:     protocolActorToRPCActorTypeEnum(m.GetActorType()),
+			PublicKey:     hex.EncodeToString(m.GetPublicKey()),
+			Chains:        m.GetChains(),
+			ServiceUrl:    m.GetServiceUrl(),
+			OutputAddress: hex.EncodeToString(m.GetOutputAddress()),
+			Signer:        hex.EncodeToString(m.GetSigner()),
+			Amount:        m.GetAmount(),
+			Denom:         ""upokt"",
+		}
+	case ""MessageEditStake"":
+		m := new(utilTypes.MessageEditStake)
+		if err := anypb.UnmarshalTo(m); err != nil {
+			return nil, err
+		}
+		fee, err := s.calculateMessageFeeForActor(m.GetActorType(), messageType)
+		if err != nil {
+			return nil, err
+		}
+		stdTx.Fee = Fee{
+			Amount: fee,
+			Denom:  ""upokt"",
+		}
+		stdTx.Message = MessageEditStake{
+			ActorType:  protocolActorToRPCActorTypeEnum(m.GetActorType()),
+			Chains:     m.GetChains(),
+			ServiceUrl: m.GetServiceUrl(),
+			Address:    hex.EncodeToString(m.GetAddress()),
+			Signer:     hex.EncodeToString(m.GetSigner()),
+			Amount:     m.GetAmount(),
+			Denom:      ""upokt"",
+		}
+	case ""MessageUnstake"":
+		m := new(utilTypes.MessageUnstake)
+		if err := anypb.UnmarshalTo(m); err != nil {
+			return nil, err
+		}
+		fee, err := s.calculateMessageFeeForActor(m.GetActorType(), messageType)
+		if err != nil {
+			return nil, err
+		}
+		stdTx.Fee = Fee{
+			Amount: fee,
+			Denom:  ""upokt"",
+		}
+		stdTx.Message = MessageUnstake{
+			ActorType: protocolActorToRPCActorTypeEnum(m.GetActorType()),
+			Address:   hex.EncodeToString(m.GetAddress()),
+			Signer:    hex.EncodeToString(m.GetSigner()),
+		}
+	case ""MessageUnpause"":
+		m := new(utilTypes.MessageUnpause)
+		if err := anypb.UnmarshalTo(m); err != nil {
+			return nil, err
+		}
+		fee, err := s.calculateMessageFeeForActor(m.GetActorType(), messageType)
+		if err != nil {
+			return nil, err
+		}
+		stdTx.Fee = Fee{
+			Amount: fee,
+			Denom:  ""upokt"",
+		}
+		stdTx.Message = MessageUnpause{
+			ActorType: protocolActorToRPCActorTypeEnum(m.GetActorType()),
+			Address:   hex.EncodeToString(m.GetAddress()),
+			Signer:    hex.EncodeToString(m.GetSigner()),
+		}
+	case ""MessageChangeParameter"":
+		m := new(utilTypes.MessageChangeParameter)
+		if err := anypb.UnmarshalTo(m); err != nil {
+			return nil, err
+		}
+		fee, err := s.calculateMessageFeeForActor(m.GetActorType(), messageType)
+		if err != nil {
+			return nil, err
+		}
+		stdTx.Fee = Fee{
+			Amount: fee,
+			Denom:  ""upokt"",
+		}
+		values := paramValueRegex.FindStringSubmatch(m.GetParameterValue().String())
+		if len(values) < 2 {
+			return nil, fmt.Errorf(""unable to extract parameter value: %s"", m.GetParameterValue().String())
+		}
+		stdTx.Message = MessageChangeParameter{
+			Signer: hex.EncodeToString(m.GetSigner()),
+			Owner:  hex.EncodeToString(m.GetOwner()),
+			Parameter: Parameter{
+				ParameterValue: values[1],
+			},
+		}
+	default:
+		return nil, fmt.Errorf(""unknown message type: %s"", messageType)
+	}
+
+	return &stdTx, nil
+}
+
+// calculateMessageFeeForActor calculates the fee for a transaction given the actor type and message type
+func (s *rpcServer) calculateMessageFeeForActor(actorType coreTypes.ActorType, messageType string) (string, error) {
+	height := int64(s.GetBus().GetConsensusModule().CurrentHeight())
+	readCtx, err := s.GetBus().GetPersistenceModule().NewReadContext(height)
+	if err != nil {
+		return """", err
+	}
+	if messageType == ""MessageSend"" {
+		return readCtx.GetStringParam(utilTypes.MessageSendFee, height)
+	}
+	if messageType == ""MessageChangeParameter"" {
+		return readCtx.GetStringParam(utilTypes.MessageChangeParameterFee, height)
+	}
+	switch actorType {
+	case coreTypes.ActorType_ACTOR_TYPE_APP:
+		switch messageType {
+		case ""MessageStake"":
+			return readCtx.GetStringParam(utilTypes.MessageStakeAppFee, height)
+		case ""MessageEditStake"":
+			return readCtx.GetStringParam(utilTypes.MessageEditStakeAppFee, height)
+		case ""MessageUnstake"":
+			return readCtx.GetStringParam(utilTypes.MessageUnstakeAppFee, height)
+		case ""MessageUnpause"":
+			return readCtx.GetStringParam(utilTypes.MessageUnpauseAppFee, height)
+		}
+	case coreTypes.ActorType_ACTOR_TYPE_FISH:
+		switch messageType {
+		case ""MessageStake"":
+			return readCtx.GetStringParam(utilTypes.MessageStakeFishermanFee, height)
+		case ""MessageEditStake"":
+			return readCtx.GetStringParam(utilTypes.MessageEditStakeFishermanFee, height)
+		case ""MessageUnstake"":
+			return readCtx.GetStringParam(utilTypes.MessageUnstakeFishermanFee, height)
+		case ""MessageUnpause"":
+			return readCtx.GetStringParam(utilTypes.MessageUnpauseFishermanFee, height)
+		}
+	case coreTypes.ActorType_ACTOR_TYPE_SERVICER:
+		switch messageType {
+		case ""MessageStake"":
+			return readCtx.GetStringParam(utilTypes.MessageStakeServicerFee, height)
+		case ""MessageEditStake"":
+			return readCtx.GetStringParam(utilTypes.MessageEditStakeServicerFee, height)
+		case ""MessageUnstake"":
+			return readCtx.GetStringParam(utilTypes.MessageUnstakeServicerFee, height)
+		case ""MessageUnpause"":
+			return readCtx.GetStringParam(utilTypes.MessageUnpauseServicerFee, height)
+		}
+	case coreTypes.ActorType_ACTOR_TYPE_VAL:
+		switch messageType {
+		case ""MessageStake"":
+			return readCtx.GetStringParam(utilTypes.MessageStakeValidatorFee, height)
+		case ""MessageEditStake"":
+			return readCtx.GetStringParam(utilTypes.MessageEditStakeValidatorFee, height)
+		case ""MessageUnstake"":
+			return readCtx.GetStringParam(utilTypes.MessageUnstakeValidatorFee, height)
+		case ""MessageUnpause"":
+			return readCtx.GetStringParam(utilTypes.MessageUnpauseValidatorFee, height)
+		}
+	default:
+		return """", fmt.Errorf(""invalid actor type: %s"", actorType.GetName())
+	}
+	return """", fmt.Errorf(""unhandled message type: %s"", messageType)
+}
+
+// txProtoBytesToRPCTransactions converts a slice of serialised Transaction protobufs to a slice of RPC transactions
+func (s *rpcServer) txProtoBytesToRPCTransactions(txProtoBytes [][]byte) ([]Transaction, error) {
+	currentHeight := s.GetBus().GetConsensusModule().CurrentHeight()
+	uow, err := s.GetBus().GetUtilityModule().NewUnitOfWork(int64(currentHeight))
+	if err != nil {
+		return nil, err
+	}
+	defer uow.Release() //nolint:errcheck // We only need to make sure the UOW is released
+
+	txs := make([]Transaction, 0)
+	for idx, txBz := range txProtoBytes {
+		tx := new(coreTypes.Transaction)
+		if err := codec.GetCodec().Unmarshal(txBz, tx); err != nil {
+			return nil, err
+		}
+		txResult, er := uow.HydrateTxResult(tx, idx)
+		if er != nil {
+			return nil, er
+		}
+		rpcTx, err := s.txResultToRPCTransaction(txResult)
+		if err != nil {
+			return nil, err
+		}
+		txs = append(txs, *rpcTx)
+	}
+
+	return txs, nil
+}
+
+// blockToRPCBlock converts a block protobuf to the RPC block type
+func (s *rpcServer) blockToRPCBlock(protoBlock *coreTypes.Block) (*Block, error) {
+	txs, err := s.txProtoBytesToRPCTransactions(protoBlock.GetTransactions())
+	if err != nil {
+		return nil, err
+	}
+
+	qc := new(conTypes.QuorumCertificate)
+	if err := codec.GetCodec().Unmarshal(protoBlock.BlockHeader.GetQuorumCertificate(), qc); err != nil {
+		return nil, err
+	}
+	partialSigs := make([]PartialSignature, 0)
+	for _, sig := range qc.GetThresholdSignature().GetSignatures() {
+		ps := PartialSignature{
+			Signature: hex.EncodeToString(sig.GetSignature()),
+			Address:   sig.GetAddress(),
+		}
+		partialSigs = append(partialSigs, ps)
+	}
+
+	qcTxs := make([]string, 0)
+	for _, txBz := range qc.GetBlock().GetTransactions() {
+		tx := base64.StdEncoding.EncodeToString(txBz)
+		qcTxs = append(qcTxs, tx)
+	}
+
+	qcBlockBz, err := codec.GetCodec().Marshal(qc.GetBlock())
+	if err != nil {
+		return nil, err
+	}
+	qcBlock := base64.StdEncoding.EncodeToString(qcBlockBz)
+
+	return &Block{
+		BlockHeader: BlockHeader{
+			Height:        int64(protoBlock.BlockHeader.GetHeight()),
+			NetworkId:     protoBlock.BlockHeader.GetNetworkId(),
+			StateHash:     protoBlock.BlockHeader.GetStateHash(),
+			PrevStateHash: protoBlock.BlockHeader.GetPrevStateHash(),
+			ProposerAddr:  hex.EncodeToString(protoBlock.BlockHeader.GetProposerAddress()),
+			QuorumCert: QuorumCertificate{
+				Height: int64(qc.GetHeight()),
+				Round:  int64(qc.GetRound()),
+				Step:   qc.GetStep().String(),
+				Block:  qcBlock,
+				ThresholdSig: ThresholdSignature{
+					Signatures: partialSigs,
+				},
+				Transactions: qcTxs,
+			},
+			Timestamp: protoBlock.BlockHeader.GetTimestampt().AsTime().String(),
+		},
+		Transactions: txs,
+	}, nil
+}
+
+// protocolActorToRPCActorTypeEnum converts a protocol actor type to the rpc actor type enum
+func protocolActorToRPCActorTypeEnum(protocolActorType coreTypes.ActorType) ActorTypesEnum {
+	switch protocolActorType {
+	case coreTypes.ActorType_ACTOR_TYPE_APP:
+		return Application
+	case coreTypes.ActorType_ACTOR_TYPE_FISH:
+		return Fisherman
+	case coreTypes.ActorType_ACTOR_TYPE_SERVICER:
+		return Servicer
+	case coreTypes.ActorType_ACTOR_TYPE_VAL:
+		return Validator
+	default:
+		panic(""invalid actor type"")
+	}
+}
+
+// getProtocolActorGetter returns the correct protocol actor getter function based on the actor type parameter
+func getProtocolActorGetter(persistenceContext modules.PersistenceReadContext, params GetV1P2pStakedActorsAddressBookParams) func(height int64) ([]*coreTypes.Actor, error) {
+	var protocolActorGetter = persistenceContext.GetAllStakedActors
+	if params.ActorType == nil {
+		return persistenceContext.GetAllStakedActors
+	}",rpc/utils.go,2023-04-21 23:29:43+00:00,2023-04-21T23:47:02Z,"Do you need this if structure at all given how you set it up?

If you add a `default` to the switch statement, you can probably just do 

```
switch ActorTye {
	App:
		return GetAllApps
	Fisher:
		...
	default:
		return GetAllStakedActors
}
```",,444.0,RIGHT,,446,RIGHT,446,,line,https://api.github.com/repos/pokt-network/pocket/pulls/684,pokt-network/pocket,9359cdf1837fa6bf84632f6ccc8dfb05de0f7296
https://api.github.com/repos/pokt-network/pocket/pulls/684,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1174224258,Olshansk,33fefdfbfb6dbfb6107ab93e63c3abca7951a012,9fb091614f1874101a5e3f3b35e5eadb67fa32ea,"@@ -52,9 +193,138 @@ func (s *rpcServer) GetV1ConsensusState(ctx echo.Context) error {
 	})
 }
 
+// Queries
+
+func (s *rpcServer) PostV1QueryAccount(ctx echo.Context) error {
+	var body QueryAddressHeight
+	if err := ctx.Bind(&body); err != nil {
+		return ctx.String(http.StatusBadRequest, ""bad request"")
+	}
+
+	// Get latest stored block height
+	currentHeight := int64(s.GetBus().GetConsensusModule().CurrentHeight())
+	if currentHeight > 0 {
+		currentHeight -= 1
+	}
+	height := body.Height
+	if height == 0 {
+		height = currentHeight
+	}
+	readCtx, err := s.GetBus().GetPersistenceModule().NewReadContext(currentHeight)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+	accBz, err := hex.DecodeString(body.Address)
+	if err != nil {
+		return ctx.String(http.StatusBadRequest, err.Error())
+	}
+	amount, err := readCtx.GetAccountAmount(accBz, height)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+
+	return ctx.JSON(http.StatusOK, Account{
+		Address: body.Address,
+		Coins:   []Coin{{Amount: amount, Denom: ""upokt""}},
+	})
+}
+
+func (s *rpcServer) PostV1QueryAccounts(ctx echo.Context) error {
+	var body QueryHeightPaginated
+	if err := ctx.Bind(&body); err != nil {
+		return ctx.String(http.StatusBadRequest, ""bad request"")
+	}
+
+	// Get latest stored block height
+	currentHeight := int64(s.GetBus().GetConsensusModule().CurrentHeight())
+	if currentHeight > 0 {
+		currentHeight -= 1
+	}
+	height := body.Height
+	if height == 0 {
+		height = currentHeight
+	}
+	readCtx, err := s.GetBus().GetPersistenceModule().NewReadContext(currentHeight)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+	allAccounts, err := readCtx.GetAllAccounts(height)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+
+	start, end, totalPages, err := getPageIndexes(len(allAccounts), int(body.Page), int(body.PerPage))
+	if err != nil && !errors.Is(err, errNoItems) {
+		return ctx.String(http.StatusBadRequest, err.Error())
+	}
+	if totalPages == 0 || errors.Is(err, errNoItems) {
+		return ctx.JSON(http.StatusOK, QueryAccountsResponse{})
+	}
+
+	accounts := make([]Account, 0)
+	for _, account := range allAccounts[start : end+1] {
+		accounts = append(accounts, Account{
+			Address: account.Address,
+			Coins:   []Coin{{Amount: account.Amount, Denom: ""upokt""}},
+		})
+	}
+
+	return ctx.JSON(http.StatusOK, QueryAccountsResponse{
+		Result:     accounts,
+		Page:       body.Page,
+		TotalPages: int64(totalPages),
+	})
+}
+
+func (s *rpcServer) PostV1QueryAccounttxs(ctx echo.Context) error {
+	var body QueryAddressPaginated
+	if err := ctx.Bind(&body); err != nil {
+		return ctx.String(http.StatusBadRequest, ""bad request"")
+	}
+	sort := checkSort(*body.Sort)
+	sortDesc := true
+	if sort == ""asc"" {
+		sortDesc = false
+	}",rpc/handlers.go,2023-04-21 23:34:35+00:00,2023-04-21T23:47:02Z,"Update `checkSort` to also return the boolean:

`sort, sortDesc = checkSort(*body.Sort)`

Ditto elsewhere",,285.0,RIGHT,,288,RIGHT,260,,line,https://api.github.com/repos/pokt-network/pocket/pulls/684,pokt-network/pocket,9359cdf1837fa6bf84632f6ccc8dfb05de0f7296
https://api.github.com/repos/pokt-network/pocket/pulls/684,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1174224772,Olshansk,33fefdfbfb6dbfb6107ab93e63c3abca7951a012,9fb091614f1874101a5e3f3b35e5eadb67fa32ea,"@@ -72,20 +342,679 @@ func (s *rpcServer) GetV1QueryAllChainParams(ctx echo.Context) error {
 	return ctx.JSON(200, resp)
 }
 
-// Broadcast to the entire validator set
-func (s *rpcServer) broadcastMessage(msgBz []byte) error {
-	utilityMsg, err := utility.PrepareTxGossipMessage(msgBz)
+func (s *rpcServer) PostV1QueryApp(ctx echo.Context) error {
+	var body QueryAddressHeight
+	if err := ctx.Bind(&body); err != nil {
+		return ctx.String(http.StatusBadRequest, ""bad request"")
+	}
+
+	// Get latest stored block height
+	currentHeight := int64(s.GetBus().GetConsensusModule().CurrentHeight())
+	if currentHeight > 0 {
+		currentHeight -= 1
+	}
+	height := body.Height
+	if height == 0 {
+		height = currentHeight
+	}
+	readCtx, err := s.GetBus().GetPersistenceModule().NewReadContext(currentHeight)
 	if err != nil {
-		s.logger.Error().Err(err).Msg(""Failed to prepare transaction gossip message"")
-		return err
+		return ctx.String(http.StatusInternalServerError, err.Error())
 	}
 
-	if err := s.GetBus().GetP2PModule().Broadcast(utilityMsg); err != nil {
-		s.logger.Error().Err(err).Msg(""Failed to broadcast utility message"")
-		return err
+	addrBz, err := hex.DecodeString(body.Address)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+	application, err := readCtx.GetApp(addrBz, height)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
 	}
 
-	return nil
+	actor := protocolActorToRPCProtocolActor(application)
+	return ctx.JSON(http.StatusOK, actor)
+}
+
+func (s *rpcServer) PostV1QueryApps(ctx echo.Context) error {
+	var body QueryHeightPaginated
+	if err := ctx.Bind(&body); err != nil {
+		return ctx.String(http.StatusBadRequest, ""bad request"")
+	}
+
+	// Get latest stored block height
+	currentHeight := int64(s.GetBus().GetConsensusModule().CurrentHeight())
+	if currentHeight > 0 {
+		currentHeight -= 1
+	}
+	height := body.Height
+	if height == 0 {
+		height = currentHeight
+	}
+	readCtx, err := s.GetBus().GetPersistenceModule().NewReadContext(currentHeight)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+	allApps, err := readCtx.GetAllApps(height)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+
+	start, end, totalPages, err := getPageIndexes(len(allApps), int(body.Page), int(body.PerPage))
+	if err != nil && !errors.Is(err, errNoItems) {
+		return ctx.String(http.StatusBadRequest, err.Error())
+	}
+	if totalPages == 0 || errors.Is(err, errNoItems) {
+		return ctx.JSON(http.StatusOK, QueryAppsResponse{})
+	}
+
+	rpcApps := make([]ProtocolActor, 0)
+	for _, app := range allApps[start : end+1] {
+		actor := protocolActorToRPCProtocolActor(app)
+		rpcApps = append(rpcApps, actor)
+	}
+
+	return ctx.JSON(http.StatusOK, QueryAppsResponse{
+		Apps:       rpcApps,
+		TotalApps:  int64(len(allApps)),
+		Page:       body.Page,
+		TotalPages: int64(totalPages),
+	})
+}
+
+func (s *rpcServer) PostV1QueryBalance(ctx echo.Context) error {
+	var body QueryAddressHeight
+	if err := ctx.Bind(&body); err != nil {
+		return ctx.String(http.StatusBadRequest, ""bad request"")
+	}
+
+	// Get latest stored block height
+	currentHeight := int64(s.GetBus().GetConsensusModule().CurrentHeight())
+	if currentHeight > 0 {
+		currentHeight -= 1
+	}
+	height := body.Height
+	if height == 0 {
+		height = currentHeight
+	}
+	readCtx, err := s.GetBus().GetPersistenceModule().NewReadContext(currentHeight)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+
+	accBz, err := hex.DecodeString(body.Address)
+	if err != nil {
+		return ctx.String(http.StatusBadRequest, err.Error())
+	}
+	amountStr, err := readCtx.GetAccountAmount(accBz, height)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+	amount, err := strconv.ParseInt(amountStr, 10, 64)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+
+	return ctx.JSON(http.StatusOK, QueryBalanceResponse{
+		Balance: amount,
+	})
+}
+
+func (s *rpcServer) PostV1QueryBlock(ctx echo.Context) error {
+	var body QueryHeight
+	if err := ctx.Bind(&body); err != nil {
+		return ctx.String(http.StatusBadRequest, ""bad request"")
+	}
+
+	// Get latest stored block height
+	currentHeight := s.GetBus().GetConsensusModule().CurrentHeight()
+	if currentHeight > 0 {
+		currentHeight -= 1
+	}
+	height := uint64(body.Height)
+	if height == 0 || height > currentHeight {
+		height = currentHeight
+	}
+
+	blockStore := s.GetBus().GetPersistenceModule().GetBlockStore()
+	blockBz, err := blockStore.Get(utils.HeightToBytes(height))
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+
+	block := new(coreTypes.Block)
+	if err := codec.GetCodec().Unmarshal(blockBz, block); err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+	rpcBlock, err := s.blockToRPCBlock(block)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+
+	return ctx.JSON(http.StatusOK, rpcBlock)
+}
+
+func (s *rpcServer) PostV1QueryBlocktxs(ctx echo.Context) error {
+	var body QueryHeightPaginated
+	if err := ctx.Bind(&body); err != nil {
+		return ctx.String(http.StatusBadRequest, ""bad request"")
+	}
+	sort := checkSort(*body.Sort)
+	sortDesc := true
+	if sort == ""asc"" {
+		sortDesc = false
+	}
+
+	// Get latest stored block height
+	currentHeight := s.GetBus().GetConsensusModule().CurrentHeight()
+	if currentHeight > 0 {
+		currentHeight -= 1
+	}
+	height := uint64(body.Height)
+	if height == 0 || height > currentHeight {
+		height = currentHeight
+	}
+
+	blockStore := s.GetBus().GetPersistenceModule().GetBlockStore()
+	blockBz, err := blockStore.Get(utils.HeightToBytes(height))
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+
+	block := new(coreTypes.Block)
+	if err := codec.GetCodec().Unmarshal(blockBz, block); err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+	rpcBlock, err := s.blockToRPCBlock(block)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+	allTxs := rpcBlock.Transactions
+	if sortDesc {
+		for i, j := 0, len(allTxs)-1; i < j; i, j = i+1, j-1 {
+			allTxs[i], allTxs[j] = allTxs[j], allTxs[i]
+		}
+	}
+
+	start, end, totalPages, err := getPageIndexes(len(allTxs), int(body.Page), int(body.PerPage))
+	if err != nil && !errors.Is(err, errNoItems) {
+		return ctx.String(http.StatusBadRequest, err.Error())
+	}
+	if totalPages == 0 || errors.Is(err, errNoItems) {
+		return ctx.JSON(http.StatusOK, QueryTxsResponse{})
+	}
+
+	return ctx.JSON(http.StatusOK, QueryTxsResponse{
+		Transactions: allTxs[start : end+1],
+		TotalTxs:     int64(len(allTxs)),
+		Page:         body.Page,
+		TotalPages:   int64(totalPages),
+	})
+}
+
+func (s *rpcServer) PostV1QueryFisherman(ctx echo.Context) error {
+	var body QueryAddressHeight
+	if err := ctx.Bind(&body); err != nil {
+		return ctx.String(http.StatusBadRequest, ""bad request"")
+	}
+
+	// Get latest stored block height
+	currentHeight := int64(s.GetBus().GetConsensusModule().CurrentHeight())
+	if currentHeight > 0 {
+		currentHeight -= 1
+	}
+	height := body.Height
+	if height == 0 {
+		height = currentHeight
+	}
+	readCtx, err := s.GetBus().GetPersistenceModule().NewReadContext(currentHeight)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+
+	addrBz, err := hex.DecodeString(body.Address)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+	fisherman, err := readCtx.GetFisherman(addrBz, height)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+
+	actor := protocolActorToRPCProtocolActor(fisherman)
+	return ctx.JSON(http.StatusOK, actor)
+}
+
+func (s *rpcServer) PostV1QueryFishermen(ctx echo.Context) error {
+	var body QueryHeightPaginated
+	if err := ctx.Bind(&body); err != nil {
+		return ctx.String(http.StatusBadRequest, ""bad request"")
+	}
+
+	// Get latest stored block height
+	currentHeight := int64(s.GetBus().GetConsensusModule().CurrentHeight())
+	if currentHeight > 0 {
+		currentHeight -= 1
+	}
+	height := body.Height
+	if height == 0 {
+		height = currentHeight
+	}
+	readCtx, err := s.GetBus().GetPersistenceModule().NewReadContext(currentHeight)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+	allFishermen, err := readCtx.GetAllFishermen(height)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+
+	start, end, totalPages, err := getPageIndexes(len(allFishermen), int(body.Page), int(body.PerPage))
+	if err != nil && !errors.Is(err, errNoItems) {
+		return ctx.String(http.StatusBadRequest, err.Error())
+	}
+	if totalPages == 0 || errors.Is(err, errNoItems) {
+		return ctx.JSON(http.StatusOK, QueryFishermenResponse{})
+	}
+
+	rpcFishermen := make([]ProtocolActor, 0)
+	for _, fm := range allFishermen[start : end+1] {
+		actor := protocolActorToRPCProtocolActor(fm)
+		rpcFishermen = append(rpcFishermen, actor)
+	}
+
+	return ctx.JSON(http.StatusOK, QueryFishermenResponse{
+		Fishermen:      rpcFishermen,
+		TotalFishermen: int64(len(allFishermen)),
+		Page:           body.Page,
+		TotalPages:     int64(totalPages),
+	})
+}
+
+func (s *rpcServer) GetV1QueryHeight(ctx echo.Context) error {
+	// Get latest stored block height
+	currentHeight := s.GetBus().GetConsensusModule().CurrentHeight()
+	if currentHeight > 0 {
+		currentHeight -= 1
+	}
+
+	return ctx.JSON(http.StatusOK, QueryHeight{
+		Height: int64(currentHeight),
+	})
+}
+
+func (s *rpcServer) PostV1QueryParam(ctx echo.Context) error {
+	var body QueryParameter
+	if err := ctx.Bind(&body); err != nil {
+		return ctx.String(http.StatusBadRequest, ""bad request"")
+	}
+
+	// Get latest stored block height
+	currentHeight := int64(s.GetBus().GetConsensusModule().CurrentHeight())
+	if currentHeight > 0 {
+		currentHeight -= 1
+	}
+	height := body.Height
+	if height == 0 || height > currentHeight {
+		height = currentHeight
+	}
+
+	readCtx, err := s.GetBus().GetPersistenceModule().NewReadContext(height)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+	paramValue, err := readCtx.GetStringParam(body.ParamName, height)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+
+	return ctx.JSON(http.StatusOK, Parameter{
+		ParameterName:  body.ParamName,
+		ParameterValue: paramValue,
+	})
+}
+
+func (s *rpcServer) PostV1QueryServicer(ctx echo.Context) error {
+	var body QueryAddressHeight
+	if err := ctx.Bind(&body); err != nil {
+		return ctx.String(http.StatusBadRequest, ""bad request"")
+	}
+
+	// Get latest stored block height
+	currentHeight := int64(s.GetBus().GetConsensusModule().CurrentHeight())
+	if currentHeight > 0 {
+		currentHeight -= 1
+	}
+	height := body.Height
+	if height == 0 {
+		height = currentHeight
+	}
+	readCtx, err := s.GetBus().GetPersistenceModule().NewReadContext(currentHeight)",rpc/handlers.go,2023-04-21 23:37:03+00:00,2023-04-21T23:47:02Z,"Should this not take in `height` instead of `currentHeight`?

If that's the case, I think we can also avoid needing to have the `CurretnHeight` call unless `height == 0`",,,,,691,RIGHT,664,,line,https://api.github.com/repos/pokt-network/pocket/pulls/684,pokt-network/pocket,9359cdf1837fa6bf84632f6ccc8dfb05de0f7296
https://api.github.com/repos/pokt-network/pocket/pulls/684,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1178511721,Olshansk,80b51ef56cd6ed47b1e20337763524198dff5c6f,9fb091614f1874101a5e3f3b35e5eadb67fa32ea,"@@ -43,6 +47,143 @@ func (s *rpcServer) PostV1ClientBroadcastTxSync(ctx echo.Context) error {
 	return nil
 }
 
+// DISCUSSION: This may need to be changed when the GetSession function is actually implemented
+func (s *rpcServer) PostV1ClientDispatch(ctx echo.Context) error {",rpc/handlers.go,2023-04-27 00:25:03+00:00,2023-04-27T00:26:49Z,Can you rename this `GetSession` (ditto elsewhere). `Dispatch` is a very legacy term.,,,,,51,RIGHT,34,,line,https://api.github.com/repos/pokt-network/pocket/pulls/684,pokt-network/pocket,9359cdf1837fa6bf84632f6ccc8dfb05de0f7296
https://api.github.com/repos/pokt-network/pocket/pulls/684,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1178512362,Olshansk,80b51ef56cd6ed47b1e20337763524198dff5c6f,9fb091614f1874101a5e3f3b35e5eadb67fa32ea,"@@ -52,12 +193,143 @@ func (s *rpcServer) GetV1ConsensusState(ctx echo.Context) error {
 	})
 }
 
+// Queries
+
+func (s *rpcServer) PostV1QueryAccount(ctx echo.Context) error {
+	var body QueryAddressHeight
+	if err := ctx.Bind(&body); err != nil {
+		return ctx.String(http.StatusBadRequest, ""bad request"")
+	}
+
+	// Get latest stored block height
+	height := body.Height
+	if height == 0 {
+		currentHeight := int64(s.GetBus().GetConsensusModule().CurrentHeight())
+		if currentHeight > 0 {
+			currentHeight -= 1
+		}
+		height = currentHeight
+	}
+	readCtx, err := s.GetBus().GetPersistenceModule().NewReadContext(height)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+	defer readCtx.Release() //nolint:errcheck // We only need to make sure the readCtx is released
+
+	accBz, err := hex.DecodeString(body.Address)
+	if err != nil {
+		return ctx.String(http.StatusBadRequest, err.Error())
+	}
+	amount, err := readCtx.GetAccountAmount(accBz, height)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+
+	return ctx.JSON(http.StatusOK, Account{
+		Address: body.Address,
+		Coins:   []Coin{{Amount: amount, Denom: ""upokt""}},
+	})
+}
+
+func (s *rpcServer) PostV1QueryAccounts(ctx echo.Context) error {
+	var body QueryHeightPaginated
+	if err := ctx.Bind(&body); err != nil {
+		return ctx.String(http.StatusBadRequest, ""bad request"")
+	}
+
+	// Get latest stored block height
+	height := body.Height
+	if height == 0 {
+		currentHeight := int64(s.GetBus().GetConsensusModule().CurrentHeight())
+		if currentHeight > 0 {
+			currentHeight -= 1
+		}
+		height = currentHeight
+	}
+	readCtx, err := s.GetBus().GetPersistenceModule().NewReadContext(height)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+	defer readCtx.Release() //nolint:errcheck // We only need to make sure the readCtx is released
+
+	allAccounts, err := readCtx.GetAllAccounts(height)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+
+	start, end, totalPages, err := getPageIndexes(len(allAccounts), int(body.Page), int(body.PerPage))
+	if err != nil && !errors.Is(err, errNoItems) {
+		return ctx.String(http.StatusBadRequest, err.Error())
+	}
+	if totalPages == 0 || errors.Is(err, errNoItems) {
+		return ctx.JSON(http.StatusOK, QueryAccountsResponse{})
+	}
+
+	accounts := make([]Account, 0)
+	for _, account := range allAccounts[start : end+1] {
+		accounts = append(accounts, Account{
+			Address: account.Address,
+			Coins:   []Coin{{Amount: account.Amount, Denom: ""upokt""}},
+		})
+	}
+
+	return ctx.JSON(http.StatusOK, QueryAccountsResponse{
+		Result:     accounts,
+		Page:       body.Page,
+		TotalPages: int64(totalPages),
+	})
+}
+
+func (s *rpcServer) PostV1QueryAccountTxs(ctx echo.Context) error {
+	var body QueryAddressPaginated
+	if err := ctx.Bind(&body); err != nil {
+		return ctx.String(http.StatusBadRequest, ""bad request"")
+	}
+	sortDesc := checkSortDesc(*body.Sort)
+
+	txIndexer := s.GetBus().GetPersistenceModule().GetTxIndexer()
+	txResults, err := txIndexer.GetBySender(body.Address, sortDesc)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+
+	start, end, totalPages, err := getPageIndexes(len(txResults), int(body.Page), int(body.PerPage))
+	if err != nil && !errors.Is(err, errNoItems) {
+		return ctx.String(http.StatusBadRequest, err.Error())
+	}
+	if totalPages == 0 || errors.Is(err, errNoItems) {
+		return ctx.JSON(http.StatusOK, QueryAccountTxsResponse{})
+	}
+
+	pageTxs := make([]Transaction, 0)
+	for _, txResult := range txResults[start : end+1] {
+		rpcTx, err := s.txResultToRPCTransaction(txResult)
+		if err != nil {
+			return ctx.String(http.StatusInternalServerError, err.Error())
+		}
+		pageTxs = append(pageTxs, *rpcTx)
+	}
+
+	return ctx.JSON(http.StatusOK, QueryAccountTxsResponse{
+		Txs:        pageTxs,
+		Page:       body.Page,
+		TotalTxs:   int64(len(txResults)),
+		TotalPages: int64(totalPages),
+	})
+}
+
 func (s *rpcServer) GetV1QueryAllChainParams(ctx echo.Context) error {",rpc/handlers.go,2023-04-27 00:26:32+00:00,2023-04-27T00:26:49Z,Why are we doing a `Get` to query ChainParams but a `POST` for querying txs?,,,,,321,RIGHT,302,,line,https://api.github.com/repos/pokt-network/pocket/pulls/684,pokt-network/pocket,9359cdf1837fa6bf84632f6ccc8dfb05de0f7296
https://api.github.com/repos/pokt-network/pocket/pulls/684,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1181971888,Olshansk,964333fcec0ccb79708af5ce07dbab1cf5efb3a5,9fb091614f1874101a5e3f3b35e5eadb67fa32ea,"@@ -80,13 +82,19 @@ func (p *PostgresContext) prepareBlock(proposerAddr, quorumCert []byte) (*coreTy
 		txs[i] = txResult.GetTx()
 	}
 
+	// Get the current timestamp
+	// TECHDEBT: This will lead to different timestamp in each node's block store because `prepareBlock` is called locally. Needs to be revisisted and decided on a proper implementation.
+	timestamp := timestamppb.Now()
+
 	// Preapre the block proto
 	blockHeader := &coreTypes.BlockHeader{
 		Height:            uint64(p.Height),
+		NetworkId:         networkId,
 		StateHash:         p.stateHash,
 		PrevStateHash:     prevBlockHash,
 		ProposerAddress:   proposerAddr,
 		QuorumCertificate: quorumCert,
+		Timestampt:        timestamp,",persistence/block.go,2023-05-01 23:46:14+00:00,2023-05-02T02:27:53Z,Looks like there's a typo in Timestampt,,,,,97,RIGHT,32,,line,https://api.github.com/repos/pokt-network/pocket/pulls/684,pokt-network/pocket,9359cdf1837fa6bf84632f6ccc8dfb05de0f7296
https://api.github.com/repos/pokt-network/pocket/pulls/684,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1181976445,Olshansk,964333fcec0ccb79708af5ce07dbab1cf5efb3a5,9fb091614f1874101a5e3f3b35e5eadb67fa32ea,"@@ -20,6 +20,8 @@ var (
 	_ modules.PersistenceModule = &persistenceModule{}
 
 	_ modules.PersistenceRWContext = &PostgresContext{}
+
+	networkId string",persistence/module.go,2023-05-01 23:57:26+00:00,2023-05-02T02:27:53Z,I think this should be part of the struct next to `config` and `genesisState`,,,,,24,RIGHT,5,,line,https://api.github.com/repos/pokt-network/pocket/pulls/684,pokt-network/pocket,9359cdf1837fa6bf84632f6ccc8dfb05de0f7296
https://api.github.com/repos/pokt-network/pocket/pulls/684,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1181990413,Olshansk,964333fcec0ccb79708af5ce07dbab1cf5efb3a5,9fb091614f1874101a5e3f3b35e5eadb67fa32ea,"@@ -22,6 +22,12 @@ type UtilityModule interface {
 	// HandleTransaction does basic `Transaction` validation & adds it to the utility's module mempool if valid
 	HandleTransaction(tx []byte) error
 
+	// SendRelay sends a relay to the specified chain returning the response
+	SendRelay(relay *coreTypes.Relay) (*coreTypes.RelayResponse, error) // TODO: Implement this",shared/modules/utility_module.go,2023-05-02 00:33:59+00:00,2023-05-02T02:27:53Z,s/SendRelay/HandleRelay,,,,,26,RIGHT,5,,line,https://api.github.com/repos/pokt-network/pocket/pulls/684,pokt-network/pocket,9359cdf1837fa6bf84632f6ccc8dfb05de0f7296
https://api.github.com/repos/pokt-network/pocket/pulls/684,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1181990651,Olshansk,964333fcec0ccb79708af5ce07dbab1cf5efb3a5,9fb091614f1874101a5e3f3b35e5eadb67fa32ea,"@@ -22,6 +22,12 @@ type UtilityModule interface {
 	// HandleTransaction does basic `Transaction` validation & adds it to the utility's module mempool if valid
 	HandleTransaction(tx []byte) error
 
+	// SendRelay sends a relay to the specified chain returning the response",shared/modules/utility_module.go,2023-05-02 00:34:37+00:00,2023-05-02T02:27:53Z,"```suggestion
	// HandleRelay process the relay to the specified chain if this node is a servicer
```",,,,,25,RIGHT,4,,line,https://api.github.com/repos/pokt-network/pocket/pulls/684,pokt-network/pocket,9359cdf1837fa6bf84632f6ccc8dfb05de0f7296
https://api.github.com/repos/pokt-network/pocket/pulls/684,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1181990806,Olshansk,964333fcec0ccb79708af5ce07dbab1cf5efb3a5,9fb091614f1874101a5e3f3b35e5eadb67fa32ea,"@@ -22,6 +22,12 @@ type UtilityModule interface {
 	// HandleTransaction does basic `Transaction` validation & adds it to the utility's module mempool if valid
 	HandleTransaction(tx []byte) error
 
+	// SendRelay sends a relay to the specified chain returning the response
+	SendRelay(relay *coreTypes.Relay) (*coreTypes.RelayResponse, error) // TODO: Implement this
+
+	// HandleChallenge handles a challenge request from a node returning the response",shared/modules/utility_module.go,2023-05-02 00:35:06+00:00,2023-05-02T02:27:53Z,"```suggestion
	// HandleChallenge handles a challenge request from an application unhappy with the response
```",,,,,28,RIGHT,7,,line,https://api.github.com/repos/pokt-network/pocket/pulls/684,pokt-network/pocket,9359cdf1837fa6bf84632f6ccc8dfb05de0f7296
https://api.github.com/repos/pokt-network/pocket/pulls/684,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1181991389,Olshansk,964333fcec0ccb79708af5ce07dbab1cf5efb3a5,9fb091614f1874101a5e3f3b35e5eadb67fa32ea,"@@ -57,6 +63,9 @@ type UtilityUnitOfWork interface {
 	// TODO: Investigate a way to potentially simplify the interface by removing this function.
 	SetProposalBlock(blockHash string, proposerAddr []byte, txs [][]byte) error
 
+	// HydrateTxResult hydrates a Transaction protobuf, with its index in the block returning a TxResult protobuf",shared/modules/utility_module.go,2023-05-02 00:36:55+00:00,2023-05-02T02:27:54Z,"Remove `protobuf` and use `structure` instead.

Protos are compiled to golang structuts, and theoretically (though its not happening), we could have used a different codec.",,,,,66,RIGHT,17,,line,https://api.github.com/repos/pokt-network/pocket/pulls/684,pokt-network/pocket,9359cdf1837fa6bf84632f6ccc8dfb05de0f7296
https://api.github.com/repos/pokt-network/pocket/pulls/684,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1181991946,Olshansk,964333fcec0ccb79708af5ce07dbab1cf5efb3a5,9fb091614f1874101a5e3f3b35e5eadb67fa32ea,"@@ -43,49 +41,151 @@ func (s *rpcServer) PostV1ClientBroadcastTxSync(ctx echo.Context) error {
 	return nil
 }
 
-func (s *rpcServer) GetV1ConsensusState(ctx echo.Context) error {
-	consensus := s.GetBus().GetConsensusModule()
-	return ctx.JSON(200, ConsensusState{
-		Height: int64(consensus.CurrentHeight()),
-		Round:  int64(consensus.CurrentRound()),
-		Step:   int64(consensus.CurrentStep()),
-	})
-}
+func (s *rpcServer) PostV1ClientGetSession(ctx echo.Context) error {
+	var body SessionRequest
+	if err := ctx.Bind(&body); err != nil {
+		return ctx.String(http.StatusBadRequest, ""bad request"")
+	}
 
-func (s *rpcServer) GetV1QueryAllChainParams(ctx echo.Context) error {
-	currHeight := s.GetBus().GetConsensusModule().CurrentHeight()
-	readCtx, err := s.GetBus().GetPersistenceModule().NewReadContext(int64(currHeight))
+	session, err := s.GetBus().GetUtilityModule().GetSession(body.AppAddress, body.SessionHeight, body.Chain, body.Geozone)
 	if err != nil {
 		return ctx.String(http.StatusInternalServerError, err.Error())
 	}
-	paramSlice, err := readCtx.GetAllParams()
-	if err != nil {
-		return ctx.String(http.StatusInternalServerError, err.Error())
+
+	application := session.GetApplication()
+	rpcApp := protocolActorToRPCProtocolActor(application)",rpc/handlers.go,2023-05-02 00:38:35+00:00,2023-05-02T02:27:54Z,You should add a helper called `protocolActorsToRPCProtocolActors` that accepts and returns a slice and use it below,,,,56.0,56,RIGHT,48,48.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/684,pokt-network/pocket,9359cdf1837fa6bf84632f6ccc8dfb05de0f7296
https://api.github.com/repos/pokt-network/pocket/pulls/684,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1181993394,Olshansk,964333fcec0ccb79708af5ce07dbab1cf5efb3a5,9fb091614f1874101a5e3f3b35e5eadb67fa32ea,"@@ -43,49 +41,151 @@ func (s *rpcServer) PostV1ClientBroadcastTxSync(ctx echo.Context) error {
 	return nil
 }
 
-func (s *rpcServer) GetV1ConsensusState(ctx echo.Context) error {
-	consensus := s.GetBus().GetConsensusModule()
-	return ctx.JSON(200, ConsensusState{
-		Height: int64(consensus.CurrentHeight()),
-		Round:  int64(consensus.CurrentRound()),
-		Step:   int64(consensus.CurrentStep()),
-	})
-}
+func (s *rpcServer) PostV1ClientGetSession(ctx echo.Context) error {
+	var body SessionRequest
+	if err := ctx.Bind(&body); err != nil {
+		return ctx.String(http.StatusBadRequest, ""bad request"")
+	}
 
-func (s *rpcServer) GetV1QueryAllChainParams(ctx echo.Context) error {
-	currHeight := s.GetBus().GetConsensusModule().CurrentHeight()
-	readCtx, err := s.GetBus().GetPersistenceModule().NewReadContext(int64(currHeight))
+	session, err := s.GetBus().GetUtilityModule().GetSession(body.AppAddress, body.SessionHeight, body.Chain, body.Geozone)
 	if err != nil {
 		return ctx.String(http.StatusInternalServerError, err.Error())
 	}
-	paramSlice, err := readCtx.GetAllParams()
-	if err != nil {
-		return ctx.String(http.StatusInternalServerError, err.Error())
+
+	application := session.GetApplication()
+	rpcApp := protocolActorToRPCProtocolActor(application)
+
+	rpcServicers := make([]ProtocolActor, 0)
+	for _, servicer := range session.GetServicers() {
+		actor := protocolActorToRPCProtocolActor(servicer)
+		rpcServicers = append(rpcServicers, actor)
 	}
-	resp := make([]Parameter, 0)
-	for i := 0; i < len(paramSlice); i++ {
-		resp = append(resp, Parameter{
-			ParameterName:  paramSlice[i][0],
-			ParameterValue: paramSlice[i][1],
-		})
+
+	rpcFishermen := make([]ProtocolActor, 0)
+	for _, fisher := range session.GetFishermen() {
+		actor := protocolActorToRPCProtocolActor(fisher)
+		rpcFishermen = append(rpcFishermen, actor)
 	}
-	return ctx.JSON(200, resp)
+
+	return ctx.JSON(http.StatusOK, Session{
+		SessionId:        session.GetId(),
+		SessionNumber:    session.GetSessionNumber(),
+		SessionHeight:    session.GetSessionHeight(),
+		NumSessionBlocks: session.GetNumSessionBlocks(),
+		Chain:            string(session.GetRelayChain()),
+		Geozone:          string(session.GetGeoZone()),
+		Application:      rpcApp,
+		Servicers:        rpcServicers,
+		Fishermen:        rpcFishermen,
+	})
 }
 
-// Broadcast to the entire validator set
-func (s *rpcServer) broadcastMessage(msgBz []byte) error {
-	utilityMsg, err := utility.PrepareTxGossipMessage(msgBz)
+// DISCUSSION: This may need to be changed when the SendRelay function is actually implemented",rpc/handlers.go,2023-05-02 00:42:58+00:00,2023-05-02T02:27:54Z,"```suggestion
// TECHDEBT: This will need to be changed when the SendRelay function is actually implemented because it
// copies data structures from v0. For example, AATs are no longer necessary in v1.
```",,,,,83,RIGHT,85,,line,https://api.github.com/repos/pokt-network/pocket/pulls/684,pokt-network/pocket,9359cdf1837fa6bf84632f6ccc8dfb05de0f7296
https://api.github.com/repos/pokt-network/pocket/pulls/684,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1181995263,Olshansk,964333fcec0ccb79708af5ce07dbab1cf5efb3a5,9fb091614f1874101a5e3f3b35e5eadb67fa32ea,"@@ -43,49 +41,151 @@ func (s *rpcServer) PostV1ClientBroadcastTxSync(ctx echo.Context) error {
 	return nil
 }
 
-func (s *rpcServer) GetV1ConsensusState(ctx echo.Context) error {
-	consensus := s.GetBus().GetConsensusModule()
-	return ctx.JSON(200, ConsensusState{
-		Height: int64(consensus.CurrentHeight()),
-		Round:  int64(consensus.CurrentRound()),
-		Step:   int64(consensus.CurrentStep()),
-	})
-}
+func (s *rpcServer) PostV1ClientGetSession(ctx echo.Context) error {
+	var body SessionRequest
+	if err := ctx.Bind(&body); err != nil {
+		return ctx.String(http.StatusBadRequest, ""bad request"")
+	}
 
-func (s *rpcServer) GetV1QueryAllChainParams(ctx echo.Context) error {
-	currHeight := s.GetBus().GetConsensusModule().CurrentHeight()
-	readCtx, err := s.GetBus().GetPersistenceModule().NewReadContext(int64(currHeight))
+	session, err := s.GetBus().GetUtilityModule().GetSession(body.AppAddress, body.SessionHeight, body.Chain, body.Geozone)
 	if err != nil {
 		return ctx.String(http.StatusInternalServerError, err.Error())
 	}
-	paramSlice, err := readCtx.GetAllParams()
-	if err != nil {
-		return ctx.String(http.StatusInternalServerError, err.Error())
+
+	application := session.GetApplication()
+	rpcApp := protocolActorToRPCProtocolActor(application)
+
+	rpcServicers := make([]ProtocolActor, 0)
+	for _, servicer := range session.GetServicers() {
+		actor := protocolActorToRPCProtocolActor(servicer)
+		rpcServicers = append(rpcServicers, actor)
 	}
-	resp := make([]Parameter, 0)
-	for i := 0; i < len(paramSlice); i++ {
-		resp = append(resp, Parameter{
-			ParameterName:  paramSlice[i][0],
-			ParameterValue: paramSlice[i][1],
-		})
+
+	rpcFishermen := make([]ProtocolActor, 0)
+	for _, fisher := range session.GetFishermen() {
+		actor := protocolActorToRPCProtocolActor(fisher)
+		rpcFishermen = append(rpcFishermen, actor)
 	}
-	return ctx.JSON(200, resp)
+
+	return ctx.JSON(http.StatusOK, Session{
+		SessionId:        session.GetId(),
+		SessionNumber:    session.GetSessionNumber(),
+		SessionHeight:    session.GetSessionHeight(),
+		NumSessionBlocks: session.GetNumSessionBlocks(),
+		Chain:            string(session.GetRelayChain()),
+		Geozone:          string(session.GetGeoZone()),
+		Application:      rpcApp,
+		Servicers:        rpcServicers,
+		Fishermen:        rpcFishermen,
+	})
 }
 
-// Broadcast to the entire validator set
-func (s *rpcServer) broadcastMessage(msgBz []byte) error {
-	utilityMsg, err := utility.PrepareTxGossipMessage(msgBz)
+// DISCUSSION: This may need to be changed when the SendRelay function is actually implemented
+func (s *rpcServer) PostV1ClientRelay(ctx echo.Context) error {
+	var body RelayRequest
+	if err := ctx.Bind(&body); err != nil {
+		return ctx.String(http.StatusBadRequest, ""bad request"")
+	}
+
+	// Parse body into the protobuf messages
+	chain := &coreTypes.Identifiable{
+		Id:   body.Meta.Chain.Id,
+		Name: body.Meta.Chain.Name,
+	}
+	geozone := &coreTypes.Identifiable{
+		Id:   body.Meta.Geozone.Id,
+		Name: body.Meta.Geozone.Name,
+	}
+	aat := &coreTypes.AAT{
+		Version:              body.Meta.Token.Version,
+		ApplicationPublicKey: body.Meta.Token.AppPubKey,
+		ClientPublicKey:      body.Meta.Token.ClientPubKey,
+		ApplicationSignature: body.Meta.Token.AppSignature,
+	}
+	relayMeta := &coreTypes.RelayMeta{
+		BlockHeight:       body.Meta.BlockHeight,
+		ServicerPublicKey: body.Meta.ServicerPubKey,
+		RelayChain:        chain,
+		GeoZone:           geozone,
+		Token:             aat,
+		Signature:         body.Meta.Signature,
+	}
+
+	payload := &coreTypes.RelayPayload{
+		Data:     body.Payload.Data,
+		Method:   body.Payload.Method,
+		HttpPath: body.Payload.Path,
+	}
+
+	headers := make(map[string]string)
+	for _, header := range body.Payload.Headers {
+		headers[header.Name] = header.Value
+	}
+	payload.Headers = headers
+
+	relayRequest := &coreTypes.Relay{
+		Payload: payload,
+		Meta:    relayMeta,
+	}
+
+	relayResponse, err := s.GetBus().GetUtilityModule().SendRelay(relayRequest)
 	if err != nil {
-		s.logger.Error().Err(err).Msg(""Failed to prepare transaction gossip message"")
-		return err
+		return ctx.String(http.StatusInternalServerError, err.Error())
 	}
 
-	if err := s.GetBus().GetP2PModule().Broadcast(utilityMsg); err != nil {
-		s.logger.Error().Err(err).Msg(""Failed to broadcast utility message"")
-		return err
+	return ctx.JSON(http.StatusOK, RelayResponse{
+		Payload:           relayResponse.Payload,
+		ServicerSignature: relayResponse.ServicerSignature,
+	})
+}
+
+// DISCUSSION: This may need to be changed when the HandleChallenge function is actually implemented",rpc/handlers.go,2023-05-02 00:48:52+00:00,2023-05-02T02:27:54Z,Ditto as above. Please specify its techdebt and WILL need to change,,,,,142,RIGHT,149,,line,https://api.github.com/repos/pokt-network/pocket/pulls/684,pokt-network/pocket,9359cdf1837fa6bf84632f6ccc8dfb05de0f7296
https://api.github.com/repos/pokt-network/pocket/pulls/684,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1181995830,Olshansk,964333fcec0ccb79708af5ce07dbab1cf5efb3a5,9fb091614f1874101a5e3f3b35e5eadb67fa32ea,"@@ -0,0 +1,854 @@
+package rpc
+
+import (
+	""encoding/hex""
+	""errors""
+	""fmt""
+	""math/big""
+	""net/http""
+	""strconv""
+
+	""github.com/labstack/echo/v4""
+	""github.com/pokt-network/pocket/shared/codec""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/utils""
+)
+
+// Queries",rpc/handlers_query.go,2023-05-02 00:50:41+00:00,2023-05-02T02:27:54Z,Please update the comment with a bit more detail on how you distinguish `Query Handlers` from the others and what this file is intended for,,,,,17,RIGHT,17,,line,https://api.github.com/repos/pokt-network/pocket/pulls/684,pokt-network/pocket,9359cdf1837fa6bf84632f6ccc8dfb05de0f7296
https://api.github.com/repos/pokt-network/pocket/pulls/684,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1181997088,Olshansk,964333fcec0ccb79708af5ce07dbab1cf5efb3a5,9fb091614f1874101a5e3f3b35e5eadb67fa32ea,"@@ -0,0 +1,854 @@
+package rpc
+
+import (
+	""encoding/hex""
+	""errors""
+	""fmt""
+	""math/big""
+	""net/http""
+	""strconv""
+
+	""github.com/labstack/echo/v4""
+	""github.com/pokt-network/pocket/shared/codec""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/utils""
+)
+
+// Queries
+
+func (s *rpcServer) PostV1QueryAccount(ctx echo.Context) error {
+	var body QueryAddressHeight
+	if err := ctx.Bind(&body); err != nil {
+		return ctx.String(http.StatusBadRequest, ""bad request"")
+	}
+
+	// Get latest stored block height
+	height := body.Height
+	if height == 0 {
+		currentHeight := int64(s.GetBus().GetConsensusModule().CurrentHeight())
+		if currentHeight > 0 {
+			currentHeight -= 1
+		}
+		height = currentHeight",rpc/handlers_query.go,2023-05-02 00:54:27+00:00,2023-05-02T02:27:54Z,"I don't fully understand why we don't just do the following:

```suggestion
		height := int64(s.GetBus().GetConsensusModule().CurrentHeight())
```

Ditto everywhere else.",,28.0,RIGHT,,32,RIGHT,32,,line,https://api.github.com/repos/pokt-network/pocket/pulls/684,pokt-network/pocket,9359cdf1837fa6bf84632f6ccc8dfb05de0f7296
https://api.github.com/repos/pokt-network/pocket/pulls/684,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1181998181,Olshansk,964333fcec0ccb79708af5ce07dbab1cf5efb3a5,9fb091614f1874101a5e3f3b35e5eadb67fa32ea,"@@ -0,0 +1,854 @@
+package rpc
+
+import (
+	""encoding/hex""
+	""errors""
+	""fmt""
+	""math/big""
+	""net/http""
+	""strconv""
+
+	""github.com/labstack/echo/v4""
+	""github.com/pokt-network/pocket/shared/codec""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/utils""
+)
+
+// Queries
+
+func (s *rpcServer) PostV1QueryAccount(ctx echo.Context) error {
+	var body QueryAddressHeight
+	if err := ctx.Bind(&body); err != nil {
+		return ctx.String(http.StatusBadRequest, ""bad request"")
+	}
+
+	// Get latest stored block height
+	height := body.Height
+	if height == 0 {
+		currentHeight := int64(s.GetBus().GetConsensusModule().CurrentHeight())
+		if currentHeight > 0 {
+			currentHeight -= 1
+		}
+		height = currentHeight
+	}
+	readCtx, err := s.GetBus().GetPersistenceModule().NewReadContext(height)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+	defer readCtx.Release() //nolint:errcheck // We only need to make sure the readCtx is released
+
+	accBz, err := hex.DecodeString(body.Address)
+	if err != nil {
+		return ctx.String(http.StatusBadRequest, err.Error())
+	}
+	amount, err := readCtx.GetAccountAmount(accBz, height)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+
+	return ctx.JSON(http.StatusOK, Account{
+		Address: body.Address,
+		Coins:   []Coin{{Amount: amount, Denom: ""upokt""}},",rpc/handlers_query.go,2023-05-02 00:57:31+00:00,2023-05-02T02:27:54Z,Move `upokt` into a constant and use everywhere,,,,,51,RIGHT,51,,line,https://api.github.com/repos/pokt-network/pocket/pulls/684,pokt-network/pocket,9359cdf1837fa6bf84632f6ccc8dfb05de0f7296
https://api.github.com/repos/pokt-network/pocket/pulls/684,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1182004075,Olshansk,964333fcec0ccb79708af5ce07dbab1cf5efb3a5,9fb091614f1874101a5e3f3b35e5eadb67fa32ea,"@@ -0,0 +1,854 @@
+package rpc
+
+import (
+	""encoding/hex""
+	""errors""
+	""fmt""
+	""math/big""
+	""net/http""
+	""strconv""
+
+	""github.com/labstack/echo/v4""
+	""github.com/pokt-network/pocket/shared/codec""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/utils""
+)
+
+// Queries
+
+func (s *rpcServer) PostV1QueryAccount(ctx echo.Context) error {
+	var body QueryAddressHeight
+	if err := ctx.Bind(&body); err != nil {
+		return ctx.String(http.StatusBadRequest, ""bad request"")
+	}
+
+	// Get latest stored block height
+	height := body.Height
+	if height == 0 {
+		currentHeight := int64(s.GetBus().GetConsensusModule().CurrentHeight())
+		if currentHeight > 0 {
+			currentHeight -= 1
+		}
+		height = currentHeight
+	}
+	readCtx, err := s.GetBus().GetPersistenceModule().NewReadContext(height)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+	defer readCtx.Release() //nolint:errcheck // We only need to make sure the readCtx is released
+
+	accBz, err := hex.DecodeString(body.Address)
+	if err != nil {
+		return ctx.String(http.StatusBadRequest, err.Error())
+	}
+	amount, err := readCtx.GetAccountAmount(accBz, height)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+
+	return ctx.JSON(http.StatusOK, Account{
+		Address: body.Address,
+		Coins:   []Coin{{Amount: amount, Denom: ""upokt""}},
+	})
+}
+
+func (s *rpcServer) PostV1QueryAccounts(ctx echo.Context) error {
+	var body QueryHeightPaginated
+	if err := ctx.Bind(&body); err != nil {
+		return ctx.String(http.StatusBadRequest, ""bad request"")
+	}
+
+	// Get latest stored block height
+	height := body.Height
+	if height == 0 {
+		currentHeight := int64(s.GetBus().GetConsensusModule().CurrentHeight())
+		if currentHeight > 0 {
+			currentHeight -= 1
+		}
+		height = currentHeight
+	}
+	readCtx, err := s.GetBus().GetPersistenceModule().NewReadContext(height)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+	defer readCtx.Release() //nolint:errcheck // We only need to make sure the readCtx is released
+
+	allAccounts, err := readCtx.GetAllAccounts(height)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+
+	start, end, totalPages, err := getPageIndexes(len(allAccounts), int(body.Page), int(body.PerPage))
+	if err != nil && !errors.Is(err, errNoItems) {
+		return ctx.String(http.StatusBadRequest, err.Error())
+	}
+	if totalPages == 0 || errors.Is(err, errNoItems) {
+		return ctx.JSON(http.StatusOK, QueryAccountsResponse{})
+	}
+
+	accounts := make([]Account, 0)
+	for _, account := range allAccounts[start : end+1] {
+		accounts = append(accounts, Account{
+			Address: account.Address,
+			Coins:   []Coin{{Amount: account.Amount, Denom: ""upokt""}},
+		})
+	}
+
+	return ctx.JSON(http.StatusOK, QueryAccountsResponse{
+		Result:     accounts,
+		Page:       body.Page,
+		TotalPages: int64(totalPages),
+	})
+}
+
+func (s *rpcServer) PostV1QueryAccountTxs(ctx echo.Context) error {
+	var body QueryAddressPaginated
+	if err := ctx.Bind(&body); err != nil {
+		return ctx.String(http.StatusBadRequest, ""bad request"")
+	}
+	sortDesc := checkSortDesc(*body.Sort)
+
+	txIndexer := s.GetBus().GetPersistenceModule().GetTxIndexer()
+	txResults, err := txIndexer.GetBySender(body.Address, sortDesc)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+
+	start, end, totalPages, err := getPageIndexes(len(txResults), int(body.Page), int(body.PerPage))
+	if err != nil && !errors.Is(err, errNoItems) {
+		return ctx.String(http.StatusBadRequest, err.Error())
+	}
+	if totalPages == 0 || errors.Is(err, errNoItems) {
+		return ctx.JSON(http.StatusOK, QueryAccountTxsResponse{})
+	}
+
+	pageTxs := make([]Transaction, 0)
+	for _, txResult := range txResults[start : end+1] {
+		rpcTx, err := s.txResultToRPCTransaction(txResult)
+		if err != nil {
+			return ctx.String(http.StatusInternalServerError, err.Error())
+		}
+		pageTxs = append(pageTxs, *rpcTx)
+	}
+
+	return ctx.JSON(http.StatusOK, QueryAccountTxsResponse{
+		Txs:        pageTxs,
+		Page:       body.Page,
+		TotalTxs:   int64(len(txResults)),
+		TotalPages: int64(totalPages),
+	})
+}
+
+func (s *rpcServer) GetV1QueryAllChainParams(ctx echo.Context) error {
+	// Get latest stored block height
+	currentHeight := int64(s.GetBus().GetConsensusModule().CurrentHeight())
+	if currentHeight > 0 {
+		currentHeight -= 1
+	}
+	readCtx, err := s.GetBus().GetPersistenceModule().NewReadContext(currentHeight)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+	defer readCtx.Release() //nolint:errcheck // We only need to make sure the readCtx is released
+
+	paramSlice, err := readCtx.GetAllParams()
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+	resp := make([]Parameter, 0)
+	for i := 0; i < len(paramSlice); i++ {
+		resp = append(resp, Parameter{
+			ParameterName:  paramSlice[i][0],
+			ParameterValue: paramSlice[i][1],
+		})
+	}
+	return ctx.JSON(200, resp)
+}
+
+func (s *rpcServer) PostV1QueryApp(ctx echo.Context) error {
+	var body QueryAddressHeight
+	if err := ctx.Bind(&body); err != nil {
+		return ctx.String(http.StatusBadRequest, ""bad request"")
+	}
+
+	// Get latest stored block height
+	height := body.Height
+	if height == 0 {
+		currentHeight := int64(s.GetBus().GetConsensusModule().CurrentHeight())
+		if currentHeight > 0 {
+			currentHeight -= 1
+		}
+		height = currentHeight
+	}
+	readCtx, err := s.GetBus().GetPersistenceModule().NewReadContext(height)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+	defer readCtx.Release() //nolint:errcheck // We only need to make sure the readCtx is released
+
+	addrBz, err := hex.DecodeString(body.Address)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+	application, err := readCtx.GetApp(addrBz, height)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+
+	actor := protocolActorToRPCProtocolActor(application)
+	return ctx.JSON(http.StatusOK, actor)
+}
+
+func (s *rpcServer) PostV1QueryApps(ctx echo.Context) error {
+	var body QueryHeightPaginated
+	if err := ctx.Bind(&body); err != nil {
+		return ctx.String(http.StatusBadRequest, ""bad request"")
+	}
+
+	// Get latest stored block height
+	height := body.Height
+	if height == 0 {
+		currentHeight := int64(s.GetBus().GetConsensusModule().CurrentHeight())
+		if currentHeight > 0 {
+			currentHeight -= 1
+		}
+		height = currentHeight
+	}
+	readCtx, err := s.GetBus().GetPersistenceModule().NewReadContext(height)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+	defer readCtx.Release() //nolint:errcheck // We only need to make sure the readCtx is released
+
+	allApps, err := readCtx.GetAllApps(height)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+
+	start, end, totalPages, err := getPageIndexes(len(allApps), int(body.Page), int(body.PerPage))
+	if err != nil && !errors.Is(err, errNoItems) {
+		return ctx.String(http.StatusBadRequest, err.Error())
+	}
+	if totalPages == 0 || errors.Is(err, errNoItems) {
+		return ctx.JSON(http.StatusOK, QueryAppsResponse{})
+	}
+
+	rpcApps := make([]ProtocolActor, 0)
+	for _, app := range allApps[start : end+1] {
+		actor := protocolActorToRPCProtocolActor(app)
+		rpcApps = append(rpcApps, actor)
+	}
+
+	return ctx.JSON(http.StatusOK, QueryAppsResponse{
+		Apps:       rpcApps,
+		TotalApps:  int64(len(allApps)),
+		Page:       body.Page,
+		TotalPages: int64(totalPages),
+	})
+}
+
+func (s *rpcServer) PostV1QueryBalance(ctx echo.Context) error {
+	var body QueryAddressHeight
+	if err := ctx.Bind(&body); err != nil {
+		return ctx.String(http.StatusBadRequest, ""bad request"")
+	}
+
+	// Get latest stored block height
+	height := body.Height
+	if height == 0 {
+		currentHeight := int64(s.GetBus().GetConsensusModule().CurrentHeight())
+		if currentHeight > 0 {
+			currentHeight -= 1
+		}
+		height = currentHeight
+	}
+	readCtx, err := s.GetBus().GetPersistenceModule().NewReadContext(height)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+	defer readCtx.Release() //nolint:errcheck // We only need to make sure the readCtx is released
+
+	accBz, err := hex.DecodeString(body.Address)
+	if err != nil {
+		return ctx.String(http.StatusBadRequest, err.Error())
+	}
+	amountStr, err := readCtx.GetAccountAmount(accBz, height)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+	amount, err := strconv.ParseInt(amountStr, 10, 64)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+
+	return ctx.JSON(http.StatusOK, QueryBalanceResponse{
+		Balance: amount,
+	})
+}
+
+func (s *rpcServer) PostV1QueryBlock(ctx echo.Context) error {
+	var body QueryHeight
+	if err := ctx.Bind(&body); err != nil {
+		return ctx.String(http.StatusBadRequest, ""bad request"")
+	}
+
+	// Get latest stored block height
+	height := uint64(body.Height)
+	if height == 0 {
+		currentHeight := s.GetBus().GetConsensusModule().CurrentHeight()
+		if currentHeight > 0 {
+			currentHeight -= 1
+		}
+		height = currentHeight
+	}
+
+	blockStore := s.GetBus().GetPersistenceModule().GetBlockStore()
+	blockBz, err := blockStore.Get(utils.HeightToBytes(height))",rpc/handlers_query.go,2023-05-02 01:15:48+00:00,2023-05-02T02:27:54Z,"Regarding the height comment I left above. I feel like if `height==0` in the body and `currentHeight > 0` in the consensus module, we would always set it to `-1`",,,,255.0,306,RIGHT,306,255.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/684,pokt-network/pocket,9359cdf1837fa6bf84632f6ccc8dfb05de0f7296
https://api.github.com/repos/pokt-network/pocket/pulls/684,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1182004593,Olshansk,964333fcec0ccb79708af5ce07dbab1cf5efb3a5,9fb091614f1874101a5e3f3b35e5eadb67fa32ea,"@@ -0,0 +1,854 @@
+package rpc
+
+import (
+	""encoding/hex""
+	""errors""
+	""fmt""
+	""math/big""
+	""net/http""
+	""strconv""
+
+	""github.com/labstack/echo/v4""
+	""github.com/pokt-network/pocket/shared/codec""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/utils""
+)
+
+// Queries
+
+func (s *rpcServer) PostV1QueryAccount(ctx echo.Context) error {
+	var body QueryAddressHeight
+	if err := ctx.Bind(&body); err != nil {
+		return ctx.String(http.StatusBadRequest, ""bad request"")
+	}
+
+	// Get latest stored block height
+	height := body.Height
+	if height == 0 {
+		currentHeight := int64(s.GetBus().GetConsensusModule().CurrentHeight())
+		if currentHeight > 0 {
+			currentHeight -= 1
+		}
+		height = currentHeight
+	}
+	readCtx, err := s.GetBus().GetPersistenceModule().NewReadContext(height)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+	defer readCtx.Release() //nolint:errcheck // We only need to make sure the readCtx is released
+
+	accBz, err := hex.DecodeString(body.Address)
+	if err != nil {
+		return ctx.String(http.StatusBadRequest, err.Error())
+	}
+	amount, err := readCtx.GetAccountAmount(accBz, height)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+
+	return ctx.JSON(http.StatusOK, Account{
+		Address: body.Address,
+		Coins:   []Coin{{Amount: amount, Denom: ""upokt""}},
+	})
+}
+
+func (s *rpcServer) PostV1QueryAccounts(ctx echo.Context) error {
+	var body QueryHeightPaginated
+	if err := ctx.Bind(&body); err != nil {
+		return ctx.String(http.StatusBadRequest, ""bad request"")
+	}
+
+	// Get latest stored block height
+	height := body.Height
+	if height == 0 {
+		currentHeight := int64(s.GetBus().GetConsensusModule().CurrentHeight())
+		if currentHeight > 0 {
+			currentHeight -= 1
+		}
+		height = currentHeight
+	}
+	readCtx, err := s.GetBus().GetPersistenceModule().NewReadContext(height)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+	defer readCtx.Release() //nolint:errcheck // We only need to make sure the readCtx is released
+
+	allAccounts, err := readCtx.GetAllAccounts(height)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+
+	start, end, totalPages, err := getPageIndexes(len(allAccounts), int(body.Page), int(body.PerPage))
+	if err != nil && !errors.Is(err, errNoItems) {
+		return ctx.String(http.StatusBadRequest, err.Error())
+	}
+	if totalPages == 0 || errors.Is(err, errNoItems) {
+		return ctx.JSON(http.StatusOK, QueryAccountsResponse{})
+	}
+
+	accounts := make([]Account, 0)
+	for _, account := range allAccounts[start : end+1] {
+		accounts = append(accounts, Account{
+			Address: account.Address,
+			Coins:   []Coin{{Amount: account.Amount, Denom: ""upokt""}},
+		})
+	}
+
+	return ctx.JSON(http.StatusOK, QueryAccountsResponse{
+		Result:     accounts,
+		Page:       body.Page,
+		TotalPages: int64(totalPages),
+	})
+}
+
+func (s *rpcServer) PostV1QueryAccountTxs(ctx echo.Context) error {
+	var body QueryAddressPaginated
+	if err := ctx.Bind(&body); err != nil {
+		return ctx.String(http.StatusBadRequest, ""bad request"")
+	}
+	sortDesc := checkSortDesc(*body.Sort)
+
+	txIndexer := s.GetBus().GetPersistenceModule().GetTxIndexer()
+	txResults, err := txIndexer.GetBySender(body.Address, sortDesc)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+
+	start, end, totalPages, err := getPageIndexes(len(txResults), int(body.Page), int(body.PerPage))
+	if err != nil && !errors.Is(err, errNoItems) {
+		return ctx.String(http.StatusBadRequest, err.Error())
+	}
+	if totalPages == 0 || errors.Is(err, errNoItems) {
+		return ctx.JSON(http.StatusOK, QueryAccountTxsResponse{})
+	}
+
+	pageTxs := make([]Transaction, 0)
+	for _, txResult := range txResults[start : end+1] {
+		rpcTx, err := s.txResultToRPCTransaction(txResult)
+		if err != nil {
+			return ctx.String(http.StatusInternalServerError, err.Error())
+		}
+		pageTxs = append(pageTxs, *rpcTx)
+	}
+
+	return ctx.JSON(http.StatusOK, QueryAccountTxsResponse{
+		Txs:        pageTxs,
+		Page:       body.Page,
+		TotalTxs:   int64(len(txResults)),
+		TotalPages: int64(totalPages),
+	})
+}
+
+func (s *rpcServer) GetV1QueryAllChainParams(ctx echo.Context) error {
+	// Get latest stored block height
+	currentHeight := int64(s.GetBus().GetConsensusModule().CurrentHeight())
+	if currentHeight > 0 {
+		currentHeight -= 1
+	}
+	readCtx, err := s.GetBus().GetPersistenceModule().NewReadContext(currentHeight)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+	defer readCtx.Release() //nolint:errcheck // We only need to make sure the readCtx is released
+
+	paramSlice, err := readCtx.GetAllParams()
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+	resp := make([]Parameter, 0)
+	for i := 0; i < len(paramSlice); i++ {
+		resp = append(resp, Parameter{
+			ParameterName:  paramSlice[i][0],
+			ParameterValue: paramSlice[i][1],
+		})
+	}
+	return ctx.JSON(200, resp)
+}
+
+func (s *rpcServer) PostV1QueryApp(ctx echo.Context) error {
+	var body QueryAddressHeight
+	if err := ctx.Bind(&body); err != nil {
+		return ctx.String(http.StatusBadRequest, ""bad request"")
+	}
+
+	// Get latest stored block height
+	height := body.Height
+	if height == 0 {
+		currentHeight := int64(s.GetBus().GetConsensusModule().CurrentHeight())
+		if currentHeight > 0 {
+			currentHeight -= 1
+		}
+		height = currentHeight
+	}
+	readCtx, err := s.GetBus().GetPersistenceModule().NewReadContext(height)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+	defer readCtx.Release() //nolint:errcheck // We only need to make sure the readCtx is released
+
+	addrBz, err := hex.DecodeString(body.Address)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+	application, err := readCtx.GetApp(addrBz, height)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+
+	actor := protocolActorToRPCProtocolActor(application)
+	return ctx.JSON(http.StatusOK, actor)
+}
+
+func (s *rpcServer) PostV1QueryApps(ctx echo.Context) error {
+	var body QueryHeightPaginated
+	if err := ctx.Bind(&body); err != nil {
+		return ctx.String(http.StatusBadRequest, ""bad request"")
+	}
+
+	// Get latest stored block height
+	height := body.Height
+	if height == 0 {
+		currentHeight := int64(s.GetBus().GetConsensusModule().CurrentHeight())
+		if currentHeight > 0 {
+			currentHeight -= 1
+		}
+		height = currentHeight
+	}
+	readCtx, err := s.GetBus().GetPersistenceModule().NewReadContext(height)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+	defer readCtx.Release() //nolint:errcheck // We only need to make sure the readCtx is released
+
+	allApps, err := readCtx.GetAllApps(height)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+
+	start, end, totalPages, err := getPageIndexes(len(allApps), int(body.Page), int(body.PerPage))
+	if err != nil && !errors.Is(err, errNoItems) {
+		return ctx.String(http.StatusBadRequest, err.Error())
+	}
+	if totalPages == 0 || errors.Is(err, errNoItems) {
+		return ctx.JSON(http.StatusOK, QueryAppsResponse{})
+	}
+
+	rpcApps := make([]ProtocolActor, 0)
+	for _, app := range allApps[start : end+1] {
+		actor := protocolActorToRPCProtocolActor(app)
+		rpcApps = append(rpcApps, actor)
+	}
+
+	return ctx.JSON(http.StatusOK, QueryAppsResponse{
+		Apps:       rpcApps,
+		TotalApps:  int64(len(allApps)),
+		Page:       body.Page,
+		TotalPages: int64(totalPages),
+	})
+}
+
+func (s *rpcServer) PostV1QueryBalance(ctx echo.Context) error {
+	var body QueryAddressHeight
+	if err := ctx.Bind(&body); err != nil {
+		return ctx.String(http.StatusBadRequest, ""bad request"")
+	}
+
+	// Get latest stored block height
+	height := body.Height
+	if height == 0 {
+		currentHeight := int64(s.GetBus().GetConsensusModule().CurrentHeight())
+		if currentHeight > 0 {
+			currentHeight -= 1
+		}
+		height = currentHeight
+	}
+	readCtx, err := s.GetBus().GetPersistenceModule().NewReadContext(height)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+	defer readCtx.Release() //nolint:errcheck // We only need to make sure the readCtx is released
+
+	accBz, err := hex.DecodeString(body.Address)
+	if err != nil {
+		return ctx.String(http.StatusBadRequest, err.Error())
+	}
+	amountStr, err := readCtx.GetAccountAmount(accBz, height)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+	amount, err := strconv.ParseInt(amountStr, 10, 64)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+
+	return ctx.JSON(http.StatusOK, QueryBalanceResponse{
+		Balance: amount,
+	})
+}
+
+func (s *rpcServer) PostV1QueryBlock(ctx echo.Context) error {
+	var body QueryHeight
+	if err := ctx.Bind(&body); err != nil {
+		return ctx.String(http.StatusBadRequest, ""bad request"")
+	}
+
+	// Get latest stored block height
+	height := uint64(body.Height)
+	if height == 0 {
+		currentHeight := s.GetBus().GetConsensusModule().CurrentHeight()
+		if currentHeight > 0 {
+			currentHeight -= 1
+		}
+		height = currentHeight
+	}
+
+	blockStore := s.GetBus().GetPersistenceModule().GetBlockStore()
+	blockBz, err := blockStore.Get(utils.HeightToBytes(height))
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+
+	block := new(coreTypes.Block)
+	if err := codec.GetCodec().Unmarshal(blockBz, block); err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+	rpcBlock, err := s.blockToRPCBlock(block)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+
+	return ctx.JSON(http.StatusOK, rpcBlock)
+}
+
+func (s *rpcServer) PostV1QueryBlockTxs(ctx echo.Context) error {
+	var body QueryHeightPaginated
+	if err := ctx.Bind(&body); err != nil {
+		return ctx.String(http.StatusBadRequest, ""bad request"")
+	}
+	sortDesc := checkSortDesc(*body.Sort)
+
+	// Get latest stored block height
+	height := uint64(body.Height)
+	if height == 0 {
+		currentHeight := s.GetBus().GetConsensusModule().CurrentHeight()
+		if currentHeight > 0 {
+			currentHeight -= 1
+		}
+		height = currentHeight
+	}
+
+	blockStore := s.GetBus().GetPersistenceModule().GetBlockStore()
+	blockBz, err := blockStore.Get(utils.HeightToBytes(height))
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+
+	block := new(coreTypes.Block)
+	if err := codec.GetCodec().Unmarshal(blockBz, block); err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+	rpcBlock, err := s.blockToRPCBlock(block)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+	allTxs := rpcBlock.Transactions
+	if sortDesc {
+		for i, j := 0, len(allTxs)-1; i < j; i, j = i+1, j-1 {
+			allTxs[i], allTxs[j] = allTxs[j], allTxs[i]
+		}
+	}
+
+	start, end, totalPages, err := getPageIndexes(len(allTxs), int(body.Page), int(body.PerPage))
+	if err != nil && !errors.Is(err, errNoItems) {
+		return ctx.String(http.StatusBadRequest, err.Error())
+	}
+	if totalPages == 0 || errors.Is(err, errNoItems) {
+		return ctx.JSON(http.StatusOK, QueryTxsResponse{})
+	}
+
+	return ctx.JSON(http.StatusOK, QueryTxsResponse{
+		Transactions: allTxs[start : end+1],
+		TotalTxs:     int64(len(allTxs)),
+		Page:         body.Page,
+		TotalPages:   int64(totalPages),
+	})
+}
+
+func (s *rpcServer) PostV1QueryFisherman(ctx echo.Context) error {
+	var body QueryAddressHeight
+	if err := ctx.Bind(&body); err != nil {
+		return ctx.String(http.StatusBadRequest, ""bad request"")
+	}
+
+	// Get latest stored block height
+	height := body.Height
+	if height == 0 {
+		currentHeight := int64(s.GetBus().GetConsensusModule().CurrentHeight())
+		if currentHeight > 0 {
+			currentHeight -= 1
+		}
+		height = currentHeight
+	}
+	readCtx, err := s.GetBus().GetPersistenceModule().NewReadContext(height)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+	defer readCtx.Release() //nolint:errcheck // We only need to make sure the readCtx is released
+
+	addrBz, err := hex.DecodeString(body.Address)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+	fisherman, err := readCtx.GetFisherman(addrBz, height)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+
+	actor := protocolActorToRPCProtocolActor(fisherman)
+	return ctx.JSON(http.StatusOK, actor)
+}
+
+func (s *rpcServer) PostV1QueryFishermen(ctx echo.Context) error {
+	var body QueryHeightPaginated
+	if err := ctx.Bind(&body); err != nil {
+		return ctx.String(http.StatusBadRequest, ""bad request"")
+	}
+
+	// Get latest stored block height
+	height := body.Height
+	if height == 0 {
+		currentHeight := int64(s.GetBus().GetConsensusModule().CurrentHeight())
+		if currentHeight > 0 {
+			currentHeight -= 1
+		}
+		height = currentHeight
+	}
+	readCtx, err := s.GetBus().GetPersistenceModule().NewReadContext(height)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+	defer readCtx.Release() //nolint:errcheck // We only need to make sure the readCtx is released
+
+	allFishermen, err := readCtx.GetAllFishermen(height)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+
+	start, end, totalPages, err := getPageIndexes(len(allFishermen), int(body.Page), int(body.PerPage))
+	if err != nil && !errors.Is(err, errNoItems) {
+		return ctx.String(http.StatusBadRequest, err.Error())
+	}
+	if totalPages == 0 || errors.Is(err, errNoItems) {
+		return ctx.JSON(http.StatusOK, QueryFishermenResponse{})
+	}
+
+	rpcFishermen := make([]ProtocolActor, 0)
+	for _, fisher := range allFishermen[start : end+1] {
+		actor := protocolActorToRPCProtocolActor(fisher)
+		rpcFishermen = append(rpcFishermen, actor)
+	}
+
+	return ctx.JSON(http.StatusOK, QueryFishermenResponse{
+		Fishermen:      rpcFishermen,
+		TotalFishermen: int64(len(allFishermen)),
+		Page:           body.Page,
+		TotalPages:     int64(totalPages),
+	})
+}
+
+func (s *rpcServer) GetV1QueryHeight(ctx echo.Context) error {
+	// Get latest stored block height
+	currentHeight := s.GetBus().GetConsensusModule().CurrentHeight()
+	if currentHeight > 0 {
+		currentHeight -= 1
+	}
+
+	return ctx.JSON(http.StatusOK, QueryHeight{
+		Height: int64(currentHeight),
+	})
+}
+
+func (s *rpcServer) PostV1QueryParam(ctx echo.Context) error {
+	var body QueryParameter
+	if err := ctx.Bind(&body); err != nil {
+		return ctx.String(http.StatusBadRequest, ""bad request"")
+	}
+
+	// Get latest stored block height
+	currentHeight := int64(s.GetBus().GetConsensusModule().CurrentHeight())
+	if currentHeight > 0 {
+		currentHeight -= 1
+	}
+	height := body.Height
+	if height == 0 || height > currentHeight {
+		height = currentHeight
+	}
+
+	readCtx, err := s.GetBus().GetPersistenceModule().NewReadContext(height)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+	defer readCtx.Release() //nolint:errcheck // We only need to make sure the readCtx is released
+
+	paramValue, err := readCtx.GetStringParam(body.ParamName, height)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+
+	return ctx.JSON(http.StatusOK, Parameter{
+		ParameterName:  body.ParamName,
+		ParameterValue: paramValue,
+	})
+}
+
+func (s *rpcServer) PostV1QueryServicer(ctx echo.Context) error {
+	var body QueryAddressHeight
+	if err := ctx.Bind(&body); err != nil {
+		return ctx.String(http.StatusBadRequest, ""bad request"")
+	}
+
+	// Get latest stored block height
+	height := body.Height
+	if height == 0 {
+		currentHeight := int64(s.GetBus().GetConsensusModule().CurrentHeight())
+		if currentHeight > 0 {
+			currentHeight -= 1
+		}
+		height = currentHeight
+	}
+	readCtx, err := s.GetBus().GetPersistenceModule().NewReadContext(height)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+	defer readCtx.Release() //nolint:errcheck // We only need to make sure the readCtx is released
+
+	addrBz, err := hex.DecodeString(body.Address)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+	servicer, err := readCtx.GetServicer(addrBz, height)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+
+	actor := protocolActorToRPCProtocolActor(servicer)
+	return ctx.JSON(http.StatusOK, actor)
+}
+
+func (s *rpcServer) PostV1QueryServicers(ctx echo.Context) error {
+	var body QueryHeightPaginated
+	if err := ctx.Bind(&body); err != nil {
+		return ctx.String(http.StatusBadRequest, ""bad request"")
+	}
+
+	// Get latest stored block height
+	height := body.Height
+	if height == 0 {
+		currentHeight := int64(s.GetBus().GetConsensusModule().CurrentHeight())
+		if currentHeight > 0 {
+			currentHeight -= 1
+		}
+		height = currentHeight
+	}
+	readCtx, err := s.GetBus().GetPersistenceModule().NewReadContext(height)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+	defer readCtx.Release() //nolint:errcheck // We only need to make sure the readCtx is released
+
+	allServicers, err := readCtx.GetAllServicers(height)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+
+	start, end, totalPages, err := getPageIndexes(len(allServicers), int(body.Page), int(body.PerPage))
+	if err != nil && !errors.Is(err, errNoItems) {
+		return ctx.String(http.StatusBadRequest, err.Error())
+	}
+	if totalPages == 0 || errors.Is(err, errNoItems) {
+		return ctx.JSON(http.StatusOK, QueryServicersResponse{})
+	}
+
+	rpcServicers := make([]ProtocolActor, 0)
+	for _, servicer := range allServicers[start : end+1] {
+		actor := protocolActorToRPCProtocolActor(servicer)
+		rpcServicers = append(rpcServicers, actor)
+	}
+
+	return ctx.JSON(http.StatusOK, QueryServicersResponse{
+		Servicers:      rpcServicers,
+		TotalServicers: int64(len(allServicers)),
+		Page:           body.Page,
+		TotalPages:     int64(totalPages),
+	})
+}
+
+func (s *rpcServer) PostV1QuerySupply(ctx echo.Context) error {
+	var body QueryHeight
+	if err := ctx.Bind(&body); err != nil {
+		return ctx.String(http.StatusBadRequest, ""bad request"")
+	}
+
+	// Get latest stored block height
+	height := body.Height
+	if height == 0 {
+		currentHeight := int64(s.GetBus().GetConsensusModule().CurrentHeight())
+		if currentHeight > 0 {
+			currentHeight -= 1
+		}
+		height = currentHeight
+	}
+	readCtx, err := s.GetBus().GetPersistenceModule().NewReadContext(height)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+	defer readCtx.Release() //nolint:errcheck // We only need to make sure the readCtx is released
+
+	pools, err := readCtx.GetAllPools(height)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+
+	rpcPools := make([]Pool, 0)
+	total := new(big.Int)
+	for _, pool := range pools {
+		name := coreTypes.PoolAddressToFriendlyName(pool.Address)
+		amount, success := new(big.Int).SetString(pool.Amount, 10)
+		if !success {
+			return ctx.String(http.StatusInternalServerError, ""failed to convert amount to big.Int"")
+		}
+		total = total.Add(total, amount)
+		rpcPools = append(rpcPools, Pool{
+			Address: pool.Address,
+			Name:    name,
+			Amount:  pool.Amount,
+			Denom:   ""upokt"",
+		})
+	}
+
+	return ctx.JSON(http.StatusOK, QuerySupplyResponse{
+		Pools: rpcPools,
+		Total: Coin{
+			Amount: total.String(),
+			Denom:  ""upokt"",
+		},
+	})
+}
+
+func (s *rpcServer) PostV1QuerySupportedChains(ctx echo.Context) error {
+	var body QueryHeight
+	if err := ctx.Bind(&body); err != nil {
+		return ctx.String(http.StatusBadRequest, ""bad request"")
+	}
+
+	// Get latest stored block height
+	height := body.Height
+	if height == 0 {
+		currentHeight := int64(s.GetBus().GetConsensusModule().CurrentHeight())
+		if currentHeight > 0 {
+			currentHeight -= 1
+		}
+		height = currentHeight
+	}
+	readCtx, err := s.GetBus().GetPersistenceModule().NewReadContext(height)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+	defer readCtx.Release() //nolint:errcheck // We only need to make sure the readCtx is released
+
+	chains, err := readCtx.GetSupportedChains(height)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+
+	return ctx.JSON(http.StatusOK, QuerySupportedChainsResponse{
+		SupportedChains: chains,
+	})
+}
+
+func (s *rpcServer) PostV1QueryTx(ctx echo.Context) error {
+	var body QueryHash
+	if err := ctx.Bind(&body); err != nil {
+		return ctx.String(http.StatusBadRequest, ""bad request"")
+	}
+
+	hashBz, err := hex.DecodeString(body.Hash)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+	txIndexer := s.GetBus().GetPersistenceModule().GetTxIndexer()
+	txResult, err := txIndexer.GetByHash(hashBz)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+
+	rpcTx, err := s.txResultToRPCTransaction(txResult)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+
+	return ctx.JSON(http.StatusOK, rpcTx)
+}
+
+func (s *rpcServer) PostV1QueryUnconfirmedTx(ctx echo.Context) error {
+	var body QueryHash
+	if err := ctx.Bind(&body); err != nil {
+		return ctx.String(http.StatusBadRequest, ""bad request"")
+	}
+
+	mempool := s.GetBus().GetUtilityModule().GetMempool()
+	uncTx := mempool.Get(body.Hash)
+	if uncTx == nil {
+		return ctx.String(http.StatusBadRequest, fmt.Sprintf(""hash not found in mempool: %s"", body.Hash))
+	}
+
+	rpcUncTxs, err := s.txProtoBytesToRPCTransactions([][]byte{uncTx})
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+
+	return ctx.JSON(http.StatusOK, rpcUncTxs[0])
+}
+
+func (s *rpcServer) PostV1QueryUnconfirmedTxs(ctx echo.Context) error {
+	var body QueryPaginated
+	if err := ctx.Bind(&body); err != nil {
+		return ctx.String(http.StatusBadRequest, ""bad request"")
+	}
+
+	mempool := s.GetBus().GetUtilityModule().GetMempool()
+	uncTxs := mempool.GetAll()
+
+	start, end, totalPages, err := getPageIndexes(len(uncTxs), int(body.Page), int(body.PerPage))
+	if err != nil && !errors.Is(err, errNoItems) {
+		return ctx.String(http.StatusBadRequest, err.Error())
+	}
+	if totalPages == 0 || errors.Is(err, errNoItems) {
+		return ctx.JSON(http.StatusOK, QueryTxsResponse{})
+	}
+
+	rpcUncTxs, err := s.txProtoBytesToRPCTransactions(uncTxs[start : end+1])
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+
+	return ctx.JSON(http.StatusOK, QueryTxsResponse{
+		Transactions: rpcUncTxs,
+		TotalTxs:     int64(len(uncTxs)),
+		Page:         body.Page,
+		TotalPages:   int64(totalPages),
+	})
+}
+
+func (s *rpcServer) PostV1QueryUpgrade(ctx echo.Context) error {
+	var body QueryHeight
+	if err := ctx.Bind(&body); err != nil {
+		return ctx.String(http.StatusBadRequest, ""bad request"")
+	}
+
+	// Get latest stored block height
+	height := body.Height
+	if height == 0 {
+		currentHeight := int64(s.GetBus().GetConsensusModule().CurrentHeight())
+		if currentHeight > 0 {
+			currentHeight -= 1
+		}
+		height = currentHeight
+	}
+	reatCtx, err := s.GetBus().GetPersistenceModule().NewReadContext(height)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+
+	version, err := reatCtx.GetVersionAtHeight(height)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+
+	return ctx.JSON(http.StatusOK, QueryUpgradeResponse{
+		Height:  height,
+		Version: version,
+	})
+}
+
+func (s *rpcServer) PostV1QueryValidator(ctx echo.Context) error {
+	var body QueryAddressHeight
+	if err := ctx.Bind(&body); err != nil {
+		return ctx.String(http.StatusBadRequest, ""bad request"")
+	}
+
+	// Get latest stored block height
+	height := body.Height
+	if height == 0 {
+		currentHeight := int64(s.GetBus().GetConsensusModule().CurrentHeight())
+		if currentHeight > 0 {
+			currentHeight -= 1
+		}
+		height = currentHeight
+	}
+	readCtx, err := s.GetBus().GetPersistenceModule().NewReadContext(height)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+	defer readCtx.Release() //nolint:errcheck // We only need to make sure the readCtx is released
+
+	addrBz, err := hex.DecodeString(body.Address)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+	validator, err := readCtx.GetValidator(addrBz, height)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+
+	actor := protocolActorToRPCProtocolActor(validator)
+	return ctx.JSON(http.StatusOK, actor)
+}
+
+func (s *rpcServer) PostV1QueryValidators(ctx echo.Context) error {
+	var body QueryHeightPaginated
+	if err := ctx.Bind(&body); err != nil {
+		return ctx.String(http.StatusBadRequest, ""bad request"")
+	}
+
+	// Get latest stored block height
+	height := body.Height
+	if height == 0 {
+		currentHeight := int64(s.GetBus().GetConsensusModule().CurrentHeight())
+		if currentHeight > 0 {
+			currentHeight -= 1
+		}
+		height = currentHeight
+	}
+	readCtx, err := s.GetBus().GetPersistenceModule().NewReadContext(height)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+	defer readCtx.Release() //nolint:errcheck // We only need to make sure the readCtx is released
+
+	allValidators, err := readCtx.GetAllValidators(height)
+	if err != nil {
+		return ctx.String(http.StatusInternalServerError, err.Error())
+	}
+
+	start, end, totalPages, err := getPageIndexes(len(allValidators), int(body.Page), int(body.PerPage))
+	if err != nil && !errors.Is(err, errNoItems) {
+		return ctx.String(http.StatusBadRequest, err.Error())
+	}
+	if totalPages == 0 || errors.Is(err, errNoItems) {
+		return ctx.JSON(http.StatusOK, QueryValidatorsResponse{})
+	}
+
+	rpcValidators := make([]ProtocolActor, 0)
+	for _, val := range allValidators[start : end+1] {
+		actor := protocolActorToRPCProtocolActor(val)
+		rpcValidators = append(rpcValidators, actor)
+	}
+
+	return ctx.JSON(http.StatusOK, QueryValidatorsResponse{
+		Validators:      rpcValidators,
+		TotalValidators: int64(len(allValidators)),
+		Page:            body.Page,
+		TotalPages:      int64(totalPages),
+	})
+}",rpc/handlers_query.go,2023-05-02 01:17:11+00:00,2023-05-02T02:27:54Z,"Not actionable: This file is a lot of redundant code so I didn't review the whole thing line by line so if there's anything where you thought ""We should do this in the future"", please add TODO comments.",,,,695.0,854,RIGHT,854,695.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/684,pokt-network/pocket,9359cdf1837fa6bf84632f6ccc8dfb05de0f7296
https://api.github.com/repos/pokt-network/pocket/pulls/684,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1182005506,Olshansk,964333fcec0ccb79708af5ce07dbab1cf5efb3a5,9fb091614f1874101a5e3f3b35e5eadb67fa32ea,"@@ -91,6 +93,94 @@ paths:
           content:
             text/plain:
               example: ""description of failure""
+  /v1/client/get_session:
+    post:
+      tags:
+        - client
+      summary: Sends a session request to the network and get the nodes that will be servicing your requests for the session
+      requestBody:
+        description: Request the nodes that will be servicing the requests in your session",rpc/v1/openapi.yaml,2023-05-02 01:19:42+00:00,2023-05-02T02:27:54Z,"```suggestion
        description: Retrieve the list of actors involved in servicing and verifying a sessio
```",,,,,102,RIGHT,26,,line,https://api.github.com/repos/pokt-network/pocket/pulls/684,pokt-network/pocket,9359cdf1837fa6bf84632f6ccc8dfb05de0f7296
https://api.github.com/repos/pokt-network/pocket/pulls/684,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1182005752,Olshansk,964333fcec0ccb79708af5ce07dbab1cf5efb3a5,9fb091614f1874101a5e3f3b35e5eadb67fa32ea,"@@ -91,6 +93,94 @@ paths:
           content:
             text/plain:
               example: ""description of failure""
+  /v1/client/get_session:
+    post:
+      tags:
+        - client
+      summary: Sends a session request to the network and get the nodes that will be servicing your requests for the session
+      requestBody:
+        description: Request the nodes that will be servicing the requests in your session
+        content:
+          application/json:
+            schema:
+              $ref: ""#/components/schemas/SessionRequest""
+        required: true
+      responses:
+        ""200"":
+          description: Session servicer response",rpc/v1/openapi.yaml,2023-05-02 01:20:25+00:00,2023-05-02T02:27:54Z,"```suggestion
          description: Session response
```",,,,,110,RIGHT,34,,line,https://api.github.com/repos/pokt-network/pocket/pulls/684,pokt-network/pocket,9359cdf1837fa6bf84632f6ccc8dfb05de0f7296
https://api.github.com/repos/pokt-network/pocket/pulls/684,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1182006003,Olshansk,964333fcec0ccb79708af5ce07dbab1cf5efb3a5,9fb091614f1874101a5e3f3b35e5eadb67fa32ea,"@@ -91,6 +93,94 @@ paths:
           content:
             text/plain:
               example: ""description of failure""
+  /v1/client/get_session:
+    post:
+      tags:
+        - client
+      summary: Sends a session request to the network and get the nodes that will be servicing your requests for the session
+      requestBody:
+        description: Request the nodes that will be servicing the requests in your session
+        content:
+          application/json:
+            schema:
+              $ref: ""#/components/schemas/SessionRequest""
+        required: true
+      responses:
+        ""200"":
+          description: Session servicer response
+          content:
+            application/json:
+              schema:
+                $ref: ""#/components/schemas/Session""
+        ""400"":
+          description: Bad request
+          content:
+            text/plain:
+              example: ""description of failure""
+        ""500"":
+          description: An error occurred while sending the session request to the network
+          content:
+            text/plain:
+              example: ""description of failure""
+  /v1/client/relay:
+    post:
+      tags:
+        - client
+      summary: Sends a challenge request to the network to service the RPC request",rpc/v1/openapi.yaml,2023-05-02 01:21:16+00:00,2023-05-02T02:27:54Z,"```suggestion
      summary: Sends a relay to the servicer to receive a response
```",,,,,129,RIGHT,53,,line,https://api.github.com/repos/pokt-network/pocket/pulls/684,pokt-network/pocket,9359cdf1837fa6bf84632f6ccc8dfb05de0f7296
https://api.github.com/repos/pokt-network/pocket/pulls/684,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1182006324,Olshansk,964333fcec0ccb79708af5ce07dbab1cf5efb3a5,9fb091614f1874101a5e3f3b35e5eadb67fa32ea,"@@ -91,6 +93,94 @@ paths:
           content:
             text/plain:
               example: ""description of failure""
+  /v1/client/get_session:
+    post:
+      tags:
+        - client
+      summary: Sends a session request to the network and get the nodes that will be servicing your requests for the session
+      requestBody:
+        description: Request the nodes that will be servicing the requests in your session
+        content:
+          application/json:
+            schema:
+              $ref: ""#/components/schemas/SessionRequest""
+        required: true
+      responses:
+        ""200"":
+          description: Session servicer response
+          content:
+            application/json:
+              schema:
+                $ref: ""#/components/schemas/Session""
+        ""400"":
+          description: Bad request
+          content:
+            text/plain:
+              example: ""description of failure""
+        ""500"":
+          description: An error occurred while sending the session request to the network
+          content:
+            text/plain:
+              example: ""description of failure""
+  /v1/client/relay:
+    post:
+      tags:
+        - client
+      summary: Sends a challenge request to the network to service the RPC request
+      requestBody:
+        description: Request a relay to be sent on behalf of your application
+        content:
+          application/json:
+            schema:
+              $ref: ""#/components/schemas/RelayRequest""
+        required: true
+      responses:
+        ""200"":
+          description: Relay request response
+          content:
+            application/json:
+              schema:
+                $ref: ""#/components/schemas/RelayResponse""
+        ""400"":
+          description: Bad request
+          content:
+            text/plain:
+              example: ""description of failure""
+        ""500"":
+          description: An error occurred while sending the relay request to the network
+          content:
+            text/plain:
+              example: ""description of failure""
+  /v1/client/challenge:
+    post:
+      tags:
+        - client
+      summary: Sends a relay request to the network to for invalid data returned from an RPC request",rpc/v1/openapi.yaml,2023-05-02 01:22:22+00:00,2023-05-02T02:27:54Z,"This is a challenge, not a relay",,,,,158,RIGHT,82,,line,https://api.github.com/repos/pokt-network/pocket/pulls/684,pokt-network/pocket,9359cdf1837fa6bf84632f6ccc8dfb05de0f7296
https://api.github.com/repos/pokt-network/pocket/pulls/684,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1182022674,Olshansk,964333fcec0ccb79708af5ce07dbab1cf5efb3a5,9fb091614f1874101a5e3f3b35e5eadb67fa32ea,"@@ -130,110 +218,1622 @@ paths:
           content:
             text/plain:
               example: ""description of failure""
-  /v1/query/allChainParams:
+
+  /v1/query/account:
+    post:
+      tags:
+        - query
+      summary: Returns the data of the account specified at a given height
+      requestBody:
+        description: Request account data at the specified height, height = 0 is used as the latest
+        content:
+          application/json:
+            schema:
+              $ref: ""#/components/schemas/QueryAddressHeight""",rpc/v1/openapi.yaml,2023-05-02 02:10:01+00:00,2023-05-02T02:27:54Z,s/QueryAddressHeight/QueryAccountHeight?,,,,,232,RIGHT,143,,line,https://api.github.com/repos/pokt-network/pocket/pulls/684,pokt-network/pocket,9359cdf1837fa6bf84632f6ccc8dfb05de0f7296
https://api.github.com/repos/pokt-network/pocket/pulls/684,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1182022834,Olshansk,964333fcec0ccb79708af5ce07dbab1cf5efb3a5,9fb091614f1874101a5e3f3b35e5eadb67fa32ea,"@@ -130,110 +218,1622 @@ paths:
           content:
             text/plain:
               example: ""description of failure""
-  /v1/query/allChainParams:
+
+  /v1/query/account:
+    post:
+      tags:
+        - query
+      summary: Returns the data of the account specified at a given height
+      requestBody:
+        description: Request account data at the specified height, height = 0 is used as the latest
+        content:
+          application/json:
+            schema:
+              $ref: ""#/components/schemas/QueryAddressHeight""
+            example:
+              address: da034209758b78eaea06dd99c07909ab54c99b45
+              height: 0
+        required: true
+      responses:
+        ""200"":
+          description: Returns account data at the specified height
+          content:
+            application/json:
+              schema:
+                $ref: ""#/components/schemas/Account""
+        ""400"":
+          description: Bad request
+          content:
+            text/plain:
+              example: ""description of failure""
+        ""500"":
+          description: An error occurred while retrieving the account data at the specified height
+          content:
+            text/plain:
+              example: ""description of failure""
+  /v1/query/accounts:
+    post:
+      tags:
+        - query
+      summary: Returns the paginated data of all accounts specified at a given height
+      requestBody:
+        description: Request all account data at the specified height, height = 0 is used as the latest; Max per_page=1000
+        content:
+          application/json:
+            schema:
+              $ref: ""#/components/schemas/QueryHeightPaginated""",rpc/v1/openapi.yaml,2023-05-02 02:10:25+00:00,2023-05-02T02:27:54Z,s/QUeryHeightPaginated/QueryAddressHeightPaginated/,,,,266.0,264,RIGHT,175,177.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/684,pokt-network/pocket,9359cdf1837fa6bf84632f6ccc8dfb05de0f7296
https://api.github.com/repos/pokt-network/pocket/pulls/684,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1182023127,Olshansk,964333fcec0ccb79708af5ce07dbab1cf5efb3a5,9fb091614f1874101a5e3f3b35e5eadb67fa32ea,"@@ -130,110 +218,1622 @@ paths:
           content:
             text/plain:
               example: ""description of failure""
-  /v1/query/allChainParams:
+
+  /v1/query/account:
+    post:
+      tags:
+        - query
+      summary: Returns the data of the account specified at a given height
+      requestBody:
+        description: Request account data at the specified height, height = 0 is used as the latest
+        content:
+          application/json:
+            schema:
+              $ref: ""#/components/schemas/QueryAddressHeight""
+            example:
+              address: da034209758b78eaea06dd99c07909ab54c99b45
+              height: 0
+        required: true
+      responses:
+        ""200"":
+          description: Returns account data at the specified height
+          content:
+            application/json:
+              schema:
+                $ref: ""#/components/schemas/Account""
+        ""400"":
+          description: Bad request
+          content:
+            text/plain:
+              example: ""description of failure""
+        ""500"":
+          description: An error occurred while retrieving the account data at the specified height
+          content:
+            text/plain:
+              example: ""description of failure""
+  /v1/query/accounts:
+    post:
+      tags:
+        - query
+      summary: Returns the paginated data of all accounts specified at a given height
+      requestBody:
+        description: Request all account data at the specified height, height = 0 is used as the latest; Max per_page=1000
+        content:
+          application/json:
+            schema:
+              $ref: ""#/components/schemas/QueryHeightPaginated""
+            example:
+              height: 0
+              page: 1
+              per_page: 50
+        required: true
+      responses:
+        ""200"":
+          description: Returns account data for all accounts at the specified height
+          content:
+            application/json:
+              schema:
+                $ref: ""#/components/schemas/QueryAccountsResponse""
+        ""400"":
+          description: Bad request
+          content:
+            text/plain:
+              example: ""description of failure""
+        ""500"":
+          description: An error occurred while retrieving accounts at the specified height
+          content:
+            text/plain:
+              example: ""description of failure""
+  /v1/query/account_txs:
+    post:
+      tags:
+        - query
+      summary: Returns all transactions sent by the specified address paginated
+      requestBody:
+        description: Returns all transactions sent by the address provided; Max per_page=1000, can be sorted either asc or desc (default)
+        content:
+          application/json:
+            schema:
+              $ref: ""#/components/schemas/QueryAddressPaginated""",rpc/v1/openapi.yaml,2023-05-02 02:11:12+00:00,2023-05-02T02:27:54Z,why is `QueryAddressPaginated` the ref for `account_txs`?,,,,,297,RIGHT,208,,line,https://api.github.com/repos/pokt-network/pocket/pulls/684,pokt-network/pocket,9359cdf1837fa6bf84632f6ccc8dfb05de0f7296
https://api.github.com/repos/pokt-network/pocket/pulls/684,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1182023274,Olshansk,964333fcec0ccb79708af5ce07dbab1cf5efb3a5,9fb091614f1874101a5e3f3b35e5eadb67fa32ea,"@@ -130,110 +218,1622 @@ paths:
           content:
             text/plain:
               example: ""description of failure""
-  /v1/query/allChainParams:
+
+  /v1/query/account:
+    post:
+      tags:
+        - query
+      summary: Returns the data of the account specified at a given height
+      requestBody:
+        description: Request account data at the specified height, height = 0 is used as the latest
+        content:
+          application/json:
+            schema:
+              $ref: ""#/components/schemas/QueryAddressHeight""
+            example:
+              address: da034209758b78eaea06dd99c07909ab54c99b45
+              height: 0
+        required: true
+      responses:
+        ""200"":
+          description: Returns account data at the specified height
+          content:
+            application/json:
+              schema:
+                $ref: ""#/components/schemas/Account""
+        ""400"":
+          description: Bad request
+          content:
+            text/plain:
+              example: ""description of failure""
+        ""500"":
+          description: An error occurred while retrieving the account data at the specified height
+          content:
+            text/plain:
+              example: ""description of failure""
+  /v1/query/accounts:
+    post:
+      tags:
+        - query
+      summary: Returns the paginated data of all accounts specified at a given height
+      requestBody:
+        description: Request all account data at the specified height, height = 0 is used as the latest; Max per_page=1000
+        content:
+          application/json:
+            schema:
+              $ref: ""#/components/schemas/QueryHeightPaginated""
+            example:
+              height: 0
+              page: 1
+              per_page: 50
+        required: true
+      responses:
+        ""200"":
+          description: Returns account data for all accounts at the specified height
+          content:
+            application/json:
+              schema:
+                $ref: ""#/components/schemas/QueryAccountsResponse""
+        ""400"":
+          description: Bad request
+          content:
+            text/plain:
+              example: ""description of failure""
+        ""500"":
+          description: An error occurred while retrieving accounts at the specified height
+          content:
+            text/plain:
+              example: ""description of failure""
+  /v1/query/account_txs:
+    post:
+      tags:
+        - query
+      summary: Returns all transactions sent by the specified address paginated
+      requestBody:
+        description: Returns all transactions sent by the address provided; Max per_page=1000, can be sorted either asc or desc (default)
+        content:
+          application/json:
+            schema:
+              $ref: ""#/components/schemas/QueryAddressPaginated""
+            example:
+              address: da034209758b78eaea06dd99c07909ab54c99b45
+              page: 1
+              per_page: 1000
+              sort: desc
+        required: true
+      responses:
+        ""200"":
+          description: Returns the transaction list for the account
+          content:
+            application/json:
+              schema:
+                $ref: ""#/components/schemas/QueryAccountTxsResponse""
+        ""400"":
+          description: Bad request
+          content:
+            text/plain:
+              example: ""description of failure""
+        ""500"":
+          description: An error occurred while retrieving the transactions for the account
+          content:
+            text/plain:
+              example: ""description of failure""
+  /v1/query/all_chain_params:
     get:
       tags:
         - query
       summary: Returns the current values of all governance parameters",rpc/v1/openapi.yaml,2023-05-02 02:11:37+00:00,2023-05-02T02:27:54Z,Is this the intended summary for all_chain_params?,,,,,325,RIGHT,236,,line,https://api.github.com/repos/pokt-network/pocket/pulls/684,pokt-network/pocket,9359cdf1837fa6bf84632f6ccc8dfb05de0f7296
https://api.github.com/repos/pokt-network/pocket/pulls/684,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1182023616,Olshansk,964333fcec0ccb79708af5ce07dbab1cf5efb3a5,9fb091614f1874101a5e3f3b35e5eadb67fa32ea,"@@ -130,110 +218,1622 @@ paths:
           content:
             text/plain:
               example: ""description of failure""
-  /v1/query/allChainParams:
+
+  /v1/query/account:
+    post:
+      tags:
+        - query
+      summary: Returns the data of the account specified at a given height
+      requestBody:
+        description: Request account data at the specified height, height = 0 is used as the latest
+        content:
+          application/json:
+            schema:
+              $ref: ""#/components/schemas/QueryAddressHeight""
+            example:
+              address: da034209758b78eaea06dd99c07909ab54c99b45
+              height: 0
+        required: true
+      responses:
+        ""200"":
+          description: Returns account data at the specified height
+          content:
+            application/json:
+              schema:
+                $ref: ""#/components/schemas/Account""
+        ""400"":
+          description: Bad request
+          content:
+            text/plain:
+              example: ""description of failure""
+        ""500"":
+          description: An error occurred while retrieving the account data at the specified height
+          content:
+            text/plain:
+              example: ""description of failure""
+  /v1/query/accounts:
+    post:
+      tags:
+        - query
+      summary: Returns the paginated data of all accounts specified at a given height
+      requestBody:
+        description: Request all account data at the specified height, height = 0 is used as the latest; Max per_page=1000
+        content:
+          application/json:
+            schema:
+              $ref: ""#/components/schemas/QueryHeightPaginated""
+            example:
+              height: 0
+              page: 1
+              per_page: 50
+        required: true
+      responses:
+        ""200"":
+          description: Returns account data for all accounts at the specified height
+          content:
+            application/json:
+              schema:
+                $ref: ""#/components/schemas/QueryAccountsResponse""
+        ""400"":
+          description: Bad request
+          content:
+            text/plain:
+              example: ""description of failure""
+        ""500"":
+          description: An error occurred while retrieving accounts at the specified height
+          content:
+            text/plain:
+              example: ""description of failure""
+  /v1/query/account_txs:
+    post:
+      tags:
+        - query
+      summary: Returns all transactions sent by the specified address paginated
+      requestBody:
+        description: Returns all transactions sent by the address provided; Max per_page=1000, can be sorted either asc or desc (default)
+        content:
+          application/json:
+            schema:
+              $ref: ""#/components/schemas/QueryAddressPaginated""
+            example:
+              address: da034209758b78eaea06dd99c07909ab54c99b45
+              page: 1
+              per_page: 1000
+              sort: desc
+        required: true
+      responses:
+        ""200"":
+          description: Returns the transaction list for the account
+          content:
+            application/json:
+              schema:
+                $ref: ""#/components/schemas/QueryAccountTxsResponse""
+        ""400"":
+          description: Bad request
+          content:
+            text/plain:
+              example: ""description of failure""
+        ""500"":
+          description: An error occurred while retrieving the transactions for the account
+          content:
+            text/plain:
+              example: ""description of failure""
+  /v1/query/all_chain_params:
     get:
       tags:
         - query
       summary: Returns the current values of all governance parameters
-
       responses:
         ""200"":
-          description: Node parameters response
+          description: Returns all the chain parameters
           content:
             application/json:
               schema:
                 $ref: ""#/components/schemas/AllChainParamsResponse""
         ""500"":
-          description: An error occurred while retrieving the current node parameters
+          description: An error occurred while retrieving the current chain parameters
           content:
             text/plain:
               example: ""description of failure""
-
-externalDocs:
-  description: Find out more about Pocket Network
-  url: ""https://pokt.network""
-components:
-  schemas:
-    RawTXRequest:
-      type: object
-      required:
-        - address
-        - raw_hex_bytes
-      properties:
-        address:
-          type: string
-        raw_hex_bytes:
-          type: string
-    ConsensusState:
-      type: object
-      required:
-        - height
-        - round
-        - step
-      properties:
-        height:
-          type: integer
-          format: int64
-        round:
-          type: integer
-          format: int64
-        step:
-          type: integer
-          format: int64
-    Actor:
-      type: object
-      required:
-        - type
-        - address
-        - public_key
-        - service_url
-      properties:
-        type:
-          $ref: ""#/components/schemas/ActorTypesEnum""
-        address:
-          type: string
-        public_key:
-          type: string
-        service_url:
-          type: string
-
-    P2PStakedActorsResponse:
-      type: object
-      required:
-        - actors
-        - height
-      properties:
-        actors:
-          type: ""array""
-          items:
-            $ref: ""#/components/schemas/Actor""
-        height:
-          type: integer
-          format: int64
-
-    ActorTypesEnum:
-      type: string
-      enum:
-        - validator
-        - servicer
-        - fisherman
-        - application
-
-    Parameter:
-      type: object
-      required:
-        - parameter_name
-        - parameter_value
-      properties:
-        parameter_name:
-          type: ""string""
-        parameter_value:
-          type: ""string""
-
-    AllChainParamsResponse:
-      type: array
-      items:
-        $ref: ""#/components/schemas/Parameter""
+  /v1/query/app:
+    post:
+      tags:
+        - query
+      summary: Returns the data for the specific app address at a given height
+      requestBody:
+        description: Request application data at the specified height, height = 0 is used as the latest
+        content:
+          application/json:
+            schema:
+              $ref: ""#/components/schemas/QueryAddressHeight""
+            example:
+              address: da034209758b78eaea06dd99c07909ab54c99b45
+              height: 0
+        required: true
+      responses:
+        ""200"":
+          description: Returns application data at the specified height
+          content:
+            application/json:
+              schema:
+                $ref: ""#/components/schemas/ProtocolActor""
+        ""400"":
+          description: Bad request
+          content:
+            text/plain:
+              example: ""description of failure""
+        ""500"":
+          description: An error occurred while retrieving the application data at the specified height
+          content:
+            text/plain:
+              example: ""description of failure""
+  # TODO: (h5law) Think of an equivalent to staking status",rpc/v1/openapi.yaml,2023-05-02 02:12:41+00:00,2023-05-02T02:27:54Z,Can you add a more descriptive TODO so anyone can pick this up in the future?,,,,,370,RIGHT,370,,line,https://api.github.com/repos/pokt-network/pocket/pulls/684,pokt-network/pocket,9359cdf1837fa6bf84632f6ccc8dfb05de0f7296
https://api.github.com/repos/pokt-network/pocket/pulls/684,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1182024432,Olshansk,964333fcec0ccb79708af5ce07dbab1cf5efb3a5,9fb091614f1874101a5e3f3b35e5eadb67fa32ea,"@@ -0,0 +1,455 @@
+package rpc
+
+import (
+	""encoding/base64""
+	""encoding/hex""
+	""fmt""
+	""math""
+	""regexp""
+	""strings""
+
+	conTypes ""github.com/pokt-network/pocket/consensus/types""
+	""github.com/pokt-network/pocket/shared/codec""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/modules""
+	""github.com/pokt-network/pocket/utility""
+	utilTypes ""github.com/pokt-network/pocket/utility/types""
+)
+
+const (
+	maxPerPage = 1000
+)
+
+var (
+	paramValueRegex *regexp.Regexp
+	errNoItems      = fmt.Errorf(""no items found"")
+)
+
+func init() {
+	paramValueRegex = regexp.MustCompile(`value:""(.+)""`)
+}
+
+// Broadcast to the entire validator set",rpc/utils.go,2023-05-02 02:15:02+00:00,2023-05-02T02:27:54Z,"```suggestion
// Broadcast to the entire network
```",,,,,32,RIGHT,32,,line,https://api.github.com/repos/pokt-network/pocket/pulls/684,pokt-network/pocket,9359cdf1837fa6bf84632f6ccc8dfb05de0f7296
https://api.github.com/repos/pokt-network/pocket/pulls/684,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1182025325,Olshansk,964333fcec0ccb79708af5ce07dbab1cf5efb3a5,9fb091614f1874101a5e3f3b35e5eadb67fa32ea,"@@ -0,0 +1,455 @@
+package rpc
+
+import (
+	""encoding/base64""
+	""encoding/hex""
+	""fmt""
+	""math""
+	""regexp""
+	""strings""
+
+	conTypes ""github.com/pokt-network/pocket/consensus/types""
+	""github.com/pokt-network/pocket/shared/codec""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/modules""
+	""github.com/pokt-network/pocket/utility""
+	utilTypes ""github.com/pokt-network/pocket/utility/types""
+)
+
+const (
+	maxPerPage = 1000
+)
+
+var (
+	paramValueRegex *regexp.Regexp
+	errNoItems      = fmt.Errorf(""no items found"")
+)
+
+func init() {
+	paramValueRegex = regexp.MustCompile(`value:""(.+)""`)
+}
+
+// Broadcast to the entire validator set
+func (s *rpcServer) broadcastMessage(msgBz []byte) error {
+	utilityMsg, err := utility.PrepareTxGossipMessage(msgBz)
+	if err != nil {
+		s.logger.Error().Err(err).Msg(""Failed to prepare transaction gossip message"")
+		return err
+	}
+
+	if err := s.GetBus().GetP2PModule().Broadcast(utilityMsg); err != nil {
+		s.logger.Error().Err(err).Msg(""Failed to broadcast utility message"")
+		return err
+	}
+
+	return nil
+}
+
+// checkSortDesc takes a sort string and returns whether to sort descending or not
+func checkSortDesc(sort string) bool {
+	return !strings.EqualFold(sort, ""asc"")
+}
+
+// getPageIndexes calculates the indexes for the page requested reading the number of items specified
+func getPageIndexes(totalItems, page, per_page int) (startIdx, endIdx, totalPages int, err error) {
+	if totalItems == 0 {
+		err = errNoItems
+		return
+	}
+	if per_page > maxPerPage {
+		err = fmt.Errorf(""per_page has a max value of %d"", maxPerPage)
+		return
+	}
+	if page == 0 || per_page == 0 {
+		err = fmt.Errorf(""page and per_page must both be greater than 0"")
+		return
+	}
+
+	totalPages = int(math.Ceil(float64(totalItems) / float64(per_page)))
+	startIdx = (page - 1) * per_page
+	if startIdx > totalItems-1 {
+		err = fmt.Errorf(""starting page too high: got %d, total pages: %d"", page, totalPages)
+		return
+	}
+	endIdx = (page * per_page) - 1
+	if endIdx >= totalItems {
+		endIdx = totalItems - 1 //  Last Index
+	}
+
+	return startIdx, endIdx, totalPages, nil
+}
+
+// protocolActorToRPCProtocolActor converts the coreTypes.Actor to an RPC ProtocolActor
+func protocolActorToRPCProtocolActor(actor *coreTypes.Actor) ProtocolActor {
+	return ProtocolActor{
+		Address:         actor.Address,
+		ActorType:       protocolActorToRPCActorTypeEnum(actor.ActorType),
+		PublicKey:       actor.PublicKey,
+		Chains:          actor.Chains,
+		ServiceUrl:      actor.ServiceUrl,
+		StakedAmount:    actor.StakedAmount,
+		PausedHeight:    actor.PausedHeight,
+		UnstakingHeight: actor.UnstakingHeight,
+		OutputAddr:      actor.Output,
+	}
+}
+
+// txResultToRPCTransaction converts the txResult protobuf into the RPC Transaction type",rpc/utils.go,2023-05-02 02:17:35+00:00,2023-05-02T02:27:54Z,"Let's be consistent and avoid `tx` and `Transaction` in the same function name. DItto below

e.g. `txResultToRPCTx`",,,,,97,RIGHT,97,,line,https://api.github.com/repos/pokt-network/pocket/pulls/684,pokt-network/pocket,9359cdf1837fa6bf84632f6ccc8dfb05de0f7296
https://api.github.com/repos/pokt-network/pocket/pulls/684,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1182028506,Olshansk,964333fcec0ccb79708af5ce07dbab1cf5efb3a5,9fb091614f1874101a5e3f3b35e5eadb67fa32ea,"@@ -130,110 +218,1622 @@ paths:
           content:
             text/plain:
               example: ""description of failure""
-  /v1/query/allChainParams:
+
+  /v1/query/account:
+    post:
+      tags:
+        - query
+      summary: Returns the data of the account specified at a given height
+      requestBody:
+        description: Request account data at the specified height, height = 0 is used as the latest
+        content:
+          application/json:
+            schema:
+              $ref: ""#/components/schemas/QueryAddressHeight""
+            example:
+              address: da034209758b78eaea06dd99c07909ab54c99b45
+              height: 0
+        required: true
+      responses:
+        ""200"":
+          description: Returns account data at the specified height
+          content:
+            application/json:
+              schema:
+                $ref: ""#/components/schemas/Account""
+        ""400"":
+          description: Bad request
+          content:
+            text/plain:
+              example: ""description of failure""
+        ""500"":
+          description: An error occurred while retrieving the account data at the specified height
+          content:
+            text/plain:
+              example: ""description of failure""
+  /v1/query/accounts:
+    post:
+      tags:
+        - query
+      summary: Returns the paginated data of all accounts specified at a given height
+      requestBody:
+        description: Request all account data at the specified height, height = 0 is used as the latest; Max per_page=1000
+        content:
+          application/json:
+            schema:
+              $ref: ""#/components/schemas/QueryHeightPaginated""
+            example:
+              height: 0
+              page: 1
+              per_page: 50
+        required: true
+      responses:
+        ""200"":
+          description: Returns account data for all accounts at the specified height
+          content:
+            application/json:
+              schema:
+                $ref: ""#/components/schemas/QueryAccountsResponse""
+        ""400"":
+          description: Bad request
+          content:
+            text/plain:
+              example: ""description of failure""
+        ""500"":
+          description: An error occurred while retrieving accounts at the specified height
+          content:
+            text/plain:
+              example: ""description of failure""
+  /v1/query/account_txs:
+    post:
+      tags:
+        - query
+      summary: Returns all transactions sent by the specified address paginated
+      requestBody:
+        description: Returns all transactions sent by the address provided; Max per_page=1000, can be sorted either asc or desc (default)
+        content:
+          application/json:
+            schema:
+              $ref: ""#/components/schemas/QueryAddressPaginated""
+            example:
+              address: da034209758b78eaea06dd99c07909ab54c99b45
+              page: 1
+              per_page: 1000
+              sort: desc
+        required: true
+      responses:
+        ""200"":
+          description: Returns the transaction list for the account
+          content:
+            application/json:
+              schema:
+                $ref: ""#/components/schemas/QueryAccountTxsResponse""
+        ""400"":
+          description: Bad request
+          content:
+            text/plain:
+              example: ""description of failure""
+        ""500"":
+          description: An error occurred while retrieving the transactions for the account
+          content:
+            text/plain:
+              example: ""description of failure""
+  /v1/query/all_chain_params:
     get:
       tags:
         - query
       summary: Returns the current values of all governance parameters
-
       responses:
         ""200"":
-          description: Node parameters response
+          description: Returns all the chain parameters
           content:
             application/json:
               schema:
                 $ref: ""#/components/schemas/AllChainParamsResponse""
         ""500"":
-          description: An error occurred while retrieving the current node parameters
+          description: An error occurred while retrieving the current chain parameters
           content:
             text/plain:
               example: ""description of failure""
-
-externalDocs:
-  description: Find out more about Pocket Network
-  url: ""https://pokt.network""
-components:
-  schemas:
-    RawTXRequest:
-      type: object
-      required:
-        - address
-        - raw_hex_bytes
-      properties:
-        address:
-          type: string
-        raw_hex_bytes:
-          type: string
-    ConsensusState:
-      type: object
-      required:
-        - height
-        - round
-        - step
-      properties:
-        height:
-          type: integer
-          format: int64
-        round:
-          type: integer
-          format: int64
-        step:
-          type: integer
-          format: int64
-    Actor:
-      type: object
-      required:
-        - type
-        - address
-        - public_key
-        - service_url
-      properties:
-        type:
-          $ref: ""#/components/schemas/ActorTypesEnum""
-        address:
-          type: string
-        public_key:
-          type: string
-        service_url:
-          type: string
-
-    P2PStakedActorsResponse:
-      type: object
-      required:
-        - actors
-        - height
-      properties:
-        actors:
-          type: ""array""
-          items:
-            $ref: ""#/components/schemas/Actor""
-        height:
-          type: integer
-          format: int64
-
-    ActorTypesEnum:
-      type: string
-      enum:
-        - validator
-        - servicer
-        - fisherman
-        - application
-
-    Parameter:
-      type: object
-      required:
-        - parameter_name
-        - parameter_value
-      properties:
-        parameter_name:
-          type: ""string""
-        parameter_value:
-          type: ""string""
-
-    AllChainParamsResponse:
-      type: array
-      items:
-        $ref: ""#/components/schemas/Parameter""
+  /v1/query/app:
+    post:
+      tags:
+        - query
+      summary: Returns the data for the specific app address at a given height
+      requestBody:
+        description: Request application data at the specified height, height = 0 is used as the latest
+        content:
+          application/json:
+            schema:
+              $ref: ""#/components/schemas/QueryAddressHeight""
+            example:
+              address: da034209758b78eaea06dd99c07909ab54c99b45
+              height: 0
+        required: true
+      responses:
+        ""200"":
+          description: Returns application data at the specified height
+          content:
+            application/json:
+              schema:
+                $ref: ""#/components/schemas/ProtocolActor""
+        ""400"":
+          description: Bad request
+          content:
+            text/plain:
+              example: ""description of failure""
+        ""500"":
+          description: An error occurred while retrieving the application data at the specified height
+          content:
+            text/plain:
+              example: ""description of failure""
+  # TODO: (h5law) Think of an equivalent to staking status
+  /v1/query/apps:
+    post:
+      tags:
+        - query
+      summary: Returns the data for the all apps at the specified height
+      requestBody:
+        description: Request all application data at the specified height, height = 0 is used as the latest; Max per_page=1000
+        content:
+          application/json:
+            schema:
+              $ref: ""#/components/schemas/QueryHeightPaginated""
+            example:
+              height: 0
+              page: 1
+              per_page: 50
+        required: true
+      responses:
+        ""200"":
+          description: Returns application data at the specified height
+          content:
+            application/json:
+              schema:
+                $ref: ""#/components/schemas/QueryAppsResponse""
+        ""400"":
+          description: Bad request
+          content:
+            text/plain:
+              example: ""description of failure""
+        ""500"":
+          description: An error occurred while retrieving all application data at the specified height
+          content:
+            text/plain:
+              example: ""description of failure""
+  /v1/query/balance:
+    post:
+      tags:
+        - query
+      summary: Returns the balance of the account at the specified height
+      requestBody:
+        description: Request account balance at the specified height, height = 0 is used as the latest
+        content:
+          application/json:
+            schema:
+              $ref: '#/components/schemas/QueryAddressHeight'
+            example:
+              address: da034209758b78eaea06dd99c07909ab54c99b45
+              height: 99
+        required: true
+      responses:
+        ""200"":
+          description: Returns account balance at the specified height
+          content:
+            application/json:
+              schema:
+                $ref: ""#/components/schemas/QueryBalanceResponse""
+        ""400"":
+          description: Bad request
+          content:
+            text/plain:
+              example: ""description of failure""
+        ""500"":
+          description: An error occurred while retrieving the account balance at the specified height
+          content:
+            text/plain:
+              example: ""description of failure""
+  /v1/query/block:
+    post:
+      tags:
+        - query
+      summary: Returns the block structure at the specified height
+      requestBody:
+        description: Request the block at the specified height, height = 0 is used as the latest
+        content:
+          application/json:
+            schema:
+              $ref: ""#/components/schemas/QueryHeight""
+            example:
+              height: 0
+        required: true
+      responses:
+        ""200"":
+          description: Returns block structure at the specified height
+          content:
+            application/json:
+              schema:
+                $ref: ""#/components/schemas/QueryBlockResponse""
+        ""400"":
+          description: Bad request
+          content:
+            text/plain:
+              example: ""description of failure""
+        ""500"":
+          description: An error occurred while retrieving the block structure at the specified height
+          content:
+            text/plain:
+              example: ""description of failure""
+  /v1/query/block_txs:
+    post:
+      tags:
+        - query
+      summary: Returns all the transactions in the block at the specified height
+      requestBody:
+        description: Request the transactions in the block at the specified height, height = 0 is used as the latest; Max per_page=1000, can be sorted either asc or desc (default)
+        content:
+          application/json:
+            schema:
+              $ref: ""#/components/schemas/QueryHeightPaginated""
+            example:
+              height: 0
+              page: 1
+              per_page: 1000
+              sort: desc
+        required: true
+      responses:
+        ""200"":
+          description: Returns all transactions in the block at the specified height
+          content:
+            application/json:
+              schema:
+                $ref: ""#/components/schemas/QueryTxsResponse""
+        ""400"":
+          description: Bad request
+          content:
+            text/plain:
+              example: ""description of failure""
+        ""500"":
+          description: An error occurred while retrieving the block transactions at the specified height
+          content:
+            text/plain:
+              example: ""description of failure""
+  /v1/query/fisherman:
+    post:
+      tags:
+        - query
+      summary: Returns the data for the specific fisherman address at a given height
+      requestBody:
+        description: Request fisherman data at the specified height, height = 0 is used as the latest
+        content:
+          application/json:
+            schema:
+              $ref: ""#/components/schemas/QueryAddressHeight""
+            example:
+              address: da034209758b78eaea06dd99c07909ab54c99b45
+              height: 0
+        required: true
+      responses:
+        ""200"":
+          description: Returns fisherman data at the specified height
+          content:
+            application/json:
+              schema:
+                $ref: ""#/components/schemas/ProtocolActor""
+        ""400"":
+          description: Bad request
+          content:
+            text/plain:
+              example: ""description of failure""
+        ""500"":
+          description: An error occurred while retrieving the fisherman data at the specified height
+          content:
+            text/plain:
+              example: ""description of failure""
+  /v1/query/fishermen:
+    post:
+      tags:
+        - query
+      summary: Returns the data for the all fishermen at the specified height
+      requestBody:
+        description: Request all fishermen data at the specified height, height = 0 is used as the latest; Max per_page=1000
+        content:
+          application/json:
+            schema:
+              $ref: ""#/components/schemas/QueryHeightPaginated""
+            example:
+              height: 0
+              page: 1
+              per_page: 50
+        required: true
+      responses:
+        ""200"":
+          description: Returns all fishermen data at the specified height
+          content:
+            application/json:
+              schema:
+                $ref: ""#/components/schemas/QueryFishermenResponse""
+        ""400"":
+          description: Bad request
+          content:
+            text/plain:
+              example: ""description of failure""
+        ""500"":
+          description: An error occurred while retrieving all fishermen data at the specified height
+          content:
+            text/plain:
+              example: ""description of failure""
+  /v1/query/height:
+    get:
+      tags:
+        - query
+      summary: Returns the current block height
+      responses:
+        ""200"":
+          description: Returns the current height
+          content:
+            application/json:
+              schema:
+                $ref: ""#/components/schemas/QueryHeight""
+        ""500"":
+          description: An error occurred while retrieving the current height
+          content:
+            text/plain:
+              example: ""description of failure""
+  /v1/query/param:
+    post:
+      tags:
+        - query
+      requestBody:
+        description: Request the value of the specified chain parameter at the given height, height = 0 is used as the latest
+        content:
+          application/json:
+            schema:
+              $ref: ""#/components/schemas/QueryParameter""
+            example:
+              param: blocks_per_session
+              height: 2
+        required: true
+      responses:
+        ""200"":
+          description: Returns the value of the parameter at the specified height
+          content:
+            application/json:
+              schema:
+                $ref: ""#/components/schemas/Parameter""
+        ""400"":
+          description: Bad request
+          content:
+            text/plain:
+              example: ""description of failure""
+        ""500"":
+          description: An error occurred while retrieving the parameter
+          content:
+            text/plain:
+              example: ""description of failure""
+  /v1/query/servicer:
+    post:
+      tags:
+        - query
+      summary: Returns the data for the specific servicer address at a given height
+      requestBody:
+        description: Request servicer data at the specified height, height = 0 is used as the latest
+        content:
+          application/json:
+            schema:
+              $ref: ""#/components/schemas/QueryAddressHeight""
+            example:
+              address: da034209758b78eaea06dd99c07909ab54c99b45
+              height: 0
+        required: true
+      responses:
+        ""200"":
+          description: Returns servicer data at the specified height
+          content:
+            application/json:
+              schema:
+                $ref: ""#/components/schemas/ProtocolActor""
+        ""400"":
+          description: Bad request
+          content:
+            text/plain:
+              example: ""description of failure""
+        ""500"":
+          description: An error occurred while retrieving the servicer data at the specified height
+          content:
+            text/plain:
+              example: ""description of failure""
+  /v1/query/servicers:
+    post:
+      tags:
+        - query
+      summary: Returns the data for the all servicers at the specified height
+      requestBody:
+        description: Request all servicers data at the specified height, height = 0 is used as the latest; Max per_page=1000
+        content:
+          application/json:
+            schema:
+              $ref: ""#/components/schemas/QueryHeightPaginated""
+            example:
+              height: 0
+              page: 1
+              per_page: 50
+        required: true
+      responses:
+        ""200"":
+          description: Returns all servicers data at the specified height
+          content:
+            application/json:
+              schema:
+                $ref: ""#/components/schemas/QueryServicersResponse""
+        ""400"":
+          description: Bad request
+          content:
+            text/plain:
+              example: ""description of failure""
+        ""500"":
+          description: An error occurred while retrieving all servicers data at the specified height
+          content:
+            text/plain:
+              example: ""description of failure""
+  /v1/query/supply:
+    post:
+      tags:
+        - query
+      summary: Returns the token supply at the specified height
+      requestBody:
+        description: Request the token supply data at the specified height, height = 0 is used as the latest; Max per_page=1000
+        content:
+          application/json:
+            schema:
+              $ref: ""#/components/schemas/QueryHeight""
+            example:
+              height: 0
+        required: true
+      responses:
+        ""200"":
+          description: Returns the token supply data at the specified height
+          content:
+            application/json:
+              schema:
+                $ref: ""#/components/schemas/QuerySupplyResponse""
+        ""400"":
+          description: Bad request
+          content:
+            text/plain:
+              example: ""description of failure""
+        ""500"":
+          description: An error occurred while retrieving the token supply data at the specified height
+          content:
+            text/plain:
+              example: ""description of failure""
+  /v1/query/supported_chains:
+    post:
+      tags:
+        - query
+      summary: Returns the supported chains at the specified height
+      requestBody:
+        description: Request the supported chains at the specified height, height = 0 is used as the latest; Max per_page=1000
+        content:
+          application/json:
+            schema:
+              $ref: ""#/components/schemas/QueryHeight""
+            example:
+              height: 0
+        required: true
+      responses:
+        ""200"":
+          description: Returns the supported chains list at the specified height
+          content:
+            application/json:
+              schema:
+                $ref: ""#/components/schemas/QuerySupportedChainsResponse""
+        ""400"":
+          description: Bad request
+          content:
+            text/plain:
+              example: ""description of failure""
+        ""500"":
+          description: An error occurred while retrieving the supported chains at the specified height
+          content:
+            text/plain:
+              example: ""description of failure""
+  /v1/query/tx:
+    post:
+      tags:
+        - query
+      summary: Returns the transaction by its hash
+      requestBody:
+        description: Request a transaction from its hash
+        content:
+          application/json:
+            schema:
+              $ref: ""#/components/schemas/QueryHash""
+            example:
+              hash: c05a67912d84860ff5db13e29b453c578c3fc0c95333f6a4987b2060f56639b6
+        required: true
+      responses:
+        ""200"":
+          description: Returns the transaction
+          content:
+            application/json:
+              schema:
+                $ref: ""#/components/schemas/Transaction""
+        ""400"":
+          description: Bad request
+          content:
+            text/plain:
+              example: ""description of failure""
+        ""500"":
+          description: An error occurred while retrieving the transaction
+          content:
+            text/plain:
+              example: ""description of failure""
+  /v1/query/unconfirmed_tx:
+    post:
+      tags:
+        - query
+      summary: Returns the unconfirmed transaction by its hash from mempool
+      requestBody:
+        description: Request an unconfirmed transaction currently in the mempool from its hash
+        content:
+          application/json:
+            schema:
+              $ref: ""#/components/schemas/QueryHash""
+            example:
+              hash: c05a67912d84860ff5db13e29b453c578c3fc0c95333f6a4987b2060f56639b6
+        required: true
+      responses:
+        ""200"":
+          description: Returns the unconfirmed transaction from the mempool
+          content:
+            application/json:
+              schema:
+                $ref: ""#/components/schemas/Transaction""
+        ""400"":
+          description: Bad request
+          content:
+            text/plain:
+              example: ""description of failure""
+        ""500"":
+          description: An error occurred while retrieving the transaction from the mempool
+          content:
+            text/plain:
+              example: ""description of failure""
+  /v1/query/unconfirmed_txs:
+    post:
+      tags:
+        - query
+      summary: Returns all unconfirmed transactions handled by the mempool
+      requestBody:
+        description: Request the unconfirmed transactions currently in the mempool
+        content:
+          application/json:
+            schema:
+              $ref: ""#/components/schemas/QueryPaginated""
+            example:
+              page: 1
+              per_page: 1000
+              sort: desc
+        required: true
+      responses:
+        ""200"":
+          description: Returns all the unconfirmed transactions in the mempool
+          content:
+            application/json:
+              schema:
+                $ref: ""#/components/schemas/QueryTxsResponse""
+        ""400"":
+          description: Bad request
+          content:
+            text/plain:
+              example: ""description of failure""
+        ""500"":
+          description: An error occurred while retrieving the transactions in the mempool
+          content:
+            text/plain:
+              example: ""description of failure""
+  /v1/query/upgrade:
+    post:
+      tags:
+        - query
+      summary: Returns the upgrade information for the specified height
+      requestBody:
+        description: Request the upgrade information for the specified height, height = 0 is used as latest
+        content:
+          application/json:
+            schema:
+              $ref: ""#/components/schemas/QueryHeight""
+            example:
+              height: 5
+        required: true
+      responses:
+        ""200"":
+          description: Returns the upgrade information for the specified height
+          content:
+            application/json:
+              schema:
+                $ref: ""#/components/schemas/QueryUpgradeResponse""
+        ""400"":
+          description: Bad request
+          content:
+            text/plain:
+              example: ""description of failure""
+        ""500"":
+          description: An error occurred while retrieving the update information
+          content:
+            text/plain:
+              example: ""description of failure""
+  /v1/query/validator:
+    post:
+      tags:
+        - query
+      summary: Returns the data for the specific validator address at a given height
+      requestBody:
+        description: Request validator data at the specified height, height = 0 is used as the latest
+        content:
+          application/json:
+            schema:
+              $ref: ""#/components/schemas/QueryAddressHeight""
+            example:
+              address: da034209758b78eaea06dd99c07909ab54c99b45
+              height: 0
+        required: true
+      responses:
+        ""200"":
+          description: Returns validator data at the specified height
+          content:
+            application/json:
+              schema:
+                $ref: ""#/components/schemas/ProtocolActor""
+        ""400"":
+          description: Bad request
+          content:
+            text/plain:
+              example: ""description of failure""
+        ""500"":
+          description: An error occurred while retrieving the validator data at the specified height
+          content:
+            text/plain:
+              example: ""description of failure""
+  /v1/query/validators:
+    post:
+      tags:
+        - query
+      summary: Returns the data for the all validators at the specified height
+      requestBody:
+        description: Request all validators data at the specified height, height = 0 is used as the latest; Max per_page=1000
+        content:
+          application/json:
+            schema:
+              $ref: ""#/components/schemas/QueryHeightPaginated""
+            example:
+              height: 0
+              page: 1
+              per_page: 50
+        required: true
+      responses:
+        ""200"":
+          description: Returns all validators data at the specified height
+          content:
+            application/json:
+              schema:
+                $ref: ""#/components/schemas/QueryValidatorsResponse""
+        ""400"":
+          description: Bad request
+          content:
+            text/plain:
+              example: ""description of failure""
+        ""500"":
+          description: An error occurred while retrieving all validators data at the specified height
+          content:
+            text/plain:
+              example: ""description of failure""
+
+externalDocs:
+  description: Find out more about Pocket Network
+  url: ""https://pokt.network""
+components:
+  schemas:
+    # Requests
+    ChallengeRequest:
+      type: object
+      required:
+        - majority_responses
+        - minority_response
+        - address
+        - servicer_pub_key
+        - session_id
+      properties:
+        majority_responses:
+          type: array
+          items:
+            $ref: ""#/components/schemas/RelayResponse""
+        minority_response:
+          $ref: ""#/components/schemas/RelayResponse""
+        address:
+          type: string
+        servicer_pub_key:
+          type: string
+        session_id:
+          type: string
+    QueryAddressHeight:
+      type: object
+      required:
+        - height
+        - address
+      properties:
+        height:
+          type: integer
+          format: int64
+        address:
+          type: string
+    QueryAddressPaginated:
+      type: object
+      required:
+        - address
+        - page
+        - per_page
+      properties:
+        address:
+          type: string
+        page:
+          type: integer
+          format: int64
+        per_page:
+          type: integer
+          format: int64
+        sort:
+          type: string
+    QueryHeightPaginated:
+      type: object
+      required:
+        - height
+        - page
+        - per_page
+      properties:
+        height:
+          type: integer
+          format: int64
+        page:
+          type: integer
+          format: int64
+        per_page:
+          type: integer
+          format: int64
+        sort:
+          type: string
+    QueryHash:
+      type: object
+      required:
+        - hash
+      properties:
+        hash:
+          type: string
+    QueryHeight:
+      type: object
+      required:
+        - height
+      properties:
+        height:
+          type: integer
+          format: int64
+    QueryPaginated:
+      type: object
+      required:
+        - page
+        - per_page
+      properties:
+        page:
+          type: integer
+          format: int64
+        per_page:
+          type: integer
+          format: int64
+        sort:
+          type: string
+    QueryParameter:
+      type: object
+      required:
+        - param_name
+        - height
+      properties:
+        param_name:
+          type: string
+        height:
+          type: integer
+          format: int64
+    RawTXRequest:
+      type: object
+      required:
+        - address
+        - raw_hex_bytes
+      properties:
+        address:
+          type: string
+        raw_hex_bytes:
+          type: string
+    RelayRequest:
+      type: object
+      required:
+        - payload
+        - meta
+      properties:
+        payload:
+          $ref: ""#/components/schemas/Payload""
+        meta:
+          $ref: ""#/components/schemas/RelayRequestMeta""
+    SessionRequest:
+      type: object
+      required:
+        - app_address
+        - chain
+        - geozone
+        - session_height
+      properties:
+        app_address:
+          type: string
+        chain:
+          type: string
+        geozone:
+          type: string
+        session_height:
+          type: integer
+          format: int64
+
+    # Responses
+    Account:
+      type: object
+      required:
+        - address
+        - coins
+      properties:
+        address:
+          type: string
+        coins:
+          type: array
+          items:
+            $ref: '#/components/schemas/Coin'
+    AllChainParamsResponse:
+      type: array
+      items:
+        $ref: ""#/components/schemas/Parameter""
+    ChallengeResponse:
+      type: object
+      required:
+        - response
+      properties:
+        response:
+          type: string
+    ConsensusState:
+      type: object
+      required:
+        - height
+        - round
+        - step
+      properties:
+        height:
+          type: integer
+          format: int64
+        round:
+          type: integer
+          format: int64
+        step:
+          type: integer
+          format: int64
+    ProtocolActor:
+      type: object
+      required:
+        - address
+        - actor_type
+        - public_key
+        - chains
+        - service_url
+        - staked_amount
+        - paused_height
+        - unstaking_height
+        - output_addr
+      properties:
+        address:
+          type: string
+        actor_type:
+          $ref: ""#/components/schemas/ActorTypesEnum""
+        public_key:
+          type: string
+        chains:
+          type: array
+          items:
+            type: string
+        service_url:
+          type: string
+        staked_amount:
+          type: string
+        paused_height:
+          type: integer
+          format: int64
+        unstaking_height:
+          type: integer
+          format: int64
+        output_addr:
+          type: string
+    P2PStakedActorsResponse:
+      type: object
+      required:
+        - actors
+        - height
+      properties:
+        actors:
+          type: ""array""
+          items:
+            $ref: ""#/components/schemas/Actor""
+        height:
+          type: integer
+          format: int64
+    QueryAccountsResponse:
+      type: object
+      required:
+        - result
+        - page
+        - total_pages
+      properties:
+        result:
+          type: array
+          items:
+            $ref: '#/components/schemas/Account'
+        page:
+          type: integer
+          format: int64
+        total_pages:
+          type: integer
+          format: int64
+    QueryAccountTxsResponse:
+      type: object
+      required:
+        - txs
+        - total_txs
+        - page
+        - total_pages
+      properties:
+        txs:
+          type: array
+          items:
+            $ref: ""#/components/schemas/Transaction""
+        total_txs:
+          type: integer
+          format: int64
+        page:
+          type: integer
+          format: int64
+        total_pages:
+          type: integer
+          format: int64
+    QueryAppsResponse:
+      type: object
+      required:
+        - apps
+        - total_apps
+        - page
+        - total_pages
+      properties:
+        apps:
+          type: array
+          items:
+            $ref: ""#/components/schemas/ProtocolActor""
+        total_apps:
+          type: integer
+          format: int64
+        page:
+          type: integer
+          format: int64
+        total_pages:
+          type: integer
+          format: int64
+    QueryBalanceResponse:
+      type: object
+      required:
+        - balance
+      properties:
+        balance:
+          type: integer
+          format: int64
+    QueryBlockResponse:
+      type: object
+      required:
+        - block
+      properties:
+        block:
+          $ref: ""#/components/schemas/Block""
+    QueryFishermenResponse:
+      type: object
+      required:
+        - fishermen
+        - total_fishermen
+        - page
+        - total_pages
+      properties:
+        fishermen:
+          type: array
+          items:
+            $ref: ""#/components/schemas/ProtocolActor""
+        total_fishermen:
+          type: integer
+          format: int64
+        page:
+          type: integer
+          format: int64
+        total_pages:
+          type: integer
+          format: int64
+    QueryServicersResponse:
+      type: object
+      required:
+        - servicers
+        - total_servicers
+        - page
+        - total_pages
+      properties:
+        servicers:
+          type: array
+          items:
+            $ref: ""#/components/schemas/ProtocolActor""
+        total_servicers:
+          type: integer
+          format: int64
+        page:
+          type: integer
+          format: int64
+        total_pages:
+          type: integer
+          format: int64
+    QuerySupplyResponse:
+      type: object
+      required:
+        - pools
+        - total
+      properties:
+        pools:
+          type: array
+          items:
+            $ref: ""#/components/schemas/Pool""
+        total:
+          $ref: ""#/components/schemas/Coin""
+    QuerySupportedChainsResponse:
+      type: object
+      required:
+        - supported_chains
+      properties:
+        supported_chains:
+          type: array
+          items:
+            type: string
+    QueryTxsResponse:
+      type: object
+      required:
+        - transactions
+        - total_txs
+        - page
+        - total_pages
+      properties:
+        transactions:
+          type: array
+          items:
+            $ref: ""#/components/schemas/Transaction""
+        total_txs:
+          type: integer
+          format: int64
+        page:
+          type: integer
+          format: int64
+        total_pages:
+          type: integer
+          format: int64
+    QueryUpgradeResponse:
+      type: object
+      required:
+        - height
+        - version
+      properties:
+        height:
+          type: integer
+          format: int64
+        version:
+          type: string
+    QueryValidatorsResponse:
+      type: object
+      required:
+        - validators
+        - total_validators
+        - page
+        - total_pages
+      properties:
+        validators:
+          type: array
+          items:
+            $ref: ""#/components/schemas/ProtocolActor""
+        total_validators:
+          type: integer
+          format: int64
+        page:
+          type: integer
+          format: int64
+        total_pages:
+          type: integer
+          format: int64
+    RelayResponse:
+      type: object
+      required:
+        - payload
+        - servicer_signature
+      properties:
+        payload:
+          type: string
+        servicer_signature:
+          type: string
+    Session:
+      type: object
+      required:
+        - session_id
+        - session_number
+        - session_height
+        - num_session_blocks
+        - chain
+        - geozone
+        - application
+        - servicers
+        - fishermen
+      properties:
+        session_id:
+          type: string
+        session_number:
+          type: integer
+          format: int64
+        session_height:
+          type: integer
+          format: int64
+        num_session_blocks:
+          type: integer
+          format: int64
+        chain:
+          type: string
+        geozone:
+          type: string
+        application:
+          $ref: ""#/components/schemas/ProtocolActor""
+        servicers:
+          type: array
+          items:
+            $ref: ""#/components/schemas/ProtocolActor""
+        fishermen:
+          type: array
+          items:
+            $ref: ""#/components/schemas/ProtocolActor""
+
+    # Types
+    AAT:
+      type: object
+      required:
+        - version
+        - app_pub_key
+        - client_pub_key
+        - app_signature
+      properties:
+        version:
+          type: string
+        app_pub_key:
+          type: string
+        client_pub_key:
+          type: string
+        app_signature:
+          type: string
+    ActorTypesEnum:
+      type: string
+      enum:
+        - validator
+        - servicer
+        - fisherman
+        - application
+    Actor:
+      type: object
+      required:
+        - type
+        - address
+        - public_key
+        - service_url
+      properties:
+        type:
+          $ref: ""#/components/schemas/ActorTypesEnum""
+        address:
+          type: string
+        public_key:
+          type: string
+        service_url:
+          type: string
+    Block:
+      type: object
+      required:
+        - block_header
+        - transactions
+      properties:
+        block_header:
+          $ref: ""#/components/schemas/BlockHeader""
+        transactions:
+          type: array
+          items:
+            $ref: ""#/components/schemas/Transaction""
+    BlockHeader:
+      type: object
+      required:
+        - height
+        - network_id
+        - state_hash
+        - prev_state_hash
+        - proposer_addr
+        - quorum_cert
+        - timestamp
+      properties:
+        height:
+          type: integer
+          format: int64
+        network_id:
+          type: string
+        state_hash:
+          type: string
+        prev_state_hash:
+          type: string
+        proposer_addr:
+          type: string
+        quorum_cert:
+          $ref: ""#/components/schemas/QuorumCertificate""
+        timestamp:
+          type: string
+    Coin:
+      type: object
+      required:
+        - amount
+        - denom
+      properties:
+        amount:
+          type: string
+        denom:
+          type: string
+    Fee:
+      type: object
+      required:
+        - amount
+        - denom
+      properties:
+        amount:
+          type: string
+        denom:
+          type: string
+    Header:
+      type: object
+      required:
+        - name
+        - value
+      properties:
+        name:
+          type: string
+        value:
+          type: string
+    Headers:
+      type: array
+      items:
+        $ref: ""#/components/schemas/Header""
+    Identifiable:
+      type: object
+      required:
+        - id
+        - name
+      properties:
+        id:
+          type: string
+        name:
+          type: string
+    MessageSend:
+      type: object
+      required:
+        - from_addr
+        - to_addr
+        - amount
+        - denom
+      properties:
+        from_addr:
+          type: string
+        to_addr:
+          type: string
+        amount:
+          type: string
+        denom:
+          type: string
+    MessageStake:
+      type: object
+      required:
+        - actor_type
+        - public_key
+        - chains
+        - service_url
+        - output_address
+        - signer
+        - amount
+        - denom
+      properties:
+        actor_type:
+          $ref: ""#/components/schemas/ActorTypesEnum""
+        public_key:
+          type: string
+        chains:
+          type: array
+          items:
+            type: string
+        service_url:
+          type: string
+        output_address:
+          type: string
+        signer:
+          type: string
+        amount:
+          type: string
+        denom:
+          type: string
+    MessageEditStake:
+      type: object
+      required:
+        - actor_type
+        - address
+        - chains
+        - service_url
+        - signer
+        - amount
+        - denom
+      properties:
+        actor_type:
+          $ref: ""#/components/schemas/ActorTypesEnum""
+        address:
+          type: string
+        chains:
+          type: array
+          items:
+            type: string
+        service_url:
+          type: string
+        signer:
+          type: string
+        amount:
+          type: string
+        denom:
+          type: string
+    MessageUnstake:
+      type: object
+      required:
+        - actor_type
+        - address
+        - signer
+      properties:
+        actor_type:
+          $ref: ""#/components/schemas/ActorTypesEnum""
+        address:
+          type: string
+        signer:
+          type: string
+    MessageUnpause:
+      type: object
+      required:
+        - actor_type
+        - address
+        - signer
+      properties:
+        actor_type:
+          $ref: ""#/components/schemas/ActorTypesEnum""
+        address:
+          type: string
+        signer:
+          type: string
+    MessageChangeParameter:
+      type: object
+      required:
+        - signer
+        - owner
+        - parameter
+      properties:
+        signer:
+          type: string
+        owner:
+          type: string
+        parameter:
+          $ref: ""#/components/schemas/Parameter""
+    Parameter:
+      type: object
+      required:
+        - parameter_name
+        - parameter_value
+      properties:
+        parameter_name:
+          type: ""string""
+        parameter_value:
+          type: ""string""
+    PartialSignature:
+      type: object
+      required:
+        - signature
+        - address
+      properties:
+        signature:
+          type: string
+        address:
+          type: string
+    Payload:
+      type: object
+      required:
+        - data
+        - method
+        - path
+        - headers
+      properties:
+        data:
+          type: string
+        method:
+          type: string
+        path:
+          type: string
+        headers:
+          $ref: ""#/components/schemas/Headers""
+    Pool:
+      type: object
+      required:
+        - address
+        - name
+        - amount
+        - denom
+      properties:
+        address:
+          type: string
+        name:
+          type: string
+        amount:
+          type: string
+        denom:
+          type: string
+    QuorumCertificate:
+      type: object
+      required:
+        - height
+        - round
+        - step
+        - block
+        - threshold_sig
+        - transactions
+      properties:
+        height:
+          type: integer
+          format: int64
+        round:
+          type: integer
+          format: int64
+        step:
+          type: string
+        block:
+          type: string
+        threshold_sig:
+          $ref: ""#/components/schemas/ThresholdSignature""
+        transactions:
+          type: array
+          items:
+            type: string
+    RelayRequestMeta:
+      type: object
+      required:
+        - block_height
+        - servicer_pub_key
+        - chain
+        - geozone
+        - token
+        - signature
+      properties:
+        block_height:
+          type: integer
+          format: int64
+        servicer_pub_key:
+          type: string
+        chain:
+          $ref: ""#/components/schemas/Identifiable""
+        geozone:
+          $ref: ""#/components/schemas/Identifiable""
+        token:
+          $ref: ""#/components/schemas/AAT""
+        signature:
+          type: string
+    Signature:
+      type: object
+      required:
+        - public_key
+        - signature
+      properties:
+        public_key:
+          type: string
+        signature:
+          type: string
+    StdTx:
+      type: object
+      required:
+        - fee
+        - message
+        - nonce
+        - signature
+      properties:
+        fee:
+          $ref: ""#/components/schemas/Fee""
+        message:
+          oneOf:
+            - $ref: ""#/components/schemas/MessageSend""
+            - $ref: ""#/components/schemas/MessageStake""
+            - $ref: ""#/components/schemas/MessageEditStake""
+            - $ref: ""#/components/schemas/MessageUnstake""
+            - $ref: ""#/components/schemas/MessageUnpause""
+            - $ref: ""#/components/schemas/MessageChangeParameter""
+        nonce:
+          type: string
+        signature:
+          $ref: ""#/components/schemas/Signature""
+    Transaction:
+      type: object
+      required:
+        - hash
+        - height
+        - index
+        - txResult
+        - stdTx
+      properties:",rpc/v1/openapi.yaml,2023-05-02 02:26:24+00:00,2023-05-02T02:27:54Z,"I'm beginning to get a bit confused here so I think finding as much consistency between what we have in the code and here will really help.

Note how in the code a `txResult` contains a `Transaction` but here its the opposite. I also want to eliminate `StdTx` because I'm not sure what that means or refers to.

```proto
message Transaction {

  // The message to be signed is intentionally an `Any` type, since it is up to the module to
  // define the exact message type, its contents and validation protocol.
  google.protobuf.Any msg = 1;

  // A one-time nonce to avoid replay previous transaction.
  string nonce = 2;

  // The signature must sign the `Transaction` protobuf containing both the `msg` and `nonce` with
  // a nil signature.
  Signature signature = 3; // The signature
}
```

```proto
message TxResult {
  bytes tx = 1; // a serialized `Transaction` proto
  int64 height = 2; // the block height at which the transaction was included
  int32 index = 3; // the transaction's index within the block (i.e. ordered by when the proposer received it in the mempool)
  int32 result_code = 4; // 0 is no error, otherwise corresponds to error object code; // IMPROVE: Consider using enums for the result codes
  string error = 5; // description of the error if the result code is non-zero; IMPROVE: Add a specific type for the error code
  string signer_addr = 6; // the address of the signer (e.g. sender) of the transaction
  string recipient_addr = 7; // Optional: the address of the recipient of the transaction (if applicable)
  string message_type = 8; // the message type contained in the transaction; must correspond to a proto that the node can can process (e.g. Stake, Unstake, Send, etc...) // IMPROVE: How do we document all the types?
}
```
",,1756.0,RIGHT,,1786,RIGHT,1786,,line,https://api.github.com/repos/pokt-network/pocket/pulls/684,pokt-network/pocket,9359cdf1837fa6bf84632f6ccc8dfb05de0f7296
https://api.github.com/repos/pokt-network/pocket/pulls/684,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1182028918,Olshansk,964333fcec0ccb79708af5ce07dbab1cf5efb3a5,9fb091614f1874101a5e3f3b35e5eadb67fa32ea,"@@ -53,6 +53,7 @@ paths:
               schema:",rpc/v1/openapi.yaml,2023-05-02 02:27:15+00:00,2023-05-02T02:27:54Z,This file is going to be very user facing so wanted to make a request that you double check the swagger file looks good ,,,,53.0,53,RIGHT,1,1.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/684,pokt-network/pocket,9359cdf1837fa6bf84632f6ccc8dfb05de0f7296
https://api.github.com/repos/pokt-network/pocket/pulls/684,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1184415888,Olshansk,42ae63c2ef0485cb92c5335efb978821b052d8ee,9fb091614f1874101a5e3f3b35e5eadb67fa32ea,"@@ -45,6 +45,21 @@ func (s *rpcServer) broadcastMessage(msgBz []byte) error {
 	return nil
 }
 
+// getQueryHeight returns either the height supplied or if it is equal to 0
+// the most recent block height that has been commited. As the current consensus height",rpc/utils.go,2023-05-04 00:10:17+00:00,2023-05-04T00:12:15Z,Some linter errors,,,,,49,RIGHT,5,,line,https://api.github.com/repos/pokt-network/pocket/pulls/684,pokt-network/pocket,9359cdf1837fa6bf84632f6ccc8dfb05de0f7296
https://api.github.com/repos/pokt-network/pocket/pulls/684,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1184416497,Olshansk,42ae63c2ef0485cb92c5335efb978821b052d8ee,9fb091614f1874101a5e3f3b35e5eadb67fa32ea,"@@ -45,6 +45,21 @@ func (s *rpcServer) broadcastMessage(msgBz []byte) error {
 	return nil
 }
 
+// getQueryHeight returns either the height supplied or if it is equal to 0
+// the most recent block height that has been commited. As the current consensus height
+// is one above this, and if used in certain queries will return an error as the height
+// has not been commited yet
+func (s *rpcServer) getQueryHeight(height int64) int64 {
+	if height == 0 {
+		currentHeight := int64(s.GetBus().GetConsensusModule().CurrentHeight())
+		if currentHeight > 0 {
+			currentHeight -= 1
+		}
+		return currentHeight
+	}
+	return height",rpc/utils.go,2023-05-04 00:11:49+00:00,2023-05-04T00:12:15Z,"Just a NIT that makes code easier to read. It's a general trick if you ever find yourself doing `if {very large block } `
```suggestion
	if height != 0 {
		return height
	}
	currentHeight := int64(s.GetBus().GetConsensusModule().CurrentHeight())
	if currentHeight > 0 {
		currentHeight -= 1
	}
	return currentHeight
```",,53.0,RIGHT,,60,RIGHT,16,,line,https://api.github.com/repos/pokt-network/pocket/pulls/684,pokt-network/pocket,9359cdf1837fa6bf84632f6ccc8dfb05de0f7296
https://api.github.com/repos/pokt-network/pocket/pulls/736,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1192815975,Olshansk,9982c62ca04143f56d2a72176e09e78e6d6b5c26,d8725cdbe4e394fb2a4a26b7ddb52ef6494a6a8f,"@@ -0,0 +1,65 @@
+package blockstore
+
+//go:generate mockgen -source=$GOFILE -destination=../types/mocks/blockstore/block_store_mock.go github.com/pokt-network/pocket/persistence/types BlockStore
+
+import (
+	""fmt""
+
+	""github.com/pokt-network/pocket/persistence/kvstore""
+)
+
+type BlockStore interface {",persistence/blockstore/block_store.go,2023-05-12 21:42:07+00:00,2023-05-12T21:44:24Z,"Please add a small comment on why how this is used. E.g. ""BlockStore is a key-value store mapping block heights to serialized block structures""",,,,14.0,14,RIGHT,11,14.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/736,pokt-network/pocket,a29b654b808b0239d4ed3dc37131317168b8aaf0
https://api.github.com/repos/pokt-network/pocket/pulls/736,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1192816579,Olshansk,9982c62ca04143f56d2a72176e09e78e6d6b5c26,d8725cdbe4e394fb2a4a26b7ddb52ef6494a6a8f,"@@ -0,0 +1,65 @@
+package blockstore
+
+//go:generate mockgen -source=$GOFILE -destination=../types/mocks/blockstore/block_store_mock.go github.com/pokt-network/pocket/persistence/types BlockStore
+
+import (
+	""fmt""
+
+	""github.com/pokt-network/pocket/persistence/kvstore""
+)
+
+type BlockStore interface {
+	kvstore.KVStore
+}
+
+var _ BlockStore = &blockStore{}
+
+// BlockStore wraps a KVStore to manage savepoint and rollback behavior.",persistence/blockstore/block_store.go,2023-05-12 21:43:14+00:00,2023-05-12T21:44:24Z,"This is great but complimentary to my request above. The way I think about it is: if we run `godoc`, this is internal and won't show up, but the above interface will.",,,,,17,RIGHT,17,,line,https://api.github.com/repos/pokt-network/pocket/pulls/736,pokt-network/pocket,a29b654b808b0239d4ed3dc37131317168b8aaf0
https://api.github.com/repos/pokt-network/pocket/pulls/727,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1189030889,Olshansk,35eb743feb0e74e2fb39399abc6efdc0155840de,d7541bfaf98a764dd9ff8e378cb576998bc358b3,"@@ -0,0 +1,1007 @@
+apiVersion: v1",build/localnet/manifests/private-keys-misc.yaml,2023-05-09 19:09:15+00:00,2023-05-09T23:09:23Z,"How does this compare to the other `.yaml`:
-  Why we need both
-  If consolidating in one `.yaml` files could work

For example, `build/localnet/manifests/private-keys.yaml` could be used with special prefixes?",,,,,1,RIGHT,1,,line,https://api.github.com/repos/pokt-network/pocket/pulls/727,pokt-network/pocket,a06d875ed5964c806a6fe1ed4f4989f82797c07a
https://api.github.com/repos/pokt-network/pocket/pulls/727,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1189207723,Olshansk,35eb743feb0e74e2fb39399abc6efdc0155840de,d7541bfaf98a764dd9ff8e378cb576998bc358b3,"@@ -143,24 +153,29 @@ func dumpKeybase(privateKeysYamlBytes []byte, targetFilePath string) {
 	fmt.Printf(""✅ Keybase dumped in %s\n"", targetFilePath)
 }
 
-func parseValidatorPrivateKeysFromEmbeddedYaml(privateKeysYamlBytes []byte) (map[string]string, error) {
+func parsePrivateKeysFromEmbeddedYaml(privateKeysYamlBytes []byte) ([]string, error) {
 	// Parse the YAML file and load into the config struct
-	var config struct {
-		ApiVersion string            `yaml:""apiVersion""`
-		Kind       string            `yaml:""kind""`
-		MetaData   map[string]string `yaml:""metadata""`
-		Type       string            `yaml:""type""`
-		StringData map[string]string `yaml:""stringData""`
-	}
-	if err := yaml.Unmarshal(privateKeysYamlBytes, &config); err != nil {
-		return nil, err
-	}
-	validatorKeysMap := make(map[string]string)
+	decoder := yaml.NewDecoder(bytes.NewReader(privateKeysYamlBytes))
+	keysList := []string{}
+
+	for {
+		var secret K8sSecret
+
+		err := decoder.Decode(&secret)
+		if err != nil {",build/debug_keybase/main.go,2023-05-09 23:07:29+00:00,2023-05-09T23:09:23Z,"```suggestion
		if err := decoder.Decode(&secret); err != nil {
```",,164.0,RIGHT,,165,RIGHT,60,,line,https://api.github.com/repos/pokt-network/pocket/pulls/727,pokt-network/pocket,a06d875ed5964c806a6fe1ed4f4989f82797c07a
https://api.github.com/repos/pokt-network/pocket/pulls/727,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1189208273,Olshansk,35eb743feb0e74e2fb39399abc6efdc0155840de,d7541bfaf98a764dd9ff8e378cb576998bc358b3,"@@ -143,24 +153,29 @@ func dumpKeybase(privateKeysYamlBytes []byte, targetFilePath string) {
 	fmt.Printf(""✅ Keybase dumped in %s\n"", targetFilePath)
 }
 
-func parseValidatorPrivateKeysFromEmbeddedYaml(privateKeysYamlBytes []byte) (map[string]string, error) {
+func parsePrivateKeysFromEmbeddedYaml(privateKeysYamlBytes []byte) ([]string, error) {
 	// Parse the YAML file and load into the config struct
-	var config struct {
-		ApiVersion string            `yaml:""apiVersion""`
-		Kind       string            `yaml:""kind""`
-		MetaData   map[string]string `yaml:""metadata""`
-		Type       string            `yaml:""type""`
-		StringData map[string]string `yaml:""stringData""`
-	}
-	if err := yaml.Unmarshal(privateKeysYamlBytes, &config); err != nil {
-		return nil, err
-	}
-	validatorKeysMap := make(map[string]string)
+	decoder := yaml.NewDecoder(bytes.NewReader(privateKeysYamlBytes))
+	keysList := []string{}",build/debug_keybase/main.go,2023-05-09 23:08:33+00:00,2023-05-09T23:09:23Z,"```suggestion
	keysList := make([]string, 0)
```",,,,,159,RIGHT,54,,line,https://api.github.com/repos/pokt-network/pocket/pulls/727,pokt-network/pocket,a06d875ed5964c806a6fe1ed4f4989f82797c07a
https://api.github.com/repos/pokt-network/pocket/pulls/734,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1200008239,bryanchriswhite,9a4ed9e64e4dcb7beea548ceec0ac8573c46adbf,15e6ef032d321fb3cfe279c205d98f180e341d30,"@@ -0,0 +1,218 @@
+# E2E Feature Path <!-- omit in toc -->
+
+_IMPROVE(olshansky): Once we've completed the entire process at least once, we'll add links to each step._
+
+- [Introduction \& Goals](#introduction--goals)
+- [Developer Journey](#developer-journey)
+- [Feature Specification](#feature-specification)
+  - [Spot E2E Feature](#spot-e2e-feature)
+  - [Spike E2E Feature](#spike-e2e-feature)
+  - [Scope E2E Feature](#scope-e2e-feature)
+    - [GitHub Ticket](#github-ticket)
+    - [Origin Document](#origin-document)
+- [E2E Feature Implementation](#e2e-feature-implementation)
+  - [POC: Proof of Concept](#poc-proof-of-concept)
+  - [MVP: Minimum Viable Product](#mvp-minimum-viable-product)
+  - [PROD: Production](#prod-production)
+
+## Introduction & Goals
+
+The [Pocket Network Specification](https://github.com/pokt-network/pocket-network-protocol/tree/main/utility) implementation is driven by various [milestones](https://github.com/pokt-network/pocket/milestones) and protocol/module/component specific tasks. Each feature cross the boundaries of business logic, data types, and interfaces for different components. Due to the complex nature of implementation, we've designed a more streamlined approach.",utility/doc/E2E_FEATURE_PATH_TEMPLATE.md,2023-05-22 06:27:59+00:00,2023-05-22T06:32:23Z,"```suggestion
The [Pocket Network Specification](https://github.com/pokt-network/pocket-network-protocol/tree/main/utility) implementation is driven by various [milestones](https://github.com/pokt-network/pocket/milestones) and protocol/module/component specific tasks. Each feature crosses the boundaries of business logic, data types, and interfaces for different components. Due to the complex nature of implementation, we've designed a streamlined ""developer journey"".
```",,,,,20,RIGHT,20,,line,https://api.github.com/repos/pokt-network/pocket/pulls/734,pokt-network/pocket,17495efadc5416bb78e9e95032626d7f03ae6542
https://api.github.com/repos/pokt-network/pocket/pulls/734,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1200009682,bryanchriswhite,9a4ed9e64e4dcb7beea548ceec0ac8573c46adbf,15e6ef032d321fb3cfe279c205d98f180e341d30,"@@ -0,0 +1,218 @@
+# E2E Feature Path <!-- omit in toc -->
+
+_IMPROVE(olshansky): Once we've completed the entire process at least once, we'll add links to each step._
+
+- [Introduction \& Goals](#introduction--goals)
+- [Developer Journey](#developer-journey)
+- [Feature Specification](#feature-specification)",utility/doc/E2E_FEATURE_PATH_TEMPLATE.md,2023-05-22 06:29:49+00:00,2023-05-22T06:29:49Z,"```suggestion
- [E2E Feature Specification](#e2e-feature-specification)
```",,,,,7,RIGHT,7,,line,https://api.github.com/repos/pokt-network/pocket/pulls/734,pokt-network/pocket,17495efadc5416bb78e9e95032626d7f03ae6542
https://api.github.com/repos/pokt-network/pocket/pulls/734,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1200009867,bryanchriswhite,9a4ed9e64e4dcb7beea548ceec0ac8573c46adbf,15e6ef032d321fb3cfe279c205d98f180e341d30,"@@ -0,0 +1,218 @@
+# E2E Feature Path <!-- omit in toc -->
+
+_IMPROVE(olshansky): Once we've completed the entire process at least once, we'll add links to each step._
+
+- [Introduction \& Goals](#introduction--goals)
+- [Developer Journey](#developer-journey)
+- [Feature Specification](#feature-specification)
+  - [Spot E2E Feature](#spot-e2e-feature)
+  - [Spike E2E Feature](#spike-e2e-feature)
+  - [Scope E2E Feature](#scope-e2e-feature)
+    - [GitHub Ticket](#github-ticket)
+    - [Origin Document](#origin-document)
+- [E2E Feature Implementation](#e2e-feature-implementation)
+  - [POC: Proof of Concept](#poc-proof-of-concept)
+  - [MVP: Minimum Viable Product](#mvp-minimum-viable-product)
+  - [PROD: Production](#prod-production)
+
+## Introduction & Goals
+
+The [Pocket Network Specification](https://github.com/pokt-network/pocket-network-protocol/tree/main/utility) implementation is driven by various [milestones](https://github.com/pokt-network/pocket/milestones) and protocol/module/component specific tasks. Each feature cross the boundaries of business logic, data types, and interfaces for different components. Due to the complex nature of implementation, we've designed a more streamlined approach.
+
+**The goal** of this document is to outline a well-defined process for adopting an end-to-end feature path approach. This makes each feature/task easier to scope, reason about, design, and implement.
+
+## Developer Journey
+
+```mermaid
+%%{init: { 'logLevel': 'debug', 'theme': 'base' } }%%
+  timeline
+    title E2E Feature Path Developer Journey
+
+    section E2E Feature Specification
+      Spot Feature:
+        User research:
+        Product management:
+        Protocol intuition/experience:
+        Addition/removal/selection of feature from the list
+      Spike Feature:
+        Research details:
+        Identify pointers:
+        Note dependencies:
+        Find blockers
+      Scope Feature:
+        Define requirements:
+        Document E2E implementation
+
+    section E2E Feature Implementation
+        POC:
+          POC Spike:
+          Explore:
+          Hack:
+          Have fun!
+        MVP:
+          Data Structures:
+          Interfaces:
+          Implementation:
+          Unit Tests:
+          E2E Tests:
+          Documentation
+        PROD:
+          Identify workarounds & hacks:
+          Document future work:
+          Ideate!
+```
+
+## Feature Specification",utility/doc/E2E_FEATURE_PATH_TEMPLATE.md,2023-05-22 06:30:02+00:00,2023-05-22T06:30:03Z,"```suggestion
## E2E Feature Specification
```",,,,,65,RIGHT,65,,line,https://api.github.com/repos/pokt-network/pocket/pulls/734,pokt-network/pocket,17495efadc5416bb78e9e95032626d7f03ae6542
https://api.github.com/repos/pokt-network/pocket/pulls/734,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1200011376,bryanchriswhite,9a4ed9e64e4dcb7beea548ceec0ac8573c46adbf,15e6ef032d321fb3cfe279c205d98f180e341d30,"@@ -0,0 +1,218 @@
+# E2E Feature Path <!-- omit in toc -->
+
+_IMPROVE(olshansky): Once we've completed the entire process at least once, we'll add links to each step._
+
+- [Introduction \& Goals](#introduction--goals)
+- [Developer Journey](#developer-journey)
+- [Feature Specification](#feature-specification)
+  - [Spot E2E Feature](#spot-e2e-feature)
+  - [Spike E2E Feature](#spike-e2e-feature)
+  - [Scope E2E Feature](#scope-e2e-feature)
+    - [GitHub Ticket](#github-ticket)
+    - [Origin Document](#origin-document)
+- [E2E Feature Implementation](#e2e-feature-implementation)
+  - [POC: Proof of Concept](#poc-proof-of-concept)
+  - [MVP: Minimum Viable Product](#mvp-minimum-viable-product)
+  - [PROD: Production](#prod-production)
+
+## Introduction & Goals
+
+The [Pocket Network Specification](https://github.com/pokt-network/pocket-network-protocol/tree/main/utility) implementation is driven by various [milestones](https://github.com/pokt-network/pocket/milestones) and protocol/module/component specific tasks. Each feature cross the boundaries of business logic, data types, and interfaces for different components. Due to the complex nature of implementation, we've designed a more streamlined approach.
+
+**The goal** of this document is to outline a well-defined process for adopting an end-to-end feature path approach. This makes each feature/task easier to scope, reason about, design, and implement.
+
+## Developer Journey
+
+```mermaid
+%%{init: { 'logLevel': 'debug', 'theme': 'base' } }%%
+  timeline
+    title E2E Feature Path Developer Journey
+
+    section E2E Feature Specification
+      Spot Feature:
+        User research:
+        Product management:
+        Protocol intuition/experience:
+        Addition/removal/selection of feature from the list
+      Spike Feature:
+        Research details:
+        Identify pointers:
+        Note dependencies:
+        Find blockers
+      Scope Feature:
+        Define requirements:
+        Document E2E implementation
+
+    section E2E Feature Implementation
+        POC:
+          POC Spike:
+          Explore:
+          Hack:
+          Have fun!
+        MVP:
+          Data Structures:
+          Interfaces:
+          Implementation:
+          Unit Tests:
+          E2E Tests:
+          Documentation
+        PROD:
+          Identify workarounds & hacks:
+          Document future work:
+          Ideate!
+```
+
+## Feature Specification
+
+### Spot E2E Feature",utility/doc/E2E_FEATURE_PATH_TEMPLATE.md,2023-05-22 06:30:55+00:00,2023-05-22T06:30:56Z,"```suggestion
### Spot Feature
```",,,,,67,RIGHT,67,,line,https://api.github.com/repos/pokt-network/pocket/pulls/734,pokt-network/pocket,17495efadc5416bb78e9e95032626d7f03ae6542
https://api.github.com/repos/pokt-network/pocket/pulls/734,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1200011815,bryanchriswhite,9a4ed9e64e4dcb7beea548ceec0ac8573c46adbf,15e6ef032d321fb3cfe279c205d98f180e341d30,"@@ -0,0 +1,218 @@
+# E2E Feature Path <!-- omit in toc -->
+
+_IMPROVE(olshansky): Once we've completed the entire process at least once, we'll add links to each step._
+
+- [Introduction \& Goals](#introduction--goals)
+- [Developer Journey](#developer-journey)
+- [Feature Specification](#feature-specification)
+  - [Spot E2E Feature](#spot-e2e-feature)
+  - [Spike E2E Feature](#spike-e2e-feature)
+  - [Scope E2E Feature](#scope-e2e-feature)
+    - [GitHub Ticket](#github-ticket)
+    - [Origin Document](#origin-document)
+- [E2E Feature Implementation](#e2e-feature-implementation)
+  - [POC: Proof of Concept](#poc-proof-of-concept)
+  - [MVP: Minimum Viable Product](#mvp-minimum-viable-product)
+  - [PROD: Production](#prod-production)
+
+## Introduction & Goals
+
+The [Pocket Network Specification](https://github.com/pokt-network/pocket-network-protocol/tree/main/utility) implementation is driven by various [milestones](https://github.com/pokt-network/pocket/milestones) and protocol/module/component specific tasks. Each feature cross the boundaries of business logic, data types, and interfaces for different components. Due to the complex nature of implementation, we've designed a more streamlined approach.
+
+**The goal** of this document is to outline a well-defined process for adopting an end-to-end feature path approach. This makes each feature/task easier to scope, reason about, design, and implement.
+
+## Developer Journey
+
+```mermaid
+%%{init: { 'logLevel': 'debug', 'theme': 'base' } }%%
+  timeline
+    title E2E Feature Path Developer Journey
+
+    section E2E Feature Specification
+      Spot Feature:
+        User research:
+        Product management:
+        Protocol intuition/experience:
+        Addition/removal/selection of feature from the list
+      Spike Feature:
+        Research details:
+        Identify pointers:
+        Note dependencies:
+        Find blockers
+      Scope Feature:
+        Define requirements:
+        Document E2E implementation
+
+    section E2E Feature Implementation
+        POC:
+          POC Spike:
+          Explore:
+          Hack:
+          Have fun!
+        MVP:
+          Data Structures:
+          Interfaces:
+          Implementation:
+          Unit Tests:
+          E2E Tests:
+          Documentation
+        PROD:
+          Identify workarounds & hacks:
+          Document future work:
+          Ideate!
+```
+
+## Feature Specification
+
+### Spot E2E Feature
+
+Choose or add a feature from the Utility E2E feature list [here](./E2E_FEATURE_LIST.md).
+
+### Spike E2E Feature",utility/doc/E2E_FEATURE_PATH_TEMPLATE.md,2023-05-22 06:31:05+00:00,2023-05-22T06:31:05Z,"```suggestion
### Spike Feature
```",,,,,71,RIGHT,71,,line,https://api.github.com/repos/pokt-network/pocket/pulls/734,pokt-network/pocket,17495efadc5416bb78e9e95032626d7f03ae6542
https://api.github.com/repos/pokt-network/pocket/pulls/734,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1200012305,bryanchriswhite,9a4ed9e64e4dcb7beea548ceec0ac8573c46adbf,15e6ef032d321fb3cfe279c205d98f180e341d30,"@@ -0,0 +1,218 @@
+# E2E Feature Path <!-- omit in toc -->
+
+_IMPROVE(olshansky): Once we've completed the entire process at least once, we'll add links to each step._
+
+- [Introduction \& Goals](#introduction--goals)
+- [Developer Journey](#developer-journey)
+- [Feature Specification](#feature-specification)
+  - [Spot E2E Feature](#spot-e2e-feature)
+  - [Spike E2E Feature](#spike-e2e-feature)
+  - [Scope E2E Feature](#scope-e2e-feature)
+    - [GitHub Ticket](#github-ticket)
+    - [Origin Document](#origin-document)
+- [E2E Feature Implementation](#e2e-feature-implementation)
+  - [POC: Proof of Concept](#poc-proof-of-concept)
+  - [MVP: Minimum Viable Product](#mvp-minimum-viable-product)
+  - [PROD: Production](#prod-production)
+
+## Introduction & Goals
+
+The [Pocket Network Specification](https://github.com/pokt-network/pocket-network-protocol/tree/main/utility) implementation is driven by various [milestones](https://github.com/pokt-network/pocket/milestones) and protocol/module/component specific tasks. Each feature cross the boundaries of business logic, data types, and interfaces for different components. Due to the complex nature of implementation, we've designed a more streamlined approach.
+
+**The goal** of this document is to outline a well-defined process for adopting an end-to-end feature path approach. This makes each feature/task easier to scope, reason about, design, and implement.
+
+## Developer Journey
+
+```mermaid
+%%{init: { 'logLevel': 'debug', 'theme': 'base' } }%%
+  timeline
+    title E2E Feature Path Developer Journey
+
+    section E2E Feature Specification
+      Spot Feature:
+        User research:
+        Product management:
+        Protocol intuition/experience:
+        Addition/removal/selection of feature from the list
+      Spike Feature:
+        Research details:
+        Identify pointers:
+        Note dependencies:
+        Find blockers
+      Scope Feature:
+        Define requirements:
+        Document E2E implementation
+
+    section E2E Feature Implementation
+        POC:
+          POC Spike:
+          Explore:
+          Hack:
+          Have fun!
+        MVP:
+          Data Structures:
+          Interfaces:
+          Implementation:
+          Unit Tests:
+          E2E Tests:
+          Documentation
+        PROD:
+          Identify workarounds & hacks:
+          Document future work:
+          Ideate!
+```
+
+## Feature Specification
+
+### Spot E2E Feature
+
+Choose or add a feature from the Utility E2E feature list [here](./E2E_FEATURE_LIST.md).
+
+### Spike E2E Feature
+
+Create a SPIKE GitHub issue, like [this](<[http](https://github.com/pokt-network/pocket/issue/TODO_LINK_TO_ISSUE_ONCE_WE_HAVE_EXAMPLE)>) to scope the feature. This ticket is responsible for creating the ticket that'll track the work.
+
+### Scope E2E Feature",utility/doc/E2E_FEATURE_PATH_TEMPLATE.md,2023-05-22 06:31:17+00:00,2023-05-22T06:31:17Z,"```suggestion
### Scope Feature
```",,,,,75,RIGHT,75,,line,https://api.github.com/repos/pokt-network/pocket/pulls/734,pokt-network/pocket,17495efadc5416bb78e9e95032626d7f03ae6542
https://api.github.com/repos/pokt-network/pocket/pulls/734,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1200024184,bryanchriswhite,9a4ed9e64e4dcb7beea548ceec0ac8573c46adbf,15e6ef032d321fb3cfe279c205d98f180e341d30,"@@ -0,0 +1,218 @@
+# E2E Feature Path <!-- omit in toc -->
+
+_IMPROVE(olshansky): Once we've completed the entire process at least once, we'll add links to each step._
+
+- [Introduction \& Goals](#introduction--goals)
+- [Developer Journey](#developer-journey)
+- [Feature Specification](#feature-specification)
+  - [Spot E2E Feature](#spot-e2e-feature)
+  - [Spike E2E Feature](#spike-e2e-feature)
+  - [Scope E2E Feature](#scope-e2e-feature)
+    - [GitHub Ticket](#github-ticket)
+    - [Origin Document](#origin-document)
+- [E2E Feature Implementation](#e2e-feature-implementation)
+  - [POC: Proof of Concept](#poc-proof-of-concept)
+  - [MVP: Minimum Viable Product](#mvp-minimum-viable-product)
+  - [PROD: Production](#prod-production)
+
+## Introduction & Goals
+
+The [Pocket Network Specification](https://github.com/pokt-network/pocket-network-protocol/tree/main/utility) implementation is driven by various [milestones](https://github.com/pokt-network/pocket/milestones) and protocol/module/component specific tasks. Each feature cross the boundaries of business logic, data types, and interfaces for different components. Due to the complex nature of implementation, we've designed a more streamlined approach.
+
+**The goal** of this document is to outline a well-defined process for adopting an end-to-end feature path approach. This makes each feature/task easier to scope, reason about, design, and implement.",utility/doc/E2E_FEATURE_PATH_TEMPLATE.md,2023-05-22 06:39:48+00:00,2023-05-22T06:40:44Z,"```suggestion
**The goal** of this document is to outline a well-defined process for incorporating an end-to-end feature path. This makes each feature/task easier to scope, reason about, design, and implement.
```",,,,,22,RIGHT,22,,line,https://api.github.com/repos/pokt-network/pocket/pulls/734,pokt-network/pocket,17495efadc5416bb78e9e95032626d7f03ae6542
https://api.github.com/repos/pokt-network/pocket/pulls/734,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1200026511,bryanchriswhite,9a4ed9e64e4dcb7beea548ceec0ac8573c46adbf,15e6ef032d321fb3cfe279c205d98f180e341d30,"@@ -0,0 +1,218 @@
+# E2E Feature Path <!-- omit in toc -->
+
+_IMPROVE(olshansky): Once we've completed the entire process at least once, we'll add links to each step._
+
+- [Introduction \& Goals](#introduction--goals)
+- [Developer Journey](#developer-journey)
+- [Feature Specification](#feature-specification)
+  - [Spot E2E Feature](#spot-e2e-feature)
+  - [Spike E2E Feature](#spike-e2e-feature)
+  - [Scope E2E Feature](#scope-e2e-feature)
+    - [GitHub Ticket](#github-ticket)
+    - [Origin Document](#origin-document)
+- [E2E Feature Implementation](#e2e-feature-implementation)
+  - [POC: Proof of Concept](#poc-proof-of-concept)
+  - [MVP: Minimum Viable Product](#mvp-minimum-viable-product)
+  - [PROD: Production](#prod-production)
+
+## Introduction & Goals
+
+The [Pocket Network Specification](https://github.com/pokt-network/pocket-network-protocol/tree/main/utility) implementation is driven by various [milestones](https://github.com/pokt-network/pocket/milestones) and protocol/module/component specific tasks. Each feature cross the boundaries of business logic, data types, and interfaces for different components. Due to the complex nature of implementation, we've designed a more streamlined approach.
+
+**The goal** of this document is to outline a well-defined process for adopting an end-to-end feature path approach. This makes each feature/task easier to scope, reason about, design, and implement.
+
+## Developer Journey
+
+```mermaid
+%%{init: { 'logLevel': 'debug', 'theme': 'base' } }%%
+  timeline
+    title E2E Feature Path Developer Journey
+
+    section E2E Feature Specification
+      Spot Feature:
+        User research:
+        Product management:
+        Protocol intuition/experience:
+        Addition/removal/selection of feature from the list
+      Spike Feature:
+        Research details:
+        Identify pointers:
+        Note dependencies:
+        Find blockers
+      Scope Feature:
+        Define requirements:
+        Document E2E implementation
+
+    section E2E Feature Implementation
+        POC:
+          POC Spike:
+          Explore:
+          Hack:
+          Have fun!
+        MVP:
+          Data Structures:
+          Interfaces:
+          Implementation:
+          Unit Tests:
+          E2E Tests:
+          Documentation
+        PROD:
+          Identify workarounds & hacks:
+          Document future work:
+          Ideate!
+```
+
+## Feature Specification
+
+### Spot E2E Feature
+
+Choose or add a feature from the Utility E2E feature list [here](./E2E_FEATURE_LIST.md).",utility/doc/E2E_FEATURE_PATH_TEMPLATE.md,2023-05-22 06:42:46+00:00,2023-05-22T06:42:46Z,Is it intentional that this file isn't present yet?,,,,69.0,69,RIGHT,69,69.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/734,pokt-network/pocket,17495efadc5416bb78e9e95032626d7f03ae6542
https://api.github.com/repos/pokt-network/pocket/pulls/734,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1200041608,bryanchriswhite,9a4ed9e64e4dcb7beea548ceec0ac8573c46adbf,15e6ef032d321fb3cfe279c205d98f180e341d30,"@@ -0,0 +1,218 @@
+# E2E Feature Path <!-- omit in toc -->
+
+_IMPROVE(olshansky): Once we've completed the entire process at least once, we'll add links to each step._
+
+- [Introduction \& Goals](#introduction--goals)
+- [Developer Journey](#developer-journey)
+- [Feature Specification](#feature-specification)
+  - [Spot E2E Feature](#spot-e2e-feature)
+  - [Spike E2E Feature](#spike-e2e-feature)
+  - [Scope E2E Feature](#scope-e2e-feature)
+    - [GitHub Ticket](#github-ticket)
+    - [Origin Document](#origin-document)
+- [E2E Feature Implementation](#e2e-feature-implementation)
+  - [POC: Proof of Concept](#poc-proof-of-concept)
+  - [MVP: Minimum Viable Product](#mvp-minimum-viable-product)
+  - [PROD: Production](#prod-production)
+
+## Introduction & Goals
+
+The [Pocket Network Specification](https://github.com/pokt-network/pocket-network-protocol/tree/main/utility) implementation is driven by various [milestones](https://github.com/pokt-network/pocket/milestones) and protocol/module/component specific tasks. Each feature cross the boundaries of business logic, data types, and interfaces for different components. Due to the complex nature of implementation, we've designed a more streamlined approach.
+
+**The goal** of this document is to outline a well-defined process for adopting an end-to-end feature path approach. This makes each feature/task easier to scope, reason about, design, and implement.
+
+## Developer Journey
+
+```mermaid
+%%{init: { 'logLevel': 'debug', 'theme': 'base' } }%%
+  timeline
+    title E2E Feature Path Developer Journey
+
+    section E2E Feature Specification
+      Spot Feature:
+        User research:
+        Product management:
+        Protocol intuition/experience:
+        Addition/removal/selection of feature from the list
+      Spike Feature:
+        Research details:
+        Identify pointers:
+        Note dependencies:
+        Find blockers
+      Scope Feature:
+        Define requirements:
+        Document E2E implementation
+
+    section E2E Feature Implementation
+        POC:
+          POC Spike:
+          Explore:
+          Hack:
+          Have fun!
+        MVP:
+          Data Structures:
+          Interfaces:
+          Implementation:
+          Unit Tests:
+          E2E Tests:
+          Documentation
+        PROD:
+          Identify workarounds & hacks:
+          Document future work:
+          Ideate!
+```
+
+## Feature Specification
+
+### Spot E2E Feature
+
+Choose or add a feature from the Utility E2E feature list [here](./E2E_FEATURE_LIST.md).
+
+### Spike E2E Feature
+
+Create a SPIKE GitHub issue, like [this](<[http](https://github.com/pokt-network/pocket/issue/TODO_LINK_TO_ISSUE_ONCE_WE_HAVE_EXAMPLE)>) to scope the feature. This ticket is responsible for creating the ticket that'll track the work.
+
+### Scope E2E Feature
+
+Leverage the results from the SPIKE to create an implementation GitHub issue, like [this](<[http](https://github.com/pokt-network/pocket/issue/TODO_LINK_TO_ISSUE_ONCE_WE_HAVE_EXAMPLE)>) to track the actual implementation.
+
+#### GitHub Ticket
+
+Adhering to the GitHub template provided [here](https://github.com/pokt-network/pocket/blob/main/.github/ISSUE_TEMPLATE/issue.md), generate a [new issue](https://github.com/pokt-network/pocket/issues/new?assignees=&labels=&projects=&template=issue.md&title=%5BREPLACE+ME%5D+with+a+descriptive+title) encompassing the subsequent elements:",utility/doc/E2E_FEATURE_PATH_TEMPLATE.md,2023-05-22 06:52:38+00:00,2023-05-22T06:52:38Z,"Is there any value in linking to the issue template as the template automatically populates the issue description when following the ""new issue"" link? I find it a bit distracting otherwise.

```suggestion
Open a [new issue](https://github.com/pokt-network/pocket/issues/new?assignees=&labels=&projects=&template=issue.md&title=%5BREPLACE+ME%5D+with+a+descriptive+title) and populate its description, respectively, with the following additional elements:
```",,,,,81,RIGHT,81,,line,https://api.github.com/repos/pokt-network/pocket/pulls/734,pokt-network/pocket,17495efadc5416bb78e9e95032626d7f03ae6542
https://api.github.com/repos/pokt-network/pocket/pulls/734,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1200051024,bryanchriswhite,9a4ed9e64e4dcb7beea548ceec0ac8573c46adbf,15e6ef032d321fb3cfe279c205d98f180e341d30,"@@ -0,0 +1,218 @@
+# E2E Feature Path <!-- omit in toc -->
+
+_IMPROVE(olshansky): Once we've completed the entire process at least once, we'll add links to each step._
+
+- [Introduction \& Goals](#introduction--goals)
+- [Developer Journey](#developer-journey)
+- [Feature Specification](#feature-specification)
+  - [Spot E2E Feature](#spot-e2e-feature)
+  - [Spike E2E Feature](#spike-e2e-feature)
+  - [Scope E2E Feature](#scope-e2e-feature)
+    - [GitHub Ticket](#github-ticket)
+    - [Origin Document](#origin-document)
+- [E2E Feature Implementation](#e2e-feature-implementation)
+  - [POC: Proof of Concept](#poc-proof-of-concept)
+  - [MVP: Minimum Viable Product](#mvp-minimum-viable-product)
+  - [PROD: Production](#prod-production)
+
+## Introduction & Goals
+
+The [Pocket Network Specification](https://github.com/pokt-network/pocket-network-protocol/tree/main/utility) implementation is driven by various [milestones](https://github.com/pokt-network/pocket/milestones) and protocol/module/component specific tasks. Each feature cross the boundaries of business logic, data types, and interfaces for different components. Due to the complex nature of implementation, we've designed a more streamlined approach.
+
+**The goal** of this document is to outline a well-defined process for adopting an end-to-end feature path approach. This makes each feature/task easier to scope, reason about, design, and implement.
+
+## Developer Journey
+
+```mermaid
+%%{init: { 'logLevel': 'debug', 'theme': 'base' } }%%
+  timeline
+    title E2E Feature Path Developer Journey
+
+    section E2E Feature Specification
+      Spot Feature:
+        User research:
+        Product management:
+        Protocol intuition/experience:
+        Addition/removal/selection of feature from the list
+      Spike Feature:
+        Research details:
+        Identify pointers:
+        Note dependencies:
+        Find blockers
+      Scope Feature:
+        Define requirements:
+        Document E2E implementation
+
+    section E2E Feature Implementation
+        POC:
+          POC Spike:
+          Explore:
+          Hack:
+          Have fun!
+        MVP:
+          Data Structures:
+          Interfaces:
+          Implementation:
+          Unit Tests:
+          E2E Tests:
+          Documentation
+        PROD:
+          Identify workarounds & hacks:
+          Document future work:
+          Ideate!
+```
+
+## Feature Specification
+
+### Spot E2E Feature
+
+Choose or add a feature from the Utility E2E feature list [here](./E2E_FEATURE_LIST.md).
+
+### Spike E2E Feature
+
+Create a SPIKE GitHub issue, like [this](<[http](https://github.com/pokt-network/pocket/issue/TODO_LINK_TO_ISSUE_ONCE_WE_HAVE_EXAMPLE)>) to scope the feature. This ticket is responsible for creating the ticket that'll track the work.
+
+### Scope E2E Feature
+
+Leverage the results from the SPIKE to create an implementation GitHub issue, like [this](<[http](https://github.com/pokt-network/pocket/issue/TODO_LINK_TO_ISSUE_ONCE_WE_HAVE_EXAMPLE)>) to track the actual implementation.
+
+#### GitHub Ticket",utility/doc/E2E_FEATURE_PATH_TEMPLATE.md,2023-05-22 07:03:04+00:00,2023-05-23T08:46:00Z,"I find it difficult to make the distinction between an H4 and bold text:

![image](https://github.com/pokt-network/pocket/assets/600733/cc6eaa10-6f3c-4e9c-9382-b0de9b99b0ce)

""Scope E2E Feature"" is noticeably larger than the rest of the text, but ""GitHubTicket"" and ""Objective"" are indistinguishable to my eye.

As the majority of the details in the ""E2E Feature Specification"" section are in the H3/H4 levels of the hierarchy, I wonder if there's a convenient way to push the detail ""up"" one level? Perhaps ""E2E Feature Specification"" and ""E2E Feature Implementation"" could become H1s.

(FWIW, I also noticed that notion only supports H1-3, I would assume it's for similar UX reasons.)",,,,,79,RIGHT,79,,line,https://api.github.com/repos/pokt-network/pocket/pulls/734,pokt-network/pocket,17495efadc5416bb78e9e95032626d7f03ae6542
https://api.github.com/repos/pokt-network/pocket/pulls/734,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1200053083,bryanchriswhite,9a4ed9e64e4dcb7beea548ceec0ac8573c46adbf,15e6ef032d321fb3cfe279c205d98f180e341d30,"@@ -0,0 +1,218 @@
+# E2E Feature Path <!-- omit in toc -->
+
+_IMPROVE(olshansky): Once we've completed the entire process at least once, we'll add links to each step._
+
+- [Introduction \& Goals](#introduction--goals)
+- [Developer Journey](#developer-journey)
+- [Feature Specification](#feature-specification)
+  - [Spot E2E Feature](#spot-e2e-feature)
+  - [Spike E2E Feature](#spike-e2e-feature)
+  - [Scope E2E Feature](#scope-e2e-feature)
+    - [GitHub Ticket](#github-ticket)
+    - [Origin Document](#origin-document)
+- [E2E Feature Implementation](#e2e-feature-implementation)
+  - [POC: Proof of Concept](#poc-proof-of-concept)
+  - [MVP: Minimum Viable Product](#mvp-minimum-viable-product)
+  - [PROD: Production](#prod-production)
+
+## Introduction & Goals
+
+The [Pocket Network Specification](https://github.com/pokt-network/pocket-network-protocol/tree/main/utility) implementation is driven by various [milestones](https://github.com/pokt-network/pocket/milestones) and protocol/module/component specific tasks. Each feature cross the boundaries of business logic, data types, and interfaces for different components. Due to the complex nature of implementation, we've designed a more streamlined approach.
+
+**The goal** of this document is to outline a well-defined process for adopting an end-to-end feature path approach. This makes each feature/task easier to scope, reason about, design, and implement.
+
+## Developer Journey
+
+```mermaid
+%%{init: { 'logLevel': 'debug', 'theme': 'base' } }%%
+  timeline
+    title E2E Feature Path Developer Journey
+
+    section E2E Feature Specification
+      Spot Feature:
+        User research:
+        Product management:
+        Protocol intuition/experience:
+        Addition/removal/selection of feature from the list
+      Spike Feature:
+        Research details:
+        Identify pointers:
+        Note dependencies:
+        Find blockers
+      Scope Feature:
+        Define requirements:
+        Document E2E implementation
+
+    section E2E Feature Implementation
+        POC:
+          POC Spike:
+          Explore:
+          Hack:
+          Have fun!
+        MVP:
+          Data Structures:
+          Interfaces:
+          Implementation:
+          Unit Tests:
+          E2E Tests:
+          Documentation
+        PROD:
+          Identify workarounds & hacks:
+          Document future work:
+          Ideate!
+```
+
+## Feature Specification
+
+### Spot E2E Feature
+
+Choose or add a feature from the Utility E2E feature list [here](./E2E_FEATURE_LIST.md).
+
+### Spike E2E Feature
+
+Create a SPIKE GitHub issue, like [this](<[http](https://github.com/pokt-network/pocket/issue/TODO_LINK_TO_ISSUE_ONCE_WE_HAVE_EXAMPLE)>) to scope the feature. This ticket is responsible for creating the ticket that'll track the work.
+
+### Scope E2E Feature
+
+Leverage the results from the SPIKE to create an implementation GitHub issue, like [this](<[http](https://github.com/pokt-network/pocket/issue/TODO_LINK_TO_ISSUE_ONCE_WE_HAVE_EXAMPLE)>) to track the actual implementation.
+
+#### GitHub Ticket
+
+Adhering to the GitHub template provided [here](https://github.com/pokt-network/pocket/blob/main/.github/ISSUE_TEMPLATE/issue.md), generate a [new issue](https://github.com/pokt-network/pocket/issues/new?assignees=&labels=&projects=&template=issue.md&title=%5BREPLACE+ME%5D+with+a+descriptive+title) encompassing the subsequent elements:
+
+**Objective**: `Implement MVP E2E Feature Path <Letter>.<Number>: <Name>`
+
+**Origin Document**: _Specify the details from the [Origin Document](#origin-document) below_
+
+**Goals**:
+
+- Complete the MVP implementation of the E2E Feature Path outlined in the objective
+- Identify future tasks and test requirements to transition the feature to production
+
+**Deliverables**:
+
+**POC**:
+
+- [ ] A POC SPIKE to be closed out and split out into multiple PRs
+
+**MVP**:
+
+- [ ] A PR that adds or modifies relevant structures and interfaces; such as [shared/core/types/proto](../../shared/core/types/proto), [shared/modules](../../shared/modules), etc
+- [ ] A PR that materializes an MVP of the feature along with unit tests
+- [ ] A PR that introduces a new E2E tests with **one happy** and **one sad** path scenarios as described in the origin document (refer to [e2e/README.md](../../e2e/e2e/README.md)); this may require additions to the [cli](https://github.com/pokt-network/pocket/tree/main/app/client)
+- [ ] A PR that updates all pertinent documentation
+
+**PROD**:
+
+- [ ] One or more subsequent GitHub issues that track future work including, but not limited to:
+  - Enhancing test coverage
+  - Adding subsequent features
+  - Patching hacks or workarounds
+  - Enabling your [imagination](https://github.com/pokt-network/pocket/assets/1892194/6aff9004-8d3b-48e8-b6d5-9b67ac266e3d)!
+
+#### Origin Document",utility/doc/E2E_FEATURE_PATH_TEMPLATE.md,2023-05-22 07:05:21+00:00,2023-05-22T07:05:22Z,"Is there a particular reason not to move this to come before the goals and deliverables, as it does in the description template? I would imagine the UX would be smoother with less scrolling.",,,,,113,RIGHT,113,,line,https://api.github.com/repos/pokt-network/pocket/pulls/734,pokt-network/pocket,17495efadc5416bb78e9e95032626d7f03ae6542
https://api.github.com/repos/pokt-network/pocket/pulls/734,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1200061719,bryanchriswhite,9a4ed9e64e4dcb7beea548ceec0ac8573c46adbf,15e6ef032d321fb3cfe279c205d98f180e341d30,"@@ -0,0 +1,218 @@
+# E2E Feature Path <!-- omit in toc -->
+
+_IMPROVE(olshansky): Once we've completed the entire process at least once, we'll add links to each step._
+
+- [Introduction \& Goals](#introduction--goals)
+- [Developer Journey](#developer-journey)
+- [Feature Specification](#feature-specification)
+  - [Spot E2E Feature](#spot-e2e-feature)
+  - [Spike E2E Feature](#spike-e2e-feature)
+  - [Scope E2E Feature](#scope-e2e-feature)
+    - [GitHub Ticket](#github-ticket)
+    - [Origin Document](#origin-document)
+- [E2E Feature Implementation](#e2e-feature-implementation)
+  - [POC: Proof of Concept](#poc-proof-of-concept)
+  - [MVP: Minimum Viable Product](#mvp-minimum-viable-product)
+  - [PROD: Production](#prod-production)
+
+## Introduction & Goals
+
+The [Pocket Network Specification](https://github.com/pokt-network/pocket-network-protocol/tree/main/utility) implementation is driven by various [milestones](https://github.com/pokt-network/pocket/milestones) and protocol/module/component specific tasks. Each feature cross the boundaries of business logic, data types, and interfaces for different components. Due to the complex nature of implementation, we've designed a more streamlined approach.
+
+**The goal** of this document is to outline a well-defined process for adopting an end-to-end feature path approach. This makes each feature/task easier to scope, reason about, design, and implement.
+
+## Developer Journey
+
+```mermaid
+%%{init: { 'logLevel': 'debug', 'theme': 'base' } }%%
+  timeline
+    title E2E Feature Path Developer Journey
+
+    section E2E Feature Specification
+      Spot Feature:
+        User research:
+        Product management:
+        Protocol intuition/experience:
+        Addition/removal/selection of feature from the list
+      Spike Feature:
+        Research details:
+        Identify pointers:
+        Note dependencies:
+        Find blockers
+      Scope Feature:
+        Define requirements:
+        Document E2E implementation
+
+    section E2E Feature Implementation
+        POC:
+          POC Spike:
+          Explore:
+          Hack:
+          Have fun!
+        MVP:
+          Data Structures:
+          Interfaces:
+          Implementation:
+          Unit Tests:
+          E2E Tests:
+          Documentation
+        PROD:
+          Identify workarounds & hacks:
+          Document future work:
+          Ideate!
+```
+
+## Feature Specification
+
+### Spot E2E Feature
+
+Choose or add a feature from the Utility E2E feature list [here](./E2E_FEATURE_LIST.md).
+
+### Spike E2E Feature
+
+Create a SPIKE GitHub issue, like [this](<[http](https://github.com/pokt-network/pocket/issue/TODO_LINK_TO_ISSUE_ONCE_WE_HAVE_EXAMPLE)>) to scope the feature. This ticket is responsible for creating the ticket that'll track the work.
+
+### Scope E2E Feature
+
+Leverage the results from the SPIKE to create an implementation GitHub issue, like [this](<[http](https://github.com/pokt-network/pocket/issue/TODO_LINK_TO_ISSUE_ONCE_WE_HAVE_EXAMPLE)>) to track the actual implementation.
+
+#### GitHub Ticket
+
+Adhering to the GitHub template provided [here](https://github.com/pokt-network/pocket/blob/main/.github/ISSUE_TEMPLATE/issue.md), generate a [new issue](https://github.com/pokt-network/pocket/issues/new?assignees=&labels=&projects=&template=issue.md&title=%5BREPLACE+ME%5D+with+a+descriptive+title) encompassing the subsequent elements:
+
+**Objective**: `Implement MVP E2E Feature Path <Letter>.<Number>: <Name>`
+
+**Origin Document**: _Specify the details from the [Origin Document](#origin-document) below_
+
+**Goals**:
+
+- Complete the MVP implementation of the E2E Feature Path outlined in the objective
+- Identify future tasks and test requirements to transition the feature to production
+
+**Deliverables**:
+
+**POC**:
+
+- [ ] A POC SPIKE to be closed out and split out into multiple PRs",utility/doc/E2E_FEATURE_PATH_TEMPLATE.md,2023-05-22 07:14:49+00:00,2023-05-22T07:14:50Z,"nit + personal opinion: I would prefer ""discarded"" over ""closed out"" because I don't think a spike necessarily needs to be opened as a huge PR and closed ritualistically. If that's the process we find to be most useful, I think it still fits within the more general notion of ""discarded"". I would also prefer ""refactored and/or restructured"" over ""split out"" to explicitly call out the desire to prioritize improving quality at this stage to such an extent that it likely necessitates code refactoring as well as restructuring commits (contents & order). 

_I'm open to couter-suggestions :stuck_out_tongue_winking_eye:_

```suggestion
- [ ] A POC SPIKE to be discarded, refactored, and/or restructured into multiple PRs
```",,,,,96,RIGHT,96,,line,https://api.github.com/repos/pokt-network/pocket/pulls/734,pokt-network/pocket,17495efadc5416bb78e9e95032626d7f03ae6542
https://api.github.com/repos/pokt-network/pocket/pulls/734,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1200069062,bryanchriswhite,9a4ed9e64e4dcb7beea548ceec0ac8573c46adbf,15e6ef032d321fb3cfe279c205d98f180e341d30,"@@ -0,0 +1,218 @@
+# E2E Feature Path <!-- omit in toc -->
+
+_IMPROVE(olshansky): Once we've completed the entire process at least once, we'll add links to each step._
+
+- [Introduction \& Goals](#introduction--goals)
+- [Developer Journey](#developer-journey)
+- [Feature Specification](#feature-specification)
+  - [Spot E2E Feature](#spot-e2e-feature)
+  - [Spike E2E Feature](#spike-e2e-feature)
+  - [Scope E2E Feature](#scope-e2e-feature)
+    - [GitHub Ticket](#github-ticket)
+    - [Origin Document](#origin-document)
+- [E2E Feature Implementation](#e2e-feature-implementation)
+  - [POC: Proof of Concept](#poc-proof-of-concept)
+  - [MVP: Minimum Viable Product](#mvp-minimum-viable-product)
+  - [PROD: Production](#prod-production)
+
+## Introduction & Goals
+
+The [Pocket Network Specification](https://github.com/pokt-network/pocket-network-protocol/tree/main/utility) implementation is driven by various [milestones](https://github.com/pokt-network/pocket/milestones) and protocol/module/component specific tasks. Each feature cross the boundaries of business logic, data types, and interfaces for different components. Due to the complex nature of implementation, we've designed a more streamlined approach.
+
+**The goal** of this document is to outline a well-defined process for adopting an end-to-end feature path approach. This makes each feature/task easier to scope, reason about, design, and implement.
+
+## Developer Journey
+
+```mermaid
+%%{init: { 'logLevel': 'debug', 'theme': 'base' } }%%
+  timeline
+    title E2E Feature Path Developer Journey
+
+    section E2E Feature Specification
+      Spot Feature:
+        User research:
+        Product management:
+        Protocol intuition/experience:
+        Addition/removal/selection of feature from the list
+      Spike Feature:
+        Research details:
+        Identify pointers:
+        Note dependencies:
+        Find blockers
+      Scope Feature:
+        Define requirements:
+        Document E2E implementation
+
+    section E2E Feature Implementation
+        POC:
+          POC Spike:
+          Explore:
+          Hack:
+          Have fun!
+        MVP:
+          Data Structures:
+          Interfaces:
+          Implementation:
+          Unit Tests:
+          E2E Tests:
+          Documentation
+        PROD:
+          Identify workarounds & hacks:
+          Document future work:
+          Ideate!
+```
+
+## Feature Specification
+
+### Spot E2E Feature
+
+Choose or add a feature from the Utility E2E feature list [here](./E2E_FEATURE_LIST.md).
+
+### Spike E2E Feature
+
+Create a SPIKE GitHub issue, like [this](<[http](https://github.com/pokt-network/pocket/issue/TODO_LINK_TO_ISSUE_ONCE_WE_HAVE_EXAMPLE)>) to scope the feature. This ticket is responsible for creating the ticket that'll track the work.
+
+### Scope E2E Feature
+
+Leverage the results from the SPIKE to create an implementation GitHub issue, like [this](<[http](https://github.com/pokt-network/pocket/issue/TODO_LINK_TO_ISSUE_ONCE_WE_HAVE_EXAMPLE)>) to track the actual implementation.
+
+#### GitHub Ticket
+
+Adhering to the GitHub template provided [here](https://github.com/pokt-network/pocket/blob/main/.github/ISSUE_TEMPLATE/issue.md), generate a [new issue](https://github.com/pokt-network/pocket/issues/new?assignees=&labels=&projects=&template=issue.md&title=%5BREPLACE+ME%5D+with+a+descriptive+title) encompassing the subsequent elements:
+
+**Objective**: `Implement MVP E2E Feature Path <Letter>.<Number>: <Name>`
+
+**Origin Document**: _Specify the details from the [Origin Document](#origin-document) below_
+
+**Goals**:
+
+- Complete the MVP implementation of the E2E Feature Path outlined in the objective
+- Identify future tasks and test requirements to transition the feature to production
+
+**Deliverables**:
+
+**POC**:
+
+- [ ] A POC SPIKE to be closed out and split out into multiple PRs
+
+**MVP**:",utility/doc/E2E_FEATURE_PATH_TEMPLATE.md,2023-05-22 07:22:09+00:00,2023-05-22T07:22:09Z,"nit: Wdyt about ""MVC"" for ""minimum viable change""? I encountered this phrasing while reading through some of the [GitLab employee handbook (values > iteration)](https://handbook.gitlab.com/handbook/values/#minimal-viable-change-mvc) and I think it could be a useful distinction for us to describe ""minimums"" for sub-product scope tasks.",,,,,98,RIGHT,98,,line,https://api.github.com/repos/pokt-network/pocket/pulls/734,pokt-network/pocket,17495efadc5416bb78e9e95032626d7f03ae6542
https://api.github.com/repos/pokt-network/pocket/pulls/734,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1200070724,bryanchriswhite,9a4ed9e64e4dcb7beea548ceec0ac8573c46adbf,15e6ef032d321fb3cfe279c205d98f180e341d30,"@@ -0,0 +1,218 @@
+# E2E Feature Path <!-- omit in toc -->
+
+_IMPROVE(olshansky): Once we've completed the entire process at least once, we'll add links to each step._
+
+- [Introduction \& Goals](#introduction--goals)
+- [Developer Journey](#developer-journey)
+- [Feature Specification](#feature-specification)
+  - [Spot E2E Feature](#spot-e2e-feature)
+  - [Spike E2E Feature](#spike-e2e-feature)
+  - [Scope E2E Feature](#scope-e2e-feature)
+    - [GitHub Ticket](#github-ticket)
+    - [Origin Document](#origin-document)
+- [E2E Feature Implementation](#e2e-feature-implementation)
+  - [POC: Proof of Concept](#poc-proof-of-concept)
+  - [MVP: Minimum Viable Product](#mvp-minimum-viable-product)
+  - [PROD: Production](#prod-production)
+
+## Introduction & Goals
+
+The [Pocket Network Specification](https://github.com/pokt-network/pocket-network-protocol/tree/main/utility) implementation is driven by various [milestones](https://github.com/pokt-network/pocket/milestones) and protocol/module/component specific tasks. Each feature cross the boundaries of business logic, data types, and interfaces for different components. Due to the complex nature of implementation, we've designed a more streamlined approach.
+
+**The goal** of this document is to outline a well-defined process for adopting an end-to-end feature path approach. This makes each feature/task easier to scope, reason about, design, and implement.
+
+## Developer Journey
+
+```mermaid
+%%{init: { 'logLevel': 'debug', 'theme': 'base' } }%%
+  timeline
+    title E2E Feature Path Developer Journey
+
+    section E2E Feature Specification
+      Spot Feature:
+        User research:
+        Product management:
+        Protocol intuition/experience:
+        Addition/removal/selection of feature from the list
+      Spike Feature:
+        Research details:
+        Identify pointers:
+        Note dependencies:
+        Find blockers
+      Scope Feature:
+        Define requirements:
+        Document E2E implementation
+
+    section E2E Feature Implementation
+        POC:
+          POC Spike:
+          Explore:
+          Hack:
+          Have fun!
+        MVP:
+          Data Structures:
+          Interfaces:
+          Implementation:
+          Unit Tests:
+          E2E Tests:
+          Documentation
+        PROD:
+          Identify workarounds & hacks:
+          Document future work:
+          Ideate!
+```
+
+## Feature Specification
+
+### Spot E2E Feature
+
+Choose or add a feature from the Utility E2E feature list [here](./E2E_FEATURE_LIST.md).
+
+### Spike E2E Feature
+
+Create a SPIKE GitHub issue, like [this](<[http](https://github.com/pokt-network/pocket/issue/TODO_LINK_TO_ISSUE_ONCE_WE_HAVE_EXAMPLE)>) to scope the feature. This ticket is responsible for creating the ticket that'll track the work.
+
+### Scope E2E Feature
+
+Leverage the results from the SPIKE to create an implementation GitHub issue, like [this](<[http](https://github.com/pokt-network/pocket/issue/TODO_LINK_TO_ISSUE_ONCE_WE_HAVE_EXAMPLE)>) to track the actual implementation.
+
+#### GitHub Ticket
+
+Adhering to the GitHub template provided [here](https://github.com/pokt-network/pocket/blob/main/.github/ISSUE_TEMPLATE/issue.md), generate a [new issue](https://github.com/pokt-network/pocket/issues/new?assignees=&labels=&projects=&template=issue.md&title=%5BREPLACE+ME%5D+with+a+descriptive+title) encompassing the subsequent elements:
+
+**Objective**: `Implement MVP E2E Feature Path <Letter>.<Number>: <Name>`
+
+**Origin Document**: _Specify the details from the [Origin Document](#origin-document) below_
+
+**Goals**:
+
+- Complete the MVP implementation of the E2E Feature Path outlined in the objective
+- Identify future tasks and test requirements to transition the feature to production
+
+**Deliverables**:
+
+**POC**:
+
+- [ ] A POC SPIKE to be closed out and split out into multiple PRs
+
+**MVP**:
+
+- [ ] A PR that adds or modifies relevant structures and interfaces; such as [shared/core/types/proto](../../shared/core/types/proto), [shared/modules](../../shared/modules), etc
+- [ ] A PR that materializes an MVP of the feature along with unit tests
+- [ ] A PR that introduces a new E2E tests with **one happy** and **one sad** path scenarios as described in the origin document (refer to [e2e/README.md](../../e2e/e2e/README.md)); this may require additions to the [cli](https://github.com/pokt-network/pocket/tree/main/app/client)",utility/doc/E2E_FEATURE_PATH_TEMPLATE.md,2023-05-22 07:23:50+00:00,2023-05-22T07:26:36Z,"Are you concerned about developers going overboard on test cases or would you be open to something like the following:
```suggestion
- [ ] A PR that introduces a new E2E tests with **one or more happy** and **one or more sad** path scenarios as described in the origin document (refer to [e2e/README.md](../../e2e/e2e/README.md)); this may require additions to the [cli](https://github.com/pokt-network/pocket/tree/main/app/client)
```",,,,,102,RIGHT,102,,line,https://api.github.com/repos/pokt-network/pocket/pulls/734,pokt-network/pocket,17495efadc5416bb78e9e95032626d7f03ae6542
https://api.github.com/repos/pokt-network/pocket/pulls/734,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1200072933,bryanchriswhite,9a4ed9e64e4dcb7beea548ceec0ac8573c46adbf,15e6ef032d321fb3cfe279c205d98f180e341d30,"@@ -0,0 +1,218 @@
+# E2E Feature Path <!-- omit in toc -->
+
+_IMPROVE(olshansky): Once we've completed the entire process at least once, we'll add links to each step._
+
+- [Introduction \& Goals](#introduction--goals)
+- [Developer Journey](#developer-journey)
+- [Feature Specification](#feature-specification)
+  - [Spot E2E Feature](#spot-e2e-feature)
+  - [Spike E2E Feature](#spike-e2e-feature)
+  - [Scope E2E Feature](#scope-e2e-feature)
+    - [GitHub Ticket](#github-ticket)
+    - [Origin Document](#origin-document)
+- [E2E Feature Implementation](#e2e-feature-implementation)
+  - [POC: Proof of Concept](#poc-proof-of-concept)
+  - [MVP: Minimum Viable Product](#mvp-minimum-viable-product)
+  - [PROD: Production](#prod-production)
+
+## Introduction & Goals
+
+The [Pocket Network Specification](https://github.com/pokt-network/pocket-network-protocol/tree/main/utility) implementation is driven by various [milestones](https://github.com/pokt-network/pocket/milestones) and protocol/module/component specific tasks. Each feature cross the boundaries of business logic, data types, and interfaces for different components. Due to the complex nature of implementation, we've designed a more streamlined approach.
+
+**The goal** of this document is to outline a well-defined process for adopting an end-to-end feature path approach. This makes each feature/task easier to scope, reason about, design, and implement.
+
+## Developer Journey
+
+```mermaid
+%%{init: { 'logLevel': 'debug', 'theme': 'base' } }%%
+  timeline
+    title E2E Feature Path Developer Journey
+
+    section E2E Feature Specification
+      Spot Feature:
+        User research:
+        Product management:
+        Protocol intuition/experience:
+        Addition/removal/selection of feature from the list
+      Spike Feature:
+        Research details:
+        Identify pointers:
+        Note dependencies:
+        Find blockers
+      Scope Feature:
+        Define requirements:
+        Document E2E implementation
+
+    section E2E Feature Implementation
+        POC:
+          POC Spike:
+          Explore:
+          Hack:
+          Have fun!
+        MVP:
+          Data Structures:
+          Interfaces:
+          Implementation:
+          Unit Tests:
+          E2E Tests:
+          Documentation
+        PROD:
+          Identify workarounds & hacks:
+          Document future work:
+          Ideate!
+```
+
+## Feature Specification
+
+### Spot E2E Feature
+
+Choose or add a feature from the Utility E2E feature list [here](./E2E_FEATURE_LIST.md).
+
+### Spike E2E Feature
+
+Create a SPIKE GitHub issue, like [this](<[http](https://github.com/pokt-network/pocket/issue/TODO_LINK_TO_ISSUE_ONCE_WE_HAVE_EXAMPLE)>) to scope the feature. This ticket is responsible for creating the ticket that'll track the work.
+
+### Scope E2E Feature
+
+Leverage the results from the SPIKE to create an implementation GitHub issue, like [this](<[http](https://github.com/pokt-network/pocket/issue/TODO_LINK_TO_ISSUE_ONCE_WE_HAVE_EXAMPLE)>) to track the actual implementation.
+
+#### GitHub Ticket
+
+Adhering to the GitHub template provided [here](https://github.com/pokt-network/pocket/blob/main/.github/ISSUE_TEMPLATE/issue.md), generate a [new issue](https://github.com/pokt-network/pocket/issues/new?assignees=&labels=&projects=&template=issue.md&title=%5BREPLACE+ME%5D+with+a+descriptive+title) encompassing the subsequent elements:
+
+**Objective**: `Implement MVP E2E Feature Path <Letter>.<Number>: <Name>`
+
+**Origin Document**: _Specify the details from the [Origin Document](#origin-document) below_
+
+**Goals**:
+
+- Complete the MVP implementation of the E2E Feature Path outlined in the objective
+- Identify future tasks and test requirements to transition the feature to production
+
+**Deliverables**:
+
+**POC**:
+
+- [ ] A POC SPIKE to be closed out and split out into multiple PRs
+
+**MVP**:
+
+- [ ] A PR that adds or modifies relevant structures and interfaces; such as [shared/core/types/proto](../../shared/core/types/proto), [shared/modules](../../shared/modules), etc
+- [ ] A PR that materializes an MVP of the feature along with unit tests
+- [ ] A PR that introduces a new E2E tests with **one happy** and **one sad** path scenarios as described in the origin document (refer to [e2e/README.md](../../e2e/e2e/README.md)); this may require additions to the [cli](https://github.com/pokt-network/pocket/tree/main/app/client)",utility/doc/E2E_FEATURE_PATH_TEMPLATE.md,2023-05-22 07:25:51+00:00,2023-05-22T07:25:51Z,"Broken link

```suggestion
- [ ] A PR that introduces a new E2E tests with **one happy** and **one sad** path scenarios as described in the origin document (refer to [e2e/README.md](../../e2e/README.md)); this may require additions to the [cli](https://github.com/pokt-network/pocket/tree/main/app/client)
```",,,,,102,RIGHT,102,,line,https://api.github.com/repos/pokt-network/pocket/pulls/734,pokt-network/pocket,17495efadc5416bb78e9e95032626d7f03ae6542
https://api.github.com/repos/pokt-network/pocket/pulls/734,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1200076356,bryanchriswhite,9a4ed9e64e4dcb7beea548ceec0ac8573c46adbf,15e6ef032d321fb3cfe279c205d98f180e341d30,"@@ -0,0 +1,218 @@
+# E2E Feature Path <!-- omit in toc -->
+
+_IMPROVE(olshansky): Once we've completed the entire process at least once, we'll add links to each step._
+
+- [Introduction \& Goals](#introduction--goals)
+- [Developer Journey](#developer-journey)
+- [Feature Specification](#feature-specification)
+  - [Spot E2E Feature](#spot-e2e-feature)
+  - [Spike E2E Feature](#spike-e2e-feature)
+  - [Scope E2E Feature](#scope-e2e-feature)
+    - [GitHub Ticket](#github-ticket)
+    - [Origin Document](#origin-document)
+- [E2E Feature Implementation](#e2e-feature-implementation)
+  - [POC: Proof of Concept](#poc-proof-of-concept)
+  - [MVP: Minimum Viable Product](#mvp-minimum-viable-product)
+  - [PROD: Production](#prod-production)
+
+## Introduction & Goals
+
+The [Pocket Network Specification](https://github.com/pokt-network/pocket-network-protocol/tree/main/utility) implementation is driven by various [milestones](https://github.com/pokt-network/pocket/milestones) and protocol/module/component specific tasks. Each feature cross the boundaries of business logic, data types, and interfaces for different components. Due to the complex nature of implementation, we've designed a more streamlined approach.
+
+**The goal** of this document is to outline a well-defined process for adopting an end-to-end feature path approach. This makes each feature/task easier to scope, reason about, design, and implement.
+
+## Developer Journey
+
+```mermaid
+%%{init: { 'logLevel': 'debug', 'theme': 'base' } }%%
+  timeline
+    title E2E Feature Path Developer Journey
+
+    section E2E Feature Specification
+      Spot Feature:
+        User research:
+        Product management:
+        Protocol intuition/experience:
+        Addition/removal/selection of feature from the list
+      Spike Feature:
+        Research details:
+        Identify pointers:
+        Note dependencies:
+        Find blockers
+      Scope Feature:
+        Define requirements:
+        Document E2E implementation
+
+    section E2E Feature Implementation
+        POC:
+          POC Spike:
+          Explore:
+          Hack:
+          Have fun!
+        MVP:
+          Data Structures:
+          Interfaces:
+          Implementation:
+          Unit Tests:
+          E2E Tests:
+          Documentation
+        PROD:
+          Identify workarounds & hacks:
+          Document future work:
+          Ideate!
+```
+
+## Feature Specification
+
+### Spot E2E Feature
+
+Choose or add a feature from the Utility E2E feature list [here](./E2E_FEATURE_LIST.md).
+
+### Spike E2E Feature
+
+Create a SPIKE GitHub issue, like [this](<[http](https://github.com/pokt-network/pocket/issue/TODO_LINK_TO_ISSUE_ONCE_WE_HAVE_EXAMPLE)>) to scope the feature. This ticket is responsible for creating the ticket that'll track the work.
+
+### Scope E2E Feature
+
+Leverage the results from the SPIKE to create an implementation GitHub issue, like [this](<[http](https://github.com/pokt-network/pocket/issue/TODO_LINK_TO_ISSUE_ONCE_WE_HAVE_EXAMPLE)>) to track the actual implementation.
+
+#### GitHub Ticket
+
+Adhering to the GitHub template provided [here](https://github.com/pokt-network/pocket/blob/main/.github/ISSUE_TEMPLATE/issue.md), generate a [new issue](https://github.com/pokt-network/pocket/issues/new?assignees=&labels=&projects=&template=issue.md&title=%5BREPLACE+ME%5D+with+a+descriptive+title) encompassing the subsequent elements:
+
+**Objective**: `Implement MVP E2E Feature Path <Letter>.<Number>: <Name>`
+
+**Origin Document**: _Specify the details from the [Origin Document](#origin-document) below_
+
+**Goals**:
+
+- Complete the MVP implementation of the E2E Feature Path outlined in the objective
+- Identify future tasks and test requirements to transition the feature to production
+
+**Deliverables**:
+
+**POC**:
+
+- [ ] A POC SPIKE to be closed out and split out into multiple PRs
+
+**MVP**:
+
+- [ ] A PR that adds or modifies relevant structures and interfaces; such as [shared/core/types/proto](../../shared/core/types/proto), [shared/modules](../../shared/modules), etc
+- [ ] A PR that materializes an MVP of the feature along with unit tests
+- [ ] A PR that introduces a new E2E tests with **one happy** and **one sad** path scenarios as described in the origin document (refer to [e2e/README.md](../../e2e/e2e/README.md)); this may require additions to the [cli](https://github.com/pokt-network/pocket/tree/main/app/client)
+- [ ] A PR that updates all pertinent documentation
+
+**PROD**:
+
+- [ ] One or more subsequent GitHub issues that track future work including, but not limited to:
+  - Enhancing test coverage
+  - Adding subsequent features
+  - Patching hacks or workarounds
+  - Enabling your [imagination](https://github.com/pokt-network/pocket/assets/1892194/6aff9004-8d3b-48e8-b6d5-9b67ac266e3d)!
+
+#### Origin Document
+
+**Purpose:** A single sentence that captures the intended purpose, behaviour and goal of the E2E feature",utility/doc/E2E_FEATURE_PATH_TEMPLATE.md,2023-05-22 07:28:59+00:00,2023-05-22T07:28:59Z,It's not clear if you intend for developers to copy/paste this line and write that sentence below or if it is a placeholder for the sentence it describes.,,,,,115,RIGHT,115,,line,https://api.github.com/repos/pokt-network/pocket/pulls/734,pokt-network/pocket,17495efadc5416bb78e9e95032626d7f03ae6542
https://api.github.com/repos/pokt-network/pocket/pulls/734,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1200078968,bryanchriswhite,9a4ed9e64e4dcb7beea548ceec0ac8573c46adbf,15e6ef032d321fb3cfe279c205d98f180e341d30,"@@ -0,0 +1,218 @@
+# E2E Feature Path <!-- omit in toc -->
+
+_IMPROVE(olshansky): Once we've completed the entire process at least once, we'll add links to each step._
+
+- [Introduction \& Goals](#introduction--goals)
+- [Developer Journey](#developer-journey)
+- [Feature Specification](#feature-specification)
+  - [Spot E2E Feature](#spot-e2e-feature)
+  - [Spike E2E Feature](#spike-e2e-feature)
+  - [Scope E2E Feature](#scope-e2e-feature)
+    - [GitHub Ticket](#github-ticket)
+    - [Origin Document](#origin-document)
+- [E2E Feature Implementation](#e2e-feature-implementation)
+  - [POC: Proof of Concept](#poc-proof-of-concept)
+  - [MVP: Minimum Viable Product](#mvp-minimum-viable-product)
+  - [PROD: Production](#prod-production)
+
+## Introduction & Goals
+
+The [Pocket Network Specification](https://github.com/pokt-network/pocket-network-protocol/tree/main/utility) implementation is driven by various [milestones](https://github.com/pokt-network/pocket/milestones) and protocol/module/component specific tasks. Each feature cross the boundaries of business logic, data types, and interfaces for different components. Due to the complex nature of implementation, we've designed a more streamlined approach.
+
+**The goal** of this document is to outline a well-defined process for adopting an end-to-end feature path approach. This makes each feature/task easier to scope, reason about, design, and implement.
+
+## Developer Journey
+
+```mermaid
+%%{init: { 'logLevel': 'debug', 'theme': 'base' } }%%
+  timeline
+    title E2E Feature Path Developer Journey
+
+    section E2E Feature Specification
+      Spot Feature:
+        User research:
+        Product management:
+        Protocol intuition/experience:
+        Addition/removal/selection of feature from the list
+      Spike Feature:
+        Research details:
+        Identify pointers:
+        Note dependencies:
+        Find blockers
+      Scope Feature:
+        Define requirements:
+        Document E2E implementation
+
+    section E2E Feature Implementation
+        POC:
+          POC Spike:
+          Explore:
+          Hack:
+          Have fun!
+        MVP:
+          Data Structures:
+          Interfaces:
+          Implementation:
+          Unit Tests:
+          E2E Tests:
+          Documentation
+        PROD:
+          Identify workarounds & hacks:
+          Document future work:
+          Ideate!
+```
+
+## Feature Specification
+
+### Spot E2E Feature
+
+Choose or add a feature from the Utility E2E feature list [here](./E2E_FEATURE_LIST.md).
+
+### Spike E2E Feature
+
+Create a SPIKE GitHub issue, like [this](<[http](https://github.com/pokt-network/pocket/issue/TODO_LINK_TO_ISSUE_ONCE_WE_HAVE_EXAMPLE)>) to scope the feature. This ticket is responsible for creating the ticket that'll track the work.
+
+### Scope E2E Feature
+
+Leverage the results from the SPIKE to create an implementation GitHub issue, like [this](<[http](https://github.com/pokt-network/pocket/issue/TODO_LINK_TO_ISSUE_ONCE_WE_HAVE_EXAMPLE)>) to track the actual implementation.
+
+#### GitHub Ticket
+
+Adhering to the GitHub template provided [here](https://github.com/pokt-network/pocket/blob/main/.github/ISSUE_TEMPLATE/issue.md), generate a [new issue](https://github.com/pokt-network/pocket/issues/new?assignees=&labels=&projects=&template=issue.md&title=%5BREPLACE+ME%5D+with+a+descriptive+title) encompassing the subsequent elements:
+
+**Objective**: `Implement MVP E2E Feature Path <Letter>.<Number>: <Name>`
+
+**Origin Document**: _Specify the details from the [Origin Document](#origin-document) below_
+
+**Goals**:
+
+- Complete the MVP implementation of the E2E Feature Path outlined in the objective
+- Identify future tasks and test requirements to transition the feature to production
+
+**Deliverables**:
+
+**POC**:
+
+- [ ] A POC SPIKE to be closed out and split out into multiple PRs
+
+**MVP**:
+
+- [ ] A PR that adds or modifies relevant structures and interfaces; such as [shared/core/types/proto](../../shared/core/types/proto), [shared/modules](../../shared/modules), etc
+- [ ] A PR that materializes an MVP of the feature along with unit tests
+- [ ] A PR that introduces a new E2E tests with **one happy** and **one sad** path scenarios as described in the origin document (refer to [e2e/README.md](../../e2e/e2e/README.md)); this may require additions to the [cli](https://github.com/pokt-network/pocket/tree/main/app/client)
+- [ ] A PR that updates all pertinent documentation
+
+**PROD**:
+
+- [ ] One or more subsequent GitHub issues that track future work including, but not limited to:
+  - Enhancing test coverage
+  - Adding subsequent features
+  - Patching hacks or workarounds
+  - Enabling your [imagination](https://github.com/pokt-network/pocket/assets/1892194/6aff9004-8d3b-48e8-b6d5-9b67ac266e3d)!
+
+#### Origin Document
+
+**Purpose:** A single sentence that captures the intended purpose, behaviour and goal of the E2E feature
+**Actors**: Check all of the protocol actors involved in the feature:
+
+- [ ] Validator
+- [ ] Application
+- [ ] Servicer
+- [ ] Fisherman
+- [ ] Portal
+
+**Data Structures**:
+
+- A list of the core types (protobufs, structs, etc) that will be used, added or modified in this feature
+- Mention or link to specific files if applicable
+- See [shared/core/types/proto](../../shared/core/types/proto) as a reference as they will most likely, but not necessarily, be part of that package
+- _TIPS:_
+
+  - _This will be non-exhaustive and will likely change during the POC or MVP stages_
+  - You can find all other structs by running this command:
+
+    ```bash
+    grep -r ""type .* struct"" --exclude-dir=""vendor"" --exclude=""*.gen.go"" --exclude=""*.pb.go"" .
+    ```
+
+  - You can find all other protobufs by running this command:
+
+    ```bash
+    find . -name ""*.proto"" -not -path ""./vendor/*""`
+    ```
+
+**Interfaces**:
+
+- A list of the interface (go interfaces, placeholder functions, grpc, etc) that will be used, added or modified in this feature
+- Mention or link to specific files if applicable
+- See [shared/modules](../../shared/modules) as a reference as they will most likely, but not necessarily, be part of that package
+- _TIPS:_
+
+  - _This will be non-exhaustive and will likely change during the POC or MVP stages_
+  - You can find all other structs by running this command:
+
+    ```bash
+    grep -r ""type .* interface"" --exclude-dir=""vendor"" --exclude=""*.gen.go"" --exclude=""*.pb.go"" .
+    ```
+
+  - You can find all other protobufs by running this command:
+
+    ```bash
+    find . -name ""*.proto"" -not -path ""./vendor/*""`
+    ```",utility/doc/E2E_FEATURE_PATH_TEMPLATE.md,2023-05-22 07:31:28+00:00,2023-05-22T07:31:29Z,:sunglasses: (same as above),,149.0,RIGHT,,162,RIGHT,162,,line,https://api.github.com/repos/pokt-network/pocket/pulls/734,pokt-network/pocket,17495efadc5416bb78e9e95032626d7f03ae6542
https://api.github.com/repos/pokt-network/pocket/pulls/734,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1200080310,bryanchriswhite,9a4ed9e64e4dcb7beea548ceec0ac8573c46adbf,15e6ef032d321fb3cfe279c205d98f180e341d30,"@@ -0,0 +1,218 @@
+# E2E Feature Path <!-- omit in toc -->
+
+_IMPROVE(olshansky): Once we've completed the entire process at least once, we'll add links to each step._
+
+- [Introduction \& Goals](#introduction--goals)
+- [Developer Journey](#developer-journey)
+- [Feature Specification](#feature-specification)
+  - [Spot E2E Feature](#spot-e2e-feature)
+  - [Spike E2E Feature](#spike-e2e-feature)
+  - [Scope E2E Feature](#scope-e2e-feature)
+    - [GitHub Ticket](#github-ticket)
+    - [Origin Document](#origin-document)
+- [E2E Feature Implementation](#e2e-feature-implementation)
+  - [POC: Proof of Concept](#poc-proof-of-concept)
+  - [MVP: Minimum Viable Product](#mvp-minimum-viable-product)
+  - [PROD: Production](#prod-production)
+
+## Introduction & Goals
+
+The [Pocket Network Specification](https://github.com/pokt-network/pocket-network-protocol/tree/main/utility) implementation is driven by various [milestones](https://github.com/pokt-network/pocket/milestones) and protocol/module/component specific tasks. Each feature cross the boundaries of business logic, data types, and interfaces for different components. Due to the complex nature of implementation, we've designed a more streamlined approach.
+
+**The goal** of this document is to outline a well-defined process for adopting an end-to-end feature path approach. This makes each feature/task easier to scope, reason about, design, and implement.
+
+## Developer Journey
+
+```mermaid
+%%{init: { 'logLevel': 'debug', 'theme': 'base' } }%%
+  timeline
+    title E2E Feature Path Developer Journey
+
+    section E2E Feature Specification
+      Spot Feature:
+        User research:
+        Product management:
+        Protocol intuition/experience:
+        Addition/removal/selection of feature from the list
+      Spike Feature:
+        Research details:
+        Identify pointers:
+        Note dependencies:
+        Find blockers
+      Scope Feature:
+        Define requirements:
+        Document E2E implementation
+
+    section E2E Feature Implementation
+        POC:
+          POC Spike:
+          Explore:
+          Hack:
+          Have fun!
+        MVP:
+          Data Structures:
+          Interfaces:
+          Implementation:
+          Unit Tests:
+          E2E Tests:
+          Documentation
+        PROD:
+          Identify workarounds & hacks:
+          Document future work:
+          Ideate!
+```
+
+## Feature Specification
+
+### Spot E2E Feature
+
+Choose or add a feature from the Utility E2E feature list [here](./E2E_FEATURE_LIST.md).
+
+### Spike E2E Feature
+
+Create a SPIKE GitHub issue, like [this](<[http](https://github.com/pokt-network/pocket/issue/TODO_LINK_TO_ISSUE_ONCE_WE_HAVE_EXAMPLE)>) to scope the feature. This ticket is responsible for creating the ticket that'll track the work.
+
+### Scope E2E Feature
+
+Leverage the results from the SPIKE to create an implementation GitHub issue, like [this](<[http](https://github.com/pokt-network/pocket/issue/TODO_LINK_TO_ISSUE_ONCE_WE_HAVE_EXAMPLE)>) to track the actual implementation.
+
+#### GitHub Ticket
+
+Adhering to the GitHub template provided [here](https://github.com/pokt-network/pocket/blob/main/.github/ISSUE_TEMPLATE/issue.md), generate a [new issue](https://github.com/pokt-network/pocket/issues/new?assignees=&labels=&projects=&template=issue.md&title=%5BREPLACE+ME%5D+with+a+descriptive+title) encompassing the subsequent elements:
+
+**Objective**: `Implement MVP E2E Feature Path <Letter>.<Number>: <Name>`
+
+**Origin Document**: _Specify the details from the [Origin Document](#origin-document) below_
+
+**Goals**:
+
+- Complete the MVP implementation of the E2E Feature Path outlined in the objective
+- Identify future tasks and test requirements to transition the feature to production
+
+**Deliverables**:
+
+**POC**:
+
+- [ ] A POC SPIKE to be closed out and split out into multiple PRs
+
+**MVP**:
+
+- [ ] A PR that adds or modifies relevant structures and interfaces; such as [shared/core/types/proto](../../shared/core/types/proto), [shared/modules](../../shared/modules), etc
+- [ ] A PR that materializes an MVP of the feature along with unit tests
+- [ ] A PR that introduces a new E2E tests with **one happy** and **one sad** path scenarios as described in the origin document (refer to [e2e/README.md](../../e2e/e2e/README.md)); this may require additions to the [cli](https://github.com/pokt-network/pocket/tree/main/app/client)
+- [ ] A PR that updates all pertinent documentation
+
+**PROD**:
+
+- [ ] One or more subsequent GitHub issues that track future work including, but not limited to:
+  - Enhancing test coverage
+  - Adding subsequent features
+  - Patching hacks or workarounds
+  - Enabling your [imagination](https://github.com/pokt-network/pocket/assets/1892194/6aff9004-8d3b-48e8-b6d5-9b67ac266e3d)!
+
+#### Origin Document
+
+**Purpose:** A single sentence that captures the intended purpose, behaviour and goal of the E2E feature
+**Actors**: Check all of the protocol actors involved in the feature:
+
+- [ ] Validator
+- [ ] Application
+- [ ] Servicer
+- [ ] Fisherman
+- [ ] Portal
+
+**Data Structures**:
+
+- A list of the core types (protobufs, structs, etc) that will be used, added or modified in this feature
+- Mention or link to specific files if applicable
+- See [shared/core/types/proto](../../shared/core/types/proto) as a reference as they will most likely, but not necessarily, be part of that package
+- _TIPS:_
+
+  - _This will be non-exhaustive and will likely change during the POC or MVP stages_
+  - You can find all other structs by running this command:
+
+    ```bash
+    grep -r ""type .* struct"" --exclude-dir=""vendor"" --exclude=""*.gen.go"" --exclude=""*.pb.go"" .
+    ```
+
+  - You can find all other protobufs by running this command:
+
+    ```bash
+    find . -name ""*.proto"" -not -path ""./vendor/*""`
+    ```
+
+**Interfaces**:
+
+- A list of the interface (go interfaces, placeholder functions, grpc, etc) that will be used, added or modified in this feature
+- Mention or link to specific files if applicable
+- See [shared/modules](../../shared/modules) as a reference as they will most likely, but not necessarily, be part of that package
+- _TIPS:_
+
+  - _This will be non-exhaustive and will likely change during the POC or MVP stages_
+  - You can find all other structs by running this command:
+
+    ```bash
+    grep -r ""type .* interface"" --exclude-dir=""vendor"" --exclude=""*.gen.go"" --exclude=""*.pb.go"" .
+    ```
+
+  - You can find all other protobufs by running this command:
+
+    ```bash
+    find . -name ""*.proto"" -not -path ""./vendor/*""`
+    ```
+
+**Diagram**:
+
+- _One or more mermaid diagrams that will visualize the E2E feature_",utility/doc/E2E_FEATURE_PATH_TEMPLATE.md,2023-05-22 07:32:42+00:00,2023-05-22T07:32:43Z,Is there a particular reason for this line to be italicized?,,,,,166,RIGHT,166,,line,https://api.github.com/repos/pokt-network/pocket/pulls/734,pokt-network/pocket,17495efadc5416bb78e9e95032626d7f03ae6542
https://api.github.com/repos/pokt-network/pocket/pulls/734,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1200082017,bryanchriswhite,9a4ed9e64e4dcb7beea548ceec0ac8573c46adbf,15e6ef032d321fb3cfe279c205d98f180e341d30,"@@ -0,0 +1,218 @@
+# E2E Feature Path <!-- omit in toc -->
+
+_IMPROVE(olshansky): Once we've completed the entire process at least once, we'll add links to each step._
+
+- [Introduction \& Goals](#introduction--goals)
+- [Developer Journey](#developer-journey)
+- [Feature Specification](#feature-specification)
+  - [Spot E2E Feature](#spot-e2e-feature)
+  - [Spike E2E Feature](#spike-e2e-feature)
+  - [Scope E2E Feature](#scope-e2e-feature)
+    - [GitHub Ticket](#github-ticket)
+    - [Origin Document](#origin-document)
+- [E2E Feature Implementation](#e2e-feature-implementation)
+  - [POC: Proof of Concept](#poc-proof-of-concept)
+  - [MVP: Minimum Viable Product](#mvp-minimum-viable-product)
+  - [PROD: Production](#prod-production)
+
+## Introduction & Goals
+
+The [Pocket Network Specification](https://github.com/pokt-network/pocket-network-protocol/tree/main/utility) implementation is driven by various [milestones](https://github.com/pokt-network/pocket/milestones) and protocol/module/component specific tasks. Each feature cross the boundaries of business logic, data types, and interfaces for different components. Due to the complex nature of implementation, we've designed a more streamlined approach.
+
+**The goal** of this document is to outline a well-defined process for adopting an end-to-end feature path approach. This makes each feature/task easier to scope, reason about, design, and implement.
+
+## Developer Journey
+
+```mermaid
+%%{init: { 'logLevel': 'debug', 'theme': 'base' } }%%
+  timeline
+    title E2E Feature Path Developer Journey
+
+    section E2E Feature Specification
+      Spot Feature:
+        User research:
+        Product management:
+        Protocol intuition/experience:
+        Addition/removal/selection of feature from the list
+      Spike Feature:
+        Research details:
+        Identify pointers:
+        Note dependencies:
+        Find blockers
+      Scope Feature:
+        Define requirements:
+        Document E2E implementation
+
+    section E2E Feature Implementation
+        POC:
+          POC Spike:
+          Explore:
+          Hack:
+          Have fun!
+        MVP:
+          Data Structures:
+          Interfaces:
+          Implementation:
+          Unit Tests:
+          E2E Tests:
+          Documentation
+        PROD:
+          Identify workarounds & hacks:
+          Document future work:
+          Ideate!
+```
+
+## Feature Specification
+
+### Spot E2E Feature
+
+Choose or add a feature from the Utility E2E feature list [here](./E2E_FEATURE_LIST.md).
+
+### Spike E2E Feature
+
+Create a SPIKE GitHub issue, like [this](<[http](https://github.com/pokt-network/pocket/issue/TODO_LINK_TO_ISSUE_ONCE_WE_HAVE_EXAMPLE)>) to scope the feature. This ticket is responsible for creating the ticket that'll track the work.
+
+### Scope E2E Feature
+
+Leverage the results from the SPIKE to create an implementation GitHub issue, like [this](<[http](https://github.com/pokt-network/pocket/issue/TODO_LINK_TO_ISSUE_ONCE_WE_HAVE_EXAMPLE)>) to track the actual implementation.
+
+#### GitHub Ticket
+
+Adhering to the GitHub template provided [here](https://github.com/pokt-network/pocket/blob/main/.github/ISSUE_TEMPLATE/issue.md), generate a [new issue](https://github.com/pokt-network/pocket/issues/new?assignees=&labels=&projects=&template=issue.md&title=%5BREPLACE+ME%5D+with+a+descriptive+title) encompassing the subsequent elements:
+
+**Objective**: `Implement MVP E2E Feature Path <Letter>.<Number>: <Name>`
+
+**Origin Document**: _Specify the details from the [Origin Document](#origin-document) below_
+
+**Goals**:
+
+- Complete the MVP implementation of the E2E Feature Path outlined in the objective
+- Identify future tasks and test requirements to transition the feature to production
+
+**Deliverables**:
+
+**POC**:
+
+- [ ] A POC SPIKE to be closed out and split out into multiple PRs
+
+**MVP**:
+
+- [ ] A PR that adds or modifies relevant structures and interfaces; such as [shared/core/types/proto](../../shared/core/types/proto), [shared/modules](../../shared/modules), etc
+- [ ] A PR that materializes an MVP of the feature along with unit tests
+- [ ] A PR that introduces a new E2E tests with **one happy** and **one sad** path scenarios as described in the origin document (refer to [e2e/README.md](../../e2e/e2e/README.md)); this may require additions to the [cli](https://github.com/pokt-network/pocket/tree/main/app/client)
+- [ ] A PR that updates all pertinent documentation
+
+**PROD**:
+
+- [ ] One or more subsequent GitHub issues that track future work including, but not limited to:
+  - Enhancing test coverage
+  - Adding subsequent features
+  - Patching hacks or workarounds
+  - Enabling your [imagination](https://github.com/pokt-network/pocket/assets/1892194/6aff9004-8d3b-48e8-b6d5-9b67ac266e3d)!
+
+#### Origin Document
+
+**Purpose:** A single sentence that captures the intended purpose, behaviour and goal of the E2E feature
+**Actors**: Check all of the protocol actors involved in the feature:
+
+- [ ] Validator
+- [ ] Application
+- [ ] Servicer
+- [ ] Fisherman
+- [ ] Portal
+
+**Data Structures**:
+
+- A list of the core types (protobufs, structs, etc) that will be used, added or modified in this feature
+- Mention or link to specific files if applicable
+- See [shared/core/types/proto](../../shared/core/types/proto) as a reference as they will most likely, but not necessarily, be part of that package
+- _TIPS:_
+
+  - _This will be non-exhaustive and will likely change during the POC or MVP stages_
+  - You can find all other structs by running this command:
+
+    ```bash
+    grep -r ""type .* struct"" --exclude-dir=""vendor"" --exclude=""*.gen.go"" --exclude=""*.pb.go"" .
+    ```
+
+  - You can find all other protobufs by running this command:
+
+    ```bash
+    find . -name ""*.proto"" -not -path ""./vendor/*""`
+    ```
+
+**Interfaces**:
+
+- A list of the interface (go interfaces, placeholder functions, grpc, etc) that will be used, added or modified in this feature
+- Mention or link to specific files if applicable
+- See [shared/modules](../../shared/modules) as a reference as they will most likely, but not necessarily, be part of that package
+- _TIPS:_
+
+  - _This will be non-exhaustive and will likely change during the POC or MVP stages_
+  - You can find all other structs by running this command:
+
+    ```bash
+    grep -r ""type .* interface"" --exclude-dir=""vendor"" --exclude=""*.gen.go"" --exclude=""*.pb.go"" .
+    ```
+
+  - You can find all other protobufs by running this command:
+
+    ```bash
+    find . -name ""*.proto"" -not -path ""./vendor/*""`
+    ```
+
+**Diagram**:
+
+- _One or more mermaid diagrams that will visualize the E2E feature_
+- _TIPs:_
+  - Use multiple diagrams if a single one ends up exceeding 7 or more core elements or steps
+  - See if there’s anything in [pokt-network/pocket-network-protocol/tree/main/utility](../../utility/) or [pokt-network/pocket/tree/main/utility/doc](../../utility/doc) that you can use as a starting point
+
+**User Stories as Tests**:
+
+- Use natural language (long-form or bullet points) to define:
+  - One (or more) HAPPY E2E path(s) from start to end with all the relevant details
+  - One (or more) SAD E2E path(s) from start to end with all the relevant details
+  - **[IMPROVE] Guiding template**: A [User | Actor | Source | etc] [performs an action] [where | when | at] [some specific context or state is guaranteed] and [the expected result is...].",utility/doc/E2E_FEATURE_PATH_TEMPLATE.md,2023-05-22 07:34:15+00:00,2023-05-22T07:34:15Z,:100: Great starting point! :raised_hands: ,,,,156.0,176,RIGHT,176,156.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/734,pokt-network/pocket,17495efadc5416bb78e9e95032626d7f03ae6542
https://api.github.com/repos/pokt-network/pocket/pulls/734,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1206755667,bryanchriswhite,4efa35778c4d2413cc69bfba083114042cdb6c79,15e6ef032d321fb3cfe279c205d98f180e341d30,"@@ -46,7 +46,11 @@ jobs:
         # Set outputs using the command.
         run: |
           bash ./.githooks/pre-receive ""${{needs.changedfiles.outputs.all}}"" 2>&1 | tee output.txt
-          echo ""all=$(cat output.txt | jq -sR .)"" >> $GITHUB_OUTPUT
+          VALIDATION_OUTPUT=$(cat output.txt)
+          echo ""all=$(echo ""$VALIDATION_OUTPUT"" | jq -sR .)"" >> $GITHUB_OUTPUT
+          if [[ ""$VALIDATION_OUTPUT"" == *""failed""* ]]; then 
+            exit 1
+          fi",.github/workflows/changelog-verify.yml,2023-05-26 13:07:09+00:00,2023-05-26T13:17:22Z,"I'm hypothesizing that this, and other changes from main, are presenting here because you merged main in using a fast-forward (i.e. no merge commit):

![image](https://github.com/pokt-network/pocket/assets/600733/446b97a0-fdef-4cfd-9a96-0ec7c5b17216)

I'm making a note to add something about this to the code review guidelines. I'm not 100% sure that's the correct or perhaps only place for it though. It makes sense in terms of giving feedback to the author if they didn't know, but I think the git workflow should be outlined in developer (or perhaps contributing (?)) documentation. Regardless, I think the advise here is to use `git merge --no-ff ...` when merging main into PR branches.",,49.0,LEFT,,53,RIGHT,9,,line,https://api.github.com/repos/pokt-network/pocket/pulls/734,pokt-network/pocket,17495efadc5416bb78e9e95032626d7f03ae6542
https://api.github.com/repos/pokt-network/pocket/pulls/734,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1206780906,bryanchriswhite,4efa35778c4d2413cc69bfba083114042cdb6c79,15e6ef032d321fb3cfe279c205d98f180e341d30,"@@ -8,8 +8,8 @@ _IMPROVE(olshansky): Once we've completed the entire process at least once, we'l
   - [Spot Feature](#spot-feature)
   - [Spike Feature](#spike-feature)
   - [Scope Feature](#scope-feature)
-    - [GitHub Ticket](#github-ticket)
-    - [Origin Document](#origin-document)
+    - [1. GitHub Ticket](#1-github-ticket)
+    - [2. Origin Document](#2-origin-document)",utility/doc/E2E_FEATURE_PATH_TEMPLATE.md,2023-05-26 13:25:06+00:00,2023-05-26T13:25:06Z,Great solution! :raised_hands: (thanks for indulging me :sweat_smile:),,11.0,LEFT,,12,RIGHT,7,,line,https://api.github.com/repos/pokt-network/pocket/pulls/734,pokt-network/pocket,17495efadc5416bb78e9e95032626d7f03ae6542
https://api.github.com/repos/pokt-network/pocket/pulls/734,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1206782757,bryanchriswhite,4efa35778c4d2413cc69bfba083114042cdb6c79,15e6ef032d321fb3cfe279c205d98f180e341d30,"@@ -127,39 +127,19 @@ Open a [new issue](https://github.com/pokt-network/pocket/issues/new?assignees=&
 - Mention or link to specific files if applicable
 - See [shared/core/types/proto](../../shared/core/types/proto) as a reference as they will most likely, but not necessarily, be part of that package
 - _TIPS:_
-
   - _This will be non-exhaustive and will likely change during the POC or MVC stages_
-  - You can find all other structs by running this command:
-
-    ```bash
-    grep -r ""type .* struct"" --exclude-dir=""vendor"" --exclude=""*.gen.go"" --exclude=""*.pb.go"" .
-    ```
-
-  - You can find all other protobufs by running this command:
-
-    ```bash
-    find . -name ""*.proto"" -not -path ""./vendor/*""`
-    ```
+  - You can find all other structs by running `make search_structs`
+  - You can find all other protobufs by running `make search_protos`",utility/doc/E2E_FEATURE_PATH_TEMPLATE.md,2023-05-26 13:26:30+00:00,2023-05-26T13:26:30Z,:sunglasses: ,131.0,131.0,RIGHT,132.0,132,RIGHT,50,132.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/734,pokt-network/pocket,17495efadc5416bb78e9e95032626d7f03ae6542
https://api.github.com/repos/pokt-network/pocket/pulls/738,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1192067815,bryanchriswhite,418b37a7844e071b2e1cbc2e12484dcc61416d0a,261e196b69a5c6e0118aa51223586cb1c4c501c1,"@@ -39,6 +39,8 @@ Please mark the relevant option(s):
 ## Testing
 
 - [ ] `make develop_test`; if any code changes were made
+- [ ] E2E tests on LocalNet
+- [ ] E2E tests on DevNet",.github/PULL_REQUEST_TEMPLATE.md,2023-05-12 08:25:15+00:00,2023-05-12T08:25:29Z,"Wdyt about adding the make command to run the step and/or linking to the relevant documentation?

```suggestion
- [ ] `make test_e2e`; E2E tests on LocalNet
- [ ] [E2E tests on DevNet](<do we have docs for this?>)
```",,42.0,RIGHT,,43,RIGHT,5,,line,https://api.github.com/repos/pokt-network/pocket/pulls/738,pokt-network/pocket,bcf3f4a5443ed8d77945eef42ee550f09dcb652d
https://api.github.com/repos/pokt-network/pocket/pulls/707,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1181748471,dylanlott,cf2e1bea43d59bd9eca189ec70173a3ed41eee98,648b75a385fb68f9255fd8c5829388381e71c06a,"@@ -0,0 +1,355 @@
+package background
+
+import (
+	""context""
+	""fmt""
+	""sync""
+	""testing""
+	""time""
+
+	""github.com/golang/mock/gomock""
+	libp2pCrypto ""github.com/libp2p/go-libp2p/core/crypto""
+	libp2pHost ""github.com/libp2p/go-libp2p/core/host""
+	libp2pPeer ""github.com/libp2p/go-libp2p/core/peer""
+	mocknet ""github.com/libp2p/go-libp2p/p2p/net/mock""
+	""github.com/multiformats/go-multiaddr""
+	""github.com/stretchr/testify/require""
+
+	""github.com/pokt-network/pocket/internal/testutil""
+	typesP2P ""github.com/pokt-network/pocket/p2p/types""
+	mock_types ""github.com/pokt-network/pocket/p2p/types/mocks""
+	""github.com/pokt-network/pocket/p2p/utils""
+	""github.com/pokt-network/pocket/runtime/configs""
+	""github.com/pokt-network/pocket/runtime/defaults""
+	cryptoPocket ""github.com/pokt-network/pocket/shared/crypto""
+	mockModules ""github.com/pokt-network/pocket/shared/modules/mocks""
+)
+
+// https://www.rfc-editor.org/rfc/rfc3986#section-3.2.2
+const testIP6ServiceURL = ""[2a00:1450:4005:802::2004]:8080""
+
+// TECHDEBT(#609): move & de-dup.
+var testLocalServiceURL = fmt.Sprintf(""127.0.0.1:%d"", defaults.DefaultP2PPort)
+
+func TestBackgroundRouter_AddPeer(t *testing.T) {
+	testRouter := newTestRouter(t, nil)
+	libp2pPStore := testRouter.host.Peerstore()
+
+	// NB: assert initial state
+	require.Equal(t, 1, testRouter.pstore.Size())
+
+	existingPeer := testRouter.pstore.GetPeerList()[0]
+	require.NotNil(t, existingPeer)
+
+	existingPeerInfo, err := utils.Libp2pAddrInfoFromPeer(existingPeer)
+	require.NoError(t, err)
+
+	existingPeerstoreAddrs := libp2pPStore.Addrs(existingPeerInfo.ID)
+	require.Len(t, existingPeerstoreAddrs, 1)
+
+	existingPeerMultiaddr, err := utils.Libp2pMultiaddrFromServiceURL(existingPeer.GetServiceURL())
+	require.NoError(t, err)
+	require.Equal(t, existingPeerstoreAddrs[0].String(), existingPeerMultiaddr.String())
+
+	newPublicKey, err := cryptoPocket.GeneratePublicKey()
+	newPoktAddr := newPublicKey.Address()
+	require.NoError(t, err)
+
+	newPeer := &typesP2P.NetworkPeer{
+		PublicKey:  newPublicKey,
+		Address:    newPoktAddr,
+		ServiceURL: testIP6ServiceURL,
+	}
+	newPeerInfo, err := utils.Libp2pAddrInfoFromPeer(newPeer)
+	require.NoError(t, err)
+	newPeerMultiaddr := newPeerInfo.Addrs[0]
+
+	// NB: add to address book
+	err = testRouter.AddPeer(newPeer)
+	require.NoError(t, err)
+
+	require.Len(t, testRouter.pstore, 2)
+	require.Equal(t, testRouter.pstore.GetPeer(existingPeer.GetAddress()), existingPeer)
+	require.Equal(t, testRouter.pstore.GetPeer(newPeer.Address), newPeer)
+
+	existingPeerstoreAddrs = libp2pPStore.Addrs(existingPeerInfo.ID)
+	newPeerstoreAddrs := libp2pPStore.Addrs(newPeerInfo.ID)
+	require.Len(t, existingPeerstoreAddrs, 1)
+	require.Len(t, newPeerstoreAddrs, 1)
+	require.Equal(t, newPeerstoreAddrs[0].String(), newPeerMultiaddr.String())
+}
+
+func TestBackgroundRouter_RemovePeer(t *testing.T) {
+	testRouter := newTestRouter(t, nil)
+	peerstore := testRouter.host.Peerstore()
+
+	// NB: assert initial state
+	require.Len(t, testRouter.pstore, 1)
+
+	existingPeer := testRouter.pstore.GetPeerList()[0]
+	require.NotNil(t, existingPeer)
+
+	existingPeerInfo, err := utils.Libp2pAddrInfoFromPeer(existingPeer)
+	require.NoError(t, err)
+
+	existingPeerstoreAddrs := peerstore.Addrs(existingPeerInfo.ID)
+	require.Len(t, existingPeerstoreAddrs, 1)
+
+	existingPeerMultiaddr, err := utils.Libp2pMultiaddrFromServiceURL(existingPeer.GetServiceURL())
+	require.NoError(t, err)
+	require.Equal(t, existingPeerstoreAddrs[0].String(), existingPeerMultiaddr.String())
+
+	err = testRouter.RemovePeer(existingPeer)
+	require.NoError(t, err)
+
+	require.Len(t, testRouter.pstore, 0)
+
+	// NB: libp2p peerstore implementations only remove peer keys and metadata
+	// but continue to resolve multiaddrs until their respective TTLs expire.
+	// (see: https://github.com/libp2p/go-libp2p/blob/v0.25.1/p2p/host/peerstore/pstoremem/peerstore.go#L108)
+	// (see: https://github.com/libp2p/go-libp2p/blob/v0.25.1/p2p/host/peerstore/pstoreds/peerstore.go#L187)
+
+	existingPeerstoreAddrs = peerstore.Addrs(existingPeerInfo.ID)
+	require.Len(t, existingPeerstoreAddrs, 1)
+}
+
+func TestBackgroundRouter_Broadcast(t *testing.T) {
+	const (
+		numPeers            = 4
+		testMsg             = ""test messsage""
+		testTimeoutDuration = time.Second * 5
+	)
+
+	var (
+		ctx = context.Background()
+		mu  sync.Mutex
+		// map used as a set to collect IDs of peers which have received a message
+		seenMessages = make(map[string]struct{})
+		wg           = sync.WaitGroup{}
+		done         = make(chan struct{}, 1)
+		testTimeout  = time.After(testTimeoutDuration)
+		// NB: peerIDs are stringified
+		actualPeerIDs   []string
+		expectedPeerIDs = make([]string, numPeers)
+		testHosts       = make([]libp2pHost.Host, 0)
+		libp2pMockNet   = mocknet.New()
+	)
+
+	// setup 4 libp2p hosts to listen for incoming streams from the test backgroundRouter
+	for i := 0; i < numPeers; i++ {
+		wg.Add(1)
+
+		privKey, selfPeer := newTestPeer(t)
+		host := newTestHost(t, libp2pMockNet, privKey)
+		testHosts = append(testHosts, host)
+		expectedPeerIDs[i] = host.ID().String()
+		rtr := newRouterWithSelfPeerAndHost(t, selfPeer, host)
+		go readSubscription(t, ctx, &wg, rtr, &mu, seenMessages)
+	}
+
+	// bootstrap off of arbitrary testHost
+	privKey, selfPeer := newTestPeer(t)
+
+	// set up a test backgroundRouter
+	testRouterHost := newTestHost(t, libp2pMockNet, privKey)
+	testRouter := newRouterWithSelfPeerAndHost(t, selfPeer, testRouterHost)
+	testHosts = append(testHosts, testRouterHost)
+
+	// simulate network links between each to every other
+	// (i.e. fully-connected network)
+	err := libp2pMockNet.LinkAll()
+	require.NoError(t, err)
+
+	bootstrap(t, ctx, testHosts)
+
+	go func() {
+		// wait for hosts to listen and peer discovery
+		time.Sleep(time.Second * 2)",p2p/background/router_test.go,2023-05-01 17:39:43+00:00,2023-05-01T17:55:44Z,"If possible, I would prefer waiting on a signal channel instead to prevent a load bearing sleep.",,166.0,RIGHT,,167,RIGHT,167,,line,https://api.github.com/repos/pokt-network/pocket/pulls/707,pokt-network/pocket,d7cc85d553cf9b0257f16c3a213ed4de96b8363a
https://api.github.com/repos/pokt-network/pocket/pulls/707,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1181752183,dylanlott,cf2e1bea43d59bd9eca189ec70173a3ed41eee98,648b75a385fb68f9255fd8c5829388381e71c06a,"@@ -1,4 +1,4 @@
-ARG GOLANG_IMAGE_VERSION=golang:1.18.3-alpine3.16
+ARG GOLANG_IMAGE_VERSION=golang:1.19-alpine3.16",build/Dockerfile.client,2023-05-01 17:45:13+00:00,2023-05-01T17:55:44Z,nit: why not latest of [1.20.3](https://hub.docker.com/layers/library/golang/1.20.3/images/sha256-9413aaefd182f9499f7e17b7400709c34eb1edac9ca71c37cdc73a63691c5f95?context=explore)?,,,,1.0,1,RIGHT,2,2.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/707,pokt-network/pocket,d7cc85d553cf9b0257f16c3a213ed4de96b8363a
https://api.github.com/repos/pokt-network/pocket/pulls/707,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1184180551,Olshansk,4159d7a40f8d99835d17a00a052b6782cb3f795d,648b75a385fb68f9255fd8c5829388381e71c06a,"@@ -0,0 +1,8 @@
+package testutil
+
+func GetKeys[K comparable, V any](keyMap map[K]V) (keys []K) {
+	for key := range keyMap {",internal/testutil/map.go,2023-05-03 19:41:38+00:00,2023-05-04T02:30:02Z,"Optional micro-optimization: If you initialize keys to a slice of the appropriate length and then do: `keys[i] = key`, it'll probably be more efficient",,,,8.0,4,RIGHT,4,8.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/707,pokt-network/pocket,d7cc85d553cf9b0257f16c3a213ed4de96b8363a
https://api.github.com/repos/pokt-network/pocket/pulls/707,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1184230622,Olshansk,4159d7a40f8d99835d17a00a052b6782cb3f795d,648b75a385fb68f9255fd8c5829388381e71c06a,"@@ -15,21 +16,39 @@ This document is meant to be a supplement to the living specification of [1.0 Po
     - [Helpers](#helpers)
     - [Test Generators](#test-generators)
 
+## Definitions
+
+### ""gossip""
+
+When used generally, shorthand for ""message propogation""; **not to be confused with ""gossipsub""**.
+
+### ""gossipsub""
+
+A specific [""pubsub""](https://pkg.go.dev/github.com/libp2p/go-libp2p-pubsub) router implementation / protocol which uses information (referred to internally as 'gossip', **distinct from our definition**) about which peers have seen which messages to facilitate ""gossip"" (as per our definition).",p2p/README.md,2023-05-03 20:34:24+00:00,2023-05-04T02:30:03Z,"```suggestion
A specific [""pubsub""](https://pkg.go.dev/github.com/libp2p/go-libp2p-pubsub) router implementation/protocol which uses information (referred to internally as 'gossip' by LibP2P, **distinct from our definition**) about which peers have seen which messages to facilitate ""gossip"" (as per our definition).
```",,,,,27,RIGHT,20,,line,https://api.github.com/repos/pokt-network/pocket/pulls/707,pokt-network/pocket,d7cc85d553cf9b0257f16c3a213ed4de96b8363a
https://api.github.com/repos/pokt-network/pocket/pulls/707,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1184286894,Olshansk,4159d7a40f8d99835d17a00a052b6782cb3f795d,648b75a385fb68f9255fd8c5829388381e71c06a,"@@ -15,21 +16,39 @@ This document is meant to be a supplement to the living specification of [1.0 Po
     - [Helpers](#helpers)
     - [Test Generators](#test-generators)
 
+## Definitions
+
+### ""gossip""
+
+When used generally, shorthand for ""message propogation""; **not to be confused with ""gossipsub""**.
+
+### ""gossipsub""
+
+A specific [""pubsub""](https://pkg.go.dev/github.com/libp2p/go-libp2p-pubsub) router implementation / protocol which uses information (referred to internally as 'gossip', **distinct from our definition**) about which peers have seen which messages to facilitate ""gossip"" (as per our definition).
+
+### ""raintree gossip""
+
+A ""gossip"" protocol (and implementation) which uses the raintree algorithm for peer selection. Used between all staked actors to optimize for ""gossip"" speed.",p2p/README.md,2023-05-03 21:09:45+00:00,2023-05-04T02:30:03Z,"```suggestion
A structured ""gossip"" protocol (and implementation) which uses the raintree algorithm for peer selection. Used between all staked actors to optimize for ""gossip"" speed.
```",,,,,31,RIGHT,24,,line,https://api.github.com/repos/pokt-network/pocket/pulls/707,pokt-network/pocket,d7cc85d553cf9b0257f16c3a213ed4de96b8363a
https://api.github.com/repos/pokt-network/pocket/pulls/707,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1184287145,Olshansk,4159d7a40f8d99835d17a00a052b6782cb3f795d,648b75a385fb68f9255fd8c5829388381e71c06a,"@@ -15,21 +16,39 @@ This document is meant to be a supplement to the living specification of [1.0 Po
     - [Helpers](#helpers)
     - [Test Generators](#test-generators)
 
+## Definitions
+
+### ""gossip""
+
+When used generally, shorthand for ""message propogation""; **not to be confused with ""gossipsub""**.
+
+### ""gossipsub""
+
+A specific [""pubsub""](https://pkg.go.dev/github.com/libp2p/go-libp2p-pubsub) router implementation / protocol which uses information (referred to internally as 'gossip', **distinct from our definition**) about which peers have seen which messages to facilitate ""gossip"" (as per our definition).
+
+### ""raintree gossip""
+
+A ""gossip"" protocol (and implementation) which uses the raintree algorithm for peer selection. Used between all staked actors to optimize for ""gossip"" speed.
+
+### ""background gossip""
+
+A ""gossip"" protocol (implementation TBD) which facilitates ""gossip"" to all P2P participants, including non-staked actors (e.g. full-nodes).",p2p/README.md,2023-05-03 21:09:57+00:00,2023-05-04T02:30:03Z,Are we not planning to use LibP2P for this?,,,,35.0,35,RIGHT,28,28.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/707,pokt-network/pocket,d7cc85d553cf9b0257f16c3a213ed4de96b8363a
https://api.github.com/repos/pokt-network/pocket/pulls/707,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1184388665,Olshansk,4159d7a40f8d99835d17a00a052b6782cb3f795d,648b75a385fb68f9255fd8c5829388381e71c06a,"@@ -48,45 +67,166 @@ flowchart TD
     class PN pocket_network
 ```
 
-### Code Architecture - Network Module
+`Routers` is where [RainTree](https://github.com/pokt-network/pocket/files/9853354/raintree.pdf) (or the simpler basic approach) is implemented. See `raintree/router.go` for the specific implementation of RainTree, but please refer to the [specifications](https://github.com/pokt-network/pocket-network-protocol/tree/main/p2p) for more details.
+
+### Raintree Router Architecture
 
 _DISCUSS(team): If you feel this needs a diagram, please reach out to the team for additional details._
 _TODO(olshansky, BenVan): Link to RainTree visualizations once it is complete._
 
+### Message Propagation
+
+Given `Local P2P Module` has a message that it needs to propagate:
+
+1a. `Raintree Router` selects targets from the `Pokt Peerstore`, **which only includes staked actors**
+
+1b. `Background Router` selects targets from the libp2p `Peerstore`, **which includes all P2P participants**
+
+2. Libp2p `Host` manages opens and closes streams to targeted peers on behalf of the routers
+
+2. `Remote P2P module`'s (i.e. receiver’s) `handleStream` is called (having been registered via `setStreamHandler()`)",p2p/README.md,2023-05-03 23:08:46+00:00,2023-05-04T02:30:03Z,"We have two bullets points numbered ""2."" Is the formatting off?

<img width=""180"" alt=""Screenshot 2023-05-03 at 4 09 54 PM"" src=""https://user-images.githubusercontent.com/1892194/236071106-2378dc5a-de32-4094-9645-a191feaa1ab5.png"">
",,,,,87,RIGHT,73,,line,https://api.github.com/repos/pokt-network/pocket/pulls/707,pokt-network/pocket,d7cc85d553cf9b0257f16c3a213ed4de96b8363a
https://api.github.com/repos/pokt-network/pocket/pulls/707,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1184390965,Olshansk,4159d7a40f8d99835d17a00a052b6782cb3f795d,648b75a385fb68f9255fd8c5829388381e71c06a,"@@ -48,45 +67,166 @@ flowchart TD
     class PN pocket_network
 ```
 
-### Code Architecture - Network Module
+`Routers` is where [RainTree](https://github.com/pokt-network/pocket/files/9853354/raintree.pdf) (or the simpler basic approach) is implemented. See `raintree/router.go` for the specific implementation of RainTree, but please refer to the [specifications](https://github.com/pokt-network/pocket-network-protocol/tree/main/p2p) for more details.
+
+### Raintree Router Architecture
 
 _DISCUSS(team): If you feel this needs a diagram, please reach out to the team for additional details._
 _TODO(olshansky, BenVan): Link to RainTree visualizations once it is complete._
 
+### Message Propagation
+
+Given `Local P2P Module` has a message that it needs to propagate:
+
+1a. `Raintree Router` selects targets from the `Pokt Peerstore`, **which only includes staked actors**
+
+1b. `Background Router` selects targets from the libp2p `Peerstore`, **which includes all P2P participants**
+
+2. Libp2p `Host` manages opens and closes streams to targeted peers on behalf of the routers
+
+2. `Remote P2P module`'s (i.e. receiver’s) `handleStream` is called (having been registered via `setStreamHandler()`)
+
+3a. `handleStream` propagates message via `Raintree Router`
+
+3b.  `handleStream` propagates message via `Background Router`
+
+4a. Repeat step 1a from `Remote P2P Module`'s perspective targeting its next peers
+
+4b. Repeat step 1b from `Remote P2P Module`'s perspective targeting its next peers
+
+```mermaid",p2p/README.md,2023-05-03 23:13:52+00:00,2023-05-04T02:30:03Z,This is an AMAZING diagram. It's easy to read but it also gives both a really good high level view and low level details at the same time. Impressive,,,,92.0,97,RIGHT,83,78.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/707,pokt-network/pocket,d7cc85d553cf9b0257f16c3a213ed4de96b8363a
https://api.github.com/repos/pokt-network/pocket/pulls/707,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1184392439,Olshansk,4159d7a40f8d99835d17a00a052b6782cb3f795d,648b75a385fb68f9255fd8c5829388381e71c06a,"@@ -0,0 +1,45 @@
+package utils
+
+import (
+	""fmt""
+
+	""github.com/libp2p/go-libp2p/core/host""
+	""go.uber.org/multierr""
+
+	""github.com/pokt-network/pocket/p2p/providers""
+	""github.com/pokt-network/pocket/shared/crypto""
+)
+
+// RouterConfig is used to configure `Router` implementations using the given
+// libp2p host and current height and peerstore providers.
+// TECHDEBT: I would prefer for this to be in p2p/types/router.go but this causes",p2p/utils/config.go,2023-05-03 23:17:07+00:00,2023-05-04T02:30:03Z,"```suggestion
// TECHDEBT: This should ideally be in p2p/types/router.go but it causes
```",,,,,15,RIGHT,15,,line,https://api.github.com/repos/pokt-network/pocket/pulls/707,pokt-network/pocket,d7cc85d553cf9b0257f16c3a213ed4de96b8363a
https://api.github.com/repos/pokt-network/pocket/pulls/707,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1184394113,Olshansk,4159d7a40f8d99835d17a00a052b6782cb3f795d,648b75a385fb68f9255fd8c5829388381e71c06a,"@@ -0,0 +1,45 @@
+package utils
+
+import (
+	""fmt""
+
+	""github.com/libp2p/go-libp2p/core/host""
+	""go.uber.org/multierr""
+
+	""github.com/pokt-network/pocket/p2p/providers""
+	""github.com/pokt-network/pocket/shared/crypto""
+)
+
+// RouterConfig is used to configure `Router` implementations using the given
+// libp2p host and current height and peerstore providers.
+// TECHDEBT: I would prefer for this to be in p2p/types/router.go but this causes
+// an import cycle between `typesP2P` and `providers`.
+type RouterConfig struct {
+	Addr                  crypto.Address
+	CurrentHeightProvider providers.CurrentHeightProvider
+	Host                  host.Host
+	Hostname              string
+	MaxMempoolCount       uint64",p2p/utils/config.go,2023-05-03 23:20:17+00:00,2023-05-04T02:30:03Z,"1. Do we need `Hostname`? I feel like it's something that should be retrievable from `Host`

2. Feels weird that `MaxMempoolCount` is part of the router. I realize this is probably a legacy thing but feels like the wrong place o have that attribute. 
2.1 Is there a better place for it?
2.2 Is it out of the scope of this commit to get it there?",,21.0,RIGHT,,22,RIGHT,22,,line,https://api.github.com/repos/pokt-network/pocket/pulls/707,pokt-network/pocket,d7cc85d553cf9b0257f16c3a213ed4de96b8363a
https://api.github.com/repos/pokt-network/pocket/pulls/707,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1184394394,Olshansk,4159d7a40f8d99835d17a00a052b6782cb3f795d,648b75a385fb68f9255fd8c5829388381e71c06a,"@@ -0,0 +1,45 @@
+package utils
+
+import (
+	""fmt""
+
+	""github.com/libp2p/go-libp2p/core/host""
+	""go.uber.org/multierr""
+
+	""github.com/pokt-network/pocket/p2p/providers""
+	""github.com/pokt-network/pocket/shared/crypto""
+)
+
+// RouterConfig is used to configure `Router` implementations using the given
+// libp2p host and current height and peerstore providers.
+// TECHDEBT: I would prefer for this to be in p2p/types/router.go but this causes
+// an import cycle between `typesP2P` and `providers`.
+type RouterConfig struct {
+	Addr                  crypto.Address
+	CurrentHeightProvider providers.CurrentHeightProvider
+	Host                  host.Host
+	Hostname              string
+	MaxMempoolCount       uint64
+	PeerstoreProvider     providers.PeerstoreProvider
+}
+
+func (cfg *RouterConfig) IsValid() (err error) {
+	// TECHDEBT: can `Hostname` or `MaxMempoolCount` be invalid?",p2p/utils/config.go,2023-05-03 23:20:49+00:00,2023-05-04T02:30:03Z,Seeing this after the comment above. I don't think  they should be part of the struct.,,,,,27,RIGHT,27,,line,https://api.github.com/repos/pokt-network/pocket/pulls/707,pokt-network/pocket,d7cc85d553cf9b0257f16c3a213ed4de96b8363a
https://api.github.com/repos/pokt-network/pocket/pulls/707,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1184430718,Olshansk,4159d7a40f8d99835d17a00a052b6782cb3f795d,648b75a385fb68f9255fd8c5829388381e71c06a,"@@ -0,0 +1,168 @@
+// TECHDEBT(olshansky): Delete this once we are fully comfortable with RainTree moving forward.
+
+package background
+
+import (
+	""context""
+	""fmt""
+
+	dht ""github.com/libp2p/go-libp2p-kad-dht""
+	pubsub ""github.com/libp2p/go-libp2p-pubsub""
+	libp2pHost ""github.com/libp2p/go-libp2p/core/host""
+
+	""github.com/pokt-network/pocket/logger""
+	""github.com/pokt-network/pocket/p2p/protocol""
+	typesP2P ""github.com/pokt-network/pocket/p2p/types""
+	""github.com/pokt-network/pocket/p2p/utils""
+	cryptoPocket ""github.com/pokt-network/pocket/shared/crypto""
+	""github.com/pokt-network/pocket/shared/modules""
+	""github.com/pokt-network/pocket/shared/modules/base_modules""
+)
+
+var (
+	_ typesP2P.Router            = &backgroundRouter{}
+	_ modules.IntegratableModule = &backgroundRouter{}
+)
+
+// backgroundRouter implements `typesP2P.Router` for use with all P2P participants.
+type backgroundRouter struct {
+	base_modules.IntegratableModule
+
+	logger *modules.Logger
+	// host represents a libp2p network node, it encapsulates a libp2p peerstore
+	// & connection manager. `libp2p.New` configures and starts listening
+	// according to options.
+	// (see: https://pkg.go.dev/github.com/libp2p/go-libp2p#section-readme)
+	host libp2pHost.Host
+	// gossipSub is used for broadcast communication
+	// (i.e. multiple, unidentified receivers)
+	// TECHDEBT: investigate diff between randomSub and gossipSub
+	gossipSub *pubsub.PubSub
+	// topic similar to pubsub but received messages are filtered by a ""topic"" string.",p2p/background/router.go,2023-05-04 00:45:13+00:00,2023-05-04T02:30:03Z,"```suggestion
	// topic is similar to pubsub but received messages are filtered by a ""topic"" string.
```",,,,,41,RIGHT,41,,line,https://api.github.com/repos/pokt-network/pocket/pulls/707,pokt-network/pocket,d7cc85d553cf9b0257f16c3a213ed4de96b8363a
https://api.github.com/repos/pokt-network/pocket/pulls/707,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1184431223,Olshansk,4159d7a40f8d99835d17a00a052b6782cb3f795d,648b75a385fb68f9255fd8c5829388381e71c06a,"@@ -0,0 +1,168 @@
+// TECHDEBT(olshansky): Delete this once we are fully comfortable with RainTree moving forward.
+
+package background
+
+import (
+	""context""
+	""fmt""
+
+	dht ""github.com/libp2p/go-libp2p-kad-dht""
+	pubsub ""github.com/libp2p/go-libp2p-pubsub""
+	libp2pHost ""github.com/libp2p/go-libp2p/core/host""
+
+	""github.com/pokt-network/pocket/logger""
+	""github.com/pokt-network/pocket/p2p/protocol""
+	typesP2P ""github.com/pokt-network/pocket/p2p/types""
+	""github.com/pokt-network/pocket/p2p/utils""
+	cryptoPocket ""github.com/pokt-network/pocket/shared/crypto""
+	""github.com/pokt-network/pocket/shared/modules""
+	""github.com/pokt-network/pocket/shared/modules/base_modules""
+)
+
+var (
+	_ typesP2P.Router            = &backgroundRouter{}
+	_ modules.IntegratableModule = &backgroundRouter{}
+)
+
+// backgroundRouter implements `typesP2P.Router` for use with all P2P participants.
+type backgroundRouter struct {
+	base_modules.IntegratableModule
+
+	logger *modules.Logger
+	// host represents a libp2p network node, it encapsulates a libp2p peerstore
+	// & connection manager. `libp2p.New` configures and starts listening
+	// according to options.
+	// (see: https://pkg.go.dev/github.com/libp2p/go-libp2p#section-readme)
+	host libp2pHost.Host
+	// gossipSub is used for broadcast communication
+	// (i.e. multiple, unidentified receivers)
+	// TECHDEBT: investigate diff between randomSub and gossipSub
+	gossipSub *pubsub.PubSub
+	// topic similar to pubsub but received messages are filtered by a ""topic"" string.
+	// Published messages are also given the respective topic before broadcast.
+	topic *pubsub.Topic
+	// subscription provides an interface to continuously read messages from.
+	subscription *pubsub.Subscription
+	kadDHT       *dht.IpfsDHT
+	pstore       typesP2P.Peerstore",p2p/background/router.go,2023-05-04 00:45:56+00:00,2023-05-04T02:30:03Z,Can you add comments for these two as well?,,46.0,RIGHT,,47,RIGHT,47,,line,https://api.github.com/repos/pokt-network/pocket/pulls/707,pokt-network/pocket,d7cc85d553cf9b0257f16c3a213ed4de96b8363a
https://api.github.com/repos/pokt-network/pocket/pulls/707,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1184435487,Olshansk,4159d7a40f8d99835d17a00a052b6782cb3f795d,648b75a385fb68f9255fd8c5829388381e71c06a,"@@ -0,0 +1,168 @@
+// TECHDEBT(olshansky): Delete this once we are fully comfortable with RainTree moving forward.
+
+package background
+
+import (
+	""context""
+	""fmt""
+
+	dht ""github.com/libp2p/go-libp2p-kad-dht""
+	pubsub ""github.com/libp2p/go-libp2p-pubsub""
+	libp2pHost ""github.com/libp2p/go-libp2p/core/host""
+
+	""github.com/pokt-network/pocket/logger""
+	""github.com/pokt-network/pocket/p2p/protocol""
+	typesP2P ""github.com/pokt-network/pocket/p2p/types""
+	""github.com/pokt-network/pocket/p2p/utils""
+	cryptoPocket ""github.com/pokt-network/pocket/shared/crypto""
+	""github.com/pokt-network/pocket/shared/modules""
+	""github.com/pokt-network/pocket/shared/modules/base_modules""
+)
+
+var (
+	_ typesP2P.Router            = &backgroundRouter{}
+	_ modules.IntegratableModule = &backgroundRouter{}
+)
+
+// backgroundRouter implements `typesP2P.Router` for use with all P2P participants.
+type backgroundRouter struct {
+	base_modules.IntegratableModule
+
+	logger *modules.Logger
+	// host represents a libp2p network node, it encapsulates a libp2p peerstore
+	// & connection manager. `libp2p.New` configures and starts listening
+	// according to options.
+	// (see: https://pkg.go.dev/github.com/libp2p/go-libp2p#section-readme)
+	host libp2pHost.Host
+	// gossipSub is used for broadcast communication
+	// (i.e. multiple, unidentified receivers)
+	// TECHDEBT: investigate diff between randomSub and gossipSub
+	gossipSub *pubsub.PubSub
+	// topic similar to pubsub but received messages are filtered by a ""topic"" string.
+	// Published messages are also given the respective topic before broadcast.
+	topic *pubsub.Topic
+	// subscription provides an interface to continuously read messages from.
+	subscription *pubsub.Subscription
+	kadDHT       *dht.IpfsDHT
+	pstore       typesP2P.Peerstore
+}
+
+// NewBackgroundRouter returns a `backgroundRouter` as a `typesP2P.Router`
+// interface using the given configuration.
+func NewBackgroundRouter(bus modules.Bus, cfg *utils.RouterConfig) (typesP2P.Router, error) {
+	// TECHDEBT(#595): add ctx to interface methods and propagate down.
+	ctx := context.TODO()
+
+	networkLogger := logger.Global.CreateLoggerForModule(""backgroundRouter"")",p2p/background/router.go,2023-05-04 00:52:18+00:00,2023-05-04T02:30:03Z,Thinking out loud and outside the scope of this PR: I'm beginning to think we should move `GetModuleName` from `InitilizableModule` to `IntegratableModule` and be consistent with `logger.Global.CreateLoggerForModule(u.GetModuleName())`,,,,61.0,56,RIGHT,56,61.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/707,pokt-network/pocket,d7cc85d553cf9b0257f16c3a213ed4de96b8363a
https://api.github.com/repos/pokt-network/pocket/pulls/707,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1184435558,Olshansk,4159d7a40f8d99835d17a00a052b6782cb3f795d,648b75a385fb68f9255fd8c5829388381e71c06a,"@@ -0,0 +1,168 @@
+// TECHDEBT(olshansky): Delete this once we are fully comfortable with RainTree moving forward.
+
+package background
+
+import (
+	""context""
+	""fmt""
+
+	dht ""github.com/libp2p/go-libp2p-kad-dht""
+	pubsub ""github.com/libp2p/go-libp2p-pubsub""
+	libp2pHost ""github.com/libp2p/go-libp2p/core/host""
+
+	""github.com/pokt-network/pocket/logger""
+	""github.com/pokt-network/pocket/p2p/protocol""
+	typesP2P ""github.com/pokt-network/pocket/p2p/types""
+	""github.com/pokt-network/pocket/p2p/utils""
+	cryptoPocket ""github.com/pokt-network/pocket/shared/crypto""
+	""github.com/pokt-network/pocket/shared/modules""
+	""github.com/pokt-network/pocket/shared/modules/base_modules""
+)
+
+var (
+	_ typesP2P.Router            = &backgroundRouter{}
+	_ modules.IntegratableModule = &backgroundRouter{}
+)
+
+// backgroundRouter implements `typesP2P.Router` for use with all P2P participants.
+type backgroundRouter struct {
+	base_modules.IntegratableModule
+
+	logger *modules.Logger
+	// host represents a libp2p network node, it encapsulates a libp2p peerstore
+	// & connection manager. `libp2p.New` configures and starts listening
+	// according to options.
+	// (see: https://pkg.go.dev/github.com/libp2p/go-libp2p#section-readme)
+	host libp2pHost.Host
+	// gossipSub is used for broadcast communication
+	// (i.e. multiple, unidentified receivers)
+	// TECHDEBT: investigate diff between randomSub and gossipSub
+	gossipSub *pubsub.PubSub
+	// topic similar to pubsub but received messages are filtered by a ""topic"" string.
+	// Published messages are also given the respective topic before broadcast.
+	topic *pubsub.Topic
+	// subscription provides an interface to continuously read messages from.
+	subscription *pubsub.Subscription
+	kadDHT       *dht.IpfsDHT
+	pstore       typesP2P.Peerstore
+}
+
+// NewBackgroundRouter returns a `backgroundRouter` as a `typesP2P.Router`
+// interface using the given configuration.
+func NewBackgroundRouter(bus modules.Bus, cfg *utils.RouterConfig) (typesP2P.Router, error) {
+	// TECHDEBT(#595): add ctx to interface methods and propagate down.
+	ctx := context.TODO()
+
+	networkLogger := logger.Global.CreateLoggerForModule(""backgroundRouter"")
+	networkLogger.Info().Msg(""Initializing background"")",p2p/background/router.go,2023-05-04 00:52:31+00:00,2023-05-04T02:30:03Z,"```suggestion
	networkLogger.Info().Msg(""Initializing background router"")
```",,,,,57,RIGHT,57,,line,https://api.github.com/repos/pokt-network/pocket/pulls/707,pokt-network/pocket,d7cc85d553cf9b0257f16c3a213ed4de96b8363a
https://api.github.com/repos/pokt-network/pocket/pulls/707,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1184436462,Olshansk,4159d7a40f8d99835d17a00a052b6782cb3f795d,648b75a385fb68f9255fd8c5829388381e71c06a,"@@ -0,0 +1,168 @@
+// TECHDEBT(olshansky): Delete this once we are fully comfortable with RainTree moving forward.
+
+package background
+
+import (
+	""context""
+	""fmt""
+
+	dht ""github.com/libp2p/go-libp2p-kad-dht""
+	pubsub ""github.com/libp2p/go-libp2p-pubsub""
+	libp2pHost ""github.com/libp2p/go-libp2p/core/host""
+
+	""github.com/pokt-network/pocket/logger""
+	""github.com/pokt-network/pocket/p2p/protocol""
+	typesP2P ""github.com/pokt-network/pocket/p2p/types""
+	""github.com/pokt-network/pocket/p2p/utils""
+	cryptoPocket ""github.com/pokt-network/pocket/shared/crypto""
+	""github.com/pokt-network/pocket/shared/modules""
+	""github.com/pokt-network/pocket/shared/modules/base_modules""
+)
+
+var (
+	_ typesP2P.Router            = &backgroundRouter{}
+	_ modules.IntegratableModule = &backgroundRouter{}
+)
+
+// backgroundRouter implements `typesP2P.Router` for use with all P2P participants.
+type backgroundRouter struct {
+	base_modules.IntegratableModule
+
+	logger *modules.Logger
+	// host represents a libp2p network node, it encapsulates a libp2p peerstore
+	// & connection manager. `libp2p.New` configures and starts listening
+	// according to options.
+	// (see: https://pkg.go.dev/github.com/libp2p/go-libp2p#section-readme)
+	host libp2pHost.Host
+	// gossipSub is used for broadcast communication
+	// (i.e. multiple, unidentified receivers)
+	// TECHDEBT: investigate diff between randomSub and gossipSub
+	gossipSub *pubsub.PubSub
+	// topic similar to pubsub but received messages are filtered by a ""topic"" string.
+	// Published messages are also given the respective topic before broadcast.
+	topic *pubsub.Topic
+	// subscription provides an interface to continuously read messages from.
+	subscription *pubsub.Subscription
+	kadDHT       *dht.IpfsDHT
+	pstore       typesP2P.Peerstore
+}
+
+// NewBackgroundRouter returns a `backgroundRouter` as a `typesP2P.Router`
+// interface using the given configuration.
+func NewBackgroundRouter(bus modules.Bus, cfg *utils.RouterConfig) (typesP2P.Router, error) {
+	// TECHDEBT(#595): add ctx to interface methods and propagate down.
+	ctx := context.TODO()
+
+	networkLogger := logger.Global.CreateLoggerForModule(""backgroundRouter"")
+	networkLogger.Info().Msg(""Initializing background"")
+
+	// seed initial peerstore with current on-chain peer info (i.e. staked actors)
+	pstore, err := cfg.PeerstoreProvider.GetStakedPeerstoreAtHeight(
+		cfg.CurrentHeightProvider.CurrentHeight(),
+	)
+	if err != nil {
+		return nil, err
+	}
+
+	// NOTE_TO_SELF: `pubsub.NewRandomSub` requires a `size` arg.",p2p/background/router.go,2023-05-04 00:54:20+00:00,2023-05-04T02:30:03Z,"maybe a `CONSIDERATION: If switching to NewRandomSub, there will be a max size`",,,,,67,RIGHT,67,,line,https://api.github.com/repos/pokt-network/pocket/pulls/707,pokt-network/pocket,d7cc85d553cf9b0257f16c3a213ed4de96b8363a
https://api.github.com/repos/pokt-network/pocket/pulls/707,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1184437070,Olshansk,4159d7a40f8d99835d17a00a052b6782cb3f795d,648b75a385fb68f9255fd8c5829388381e71c06a,"@@ -0,0 +1,168 @@
+// TECHDEBT(olshansky): Delete this once we are fully comfortable with RainTree moving forward.
+
+package background
+
+import (
+	""context""
+	""fmt""
+
+	dht ""github.com/libp2p/go-libp2p-kad-dht""
+	pubsub ""github.com/libp2p/go-libp2p-pubsub""
+	libp2pHost ""github.com/libp2p/go-libp2p/core/host""
+
+	""github.com/pokt-network/pocket/logger""
+	""github.com/pokt-network/pocket/p2p/protocol""
+	typesP2P ""github.com/pokt-network/pocket/p2p/types""
+	""github.com/pokt-network/pocket/p2p/utils""
+	cryptoPocket ""github.com/pokt-network/pocket/shared/crypto""
+	""github.com/pokt-network/pocket/shared/modules""
+	""github.com/pokt-network/pocket/shared/modules/base_modules""
+)
+
+var (
+	_ typesP2P.Router            = &backgroundRouter{}
+	_ modules.IntegratableModule = &backgroundRouter{}
+)
+
+// backgroundRouter implements `typesP2P.Router` for use with all P2P participants.
+type backgroundRouter struct {
+	base_modules.IntegratableModule
+
+	logger *modules.Logger
+	// host represents a libp2p network node, it encapsulates a libp2p peerstore
+	// & connection manager. `libp2p.New` configures and starts listening
+	// according to options.
+	// (see: https://pkg.go.dev/github.com/libp2p/go-libp2p#section-readme)
+	host libp2pHost.Host
+	// gossipSub is used for broadcast communication
+	// (i.e. multiple, unidentified receivers)
+	// TECHDEBT: investigate diff between randomSub and gossipSub
+	gossipSub *pubsub.PubSub
+	// topic similar to pubsub but received messages are filtered by a ""topic"" string.
+	// Published messages are also given the respective topic before broadcast.
+	topic *pubsub.Topic
+	// subscription provides an interface to continuously read messages from.
+	subscription *pubsub.Subscription
+	kadDHT       *dht.IpfsDHT
+	pstore       typesP2P.Peerstore
+}
+
+// NewBackgroundRouter returns a `backgroundRouter` as a `typesP2P.Router`
+// interface using the given configuration.
+func NewBackgroundRouter(bus modules.Bus, cfg *utils.RouterConfig) (typesP2P.Router, error) {
+	// TECHDEBT(#595): add ctx to interface methods and propagate down.
+	ctx := context.TODO()
+
+	networkLogger := logger.Global.CreateLoggerForModule(""backgroundRouter"")
+	networkLogger.Info().Msg(""Initializing background"")
+
+	// seed initial peerstore with current on-chain peer info (i.e. staked actors)
+	pstore, err := cfg.PeerstoreProvider.GetStakedPeerstoreAtHeight(
+		cfg.CurrentHeightProvider.CurrentHeight(),
+	)
+	if err != nil {
+		return nil, err
+	}
+
+	// NOTE_TO_SELF: `pubsub.NewRandomSub` requires a `size` arg.
+	gossipSub, err := pubsub.NewGossipSub(ctx, cfg.Host)
+	if err != nil {
+		return nil, fmt.Errorf(""creating gossip pubsub: %w"", err)
+	}
+
+	dhtMode := dht.ModeAutoServer
+	// NB: don't act as a bootstrap node in peer discovery in client debug mode",p2p/background/router.go,2023-05-04 00:55:32+00:00,2023-05-04T02:30:03Z,"should this be a ""discoverable node"" rather than a ""bootstrap node"" which can be an overloaded term?",,,,79.0,74,RIGHT,74,79.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/707,pokt-network/pocket,d7cc85d553cf9b0257f16c3a213ed4de96b8363a
https://api.github.com/repos/pokt-network/pocket/pulls/707,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1184439341,Olshansk,4159d7a40f8d99835d17a00a052b6782cb3f795d,648b75a385fb68f9255fd8c5829388381e71c06a,"@@ -0,0 +1,168 @@
+// TECHDEBT(olshansky): Delete this once we are fully comfortable with RainTree moving forward.
+
+package background
+
+import (
+	""context""
+	""fmt""
+
+	dht ""github.com/libp2p/go-libp2p-kad-dht""
+	pubsub ""github.com/libp2p/go-libp2p-pubsub""
+	libp2pHost ""github.com/libp2p/go-libp2p/core/host""
+
+	""github.com/pokt-network/pocket/logger""
+	""github.com/pokt-network/pocket/p2p/protocol""
+	typesP2P ""github.com/pokt-network/pocket/p2p/types""
+	""github.com/pokt-network/pocket/p2p/utils""
+	cryptoPocket ""github.com/pokt-network/pocket/shared/crypto""
+	""github.com/pokt-network/pocket/shared/modules""
+	""github.com/pokt-network/pocket/shared/modules/base_modules""
+)
+
+var (
+	_ typesP2P.Router            = &backgroundRouter{}
+	_ modules.IntegratableModule = &backgroundRouter{}
+)
+
+// backgroundRouter implements `typesP2P.Router` for use with all P2P participants.
+type backgroundRouter struct {
+	base_modules.IntegratableModule
+
+	logger *modules.Logger
+	// host represents a libp2p network node, it encapsulates a libp2p peerstore
+	// & connection manager. `libp2p.New` configures and starts listening
+	// according to options.
+	// (see: https://pkg.go.dev/github.com/libp2p/go-libp2p#section-readme)
+	host libp2pHost.Host
+	// gossipSub is used for broadcast communication
+	// (i.e. multiple, unidentified receivers)
+	// TECHDEBT: investigate diff between randomSub and gossipSub
+	gossipSub *pubsub.PubSub
+	// topic similar to pubsub but received messages are filtered by a ""topic"" string.
+	// Published messages are also given the respective topic before broadcast.
+	topic *pubsub.Topic
+	// subscription provides an interface to continuously read messages from.
+	subscription *pubsub.Subscription
+	kadDHT       *dht.IpfsDHT
+	pstore       typesP2P.Peerstore
+}
+
+// NewBackgroundRouter returns a `backgroundRouter` as a `typesP2P.Router`
+// interface using the given configuration.
+func NewBackgroundRouter(bus modules.Bus, cfg *utils.RouterConfig) (typesP2P.Router, error) {
+	// TECHDEBT(#595): add ctx to interface methods and propagate down.
+	ctx := context.TODO()
+
+	networkLogger := logger.Global.CreateLoggerForModule(""backgroundRouter"")
+	networkLogger.Info().Msg(""Initializing background"")
+
+	// seed initial peerstore with current on-chain peer info (i.e. staked actors)
+	pstore, err := cfg.PeerstoreProvider.GetStakedPeerstoreAtHeight(
+		cfg.CurrentHeightProvider.CurrentHeight(),
+	)
+	if err != nil {
+		return nil, err
+	}
+
+	// NOTE_TO_SELF: `pubsub.NewRandomSub` requires a `size` arg.
+	gossipSub, err := pubsub.NewGossipSub(ctx, cfg.Host)
+	if err != nil {
+		return nil, fmt.Errorf(""creating gossip pubsub: %w"", err)
+	}
+
+	dhtMode := dht.ModeAutoServer
+	// NB: don't act as a bootstrap node in peer discovery in client debug mode
+	if isClientDebugMode(bus) {
+		dhtMode = dht.ModeClient
+	}
+
+	kadDHT, err := dht.New(ctx, cfg.Host, dht.Mode(dhtMode))
+	if err != nil {
+		return nil, fmt.Errorf(""creating DHT: %w"", err)
+	}
+
+	topic, err := gossipSub.Join(protocol.BackgroundTopicStr)
+	if err != nil {
+		return nil, fmt.Errorf(""joining background topic: %w"", err)
+	}
+
+	// INVESTIGATE: `WithBufferSize` `SubOpt`:
+	// > WithBufferSize is a Subscribe option to customize the size of the subscribe
+	// > output buffer. The default length is 32 but it can be configured to avoid
+	// > dropping messages if the consumer is not reading fast enough.
+	// (see: https://pkg.go.dev/github.com/libp2p/go-libp2p-pubsub#WithBufferSize)
+	subscription, err := topic.Subscribe()
+	if err != nil {
+		return nil, fmt.Errorf(""subscribing to background topic: %w"", err)
+	}
+
+	rtr := &backgroundRouter{
+		host:         cfg.Host,
+		gossipSub:    gossipSub,
+		kadDHT:       kadDHT,
+		topic:        topic,
+		subscription: subscription,
+		logger:       networkLogger,
+		pstore:       pstore,
+	}
+
+	return rtr, nil",p2p/background/router.go,2023-05-04 00:57:13+00:00,2023-05-04T02:30:03Z,Very clean initialization method 💯 !,,,,114.0,109,RIGHT,109,114.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/707,pokt-network/pocket,d7cc85d553cf9b0257f16c3a213ed4de96b8363a
https://api.github.com/repos/pokt-network/pocket/pulls/707,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1184439797,Olshansk,4159d7a40f8d99835d17a00a052b6782cb3f795d,648b75a385fb68f9255fd8c5829388381e71c06a,"@@ -0,0 +1,168 @@
+// TECHDEBT(olshansky): Delete this once we are fully comfortable with RainTree moving forward.
+
+package background
+
+import (
+	""context""
+	""fmt""
+
+	dht ""github.com/libp2p/go-libp2p-kad-dht""
+	pubsub ""github.com/libp2p/go-libp2p-pubsub""
+	libp2pHost ""github.com/libp2p/go-libp2p/core/host""
+
+	""github.com/pokt-network/pocket/logger""
+	""github.com/pokt-network/pocket/p2p/protocol""
+	typesP2P ""github.com/pokt-network/pocket/p2p/types""
+	""github.com/pokt-network/pocket/p2p/utils""
+	cryptoPocket ""github.com/pokt-network/pocket/shared/crypto""
+	""github.com/pokt-network/pocket/shared/modules""
+	""github.com/pokt-network/pocket/shared/modules/base_modules""
+)
+
+var (
+	_ typesP2P.Router            = &backgroundRouter{}
+	_ modules.IntegratableModule = &backgroundRouter{}
+)
+
+// backgroundRouter implements `typesP2P.Router` for use with all P2P participants.
+type backgroundRouter struct {
+	base_modules.IntegratableModule
+
+	logger *modules.Logger
+	// host represents a libp2p network node, it encapsulates a libp2p peerstore
+	// & connection manager. `libp2p.New` configures and starts listening
+	// according to options.
+	// (see: https://pkg.go.dev/github.com/libp2p/go-libp2p#section-readme)
+	host libp2pHost.Host
+	// gossipSub is used for broadcast communication
+	// (i.e. multiple, unidentified receivers)
+	// TECHDEBT: investigate diff between randomSub and gossipSub
+	gossipSub *pubsub.PubSub
+	// topic similar to pubsub but received messages are filtered by a ""topic"" string.
+	// Published messages are also given the respective topic before broadcast.
+	topic *pubsub.Topic
+	// subscription provides an interface to continuously read messages from.
+	subscription *pubsub.Subscription
+	kadDHT       *dht.IpfsDHT
+	pstore       typesP2P.Peerstore
+}
+
+// NewBackgroundRouter returns a `backgroundRouter` as a `typesP2P.Router`
+// interface using the given configuration.
+func NewBackgroundRouter(bus modules.Bus, cfg *utils.RouterConfig) (typesP2P.Router, error) {
+	// TECHDEBT(#595): add ctx to interface methods and propagate down.
+	ctx := context.TODO()
+
+	networkLogger := logger.Global.CreateLoggerForModule(""backgroundRouter"")
+	networkLogger.Info().Msg(""Initializing background"")
+
+	// seed initial peerstore with current on-chain peer info (i.e. staked actors)
+	pstore, err := cfg.PeerstoreProvider.GetStakedPeerstoreAtHeight(
+		cfg.CurrentHeightProvider.CurrentHeight(),
+	)
+	if err != nil {
+		return nil, err
+	}
+
+	// NOTE_TO_SELF: `pubsub.NewRandomSub` requires a `size` arg.
+	gossipSub, err := pubsub.NewGossipSub(ctx, cfg.Host)
+	if err != nil {
+		return nil, fmt.Errorf(""creating gossip pubsub: %w"", err)
+	}
+
+	dhtMode := dht.ModeAutoServer
+	// NB: don't act as a bootstrap node in peer discovery in client debug mode
+	if isClientDebugMode(bus) {
+		dhtMode = dht.ModeClient
+	}
+
+	kadDHT, err := dht.New(ctx, cfg.Host, dht.Mode(dhtMode))
+	if err != nil {
+		return nil, fmt.Errorf(""creating DHT: %w"", err)
+	}
+
+	topic, err := gossipSub.Join(protocol.BackgroundTopicStr)
+	if err != nil {
+		return nil, fmt.Errorf(""joining background topic: %w"", err)
+	}
+
+	// INVESTIGATE: `WithBufferSize` `SubOpt`:
+	// > WithBufferSize is a Subscribe option to customize the size of the subscribe
+	// > output buffer. The default length is 32 but it can be configured to avoid
+	// > dropping messages if the consumer is not reading fast enough.
+	// (see: https://pkg.go.dev/github.com/libp2p/go-libp2p-pubsub#WithBufferSize)
+	subscription, err := topic.Subscribe()
+	if err != nil {
+		return nil, fmt.Errorf(""subscribing to background topic: %w"", err)
+	}
+
+	rtr := &backgroundRouter{
+		host:         cfg.Host,
+		gossipSub:    gossipSub,
+		kadDHT:       kadDHT,
+		topic:        topic,
+		subscription: subscription,
+		logger:       networkLogger,
+		pstore:       pstore,
+	}
+
+	return rtr, nil
+}
+
+// Broadcast implements the respective `typesP2P.Router` interface  method.
+func (rtr *backgroundRouter) Broadcast(data []byte) error {
+	// TECHDEBT(#595): add ctx to interface methods and propagate down.
+	return rtr.topic.Publish(context.TODO(), data)
+}
+
+// Send implements the respective `typesP2P.Router` interface  method.
+func (rtr *backgroundRouter) Send(data []byte, address cryptoPocket.Address) error {
+	peer := rtr.pstore.GetPeer(address)
+	if peer == nil {
+		return fmt.Errorf(""peer with address %s not in peerstore"", address)
+	}
+
+	if err := utils.Libp2pSendToPeer(rtr.host, data, peer); err != nil {
+		return err
+	}
+	return nil
+}
+
+// HandleNetworkData implements the respective `typesP2P.Router` interface  method.
+func (rtr *backgroundRouter) HandleNetworkData(data []byte) ([]byte, error) {
+	return data, nil // intentional passthrough
+}
+
+// GetPeerstore implements the respective `typesP2P.Router` interface  method.
+func (rtr *backgroundRouter) GetPeerstore() typesP2P.Peerstore {
+	return rtr.pstore
+}
+
+// AddPeer implements the respective `typesP2P.Router` interface  method.
+func (rtr *backgroundRouter) AddPeer(peer typesP2P.Peer) error {
+	// Noop if peer with the pokt address already exists in the peerstore.
+	// TECHDEBT: add method(s) to update peers.",p2p/background/router.go,2023-05-04 00:58:35+00:00,2023-05-04T02:30:03Z,Looking forward to the day that we run into this in testing 😅 ,,,,149.0,144,RIGHT,144,149.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/707,pokt-network/pocket,d7cc85d553cf9b0257f16c3a213ed4de96b8363a
https://api.github.com/repos/pokt-network/pocket/pulls/707,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1184444837,Olshansk,4159d7a40f8d99835d17a00a052b6782cb3f795d,648b75a385fb68f9255fd8c5829388381e71c06a,"@@ -0,0 +1,373 @@
+package background
+
+import (
+	""context""
+	""fmt""
+	""sync""
+	""testing""
+	""time""
+
+	""github.com/golang/mock/gomock""
+	libp2pCrypto ""github.com/libp2p/go-libp2p/core/crypto""
+	libp2pHost ""github.com/libp2p/go-libp2p/core/host""
+	libp2pNetwork ""github.com/libp2p/go-libp2p/core/network""
+	libp2pPeer ""github.com/libp2p/go-libp2p/core/peer""
+	mocknet ""github.com/libp2p/go-libp2p/p2p/net/mock""
+	""github.com/multiformats/go-multiaddr""
+	""github.com/stretchr/testify/require""
+
+	""github.com/pokt-network/pocket/internal/testutil""
+	typesP2P ""github.com/pokt-network/pocket/p2p/types""
+	mock_types ""github.com/pokt-network/pocket/p2p/types/mocks""
+	""github.com/pokt-network/pocket/p2p/utils""
+	""github.com/pokt-network/pocket/runtime/configs""
+	""github.com/pokt-network/pocket/runtime/defaults""
+	cryptoPocket ""github.com/pokt-network/pocket/shared/crypto""
+	mockModules ""github.com/pokt-network/pocket/shared/modules/mocks""
+)
+
+// https://www.rfc-editor.org/rfc/rfc3986#section-3.2.2
+const testIP6ServiceURL = ""[2a00:1450:4005:802::2004]:8080""
+
+// TECHDEBT(#609): move & de-dup.
+var testLocalServiceURL = fmt.Sprintf(""127.0.0.1:%d"", defaults.DefaultP2PPort)
+
+func TestBackgroundRouter_AddPeer(t *testing.T) {
+	testRouter := newTestRouter(t, nil)
+	libp2pPStore := testRouter.host.Peerstore()
+
+	// NB: assert initial state
+	require.Equal(t, 1, testRouter.pstore.Size())
+
+	existingPeer := testRouter.pstore.GetPeerList()[0]
+	require.NotNil(t, existingPeer)
+
+	existingPeerInfo, err := utils.Libp2pAddrInfoFromPeer(existingPeer)
+	require.NoError(t, err)
+
+	existingPeerstoreAddrs := libp2pPStore.Addrs(existingPeerInfo.ID)
+	require.Len(t, existingPeerstoreAddrs, 1)
+
+	existingPeerMultiaddr, err := utils.Libp2pMultiaddrFromServiceURL(existingPeer.GetServiceURL())
+	require.NoError(t, err)
+	require.Equal(t, existingPeerstoreAddrs[0].String(), existingPeerMultiaddr.String())
+
+	newPublicKey, err := cryptoPocket.GeneratePublicKey()
+	newPoktAddr := newPublicKey.Address()
+	require.NoError(t, err)
+
+	newPeer := &typesP2P.NetworkPeer{
+		PublicKey:  newPublicKey,
+		Address:    newPoktAddr,
+		ServiceURL: testIP6ServiceURL,
+	}
+	newPeerInfo, err := utils.Libp2pAddrInfoFromPeer(newPeer)
+	require.NoError(t, err)
+	newPeerMultiaddr := newPeerInfo.Addrs[0]
+
+	// NB: add to address book
+	err = testRouter.AddPeer(newPeer)
+	require.NoError(t, err)
+
+	require.Len(t, testRouter.pstore, 2)
+	require.Equal(t, testRouter.pstore.GetPeer(existingPeer.GetAddress()), existingPeer)
+	require.Equal(t, testRouter.pstore.GetPeer(newPeer.Address), newPeer)
+
+	existingPeerstoreAddrs = libp2pPStore.Addrs(existingPeerInfo.ID)
+	newPeerstoreAddrs := libp2pPStore.Addrs(newPeerInfo.ID)
+	require.Len(t, existingPeerstoreAddrs, 1)
+	require.Len(t, newPeerstoreAddrs, 1)
+	require.Equal(t, newPeerstoreAddrs[0].String(), newPeerMultiaddr.String())
+}
+
+func TestBackgroundRouter_RemovePeer(t *testing.T) {
+	testRouter := newTestRouter(t, nil)
+	peerstore := testRouter.host.Peerstore()
+
+	// NB: assert initial state
+	require.Len(t, testRouter.pstore, 1)
+
+	existingPeer := testRouter.pstore.GetPeerList()[0]
+	require.NotNil(t, existingPeer)
+
+	existingPeerInfo, err := utils.Libp2pAddrInfoFromPeer(existingPeer)
+	require.NoError(t, err)
+
+	existingPeerstoreAddrs := peerstore.Addrs(existingPeerInfo.ID)
+	require.Len(t, existingPeerstoreAddrs, 1)
+
+	existingPeerMultiaddr, err := utils.Libp2pMultiaddrFromServiceURL(existingPeer.GetServiceURL())
+	require.NoError(t, err)
+	require.Equal(t, existingPeerstoreAddrs[0].String(), existingPeerMultiaddr.String())
+
+	err = testRouter.RemovePeer(existingPeer)
+	require.NoError(t, err)
+
+	require.Len(t, testRouter.pstore, 0)
+
+	// NB: libp2p peerstore implementations only remove peer keys and metadata",p2p/background/router_test.go,2023-05-04 01:11:14+00:00,2023-05-04T02:30:03Z,This must have been hard to find. I understand the caching decision on their end but it could definitely have gone both ways,,,,109.0,108,RIGHT,108,109.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/707,pokt-network/pocket,d7cc85d553cf9b0257f16c3a213ed4de96b8363a
https://api.github.com/repos/pokt-network/pocket/pulls/707,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1184446336,Olshansk,4159d7a40f8d99835d17a00a052b6782cb3f795d,648b75a385fb68f9255fd8c5829388381e71c06a,"@@ -0,0 +1,373 @@
+package background
+
+import (
+	""context""
+	""fmt""
+	""sync""
+	""testing""
+	""time""
+
+	""github.com/golang/mock/gomock""
+	libp2pCrypto ""github.com/libp2p/go-libp2p/core/crypto""
+	libp2pHost ""github.com/libp2p/go-libp2p/core/host""
+	libp2pNetwork ""github.com/libp2p/go-libp2p/core/network""
+	libp2pPeer ""github.com/libp2p/go-libp2p/core/peer""
+	mocknet ""github.com/libp2p/go-libp2p/p2p/net/mock""
+	""github.com/multiformats/go-multiaddr""
+	""github.com/stretchr/testify/require""
+
+	""github.com/pokt-network/pocket/internal/testutil""
+	typesP2P ""github.com/pokt-network/pocket/p2p/types""
+	mock_types ""github.com/pokt-network/pocket/p2p/types/mocks""
+	""github.com/pokt-network/pocket/p2p/utils""
+	""github.com/pokt-network/pocket/runtime/configs""
+	""github.com/pokt-network/pocket/runtime/defaults""
+	cryptoPocket ""github.com/pokt-network/pocket/shared/crypto""
+	mockModules ""github.com/pokt-network/pocket/shared/modules/mocks""
+)
+
+// https://www.rfc-editor.org/rfc/rfc3986#section-3.2.2
+const testIP6ServiceURL = ""[2a00:1450:4005:802::2004]:8080""
+
+// TECHDEBT(#609): move & de-dup.
+var testLocalServiceURL = fmt.Sprintf(""127.0.0.1:%d"", defaults.DefaultP2PPort)
+
+func TestBackgroundRouter_AddPeer(t *testing.T) {
+	testRouter := newTestRouter(t, nil)
+	libp2pPStore := testRouter.host.Peerstore()
+
+	// NB: assert initial state
+	require.Equal(t, 1, testRouter.pstore.Size())
+
+	existingPeer := testRouter.pstore.GetPeerList()[0]
+	require.NotNil(t, existingPeer)
+
+	existingPeerInfo, err := utils.Libp2pAddrInfoFromPeer(existingPeer)
+	require.NoError(t, err)
+
+	existingPeerstoreAddrs := libp2pPStore.Addrs(existingPeerInfo.ID)
+	require.Len(t, existingPeerstoreAddrs, 1)
+
+	existingPeerMultiaddr, err := utils.Libp2pMultiaddrFromServiceURL(existingPeer.GetServiceURL())
+	require.NoError(t, err)
+	require.Equal(t, existingPeerstoreAddrs[0].String(), existingPeerMultiaddr.String())
+
+	newPublicKey, err := cryptoPocket.GeneratePublicKey()
+	newPoktAddr := newPublicKey.Address()
+	require.NoError(t, err)
+
+	newPeer := &typesP2P.NetworkPeer{
+		PublicKey:  newPublicKey,
+		Address:    newPoktAddr,
+		ServiceURL: testIP6ServiceURL,
+	}
+	newPeerInfo, err := utils.Libp2pAddrInfoFromPeer(newPeer)
+	require.NoError(t, err)
+	newPeerMultiaddr := newPeerInfo.Addrs[0]
+
+	// NB: add to address book
+	err = testRouter.AddPeer(newPeer)
+	require.NoError(t, err)
+
+	require.Len(t, testRouter.pstore, 2)
+	require.Equal(t, testRouter.pstore.GetPeer(existingPeer.GetAddress()), existingPeer)
+	require.Equal(t, testRouter.pstore.GetPeer(newPeer.Address), newPeer)
+
+	existingPeerstoreAddrs = libp2pPStore.Addrs(existingPeerInfo.ID)
+	newPeerstoreAddrs := libp2pPStore.Addrs(newPeerInfo.ID)
+	require.Len(t, existingPeerstoreAddrs, 1)
+	require.Len(t, newPeerstoreAddrs, 1)
+	require.Equal(t, newPeerstoreAddrs[0].String(), newPeerMultiaddr.String())
+}
+
+func TestBackgroundRouter_RemovePeer(t *testing.T) {
+	testRouter := newTestRouter(t, nil)
+	peerstore := testRouter.host.Peerstore()
+
+	// NB: assert initial state
+	require.Len(t, testRouter.pstore, 1)
+
+	existingPeer := testRouter.pstore.GetPeerList()[0]
+	require.NotNil(t, existingPeer)
+
+	existingPeerInfo, err := utils.Libp2pAddrInfoFromPeer(existingPeer)
+	require.NoError(t, err)
+
+	existingPeerstoreAddrs := peerstore.Addrs(existingPeerInfo.ID)
+	require.Len(t, existingPeerstoreAddrs, 1)
+
+	existingPeerMultiaddr, err := utils.Libp2pMultiaddrFromServiceURL(existingPeer.GetServiceURL())
+	require.NoError(t, err)
+	require.Equal(t, existingPeerstoreAddrs[0].String(), existingPeerMultiaddr.String())
+
+	err = testRouter.RemovePeer(existingPeer)
+	require.NoError(t, err)
+
+	require.Len(t, testRouter.pstore, 0)
+
+	// NB: libp2p peerstore implementations only remove peer keys and metadata
+	// but continue to resolve multiaddrs until their respective TTLs expire.
+	// (see: https://github.com/libp2p/go-libp2p/blob/v0.25.1/p2p/host/peerstore/pstoremem/peerstore.go#L108)
+	// (see: https://github.com/libp2p/go-libp2p/blob/v0.25.1/p2p/host/peerstore/pstoreds/peerstore.go#L187)
+
+	existingPeerstoreAddrs = peerstore.Addrs(existingPeerInfo.ID)
+	require.Len(t, existingPeerstoreAddrs, 1)
+}
+
+func TestBackgroundRouter_Broadcast(t *testing.T) {
+	const (
+		numPeers            = 4
+		testMsg             = ""test messsage""
+		testTimeoutDuration = time.Second * 5
+	)
+
+	var (
+		ctx = context.Background()
+		mu  sync.Mutex
+		// map used as a set to collect IDs of peers which have received a message
+		seenMessages       = make(map[string]struct{})
+		bootstrapWaitgroup = sync.WaitGroup{}
+		broadcastWaitgroup = sync.WaitGroup{}
+		broadcastDone      = make(chan struct{}, 1)
+		testTimeout        = time.After(testTimeoutDuration)
+		// NB: peerIDs are stringified
+		actualPeerIDs   []string
+		expectedPeerIDs = make([]string, numPeers)
+		testHosts       = make([]libp2pHost.Host, 0)
+		libp2pMockNet   = mocknet.New()
+	)
+
+	// setup 4 libp2p hosts to listen for incoming streams from the test backgroundRouter
+	for i := 0; i < numPeers; i++ {
+		broadcastWaitgroup.Add(1)
+		bootstrapWaitgroup.Add(1)
+
+		privKey, selfPeer := newTestPeer(t)
+		host := newTestHost(t, libp2pMockNet, privKey)
+		testHosts = append(testHosts, host)
+		expectedPeerIDs[i] = host.ID().String()
+		rtr := newRouterWithSelfPeerAndHost(t, selfPeer, host)
+		go readSubscription(t, ctx, &broadcastWaitgroup, rtr, &mu, seenMessages)
+	}
+
+	// bootstrap off of arbitrary testHost
+	privKey, selfPeer := newTestPeer(t)
+
+	// set up a test backgroundRouter
+	testRouterHost := newTestHost(t, libp2pMockNet, privKey)
+	testRouter := newRouterWithSelfPeerAndHost(t, selfPeer, testRouterHost)
+	testHosts = append(testHosts, testRouterHost)
+
+	// simulate network links between each to every other
+	// (i.e. fully-connected network)
+	err := libp2pMockNet.LinkAll()
+	require.NoError(t, err)
+
+	// setup notifee/notify BEFORE bootstrapping
+	notifee := &libp2pNetwork.NotifyBundle{
+		ConnectedF: func(_ libp2pNetwork.Network, _ libp2pNetwork.Conn) {
+			t.Logf(""connected!"")
+			bootstrapWaitgroup.Done()
+		},
+	}
+	testRouter.host.Network().Notify(notifee)
+
+	bootstrap(t, ctx, testHosts)
+
+	go func() {
+		// wait for hosts to listen and peer discovery
+		bootstrapWaitgroup.Wait()
+		// INVESTIGATE: look for a more idiomatic way to wait for DHT peer discovery to complete
+		//
+		// `bootstrapWaitgroup` isn't quite sufficient; I suspect the DHT
+		// needs more time but am unaware of a notify/notifee interface (or
+		// something similar) at that level.
+		time.Sleep(time.Millisecond * 250)
+
+		// broadcast message
+		t.Log(""broadcasting..."")
+		err := testRouter.Broadcast([]byte(testMsg))
+		require.NoError(t, err)
+	}()
+
+	// wait concurrently
+	go func() {
+		broadcastWaitgroup.Wait()
+		broadcastDone <- struct{}{}
+	}()
+
+	// waitgroup broadcastDone or timeout
+	select {
+	case <-testTimeout:
+		t.Fatalf(
+			""timed out waiting for message: got %d; wanted %d"",
+			len(seenMessages),
+			numPeers,
+		)
+	case <-broadcastDone:
+	}
+
+	actualPeerIDs = testutil.GetKeys[string](seenMessages)
+	require.ElementsMatchf(t, expectedPeerIDs, actualPeerIDs, ""peerIDs don't match"")
+}
+
+// bootstrap connects each host to one other except for the arbitrarily chosen ""bootstrap host""
+func bootstrap(t *testing.T, ctx context.Context, testHosts []libp2pHost.Host) {
+	t.Helper()
+
+	t.Log(""bootstrapping..."")",p2p/background/router_test.go,2023-05-04 01:14:18+00:00,2023-05-04T02:30:03Z,Consider move log into the loop at log the host you're bootstrapping,,,,220.0,218,RIGHT,218,220.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/707,pokt-network/pocket,d7cc85d553cf9b0257f16c3a213ed4de96b8363a
https://api.github.com/repos/pokt-network/pocket/pulls/707,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1184468708,Olshansk,4159d7a40f8d99835d17a00a052b6782cb3f795d,648b75a385fb68f9255fd8c5829388381e71c06a,"@@ -0,0 +1,373 @@
+package background
+
+import (
+	""context""
+	""fmt""
+	""sync""
+	""testing""
+	""time""
+
+	""github.com/golang/mock/gomock""
+	libp2pCrypto ""github.com/libp2p/go-libp2p/core/crypto""
+	libp2pHost ""github.com/libp2p/go-libp2p/core/host""
+	libp2pNetwork ""github.com/libp2p/go-libp2p/core/network""
+	libp2pPeer ""github.com/libp2p/go-libp2p/core/peer""
+	mocknet ""github.com/libp2p/go-libp2p/p2p/net/mock""
+	""github.com/multiformats/go-multiaddr""
+	""github.com/stretchr/testify/require""
+
+	""github.com/pokt-network/pocket/internal/testutil""
+	typesP2P ""github.com/pokt-network/pocket/p2p/types""
+	mock_types ""github.com/pokt-network/pocket/p2p/types/mocks""
+	""github.com/pokt-network/pocket/p2p/utils""
+	""github.com/pokt-network/pocket/runtime/configs""
+	""github.com/pokt-network/pocket/runtime/defaults""
+	cryptoPocket ""github.com/pokt-network/pocket/shared/crypto""
+	mockModules ""github.com/pokt-network/pocket/shared/modules/mocks""
+)
+
+// https://www.rfc-editor.org/rfc/rfc3986#section-3.2.2
+const testIP6ServiceURL = ""[2a00:1450:4005:802::2004]:8080""
+
+// TECHDEBT(#609): move & de-dup.
+var testLocalServiceURL = fmt.Sprintf(""127.0.0.1:%d"", defaults.DefaultP2PPort)
+
+func TestBackgroundRouter_AddPeer(t *testing.T) {
+	testRouter := newTestRouter(t, nil)
+	libp2pPStore := testRouter.host.Peerstore()
+
+	// NB: assert initial state
+	require.Equal(t, 1, testRouter.pstore.Size())
+
+	existingPeer := testRouter.pstore.GetPeerList()[0]
+	require.NotNil(t, existingPeer)
+
+	existingPeerInfo, err := utils.Libp2pAddrInfoFromPeer(existingPeer)
+	require.NoError(t, err)
+
+	existingPeerstoreAddrs := libp2pPStore.Addrs(existingPeerInfo.ID)
+	require.Len(t, existingPeerstoreAddrs, 1)
+
+	existingPeerMultiaddr, err := utils.Libp2pMultiaddrFromServiceURL(existingPeer.GetServiceURL())
+	require.NoError(t, err)
+	require.Equal(t, existingPeerstoreAddrs[0].String(), existingPeerMultiaddr.String())
+
+	newPublicKey, err := cryptoPocket.GeneratePublicKey()
+	newPoktAddr := newPublicKey.Address()
+	require.NoError(t, err)
+
+	newPeer := &typesP2P.NetworkPeer{
+		PublicKey:  newPublicKey,
+		Address:    newPoktAddr,
+		ServiceURL: testIP6ServiceURL,
+	}
+	newPeerInfo, err := utils.Libp2pAddrInfoFromPeer(newPeer)
+	require.NoError(t, err)
+	newPeerMultiaddr := newPeerInfo.Addrs[0]
+
+	// NB: add to address book
+	err = testRouter.AddPeer(newPeer)
+	require.NoError(t, err)
+
+	require.Len(t, testRouter.pstore, 2)
+	require.Equal(t, testRouter.pstore.GetPeer(existingPeer.GetAddress()), existingPeer)
+	require.Equal(t, testRouter.pstore.GetPeer(newPeer.Address), newPeer)
+
+	existingPeerstoreAddrs = libp2pPStore.Addrs(existingPeerInfo.ID)
+	newPeerstoreAddrs := libp2pPStore.Addrs(newPeerInfo.ID)
+	require.Len(t, existingPeerstoreAddrs, 1)
+	require.Len(t, newPeerstoreAddrs, 1)
+	require.Equal(t, newPeerstoreAddrs[0].String(), newPeerMultiaddr.String())
+}
+
+func TestBackgroundRouter_RemovePeer(t *testing.T) {
+	testRouter := newTestRouter(t, nil)
+	peerstore := testRouter.host.Peerstore()
+
+	// NB: assert initial state
+	require.Len(t, testRouter.pstore, 1)
+
+	existingPeer := testRouter.pstore.GetPeerList()[0]
+	require.NotNil(t, existingPeer)
+
+	existingPeerInfo, err := utils.Libp2pAddrInfoFromPeer(existingPeer)
+	require.NoError(t, err)
+
+	existingPeerstoreAddrs := peerstore.Addrs(existingPeerInfo.ID)
+	require.Len(t, existingPeerstoreAddrs, 1)
+
+	existingPeerMultiaddr, err := utils.Libp2pMultiaddrFromServiceURL(existingPeer.GetServiceURL())
+	require.NoError(t, err)
+	require.Equal(t, existingPeerstoreAddrs[0].String(), existingPeerMultiaddr.String())
+
+	err = testRouter.RemovePeer(existingPeer)
+	require.NoError(t, err)
+
+	require.Len(t, testRouter.pstore, 0)
+
+	// NB: libp2p peerstore implementations only remove peer keys and metadata
+	// but continue to resolve multiaddrs until their respective TTLs expire.
+	// (see: https://github.com/libp2p/go-libp2p/blob/v0.25.1/p2p/host/peerstore/pstoremem/peerstore.go#L108)
+	// (see: https://github.com/libp2p/go-libp2p/blob/v0.25.1/p2p/host/peerstore/pstoreds/peerstore.go#L187)
+
+	existingPeerstoreAddrs = peerstore.Addrs(existingPeerInfo.ID)
+	require.Len(t, existingPeerstoreAddrs, 1)
+}
+
+func TestBackgroundRouter_Broadcast(t *testing.T) {
+	const (
+		numPeers            = 4
+		testMsg             = ""test messsage""
+		testTimeoutDuration = time.Second * 5
+	)
+
+	var (
+		ctx = context.Background()
+		mu  sync.Mutex
+		// map used as a set to collect IDs of peers which have received a message
+		seenMessages       = make(map[string]struct{})
+		bootstrapWaitgroup = sync.WaitGroup{}
+		broadcastWaitgroup = sync.WaitGroup{}
+		broadcastDone      = make(chan struct{}, 1)
+		testTimeout        = time.After(testTimeoutDuration)
+		// NB: peerIDs are stringified
+		actualPeerIDs   []string
+		expectedPeerIDs = make([]string, numPeers)
+		testHosts       = make([]libp2pHost.Host, 0)
+		libp2pMockNet   = mocknet.New()
+	)
+
+	// setup 4 libp2p hosts to listen for incoming streams from the test backgroundRouter
+	for i := 0; i < numPeers; i++ {
+		broadcastWaitgroup.Add(1)
+		bootstrapWaitgroup.Add(1)
+
+		privKey, selfPeer := newTestPeer(t)
+		host := newTestHost(t, libp2pMockNet, privKey)
+		testHosts = append(testHosts, host)
+		expectedPeerIDs[i] = host.ID().String()
+		rtr := newRouterWithSelfPeerAndHost(t, selfPeer, host)
+		go readSubscription(t, ctx, &broadcastWaitgroup, rtr, &mu, seenMessages)
+	}
+
+	// bootstrap off of arbitrary testHost
+	privKey, selfPeer := newTestPeer(t)
+
+	// set up a test backgroundRouter
+	testRouterHost := newTestHost(t, libp2pMockNet, privKey)
+	testRouter := newRouterWithSelfPeerAndHost(t, selfPeer, testRouterHost)
+	testHosts = append(testHosts, testRouterHost)
+
+	// simulate network links between each to every other
+	// (i.e. fully-connected network)
+	err := libp2pMockNet.LinkAll()
+	require.NoError(t, err)
+
+	// setup notifee/notify BEFORE bootstrapping
+	notifee := &libp2pNetwork.NotifyBundle{
+		ConnectedF: func(_ libp2pNetwork.Network, _ libp2pNetwork.Conn) {
+			t.Logf(""connected!"")
+			bootstrapWaitgroup.Done()
+		},
+	}
+	testRouter.host.Network().Notify(notifee)
+
+	bootstrap(t, ctx, testHosts)
+
+	go func() {
+		// wait for hosts to listen and peer discovery
+		bootstrapWaitgroup.Wait()
+		// INVESTIGATE: look for a more idiomatic way to wait for DHT peer discovery to complete
+		//
+		// `bootstrapWaitgroup` isn't quite sufficient; I suspect the DHT
+		// needs more time but am unaware of a notify/notifee interface (or
+		// something similar) at that level.
+		time.Sleep(time.Millisecond * 250)
+
+		// broadcast message
+		t.Log(""broadcasting..."")
+		err := testRouter.Broadcast([]byte(testMsg))
+		require.NoError(t, err)
+	}()
+
+	// wait concurrently
+	go func() {
+		broadcastWaitgroup.Wait()
+		broadcastDone <- struct{}{}
+	}()
+
+	// waitgroup broadcastDone or timeout
+	select {
+	case <-testTimeout:
+		t.Fatalf(
+			""timed out waiting for message: got %d; wanted %d"",
+			len(seenMessages),
+			numPeers,
+		)
+	case <-broadcastDone:
+	}
+
+	actualPeerIDs = testutil.GetKeys[string](seenMessages)
+	require.ElementsMatchf(t, expectedPeerIDs, actualPeerIDs, ""peerIDs don't match"")
+}
+
+// bootstrap connects each host to one other except for the arbitrarily chosen ""bootstrap host""
+func bootstrap(t *testing.T, ctx context.Context, testHosts []libp2pHost.Host) {
+	t.Helper()
+
+	t.Log(""bootstrapping..."")
+	bootstrapHost := testHosts[0]
+	for _, h := range testHosts {
+		if h.ID() == bootstrapHost.ID() {
+			continue
+		}
+
+		p2pAddr, err := multiaddr.NewMultiaddr(fmt.Sprintf(""/p2p/%s"", bootstrapHost.ID()))
+		require.NoError(t, err)
+
+		addrInfo := libp2pPeer.AddrInfo{
+			ID: bootstrapHost.ID(),
+			Addrs: []multiaddr.Multiaddr{
+				bootstrapHost.Addrs()[0].Encapsulate(p2pAddr),",p2p/background/router_test.go,2023-05-04 01:51:07+00:00,2023-05-04T02:30:03Z,I think you should move `bootstrapHost.Addrs()[0]` into a local var called `bootstrapAddr`,,,,,231,RIGHT,231,,line,https://api.github.com/repos/pokt-network/pocket/pulls/707,pokt-network/pocket,d7cc85d553cf9b0257f16c3a213ed4de96b8363a
https://api.github.com/repos/pokt-network/pocket/pulls/707,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1184469677,Olshansk,4159d7a40f8d99835d17a00a052b6782cb3f795d,648b75a385fb68f9255fd8c5829388381e71c06a,"@@ -0,0 +1,373 @@
+package background
+
+import (
+	""context""
+	""fmt""
+	""sync""
+	""testing""
+	""time""
+
+	""github.com/golang/mock/gomock""
+	libp2pCrypto ""github.com/libp2p/go-libp2p/core/crypto""
+	libp2pHost ""github.com/libp2p/go-libp2p/core/host""
+	libp2pNetwork ""github.com/libp2p/go-libp2p/core/network""
+	libp2pPeer ""github.com/libp2p/go-libp2p/core/peer""
+	mocknet ""github.com/libp2p/go-libp2p/p2p/net/mock""
+	""github.com/multiformats/go-multiaddr""
+	""github.com/stretchr/testify/require""
+
+	""github.com/pokt-network/pocket/internal/testutil""
+	typesP2P ""github.com/pokt-network/pocket/p2p/types""
+	mock_types ""github.com/pokt-network/pocket/p2p/types/mocks""
+	""github.com/pokt-network/pocket/p2p/utils""
+	""github.com/pokt-network/pocket/runtime/configs""
+	""github.com/pokt-network/pocket/runtime/defaults""
+	cryptoPocket ""github.com/pokt-network/pocket/shared/crypto""
+	mockModules ""github.com/pokt-network/pocket/shared/modules/mocks""
+)
+
+// https://www.rfc-editor.org/rfc/rfc3986#section-3.2.2
+const testIP6ServiceURL = ""[2a00:1450:4005:802::2004]:8080""
+
+// TECHDEBT(#609): move & de-dup.
+var testLocalServiceURL = fmt.Sprintf(""127.0.0.1:%d"", defaults.DefaultP2PPort)
+
+func TestBackgroundRouter_AddPeer(t *testing.T) {
+	testRouter := newTestRouter(t, nil)
+	libp2pPStore := testRouter.host.Peerstore()
+
+	// NB: assert initial state
+	require.Equal(t, 1, testRouter.pstore.Size())
+
+	existingPeer := testRouter.pstore.GetPeerList()[0]
+	require.NotNil(t, existingPeer)
+
+	existingPeerInfo, err := utils.Libp2pAddrInfoFromPeer(existingPeer)
+	require.NoError(t, err)
+
+	existingPeerstoreAddrs := libp2pPStore.Addrs(existingPeerInfo.ID)
+	require.Len(t, existingPeerstoreAddrs, 1)
+
+	existingPeerMultiaddr, err := utils.Libp2pMultiaddrFromServiceURL(existingPeer.GetServiceURL())
+	require.NoError(t, err)
+	require.Equal(t, existingPeerstoreAddrs[0].String(), existingPeerMultiaddr.String())
+
+	newPublicKey, err := cryptoPocket.GeneratePublicKey()
+	newPoktAddr := newPublicKey.Address()
+	require.NoError(t, err)
+
+	newPeer := &typesP2P.NetworkPeer{
+		PublicKey:  newPublicKey,
+		Address:    newPoktAddr,
+		ServiceURL: testIP6ServiceURL,
+	}
+	newPeerInfo, err := utils.Libp2pAddrInfoFromPeer(newPeer)
+	require.NoError(t, err)
+	newPeerMultiaddr := newPeerInfo.Addrs[0]
+
+	// NB: add to address book
+	err = testRouter.AddPeer(newPeer)
+	require.NoError(t, err)
+
+	require.Len(t, testRouter.pstore, 2)
+	require.Equal(t, testRouter.pstore.GetPeer(existingPeer.GetAddress()), existingPeer)
+	require.Equal(t, testRouter.pstore.GetPeer(newPeer.Address), newPeer)
+
+	existingPeerstoreAddrs = libp2pPStore.Addrs(existingPeerInfo.ID)
+	newPeerstoreAddrs := libp2pPStore.Addrs(newPeerInfo.ID)
+	require.Len(t, existingPeerstoreAddrs, 1)
+	require.Len(t, newPeerstoreAddrs, 1)
+	require.Equal(t, newPeerstoreAddrs[0].String(), newPeerMultiaddr.String())
+}
+
+func TestBackgroundRouter_RemovePeer(t *testing.T) {
+	testRouter := newTestRouter(t, nil)
+	peerstore := testRouter.host.Peerstore()
+
+	// NB: assert initial state
+	require.Len(t, testRouter.pstore, 1)
+
+	existingPeer := testRouter.pstore.GetPeerList()[0]
+	require.NotNil(t, existingPeer)
+
+	existingPeerInfo, err := utils.Libp2pAddrInfoFromPeer(existingPeer)
+	require.NoError(t, err)
+
+	existingPeerstoreAddrs := peerstore.Addrs(existingPeerInfo.ID)
+	require.Len(t, existingPeerstoreAddrs, 1)
+
+	existingPeerMultiaddr, err := utils.Libp2pMultiaddrFromServiceURL(existingPeer.GetServiceURL())
+	require.NoError(t, err)
+	require.Equal(t, existingPeerstoreAddrs[0].String(), existingPeerMultiaddr.String())
+
+	err = testRouter.RemovePeer(existingPeer)
+	require.NoError(t, err)
+
+	require.Len(t, testRouter.pstore, 0)
+
+	// NB: libp2p peerstore implementations only remove peer keys and metadata
+	// but continue to resolve multiaddrs until their respective TTLs expire.
+	// (see: https://github.com/libp2p/go-libp2p/blob/v0.25.1/p2p/host/peerstore/pstoremem/peerstore.go#L108)
+	// (see: https://github.com/libp2p/go-libp2p/blob/v0.25.1/p2p/host/peerstore/pstoreds/peerstore.go#L187)
+
+	existingPeerstoreAddrs = peerstore.Addrs(existingPeerInfo.ID)
+	require.Len(t, existingPeerstoreAddrs, 1)
+}
+
+func TestBackgroundRouter_Broadcast(t *testing.T) {
+	const (
+		numPeers            = 4
+		testMsg             = ""test messsage""
+		testTimeoutDuration = time.Second * 5
+	)
+
+	var (
+		ctx = context.Background()
+		mu  sync.Mutex",p2p/background/router_test.go,2023-05-04 01:54:23+00:00,2023-05-04T02:30:03Z,"1. s/mu/seenMessagesMutext
2. Add a `// mutex to avoid concurrent writes to the seenMessages map`",,,,,126,RIGHT,126,,line,https://api.github.com/repos/pokt-network/pocket/pulls/707,pokt-network/pocket,d7cc85d553cf9b0257f16c3a213ed4de96b8363a
https://api.github.com/repos/pokt-network/pocket/pulls/707,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1184470542,Olshansk,4159d7a40f8d99835d17a00a052b6782cb3f795d,648b75a385fb68f9255fd8c5829388381e71c06a,"@@ -0,0 +1,373 @@
+package background
+
+import (
+	""context""
+	""fmt""
+	""sync""
+	""testing""
+	""time""
+
+	""github.com/golang/mock/gomock""
+	libp2pCrypto ""github.com/libp2p/go-libp2p/core/crypto""
+	libp2pHost ""github.com/libp2p/go-libp2p/core/host""
+	libp2pNetwork ""github.com/libp2p/go-libp2p/core/network""
+	libp2pPeer ""github.com/libp2p/go-libp2p/core/peer""
+	mocknet ""github.com/libp2p/go-libp2p/p2p/net/mock""
+	""github.com/multiformats/go-multiaddr""
+	""github.com/stretchr/testify/require""
+
+	""github.com/pokt-network/pocket/internal/testutil""
+	typesP2P ""github.com/pokt-network/pocket/p2p/types""
+	mock_types ""github.com/pokt-network/pocket/p2p/types/mocks""
+	""github.com/pokt-network/pocket/p2p/utils""
+	""github.com/pokt-network/pocket/runtime/configs""
+	""github.com/pokt-network/pocket/runtime/defaults""
+	cryptoPocket ""github.com/pokt-network/pocket/shared/crypto""
+	mockModules ""github.com/pokt-network/pocket/shared/modules/mocks""
+)
+
+// https://www.rfc-editor.org/rfc/rfc3986#section-3.2.2
+const testIP6ServiceURL = ""[2a00:1450:4005:802::2004]:8080""
+
+// TECHDEBT(#609): move & de-dup.
+var testLocalServiceURL = fmt.Sprintf(""127.0.0.1:%d"", defaults.DefaultP2PPort)
+
+func TestBackgroundRouter_AddPeer(t *testing.T) {
+	testRouter := newTestRouter(t, nil)
+	libp2pPStore := testRouter.host.Peerstore()
+
+	// NB: assert initial state
+	require.Equal(t, 1, testRouter.pstore.Size())
+
+	existingPeer := testRouter.pstore.GetPeerList()[0]
+	require.NotNil(t, existingPeer)
+
+	existingPeerInfo, err := utils.Libp2pAddrInfoFromPeer(existingPeer)
+	require.NoError(t, err)
+
+	existingPeerstoreAddrs := libp2pPStore.Addrs(existingPeerInfo.ID)
+	require.Len(t, existingPeerstoreAddrs, 1)
+
+	existingPeerMultiaddr, err := utils.Libp2pMultiaddrFromServiceURL(existingPeer.GetServiceURL())
+	require.NoError(t, err)
+	require.Equal(t, existingPeerstoreAddrs[0].String(), existingPeerMultiaddr.String())
+
+	newPublicKey, err := cryptoPocket.GeneratePublicKey()
+	newPoktAddr := newPublicKey.Address()
+	require.NoError(t, err)
+
+	newPeer := &typesP2P.NetworkPeer{
+		PublicKey:  newPublicKey,
+		Address:    newPoktAddr,
+		ServiceURL: testIP6ServiceURL,
+	}
+	newPeerInfo, err := utils.Libp2pAddrInfoFromPeer(newPeer)
+	require.NoError(t, err)
+	newPeerMultiaddr := newPeerInfo.Addrs[0]
+
+	// NB: add to address book
+	err = testRouter.AddPeer(newPeer)
+	require.NoError(t, err)
+
+	require.Len(t, testRouter.pstore, 2)
+	require.Equal(t, testRouter.pstore.GetPeer(existingPeer.GetAddress()), existingPeer)
+	require.Equal(t, testRouter.pstore.GetPeer(newPeer.Address), newPeer)
+
+	existingPeerstoreAddrs = libp2pPStore.Addrs(existingPeerInfo.ID)
+	newPeerstoreAddrs := libp2pPStore.Addrs(newPeerInfo.ID)
+	require.Len(t, existingPeerstoreAddrs, 1)
+	require.Len(t, newPeerstoreAddrs, 1)
+	require.Equal(t, newPeerstoreAddrs[0].String(), newPeerMultiaddr.String())
+}
+
+func TestBackgroundRouter_RemovePeer(t *testing.T) {
+	testRouter := newTestRouter(t, nil)
+	peerstore := testRouter.host.Peerstore()
+
+	// NB: assert initial state
+	require.Len(t, testRouter.pstore, 1)
+
+	existingPeer := testRouter.pstore.GetPeerList()[0]
+	require.NotNil(t, existingPeer)
+
+	existingPeerInfo, err := utils.Libp2pAddrInfoFromPeer(existingPeer)
+	require.NoError(t, err)
+
+	existingPeerstoreAddrs := peerstore.Addrs(existingPeerInfo.ID)
+	require.Len(t, existingPeerstoreAddrs, 1)
+
+	existingPeerMultiaddr, err := utils.Libp2pMultiaddrFromServiceURL(existingPeer.GetServiceURL())
+	require.NoError(t, err)
+	require.Equal(t, existingPeerstoreAddrs[0].String(), existingPeerMultiaddr.String())
+
+	err = testRouter.RemovePeer(existingPeer)
+	require.NoError(t, err)
+
+	require.Len(t, testRouter.pstore, 0)
+
+	// NB: libp2p peerstore implementations only remove peer keys and metadata
+	// but continue to resolve multiaddrs until their respective TTLs expire.
+	// (see: https://github.com/libp2p/go-libp2p/blob/v0.25.1/p2p/host/peerstore/pstoremem/peerstore.go#L108)
+	// (see: https://github.com/libp2p/go-libp2p/blob/v0.25.1/p2p/host/peerstore/pstoreds/peerstore.go#L187)
+
+	existingPeerstoreAddrs = peerstore.Addrs(existingPeerInfo.ID)
+	require.Len(t, existingPeerstoreAddrs, 1)
+}
+
+func TestBackgroundRouter_Broadcast(t *testing.T) {
+	const (
+		numPeers            = 4
+		testMsg             = ""test messsage""
+		testTimeoutDuration = time.Second * 5
+	)
+
+	var (
+		ctx = context.Background()
+		mu  sync.Mutex
+		// map used as a set to collect IDs of peers which have received a message
+		seenMessages       = make(map[string]struct{})
+		bootstrapWaitgroup = sync.WaitGroup{}
+		broadcastWaitgroup = sync.WaitGroup{}
+		broadcastDone      = make(chan struct{}, 1)
+		testTimeout        = time.After(testTimeoutDuration)
+		// NB: peerIDs are stringified
+		actualPeerIDs   []string
+		expectedPeerIDs = make([]string, numPeers)
+		testHosts       = make([]libp2pHost.Host, 0)
+		libp2pMockNet   = mocknet.New()
+	)
+
+	// setup 4 libp2p hosts to listen for incoming streams from the test backgroundRouter
+	for i := 0; i < numPeers; i++ {
+		broadcastWaitgroup.Add(1)
+		bootstrapWaitgroup.Add(1)
+
+		privKey, selfPeer := newTestPeer(t)
+		host := newTestHost(t, libp2pMockNet, privKey)
+		testHosts = append(testHosts, host)
+		expectedPeerIDs[i] = host.ID().String()
+		rtr := newRouterWithSelfPeerAndHost(t, selfPeer, host)
+		go readSubscription(t, ctx, &broadcastWaitgroup, rtr, &mu, seenMessages)
+	}
+
+	// bootstrap off of arbitrary testHost
+	privKey, selfPeer := newTestPeer(t)
+
+	// set up a test backgroundRouter
+	testRouterHost := newTestHost(t, libp2pMockNet, privKey)
+	testRouter := newRouterWithSelfPeerAndHost(t, selfPeer, testRouterHost)
+	testHosts = append(testHosts, testRouterHost)
+
+	// simulate network links between each to every other
+	// (i.e. fully-connected network)
+	err := libp2pMockNet.LinkAll()
+	require.NoError(t, err)
+
+	// setup notifee/notify BEFORE bootstrapping
+	notifee := &libp2pNetwork.NotifyBundle{
+		ConnectedF: func(_ libp2pNetwork.Network, _ libp2pNetwork.Conn) {
+			t.Logf(""connected!"")
+			bootstrapWaitgroup.Done()
+		},
+	}
+	testRouter.host.Network().Notify(notifee)
+
+	bootstrap(t, ctx, testHosts)
+
+	go func() {",p2p/background/router_test.go,2023-05-04 01:56:31+00:00,2023-05-04T02:30:03Z,"We are only broadcasting after we bootstrap + wait for DHT to fill out.

Why do we have to async goroutines? Seems like having them in place would make things simpler",,,,181.0,177,RIGHT,177,181.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/707,pokt-network/pocket,d7cc85d553cf9b0257f16c3a213ed4de96b8363a
https://api.github.com/repos/pokt-network/pocket/pulls/707,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1184470959,Olshansk,4159d7a40f8d99835d17a00a052b6782cb3f795d,648b75a385fb68f9255fd8c5829388381e71c06a,"@@ -0,0 +1,373 @@
+package background
+
+import (
+	""context""
+	""fmt""
+	""sync""
+	""testing""
+	""time""
+
+	""github.com/golang/mock/gomock""
+	libp2pCrypto ""github.com/libp2p/go-libp2p/core/crypto""
+	libp2pHost ""github.com/libp2p/go-libp2p/core/host""
+	libp2pNetwork ""github.com/libp2p/go-libp2p/core/network""
+	libp2pPeer ""github.com/libp2p/go-libp2p/core/peer""
+	mocknet ""github.com/libp2p/go-libp2p/p2p/net/mock""
+	""github.com/multiformats/go-multiaddr""
+	""github.com/stretchr/testify/require""
+
+	""github.com/pokt-network/pocket/internal/testutil""
+	typesP2P ""github.com/pokt-network/pocket/p2p/types""
+	mock_types ""github.com/pokt-network/pocket/p2p/types/mocks""
+	""github.com/pokt-network/pocket/p2p/utils""
+	""github.com/pokt-network/pocket/runtime/configs""
+	""github.com/pokt-network/pocket/runtime/defaults""
+	cryptoPocket ""github.com/pokt-network/pocket/shared/crypto""
+	mockModules ""github.com/pokt-network/pocket/shared/modules/mocks""
+)
+
+// https://www.rfc-editor.org/rfc/rfc3986#section-3.2.2
+const testIP6ServiceURL = ""[2a00:1450:4005:802::2004]:8080""
+
+// TECHDEBT(#609): move & de-dup.
+var testLocalServiceURL = fmt.Sprintf(""127.0.0.1:%d"", defaults.DefaultP2PPort)
+
+func TestBackgroundRouter_AddPeer(t *testing.T) {
+	testRouter := newTestRouter(t, nil)
+	libp2pPStore := testRouter.host.Peerstore()
+
+	// NB: assert initial state
+	require.Equal(t, 1, testRouter.pstore.Size())
+
+	existingPeer := testRouter.pstore.GetPeerList()[0]
+	require.NotNil(t, existingPeer)
+
+	existingPeerInfo, err := utils.Libp2pAddrInfoFromPeer(existingPeer)
+	require.NoError(t, err)
+
+	existingPeerstoreAddrs := libp2pPStore.Addrs(existingPeerInfo.ID)
+	require.Len(t, existingPeerstoreAddrs, 1)
+
+	existingPeerMultiaddr, err := utils.Libp2pMultiaddrFromServiceURL(existingPeer.GetServiceURL())
+	require.NoError(t, err)
+	require.Equal(t, existingPeerstoreAddrs[0].String(), existingPeerMultiaddr.String())
+
+	newPublicKey, err := cryptoPocket.GeneratePublicKey()
+	newPoktAddr := newPublicKey.Address()
+	require.NoError(t, err)
+
+	newPeer := &typesP2P.NetworkPeer{
+		PublicKey:  newPublicKey,
+		Address:    newPoktAddr,
+		ServiceURL: testIP6ServiceURL,
+	}
+	newPeerInfo, err := utils.Libp2pAddrInfoFromPeer(newPeer)
+	require.NoError(t, err)
+	newPeerMultiaddr := newPeerInfo.Addrs[0]
+
+	// NB: add to address book
+	err = testRouter.AddPeer(newPeer)
+	require.NoError(t, err)
+
+	require.Len(t, testRouter.pstore, 2)
+	require.Equal(t, testRouter.pstore.GetPeer(existingPeer.GetAddress()), existingPeer)
+	require.Equal(t, testRouter.pstore.GetPeer(newPeer.Address), newPeer)
+
+	existingPeerstoreAddrs = libp2pPStore.Addrs(existingPeerInfo.ID)
+	newPeerstoreAddrs := libp2pPStore.Addrs(newPeerInfo.ID)
+	require.Len(t, existingPeerstoreAddrs, 1)
+	require.Len(t, newPeerstoreAddrs, 1)
+	require.Equal(t, newPeerstoreAddrs[0].String(), newPeerMultiaddr.String())
+}
+
+func TestBackgroundRouter_RemovePeer(t *testing.T) {
+	testRouter := newTestRouter(t, nil)
+	peerstore := testRouter.host.Peerstore()
+
+	// NB: assert initial state
+	require.Len(t, testRouter.pstore, 1)
+
+	existingPeer := testRouter.pstore.GetPeerList()[0]
+	require.NotNil(t, existingPeer)
+
+	existingPeerInfo, err := utils.Libp2pAddrInfoFromPeer(existingPeer)
+	require.NoError(t, err)
+
+	existingPeerstoreAddrs := peerstore.Addrs(existingPeerInfo.ID)
+	require.Len(t, existingPeerstoreAddrs, 1)
+
+	existingPeerMultiaddr, err := utils.Libp2pMultiaddrFromServiceURL(existingPeer.GetServiceURL())
+	require.NoError(t, err)
+	require.Equal(t, existingPeerstoreAddrs[0].String(), existingPeerMultiaddr.String())
+
+	err = testRouter.RemovePeer(existingPeer)
+	require.NoError(t, err)
+
+	require.Len(t, testRouter.pstore, 0)
+
+	// NB: libp2p peerstore implementations only remove peer keys and metadata
+	// but continue to resolve multiaddrs until their respective TTLs expire.
+	// (see: https://github.com/libp2p/go-libp2p/blob/v0.25.1/p2p/host/peerstore/pstoremem/peerstore.go#L108)
+	// (see: https://github.com/libp2p/go-libp2p/blob/v0.25.1/p2p/host/peerstore/pstoreds/peerstore.go#L187)
+
+	existingPeerstoreAddrs = peerstore.Addrs(existingPeerInfo.ID)
+	require.Len(t, existingPeerstoreAddrs, 1)
+}
+
+func TestBackgroundRouter_Broadcast(t *testing.T) {
+	const (
+		numPeers            = 4
+		testMsg             = ""test messsage""
+		testTimeoutDuration = time.Second * 5
+	)
+
+	var (
+		ctx = context.Background()
+		mu  sync.Mutex
+		// map used as a set to collect IDs of peers which have received a message
+		seenMessages       = make(map[string]struct{})
+		bootstrapWaitgroup = sync.WaitGroup{}
+		broadcastWaitgroup = sync.WaitGroup{}
+		broadcastDone      = make(chan struct{}, 1)
+		testTimeout        = time.After(testTimeoutDuration)
+		// NB: peerIDs are stringified
+		actualPeerIDs   []string
+		expectedPeerIDs = make([]string, numPeers)
+		testHosts       = make([]libp2pHost.Host, 0)
+		libp2pMockNet   = mocknet.New()
+	)
+
+	// setup 4 libp2p hosts to listen for incoming streams from the test backgroundRouter
+	for i := 0; i < numPeers; i++ {
+		broadcastWaitgroup.Add(1)
+		bootstrapWaitgroup.Add(1)
+
+		privKey, selfPeer := newTestPeer(t)
+		host := newTestHost(t, libp2pMockNet, privKey)
+		testHosts = append(testHosts, host)
+		expectedPeerIDs[i] = host.ID().String()
+		rtr := newRouterWithSelfPeerAndHost(t, selfPeer, host)
+		go readSubscription(t, ctx, &broadcastWaitgroup, rtr, &mu, seenMessages)
+	}
+
+	// bootstrap off of arbitrary testHost
+	privKey, selfPeer := newTestPeer(t)
+
+	// set up a test backgroundRouter
+	testRouterHost := newTestHost(t, libp2pMockNet, privKey)
+	testRouter := newRouterWithSelfPeerAndHost(t, selfPeer, testRouterHost)
+	testHosts = append(testHosts, testRouterHost)
+
+	// simulate network links between each to every other
+	// (i.e. fully-connected network)
+	err := libp2pMockNet.LinkAll()
+	require.NoError(t, err)
+
+	// setup notifee/notify BEFORE bootstrapping
+	notifee := &libp2pNetwork.NotifyBundle{
+		ConnectedF: func(_ libp2pNetwork.Network, _ libp2pNetwork.Conn) {
+			t.Logf(""connected!"")
+			bootstrapWaitgroup.Done()
+		},
+	}
+	testRouter.host.Network().Notify(notifee)
+
+	bootstrap(t, ctx, testHosts)
+
+	go func() {
+		// wait for hosts to listen and peer discovery
+		bootstrapWaitgroup.Wait()
+		// INVESTIGATE: look for a more idiomatic way to wait for DHT peer discovery to complete
+		//
+		// `bootstrapWaitgroup` isn't quite sufficient; I suspect the DHT
+		// needs more time but am unaware of a notify/notifee interface (or
+		// something similar) at that level.
+		time.Sleep(time.Millisecond * 250)
+
+		// broadcast message
+		t.Log(""broadcasting..."")
+		err := testRouter.Broadcast([]byte(testMsg))
+		require.NoError(t, err)
+	}()
+
+	// wait concurrently
+	go func() {
+		broadcastWaitgroup.Wait()
+		broadcastDone <- struct{}{}
+	}()
+
+	// waitgroup broadcastDone or timeout
+	select {
+	case <-testTimeout:
+		t.Fatalf(
+			""timed out waiting for message: got %d; wanted %d"",",p2p/background/router_test.go,2023-05-04 01:57:44+00:00,2023-05-04T02:30:03Z,"```suggestion
			""timed out waiting for all expected messages: got %d; wanted %d"",
```",,,,,203,RIGHT,203,,line,https://api.github.com/repos/pokt-network/pocket/pulls/707,pokt-network/pocket,d7cc85d553cf9b0257f16c3a213ed4de96b8363a
https://api.github.com/repos/pokt-network/pocket/pulls/707,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1184471500,Olshansk,4159d7a40f8d99835d17a00a052b6782cb3f795d,648b75a385fb68f9255fd8c5829388381e71c06a,"@@ -0,0 +1,373 @@
+package background
+
+import (
+	""context""
+	""fmt""
+	""sync""
+	""testing""
+	""time""
+
+	""github.com/golang/mock/gomock""
+	libp2pCrypto ""github.com/libp2p/go-libp2p/core/crypto""
+	libp2pHost ""github.com/libp2p/go-libp2p/core/host""
+	libp2pNetwork ""github.com/libp2p/go-libp2p/core/network""
+	libp2pPeer ""github.com/libp2p/go-libp2p/core/peer""
+	mocknet ""github.com/libp2p/go-libp2p/p2p/net/mock""
+	""github.com/multiformats/go-multiaddr""
+	""github.com/stretchr/testify/require""
+
+	""github.com/pokt-network/pocket/internal/testutil""
+	typesP2P ""github.com/pokt-network/pocket/p2p/types""
+	mock_types ""github.com/pokt-network/pocket/p2p/types/mocks""
+	""github.com/pokt-network/pocket/p2p/utils""
+	""github.com/pokt-network/pocket/runtime/configs""
+	""github.com/pokt-network/pocket/runtime/defaults""
+	cryptoPocket ""github.com/pokt-network/pocket/shared/crypto""
+	mockModules ""github.com/pokt-network/pocket/shared/modules/mocks""
+)
+
+// https://www.rfc-editor.org/rfc/rfc3986#section-3.2.2
+const testIP6ServiceURL = ""[2a00:1450:4005:802::2004]:8080""
+
+// TECHDEBT(#609): move & de-dup.
+var testLocalServiceURL = fmt.Sprintf(""127.0.0.1:%d"", defaults.DefaultP2PPort)
+
+func TestBackgroundRouter_AddPeer(t *testing.T) {
+	testRouter := newTestRouter(t, nil)
+	libp2pPStore := testRouter.host.Peerstore()
+
+	// NB: assert initial state
+	require.Equal(t, 1, testRouter.pstore.Size())
+
+	existingPeer := testRouter.pstore.GetPeerList()[0]
+	require.NotNil(t, existingPeer)
+
+	existingPeerInfo, err := utils.Libp2pAddrInfoFromPeer(existingPeer)
+	require.NoError(t, err)
+
+	existingPeerstoreAddrs := libp2pPStore.Addrs(existingPeerInfo.ID)
+	require.Len(t, existingPeerstoreAddrs, 1)
+
+	existingPeerMultiaddr, err := utils.Libp2pMultiaddrFromServiceURL(existingPeer.GetServiceURL())
+	require.NoError(t, err)
+	require.Equal(t, existingPeerstoreAddrs[0].String(), existingPeerMultiaddr.String())
+
+	newPublicKey, err := cryptoPocket.GeneratePublicKey()
+	newPoktAddr := newPublicKey.Address()
+	require.NoError(t, err)
+
+	newPeer := &typesP2P.NetworkPeer{
+		PublicKey:  newPublicKey,
+		Address:    newPoktAddr,
+		ServiceURL: testIP6ServiceURL,
+	}
+	newPeerInfo, err := utils.Libp2pAddrInfoFromPeer(newPeer)
+	require.NoError(t, err)
+	newPeerMultiaddr := newPeerInfo.Addrs[0]
+
+	// NB: add to address book
+	err = testRouter.AddPeer(newPeer)
+	require.NoError(t, err)
+
+	require.Len(t, testRouter.pstore, 2)
+	require.Equal(t, testRouter.pstore.GetPeer(existingPeer.GetAddress()), existingPeer)
+	require.Equal(t, testRouter.pstore.GetPeer(newPeer.Address), newPeer)
+
+	existingPeerstoreAddrs = libp2pPStore.Addrs(existingPeerInfo.ID)
+	newPeerstoreAddrs := libp2pPStore.Addrs(newPeerInfo.ID)
+	require.Len(t, existingPeerstoreAddrs, 1)
+	require.Len(t, newPeerstoreAddrs, 1)
+	require.Equal(t, newPeerstoreAddrs[0].String(), newPeerMultiaddr.String())
+}
+
+func TestBackgroundRouter_RemovePeer(t *testing.T) {
+	testRouter := newTestRouter(t, nil)
+	peerstore := testRouter.host.Peerstore()
+
+	// NB: assert initial state
+	require.Len(t, testRouter.pstore, 1)
+
+	existingPeer := testRouter.pstore.GetPeerList()[0]
+	require.NotNil(t, existingPeer)
+
+	existingPeerInfo, err := utils.Libp2pAddrInfoFromPeer(existingPeer)
+	require.NoError(t, err)
+
+	existingPeerstoreAddrs := peerstore.Addrs(existingPeerInfo.ID)
+	require.Len(t, existingPeerstoreAddrs, 1)
+
+	existingPeerMultiaddr, err := utils.Libp2pMultiaddrFromServiceURL(existingPeer.GetServiceURL())
+	require.NoError(t, err)
+	require.Equal(t, existingPeerstoreAddrs[0].String(), existingPeerMultiaddr.String())
+
+	err = testRouter.RemovePeer(existingPeer)
+	require.NoError(t, err)
+
+	require.Len(t, testRouter.pstore, 0)
+
+	// NB: libp2p peerstore implementations only remove peer keys and metadata
+	// but continue to resolve multiaddrs until their respective TTLs expire.
+	// (see: https://github.com/libp2p/go-libp2p/blob/v0.25.1/p2p/host/peerstore/pstoremem/peerstore.go#L108)
+	// (see: https://github.com/libp2p/go-libp2p/blob/v0.25.1/p2p/host/peerstore/pstoreds/peerstore.go#L187)
+
+	existingPeerstoreAddrs = peerstore.Addrs(existingPeerInfo.ID)
+	require.Len(t, existingPeerstoreAddrs, 1)
+}
+
+func TestBackgroundRouter_Broadcast(t *testing.T) {
+	const (
+		numPeers            = 4
+		testMsg             = ""test messsage""
+		testTimeoutDuration = time.Second * 5
+	)
+
+	var (
+		ctx = context.Background()
+		mu  sync.Mutex
+		// map used as a set to collect IDs of peers which have received a message
+		seenMessages       = make(map[string]struct{})
+		bootstrapWaitgroup = sync.WaitGroup{}
+		broadcastWaitgroup = sync.WaitGroup{}
+		broadcastDone      = make(chan struct{}, 1)
+		testTimeout        = time.After(testTimeoutDuration)
+		// NB: peerIDs are stringified
+		actualPeerIDs   []string
+		expectedPeerIDs = make([]string, numPeers)
+		testHosts       = make([]libp2pHost.Host, 0)
+		libp2pMockNet   = mocknet.New()
+	)
+
+	// setup 4 libp2p hosts to listen for incoming streams from the test backgroundRouter
+	for i := 0; i < numPeers; i++ {
+		broadcastWaitgroup.Add(1)
+		bootstrapWaitgroup.Add(1)
+
+		privKey, selfPeer := newTestPeer(t)
+		host := newTestHost(t, libp2pMockNet, privKey)
+		testHosts = append(testHosts, host)
+		expectedPeerIDs[i] = host.ID().String()
+		rtr := newRouterWithSelfPeerAndHost(t, selfPeer, host)
+		go readSubscription(t, ctx, &broadcastWaitgroup, rtr, &mu, seenMessages)
+	}
+
+	// bootstrap off of arbitrary testHost
+	privKey, selfPeer := newTestPeer(t)
+
+	// set up a test backgroundRouter
+	testRouterHost := newTestHost(t, libp2pMockNet, privKey)
+	testRouter := newRouterWithSelfPeerAndHost(t, selfPeer, testRouterHost)
+	testHosts = append(testHosts, testRouterHost)
+
+	// simulate network links between each to every other
+	// (i.e. fully-connected network)
+	err := libp2pMockNet.LinkAll()
+	require.NoError(t, err)
+
+	// setup notifee/notify BEFORE bootstrapping
+	notifee := &libp2pNetwork.NotifyBundle{
+		ConnectedF: func(_ libp2pNetwork.Network, _ libp2pNetwork.Conn) {
+			t.Logf(""connected!"")
+			bootstrapWaitgroup.Done()
+		},
+	}
+	testRouter.host.Network().Notify(notifee)
+
+	bootstrap(t, ctx, testHosts)
+
+	go func() {
+		// wait for hosts to listen and peer discovery
+		bootstrapWaitgroup.Wait()
+		// INVESTIGATE: look for a more idiomatic way to wait for DHT peer discovery to complete
+		//
+		// `bootstrapWaitgroup` isn't quite sufficient; I suspect the DHT
+		// needs more time but am unaware of a notify/notifee interface (or
+		// something similar) at that level.
+		time.Sleep(time.Millisecond * 250)
+
+		// broadcast message
+		t.Log(""broadcasting..."")
+		err := testRouter.Broadcast([]byte(testMsg))
+		require.NoError(t, err)
+	}()
+
+	// wait concurrently
+	go func() {
+		broadcastWaitgroup.Wait()
+		broadcastDone <- struct{}{}
+	}()
+
+	// waitgroup broadcastDone or timeout
+	select {
+	case <-testTimeout:
+		t.Fatalf(
+			""timed out waiting for message: got %d; wanted %d"",
+			len(seenMessages),
+			numPeers,
+		)
+	case <-broadcastDone:
+	}
+
+	actualPeerIDs = testutil.GetKeys[string](seenMessages)
+	require.ElementsMatchf(t, expectedPeerIDs, actualPeerIDs, ""peerIDs don't match"")
+}
+
+// bootstrap connects each host to one other except for the arbitrarily chosen ""bootstrap host""
+func bootstrap(t *testing.T, ctx context.Context, testHosts []libp2pHost.Host) {
+	t.Helper()
+
+	t.Log(""bootstrapping..."")
+	bootstrapHost := testHosts[0]
+	for _, h := range testHosts {
+		if h.ID() == bootstrapHost.ID() {
+			continue
+		}
+
+		p2pAddr, err := multiaddr.NewMultiaddr(fmt.Sprintf(""/p2p/%s"", bootstrapHost.ID()))
+		require.NoError(t, err)
+
+		addrInfo := libp2pPeer.AddrInfo{
+			ID: bootstrapHost.ID(),
+			Addrs: []multiaddr.Multiaddr{
+				bootstrapHost.Addrs()[0].Encapsulate(p2pAddr),
+			},
+		}
+
+		t.Logf(""connecting to %s..."", addrInfo.ID.String())
+		err = h.Connect(ctx, addrInfo)
+		require.NoError(t, err)
+	}
+}
+
+// TECHDEBT(#609): move & de-duplicate
+func newTestRouter(t *testing.T, libp2pMockNet mocknet.Mocknet) *backgroundRouter {
+	t.Helper()
+
+	privKey, selfPeer := newTestPeer(t)
+
+	if libp2pMockNet == nil {
+		libp2pMockNet = mocknet.New()
+	}
+
+	host := newMockNetHostFromPeer(t, libp2pMockNet, privKey, selfPeer)
+	t.Cleanup(func() {
+		err := host.Close()
+		require.NoError(t, err)
+	})
+
+	return newRouterWithSelfPeerAndHost(t, selfPeer, host)
+}
+
+func newRouterWithSelfPeerAndHost(t *testing.T, selfPeer typesP2P.Peer, host libp2pHost.Host) *backgroundRouter {
+	t.Helper()
+
+	ctrl := gomock.NewController(t)
+	runtimeMgrMock := mockModules.NewMockRuntimeMgr(ctrl)
+	runtimeMgrMock.EXPECT().GetConfig().Return(&configs.Config{
+		P2P: &configs.P2PConfig{
+			IsClientOnly: false,
+		},
+	})
+
+	consensusMock := mockModules.NewMockConsensusModule(ctrl)
+	consensusMock.EXPECT().CurrentHeight().Return(uint64(1)).AnyTimes()
+
+	pstore := make(typesP2P.PeerAddrMap)
+	pstoreProviderMock := mock_types.NewMockPeerstoreProvider(ctrl)
+	pstoreProviderMock.EXPECT().GetStakedPeerstoreAtHeight(gomock.Any()).Return(pstore, nil).AnyTimes()
+
+	busMock := mockModules.NewMockBus(ctrl)
+	busMock.EXPECT().GetConsensusModule().Return(consensusMock).AnyTimes()
+	busMock.EXPECT().GetRuntimeMgr().Return(runtimeMgrMock).AnyTimes()
+
+	err := pstore.AddPeer(selfPeer)
+	require.NoError(t, err)
+
+	router, err := NewBackgroundRouter(busMock, &utils.RouterConfig{
+		Addr:                  selfPeer.GetAddress(),
+		PeerstoreProvider:     pstoreProviderMock,
+		CurrentHeightProvider: consensusMock,
+		Host:                  host,
+	})
+	require.NoError(t, err)
+
+	libp2pNet, ok := router.(*backgroundRouter)
+	require.Truef(t, ok, ""unexpected router type: %T"", router)
+
+	return libp2pNet
+}
+
+// TECHDEBT: move & de-dup",p2p/background/router_test.go,2023-05-04 01:59:39+00:00,2023-05-04T02:30:03Z,"```suggestion
// TECHDEBT(#609): move & de-duplicate
```",,,,,299,RIGHT,299,,line,https://api.github.com/repos/pokt-network/pocket/pulls/707,pokt-network/pocket,d7cc85d553cf9b0257f16c3a213ed4de96b8363a
https://api.github.com/repos/pokt-network/pocket/pulls/707,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1184471728,Olshansk,4159d7a40f8d99835d17a00a052b6782cb3f795d,648b75a385fb68f9255fd8c5829388381e71c06a,"@@ -0,0 +1,373 @@
+package background
+
+import (
+	""context""
+	""fmt""
+	""sync""
+	""testing""
+	""time""
+
+	""github.com/golang/mock/gomock""
+	libp2pCrypto ""github.com/libp2p/go-libp2p/core/crypto""
+	libp2pHost ""github.com/libp2p/go-libp2p/core/host""
+	libp2pNetwork ""github.com/libp2p/go-libp2p/core/network""
+	libp2pPeer ""github.com/libp2p/go-libp2p/core/peer""
+	mocknet ""github.com/libp2p/go-libp2p/p2p/net/mock""
+	""github.com/multiformats/go-multiaddr""
+	""github.com/stretchr/testify/require""
+
+	""github.com/pokt-network/pocket/internal/testutil""
+	typesP2P ""github.com/pokt-network/pocket/p2p/types""
+	mock_types ""github.com/pokt-network/pocket/p2p/types/mocks""
+	""github.com/pokt-network/pocket/p2p/utils""
+	""github.com/pokt-network/pocket/runtime/configs""
+	""github.com/pokt-network/pocket/runtime/defaults""
+	cryptoPocket ""github.com/pokt-network/pocket/shared/crypto""
+	mockModules ""github.com/pokt-network/pocket/shared/modules/mocks""
+)
+
+// https://www.rfc-editor.org/rfc/rfc3986#section-3.2.2
+const testIP6ServiceURL = ""[2a00:1450:4005:802::2004]:8080""
+
+// TECHDEBT(#609): move & de-dup.
+var testLocalServiceURL = fmt.Sprintf(""127.0.0.1:%d"", defaults.DefaultP2PPort)
+
+func TestBackgroundRouter_AddPeer(t *testing.T) {
+	testRouter := newTestRouter(t, nil)
+	libp2pPStore := testRouter.host.Peerstore()
+
+	// NB: assert initial state
+	require.Equal(t, 1, testRouter.pstore.Size())
+
+	existingPeer := testRouter.pstore.GetPeerList()[0]
+	require.NotNil(t, existingPeer)
+
+	existingPeerInfo, err := utils.Libp2pAddrInfoFromPeer(existingPeer)
+	require.NoError(t, err)
+
+	existingPeerstoreAddrs := libp2pPStore.Addrs(existingPeerInfo.ID)
+	require.Len(t, existingPeerstoreAddrs, 1)
+
+	existingPeerMultiaddr, err := utils.Libp2pMultiaddrFromServiceURL(existingPeer.GetServiceURL())
+	require.NoError(t, err)
+	require.Equal(t, existingPeerstoreAddrs[0].String(), existingPeerMultiaddr.String())
+
+	newPublicKey, err := cryptoPocket.GeneratePublicKey()
+	newPoktAddr := newPublicKey.Address()
+	require.NoError(t, err)
+
+	newPeer := &typesP2P.NetworkPeer{
+		PublicKey:  newPublicKey,
+		Address:    newPoktAddr,
+		ServiceURL: testIP6ServiceURL,
+	}
+	newPeerInfo, err := utils.Libp2pAddrInfoFromPeer(newPeer)
+	require.NoError(t, err)
+	newPeerMultiaddr := newPeerInfo.Addrs[0]
+
+	// NB: add to address book
+	err = testRouter.AddPeer(newPeer)
+	require.NoError(t, err)
+
+	require.Len(t, testRouter.pstore, 2)
+	require.Equal(t, testRouter.pstore.GetPeer(existingPeer.GetAddress()), existingPeer)
+	require.Equal(t, testRouter.pstore.GetPeer(newPeer.Address), newPeer)
+
+	existingPeerstoreAddrs = libp2pPStore.Addrs(existingPeerInfo.ID)
+	newPeerstoreAddrs := libp2pPStore.Addrs(newPeerInfo.ID)
+	require.Len(t, existingPeerstoreAddrs, 1)
+	require.Len(t, newPeerstoreAddrs, 1)
+	require.Equal(t, newPeerstoreAddrs[0].String(), newPeerMultiaddr.String())
+}
+
+func TestBackgroundRouter_RemovePeer(t *testing.T) {
+	testRouter := newTestRouter(t, nil)
+	peerstore := testRouter.host.Peerstore()
+
+	// NB: assert initial state
+	require.Len(t, testRouter.pstore, 1)
+
+	existingPeer := testRouter.pstore.GetPeerList()[0]
+	require.NotNil(t, existingPeer)
+
+	existingPeerInfo, err := utils.Libp2pAddrInfoFromPeer(existingPeer)
+	require.NoError(t, err)
+
+	existingPeerstoreAddrs := peerstore.Addrs(existingPeerInfo.ID)
+	require.Len(t, existingPeerstoreAddrs, 1)
+
+	existingPeerMultiaddr, err := utils.Libp2pMultiaddrFromServiceURL(existingPeer.GetServiceURL())
+	require.NoError(t, err)
+	require.Equal(t, existingPeerstoreAddrs[0].String(), existingPeerMultiaddr.String())
+
+	err = testRouter.RemovePeer(existingPeer)
+	require.NoError(t, err)
+
+	require.Len(t, testRouter.pstore, 0)
+
+	// NB: libp2p peerstore implementations only remove peer keys and metadata
+	// but continue to resolve multiaddrs until their respective TTLs expire.
+	// (see: https://github.com/libp2p/go-libp2p/blob/v0.25.1/p2p/host/peerstore/pstoremem/peerstore.go#L108)
+	// (see: https://github.com/libp2p/go-libp2p/blob/v0.25.1/p2p/host/peerstore/pstoreds/peerstore.go#L187)
+
+	existingPeerstoreAddrs = peerstore.Addrs(existingPeerInfo.ID)
+	require.Len(t, existingPeerstoreAddrs, 1)
+}
+
+func TestBackgroundRouter_Broadcast(t *testing.T) {
+	const (
+		numPeers            = 4
+		testMsg             = ""test messsage""
+		testTimeoutDuration = time.Second * 5
+	)
+
+	var (
+		ctx = context.Background()
+		mu  sync.Mutex
+		// map used as a set to collect IDs of peers which have received a message
+		seenMessages       = make(map[string]struct{})
+		bootstrapWaitgroup = sync.WaitGroup{}
+		broadcastWaitgroup = sync.WaitGroup{}
+		broadcastDone      = make(chan struct{}, 1)
+		testTimeout        = time.After(testTimeoutDuration)
+		// NB: peerIDs are stringified
+		actualPeerIDs   []string
+		expectedPeerIDs = make([]string, numPeers)
+		testHosts       = make([]libp2pHost.Host, 0)
+		libp2pMockNet   = mocknet.New()
+	)
+
+	// setup 4 libp2p hosts to listen for incoming streams from the test backgroundRouter
+	for i := 0; i < numPeers; i++ {
+		broadcastWaitgroup.Add(1)
+		bootstrapWaitgroup.Add(1)
+
+		privKey, selfPeer := newTestPeer(t)
+		host := newTestHost(t, libp2pMockNet, privKey)
+		testHosts = append(testHosts, host)
+		expectedPeerIDs[i] = host.ID().String()
+		rtr := newRouterWithSelfPeerAndHost(t, selfPeer, host)
+		go readSubscription(t, ctx, &broadcastWaitgroup, rtr, &mu, seenMessages)
+	}
+
+	// bootstrap off of arbitrary testHost
+	privKey, selfPeer := newTestPeer(t)
+
+	// set up a test backgroundRouter
+	testRouterHost := newTestHost(t, libp2pMockNet, privKey)
+	testRouter := newRouterWithSelfPeerAndHost(t, selfPeer, testRouterHost)
+	testHosts = append(testHosts, testRouterHost)
+
+	// simulate network links between each to every other
+	// (i.e. fully-connected network)
+	err := libp2pMockNet.LinkAll()
+	require.NoError(t, err)
+
+	// setup notifee/notify BEFORE bootstrapping
+	notifee := &libp2pNetwork.NotifyBundle{
+		ConnectedF: func(_ libp2pNetwork.Network, _ libp2pNetwork.Conn) {
+			t.Logf(""connected!"")
+			bootstrapWaitgroup.Done()
+		},
+	}
+	testRouter.host.Network().Notify(notifee)
+
+	bootstrap(t, ctx, testHosts)
+
+	go func() {
+		// wait for hosts to listen and peer discovery
+		bootstrapWaitgroup.Wait()
+		// INVESTIGATE: look for a more idiomatic way to wait for DHT peer discovery to complete
+		//
+		// `bootstrapWaitgroup` isn't quite sufficient; I suspect the DHT
+		// needs more time but am unaware of a notify/notifee interface (or
+		// something similar) at that level.
+		time.Sleep(time.Millisecond * 250)
+
+		// broadcast message
+		t.Log(""broadcasting..."")
+		err := testRouter.Broadcast([]byte(testMsg))
+		require.NoError(t, err)
+	}()
+
+	// wait concurrently
+	go func() {
+		broadcastWaitgroup.Wait()
+		broadcastDone <- struct{}{}
+	}()
+
+	// waitgroup broadcastDone or timeout
+	select {
+	case <-testTimeout:
+		t.Fatalf(
+			""timed out waiting for message: got %d; wanted %d"",
+			len(seenMessages),
+			numPeers,
+		)
+	case <-broadcastDone:
+	}
+
+	actualPeerIDs = testutil.GetKeys[string](seenMessages)
+	require.ElementsMatchf(t, expectedPeerIDs, actualPeerIDs, ""peerIDs don't match"")
+}
+
+// bootstrap connects each host to one other except for the arbitrarily chosen ""bootstrap host""
+func bootstrap(t *testing.T, ctx context.Context, testHosts []libp2pHost.Host) {
+	t.Helper()
+
+	t.Log(""bootstrapping..."")
+	bootstrapHost := testHosts[0]
+	for _, h := range testHosts {
+		if h.ID() == bootstrapHost.ID() {
+			continue
+		}
+
+		p2pAddr, err := multiaddr.NewMultiaddr(fmt.Sprintf(""/p2p/%s"", bootstrapHost.ID()))
+		require.NoError(t, err)
+
+		addrInfo := libp2pPeer.AddrInfo{
+			ID: bootstrapHost.ID(),
+			Addrs: []multiaddr.Multiaddr{
+				bootstrapHost.Addrs()[0].Encapsulate(p2pAddr),
+			},
+		}
+
+		t.Logf(""connecting to %s..."", addrInfo.ID.String())
+		err = h.Connect(ctx, addrInfo)
+		require.NoError(t, err)
+	}
+}
+
+// TECHDEBT(#609): move & de-duplicate
+func newTestRouter(t *testing.T, libp2pMockNet mocknet.Mocknet) *backgroundRouter {
+	t.Helper()
+
+	privKey, selfPeer := newTestPeer(t)
+
+	if libp2pMockNet == nil {
+		libp2pMockNet = mocknet.New()
+	}
+
+	host := newMockNetHostFromPeer(t, libp2pMockNet, privKey, selfPeer)
+	t.Cleanup(func() {
+		err := host.Close()
+		require.NoError(t, err)
+	})
+
+	return newRouterWithSelfPeerAndHost(t, selfPeer, host)
+}
+
+func newRouterWithSelfPeerAndHost(t *testing.T, selfPeer typesP2P.Peer, host libp2pHost.Host) *backgroundRouter {
+	t.Helper()
+
+	ctrl := gomock.NewController(t)
+	runtimeMgrMock := mockModules.NewMockRuntimeMgr(ctrl)
+	runtimeMgrMock.EXPECT().GetConfig().Return(&configs.Config{
+		P2P: &configs.P2PConfig{
+			IsClientOnly: false,
+		},
+	})
+
+	consensusMock := mockModules.NewMockConsensusModule(ctrl)
+	consensusMock.EXPECT().CurrentHeight().Return(uint64(1)).AnyTimes()
+
+	pstore := make(typesP2P.PeerAddrMap)
+	pstoreProviderMock := mock_types.NewMockPeerstoreProvider(ctrl)
+	pstoreProviderMock.EXPECT().GetStakedPeerstoreAtHeight(gomock.Any()).Return(pstore, nil).AnyTimes()
+
+	busMock := mockModules.NewMockBus(ctrl)
+	busMock.EXPECT().GetConsensusModule().Return(consensusMock).AnyTimes()
+	busMock.EXPECT().GetRuntimeMgr().Return(runtimeMgrMock).AnyTimes()
+
+	err := pstore.AddPeer(selfPeer)
+	require.NoError(t, err)
+
+	router, err := NewBackgroundRouter(busMock, &utils.RouterConfig{
+		Addr:                  selfPeer.GetAddress(),
+		PeerstoreProvider:     pstoreProviderMock,
+		CurrentHeightProvider: consensusMock,
+		Host:                  host,
+	})
+	require.NoError(t, err)
+
+	libp2pNet, ok := router.(*backgroundRouter)
+	require.Truef(t, ok, ""unexpected router type: %T"", router)
+
+	return libp2pNet
+}
+
+// TECHDEBT: move & de-dup
+func newTestPeer(t *testing.T) (cryptoPocket.PrivateKey, *typesP2P.NetworkPeer) {
+	t.Helper()
+
+	privKey, err := cryptoPocket.GeneratePrivateKey()
+	require.NoError(t, err)
+
+	return privKey, &typesP2P.NetworkPeer{
+		PublicKey:  privKey.PublicKey(),
+		Address:    privKey.Address(),
+		ServiceURL: testLocalServiceURL,
+	}
+}
+
+func newMockNetHostFromPeer(
+	t *testing.T,
+	mockNet mocknet.Mocknet,
+	privKey cryptoPocket.PrivateKey,
+	peer *typesP2P.NetworkPeer,
+) libp2pHost.Host {
+	t.Helper()
+
+	libp2pPrivKey, err := libp2pCrypto.UnmarshalEd25519PrivateKey(privKey.Bytes())
+	require.NoError(t, err)
+
+	libp2pMultiAddr, err := utils.Libp2pMultiaddrFromServiceURL(peer.ServiceURL)
+	require.NoError(t, err)
+
+	host, err := mockNet.AddPeer(libp2pPrivKey, libp2pMultiAddr)
+	require.NoError(t, err)
+
+	return host
+}
+
+func newTestHost(t *testing.T, mockNet mocknet.Mocknet, privKey cryptoPocket.PrivateKey) libp2pHost.Host {
+	t.Helper()
+
+	// listen on random port on loopback interface
+	peer := &typesP2P.NetworkPeer{
+		PublicKey:  privKey.PublicKey(),
+		Address:    privKey.Address(),
+		ServiceURL: testLocalServiceURL,
+	}
+
+	// construct mock host
+	return newMockNetHostFromPeer(t, mockNet, privKey, peer)
+}
+
+func readSubscription(
+	t *testing.T,
+	ctx context.Context,
+	wg *sync.WaitGroup,",p2p/background/router_test.go,2023-05-04 02:00:25+00:00,2023-05-04T02:30:03Z,Can you reflect the same name of the wg as what you passed in. It'll help with the flow of the code to the reader.,,,,,350,RIGHT,350,,line,https://api.github.com/repos/pokt-network/pocket/pulls/707,pokt-network/pocket,d7cc85d553cf9b0257f16c3a213ed4de96b8363a
https://api.github.com/repos/pokt-network/pocket/pulls/707,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1184480485,Olshansk,4159d7a40f8d99835d17a00a052b6782cb3f795d,648b75a385fb68f9255fd8c5829388381e71c06a,"@@ -0,0 +1,128 @@
+package background
+
+import (
+	""context""
+	""crypto/rand""
+	""fmt""
+	""testing""
+	""time""
+
+	""github.com/libp2p/go-libp2p""
+	dht ""github.com/libp2p/go-libp2p-kad-dht""
+	libp2pCrypto ""github.com/libp2p/go-libp2p/core/crypto""
+	libp2pHost ""github.com/libp2p/go-libp2p/core/host""
+	libp2pPeer ""github.com/libp2p/go-libp2p/core/peer""
+	""github.com/multiformats/go-multiaddr""
+	""github.com/stretchr/testify/require""
+
+	""github.com/pokt-network/pocket/runtime/defaults""
+)
+
+func TestLibp2pKademliaPeerDiscovery(t *testing.T) {
+	ctx := context.Background()
+
+	addr1, host1, _ := setupHostAndDiscovery(t, ctx, defaults.DefaultP2PPort, nil)
+
+	bootstrapAddr, err := multiaddr.NewMultiaddr(fmt.Sprintf(""%s/p2p/%s"", addr1, host1.ID().String()))
+	require.NoError(t, err)
+
+	addr2, host2, _ := setupHostAndDiscovery(t, ctx, defaults.DefaultP2PPort+1, bootstrapAddr)
+	addr3, host3, _ := setupHostAndDiscovery(t, ctx, defaults.DefaultP2PPort+2, bootstrapAddr)
+
+	expectedPeerIDs := []libp2pPeer.ID{host1.ID(), host2.ID(), host3.ID()}
+
+	// TECHDEBT: consider using `host.ConnManager().Notifee()` to avoid sleeping here
+	// delay assertions for 500ms
+	time.Sleep(time.Millisecond * 500)
+
+	// assert that host2 has host3 in its peerstore
+	host2DiscoveredAddrs := host2.Peerstore().Addrs(host3.ID())
+	require.Lenf(t, host2DiscoveredAddrs, 1, ""did not discover host3"")
+	require.Equalf(t, addr3.String(), host2DiscoveredAddrs[0].String(), ""did not discover host3"")
+	require.ElementsMatchf(t, expectedPeerIDs, host2.Peerstore().Peers(), ""host2 peer IDs don't match"")
+
+	// assert that host3 has host2 in its peerstore
+	host3DiscoveredHost2Addrs := host3.Peerstore().Addrs(host2.ID())
+	require.Lenf(t, host3DiscoveredHost2Addrs, 1, ""host3 did not discover host2"")
+	require.Equalf(t, addr2.String(), host3DiscoveredHost2Addrs[0].String(), ""host3 did not discover host2"")
+	require.ElementsMatchf(t, expectedPeerIDs, host3.Peerstore().Peers(), ""host3 peer IDs don't match"")
+
+	// add another peer to network...
+	addr4, host4, _ := setupHostAndDiscovery(t, ctx, defaults.DefaultP2PPort+3, bootstrapAddr)
+	expectedPeerIDs = append(expectedPeerIDs, host4.ID())
+
+	// TECHDEBT: consider using `host.ConnManager().Notifee()` to avoid sleeping here
+	time.Sleep(time.Millisecond * 500)
+
+	// new host discovers existing hosts...
+	host4DiscoveredHost2Addrs := host4.Peerstore().Addrs(host2.ID())
+	require.Lenf(t, host4DiscoveredHost2Addrs, 1, ""host4 did not discover host2"")
+	require.Equalf(t, addr2.String(), host4DiscoveredHost2Addrs[0].String(), ""host4 did not discover host2"")
+
+	host4DiscoveredHost3Addrs := host4.Peerstore().Addrs(host3.ID())
+	require.Lenf(t, host4DiscoveredHost3Addrs, 1, ""host4 did not discover host3"")
+	require.Equalf(t, addr3.String(), host4DiscoveredHost3Addrs[0].String(), ""host4 did not discover host3"")
+
+	// existing hosts discovers host host...
+	host2DiscoveredHost4Addrs := host2.Peerstore().Addrs(host4.ID())
+	require.Lenf(t, host2DiscoveredHost4Addrs, 1, ""host2 did not discover host4"")
+	require.Equalf(t, addr4.String(), host2DiscoveredHost4Addrs[0].String(), ""host2 did not discover host4"")
+
+	host3DiscoveredHost4Addrs := host3.Peerstore().Addrs(host4.ID())
+	require.Lenf(t, host3DiscoveredHost4Addrs, 1, ""host3 did not discover host4"")
+	require.Equalf(t, addr4.String(), host3DiscoveredHost4Addrs[0].String(), ""host3 did not discover host4"")
+
+	require.ElementsMatchf(t, expectedPeerIDs, host4.Peerstore().Peers(), ""host4 peer IDs don't match"")
+}
+
+//nolint:unparam // DHT must exist but is otherwise ""unused"" (i.e. its API)",p2p/background/kad_discovery_baseline_test.go,2023-05-04 02:24:46+00:00,2023-05-04T02:30:04Z,"Would it be clearer if we just refacto to `setupHost` and call `setupDHT(t, ctx, host, bootstrapAddr)` in place in the test above?

We can group the host creation and make it explicit when we need the bootstrap addr or not.

Lmk if you can ""visualize"" the alternate (potentially clearer) implementation",,,,81.0,78,RIGHT,78,81.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/707,pokt-network/pocket,d7cc85d553cf9b0257f16c3a213ed4de96b8363a
https://api.github.com/repos/pokt-network/pocket/pulls/707,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1184480638,Olshansk,4159d7a40f8d99835d17a00a052b6782cb3f795d,648b75a385fb68f9255fd8c5829388381e71c06a,"@@ -0,0 +1,128 @@
+package background
+
+import (
+	""context""
+	""crypto/rand""
+	""fmt""
+	""testing""
+	""time""
+
+	""github.com/libp2p/go-libp2p""
+	dht ""github.com/libp2p/go-libp2p-kad-dht""
+	libp2pCrypto ""github.com/libp2p/go-libp2p/core/crypto""
+	libp2pHost ""github.com/libp2p/go-libp2p/core/host""
+	libp2pPeer ""github.com/libp2p/go-libp2p/core/peer""
+	""github.com/multiformats/go-multiaddr""
+	""github.com/stretchr/testify/require""
+
+	""github.com/pokt-network/pocket/runtime/defaults""
+)
+
+func TestLibp2pKademliaPeerDiscovery(t *testing.T) {
+	ctx := context.Background()
+
+	addr1, host1, _ := setupHostAndDiscovery(t, ctx, defaults.DefaultP2PPort, nil)
+
+	bootstrapAddr, err := multiaddr.NewMultiaddr(fmt.Sprintf(""%s/p2p/%s"", addr1, host1.ID().String()))
+	require.NoError(t, err)
+
+	addr2, host2, _ := setupHostAndDiscovery(t, ctx, defaults.DefaultP2PPort+1, bootstrapAddr)
+	addr3, host3, _ := setupHostAndDiscovery(t, ctx, defaults.DefaultP2PPort+2, bootstrapAddr)
+
+	expectedPeerIDs := []libp2pPeer.ID{host1.ID(), host2.ID(), host3.ID()}
+
+	// TECHDEBT: consider using `host.ConnManager().Notifee()` to avoid sleeping here
+	// delay assertions for 500ms",p2p/background/kad_discovery_baseline_test.go,2023-05-04 02:25:16+00:00,2023-05-04T02:30:04Z,Update comment saying you're waiting for the DHT to fill up,,,,37.0,35,RIGHT,35,37.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/707,pokt-network/pocket,d7cc85d553cf9b0257f16c3a213ed4de96b8363a
https://api.github.com/repos/pokt-network/pocket/pulls/707,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1184481218,Olshansk,4159d7a40f8d99835d17a00a052b6782cb3f795d,648b75a385fb68f9255fd8c5829388381e71c06a,"@@ -0,0 +1,128 @@
+package background
+
+import (
+	""context""
+	""crypto/rand""
+	""fmt""
+	""testing""
+	""time""
+
+	""github.com/libp2p/go-libp2p""
+	dht ""github.com/libp2p/go-libp2p-kad-dht""
+	libp2pCrypto ""github.com/libp2p/go-libp2p/core/crypto""
+	libp2pHost ""github.com/libp2p/go-libp2p/core/host""
+	libp2pPeer ""github.com/libp2p/go-libp2p/core/peer""
+	""github.com/multiformats/go-multiaddr""
+	""github.com/stretchr/testify/require""
+
+	""github.com/pokt-network/pocket/runtime/defaults""
+)
+
+func TestLibp2pKademliaPeerDiscovery(t *testing.T) {
+	ctx := context.Background()
+
+	addr1, host1, _ := setupHostAndDiscovery(t, ctx, defaults.DefaultP2PPort, nil)
+
+	bootstrapAddr, err := multiaddr.NewMultiaddr(fmt.Sprintf(""%s/p2p/%s"", addr1, host1.ID().String()))
+	require.NoError(t, err)
+
+	addr2, host2, _ := setupHostAndDiscovery(t, ctx, defaults.DefaultP2PPort+1, bootstrapAddr)
+	addr3, host3, _ := setupHostAndDiscovery(t, ctx, defaults.DefaultP2PPort+2, bootstrapAddr)
+
+	expectedPeerIDs := []libp2pPeer.ID{host1.ID(), host2.ID(), host3.ID()}
+
+	// TECHDEBT: consider using `host.ConnManager().Notifee()` to avoid sleeping here
+	// delay assertions for 500ms
+	time.Sleep(time.Millisecond * 500)
+
+	// assert that host2 has host3 in its peerstore
+	host2DiscoveredAddrs := host2.Peerstore().Addrs(host3.ID())
+	require.Lenf(t, host2DiscoveredAddrs, 1, ""did not discover host3"")",p2p/background/kad_discovery_baseline_test.go,2023-05-04 02:27:09+00:00,2023-05-04T02:30:04Z,"This might be a huge NIT, but what if it's (somehow) it's greater than 1? Maybe we should update the error to be ""expected exactly 1 address for host3 but found %d""

",,,,,40,RIGHT,40,,line,https://api.github.com/repos/pokt-network/pocket/pulls/707,pokt-network/pocket,d7cc85d553cf9b0257f16c3a213ed4de96b8363a
https://api.github.com/repos/pokt-network/pocket/pulls/707,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1184481694,Olshansk,4159d7a40f8d99835d17a00a052b6782cb3f795d,648b75a385fb68f9255fd8c5829388381e71c06a,"@@ -0,0 +1,128 @@
+package background
+
+import (
+	""context""
+	""crypto/rand""
+	""fmt""
+	""testing""
+	""time""
+
+	""github.com/libp2p/go-libp2p""
+	dht ""github.com/libp2p/go-libp2p-kad-dht""
+	libp2pCrypto ""github.com/libp2p/go-libp2p/core/crypto""
+	libp2pHost ""github.com/libp2p/go-libp2p/core/host""
+	libp2pPeer ""github.com/libp2p/go-libp2p/core/peer""
+	""github.com/multiformats/go-multiaddr""
+	""github.com/stretchr/testify/require""
+
+	""github.com/pokt-network/pocket/runtime/defaults""
+)
+
+func TestLibp2pKademliaPeerDiscovery(t *testing.T) {
+	ctx := context.Background()
+
+	addr1, host1, _ := setupHostAndDiscovery(t, ctx, defaults.DefaultP2PPort, nil)
+
+	bootstrapAddr, err := multiaddr.NewMultiaddr(fmt.Sprintf(""%s/p2p/%s"", addr1, host1.ID().String()))
+	require.NoError(t, err)
+
+	addr2, host2, _ := setupHostAndDiscovery(t, ctx, defaults.DefaultP2PPort+1, bootstrapAddr)
+	addr3, host3, _ := setupHostAndDiscovery(t, ctx, defaults.DefaultP2PPort+2, bootstrapAddr)
+
+	expectedPeerIDs := []libp2pPeer.ID{host1.ID(), host2.ID(), host3.ID()}
+
+	// TECHDEBT: consider using `host.ConnManager().Notifee()` to avoid sleeping here
+	// delay assertions for 500ms
+	time.Sleep(time.Millisecond * 500)
+
+	// assert that host2 has host3 in its peerstore
+	host2DiscoveredAddrs := host2.Peerstore().Addrs(host3.ID())
+	require.Lenf(t, host2DiscoveredAddrs, 1, ""did not discover host3"")
+	require.Equalf(t, addr3.String(), host2DiscoveredAddrs[0].String(), ""did not discover host3"")
+	require.ElementsMatchf(t, expectedPeerIDs, host2.Peerstore().Peers(), ""host2 peer IDs don't match"")
+
+	// assert that host3 has host2 in its peerstore
+	host3DiscoveredHost2Addrs := host3.Peerstore().Addrs(host2.ID())
+	require.Lenf(t, host3DiscoveredHost2Addrs, 1, ""host3 did not discover host2"")
+	require.Equalf(t, addr2.String(), host3DiscoveredHost2Addrs[0].String(), ""host3 did not discover host2"")
+	require.ElementsMatchf(t, expectedPeerIDs, host3.Peerstore().Peers(), ""host3 peer IDs don't match"")
+
+	// add another peer to network...",p2p/background/kad_discovery_baseline_test.go,2023-05-04 02:28:35+00:00,2023-05-04T02:30:04Z,"Missed opportunity to say ""A wild peer appears in the network""

![tumblr_e19b0725ffd8972d59be1a9950b78229_8f06cfe2_640](https://user-images.githubusercontent.com/1892194/236097856-98d660cb-0498-49fe-86b5-c9dbe373fdd9.gif)
",,,,53.0,50,RIGHT,50,53.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/707,pokt-network/pocket,d7cc85d553cf9b0257f16c3a213ed4de96b8363a
https://api.github.com/repos/pokt-network/pocket/pulls/707,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1184481917,Olshansk,4159d7a40f8d99835d17a00a052b6782cb3f795d,648b75a385fb68f9255fd8c5829388381e71c06a,"@@ -0,0 +1,128 @@
+package background
+
+import (
+	""context""
+	""crypto/rand""
+	""fmt""
+	""testing""
+	""time""
+
+	""github.com/libp2p/go-libp2p""
+	dht ""github.com/libp2p/go-libp2p-kad-dht""
+	libp2pCrypto ""github.com/libp2p/go-libp2p/core/crypto""
+	libp2pHost ""github.com/libp2p/go-libp2p/core/host""
+	libp2pPeer ""github.com/libp2p/go-libp2p/core/peer""
+	""github.com/multiformats/go-multiaddr""
+	""github.com/stretchr/testify/require""
+
+	""github.com/pokt-network/pocket/runtime/defaults""
+)
+
+func TestLibp2pKademliaPeerDiscovery(t *testing.T) {
+	ctx := context.Background()
+
+	addr1, host1, _ := setupHostAndDiscovery(t, ctx, defaults.DefaultP2PPort, nil)
+
+	bootstrapAddr, err := multiaddr.NewMultiaddr(fmt.Sprintf(""%s/p2p/%s"", addr1, host1.ID().String()))
+	require.NoError(t, err)
+
+	addr2, host2, _ := setupHostAndDiscovery(t, ctx, defaults.DefaultP2PPort+1, bootstrapAddr)
+	addr3, host3, _ := setupHostAndDiscovery(t, ctx, defaults.DefaultP2PPort+2, bootstrapAddr)
+
+	expectedPeerIDs := []libp2pPeer.ID{host1.ID(), host2.ID(), host3.ID()}
+
+	// TECHDEBT: consider using `host.ConnManager().Notifee()` to avoid sleeping here
+	// delay assertions for 500ms
+	time.Sleep(time.Millisecond * 500)
+
+	// assert that host2 has host3 in its peerstore
+	host2DiscoveredAddrs := host2.Peerstore().Addrs(host3.ID())
+	require.Lenf(t, host2DiscoveredAddrs, 1, ""did not discover host3"")
+	require.Equalf(t, addr3.String(), host2DiscoveredAddrs[0].String(), ""did not discover host3"")
+	require.ElementsMatchf(t, expectedPeerIDs, host2.Peerstore().Peers(), ""host2 peer IDs don't match"")
+
+	// assert that host3 has host2 in its peerstore
+	host3DiscoveredHost2Addrs := host3.Peerstore().Addrs(host2.ID())
+	require.Lenf(t, host3DiscoveredHost2Addrs, 1, ""host3 did not discover host2"")
+	require.Equalf(t, addr2.String(), host3DiscoveredHost2Addrs[0].String(), ""host3 did not discover host2"")
+	require.ElementsMatchf(t, expectedPeerIDs, host3.Peerstore().Peers(), ""host3 peer IDs don't match"")
+
+	// add another peer to network...
+	addr4, host4, _ := setupHostAndDiscovery(t, ctx, defaults.DefaultP2PPort+3, bootstrapAddr)
+	expectedPeerIDs = append(expectedPeerIDs, host4.ID())
+
+	// TECHDEBT: consider using `host.ConnManager().Notifee()` to avoid sleeping here",p2p/background/kad_discovery_baseline_test.go,2023-05-04 02:29:21+00:00,2023-05-04T02:30:04Z,"Ditto as above as to why we need a sleep.

Maybe move it to a constant ith a comment.

```go
// ...
const dhtUpdateSleepTime := time.Millisecond * 500
```",,,,57.0,54,RIGHT,54,57.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/707,pokt-network/pocket,d7cc85d553cf9b0257f16c3a213ed4de96b8363a
https://api.github.com/repos/pokt-network/pocket/pulls/707,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1185402516,Olshansk,ee76dcda4890aa980fb3d553ba8df931c6dee560,648b75a385fb68f9255fd8c5829388381e71c06a,"@@ -47,11 +47,11 @@ var (
 	DefaultPersistencePostgresURL    = ""postgres://postgres:postgres@pocket-db:5432/postgres""
 	DefaultPersistenceBlockStorePath = ""/var/blockstore""
 	// p2p
-	DefaultUseLibp2p          = false
-	DefaultP2PPort            = uint32(42069)
-	DefaultP2PUseRainTree     = true
-	DefaultP2PConnectionType  = types.ConnectionType_TCPConnection
-	DefaultP2PMaxMempoolCount = uint64(1e5)",runtime/defaults/defaults.go,2023-05-04 18:59:02+00:00,2023-05-04T23:28:44Z,"Why did you rename this? 

I felt that having ""mempool"" in the name was helpful to explain that the maximum count is used to limit the size of the ephemeral messages stored in memory during node operation.",,,,56.0,54,LEFT,8,8.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/707,pokt-network/pocket,d7cc85d553cf9b0257f16c3a213ed4de96b8363a
https://api.github.com/repos/pokt-network/pocket/pulls/707,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1185598704,Olshansk,ee76dcda4890aa980fb3d553ba8df931c6dee560,648b75a385fb68f9255fd8c5829388381e71c06a,"@@ -0,0 +1,86 @@
+package config
+
+import (
+	""fmt""
+	""github.com/libp2p/go-libp2p/core/host""
+	""github.com/pokt-network/pocket/p2p/providers""
+	""github.com/pokt-network/pocket/shared/crypto""
+	""go.uber.org/multierr""
+)
+
+// baseConfig implements `RouterConfig` using the given libp2p host and current
+// height and peerstore providers. Intended for internal use by other `RouterConfig`
+// implementations with common config parameters.
+//
+// NB: intentionally *not* embedding `baseConfig` to improve readability of usages",p2p/config/config.go,2023-05-04 23:28:26+00:00,2023-05-04T23:28:44Z,"I don't fully understand this. So when would you embed a struct inside of another one?

To me this seems like a worthwhile usecase",,,,15.0,15,RIGHT,15,15.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/707,pokt-network/pocket,d7cc85d553cf9b0257f16c3a213ed4de96b8363a
https://api.github.com/repos/pokt-network/pocket/pulls/732,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1243069482,Olshansk,8467f3a832ae26b48ed9ec481a8b99355c849c09,6fde86f231f3a1866c34e668ac226f4a6adb05d6,"@@ -0,0 +1,8 @@
+syntax = ""proto3"";
+package background;
+
+option go_package = ""github.com/pokt-network/pocket/p2p/types"";
+
+message BackgroundMessage {",p2p/types/proto/background.proto,2023-06-27 02:35:24+00:00,2023-06-27T04:11:42Z,"Please add a small comment on why/how we need this. Even something as similar as ""// Intended for gossiping message via implementations of BackgroundRouter`",,,,11.0,6,RIGHT,6,11.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/732,pokt-network/pocket,6b875eee002f49c4b1abe5ac9faa61f59daaa4cf
https://api.github.com/repos/pokt-network/pocket/pulls/732,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1243069853,Olshansk,8467f3a832ae26b48ed9ec481a8b99355c849c09,6fde86f231f3a1866c34e668ac226f4a6adb05d6,"@@ -107,10 +109,20 @@ func waitForNetworkSimulationCompletion(t *testing.T, wg *sync.WaitGroup) {
 func createP2PModules(t *testing.T, busMocks []*mockModules.MockBus, netMock mocknet.Mocknet) (p2pModules map[string]*p2pModule) {
 	peerIDs := setupMockNetPeers(t, netMock, len(busMocks))
 
+	ctrl := gomock.NewController(t)
+	backgroundRouterMock := mock_types.NewMockRouter(ctrl)",p2p/utils_test.go,2023-06-27 02:36:18+00:00,2023-06-27T04:11:42Z,Should we rename this to `noopBackgroundRouterMock` per the comment below?,,,,,113,RIGHT,21,,line,https://api.github.com/repos/pokt-network/pocket/pulls/732,pokt-network/pocket,6b875eee002f49c4b1abe5ac9faa61f59daaa4cf
https://api.github.com/repos/pokt-network/pocket/pulls/732,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1243074460,Olshansk,8467f3a832ae26b48ed9ec481a8b99355c849c09,6fde86f231f3a1866c34e668ac226f4a6adb05d6,"@@ -9,31 +9,50 @@ import (
 	dht ""github.com/libp2p/go-libp2p-kad-dht""
 	pubsub ""github.com/libp2p/go-libp2p-pubsub""
 	libp2pHost ""github.com/libp2p/go-libp2p/core/host""
+	libp2pPeer ""github.com/libp2p/go-libp2p/core/peer""
+	""go.uber.org/multierr""
+	""google.golang.org/protobuf/proto""
+
 	""github.com/pokt-network/pocket/logger""
 	""github.com/pokt-network/pocket/p2p/config""
 	""github.com/pokt-network/pocket/p2p/protocol""
+	""github.com/pokt-network/pocket/p2p/providers""
 	typesP2P ""github.com/pokt-network/pocket/p2p/types""
+	""github.com/pokt-network/pocket/p2p/unicast""
 	""github.com/pokt-network/pocket/p2p/utils""
 	cryptoPocket ""github.com/pokt-network/pocket/shared/crypto""
+	""github.com/pokt-network/pocket/shared/messaging""
 	""github.com/pokt-network/pocket/shared/modules""
 	""github.com/pokt-network/pocket/shared/modules/base_modules""
 )
 
 var (
 	_ typesP2P.Router            = &backgroundRouter{}
 	_ modules.IntegratableModule = &backgroundRouter{}
+	_ backgroundRouterFactory    = &backgroundRouter{}
 )
 
+type backgroundRouterFactory = modules.FactoryWithConfig[typesP2P.Router, *config.BackgroundConfig]
+
 // backgroundRouter implements `typesP2P.Router` for use with all P2P participants.
 type backgroundRouter struct {
 	base_modules.IntegratableModule
+	unicast.UnicastRouter
 
 	logger *modules.Logger
+	// handler is the function to call when a message is received.
+	handler typesP2P.MessageHandler
 	// host represents a libp2p network node, it encapsulates a libp2p peerstore
 	// & connection manager. `libp2p.New` configures and starts listening
 	// according to options.
 	// (see: https://pkg.go.dev/github.com/libp2p/go-libp2p#section-readme)
 	host libp2pHost.Host
+	// cancelCtx is the cancel function for the context which is provided to the
+	// gossipsub subscription. Used to terminate the `readSubscription()` go routine.
+	cancelCtx context.CancelFunc",p2p/background/router.go,2023-06-27 02:41:51+00:00,2023-06-27T04:11:42Z,s/cancelCtx/readSubscriptionCancelFunc,,,,,52,RIGHT,44,,line,https://api.github.com/repos/pokt-network/pocket/pulls/732,pokt-network/pocket,6b875eee002f49c4b1abe5ac9faa61f59daaa4cf
https://api.github.com/repos/pokt-network/pocket/pulls/732,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1243074600,Olshansk,8467f3a832ae26b48ed9ec481a8b99355c849c09,6fde86f231f3a1866c34e668ac226f4a6adb05d6,"@@ -9,31 +9,50 @@ import (
 	dht ""github.com/libp2p/go-libp2p-kad-dht""
 	pubsub ""github.com/libp2p/go-libp2p-pubsub""
 	libp2pHost ""github.com/libp2p/go-libp2p/core/host""
+	libp2pPeer ""github.com/libp2p/go-libp2p/core/peer""
+	""go.uber.org/multierr""
+	""google.golang.org/protobuf/proto""
+
 	""github.com/pokt-network/pocket/logger""
 	""github.com/pokt-network/pocket/p2p/config""
 	""github.com/pokt-network/pocket/p2p/protocol""
+	""github.com/pokt-network/pocket/p2p/providers""
 	typesP2P ""github.com/pokt-network/pocket/p2p/types""
+	""github.com/pokt-network/pocket/p2p/unicast""
 	""github.com/pokt-network/pocket/p2p/utils""
 	cryptoPocket ""github.com/pokt-network/pocket/shared/crypto""
+	""github.com/pokt-network/pocket/shared/messaging""
 	""github.com/pokt-network/pocket/shared/modules""
 	""github.com/pokt-network/pocket/shared/modules/base_modules""
 )
 
 var (
 	_ typesP2P.Router            = &backgroundRouter{}
 	_ modules.IntegratableModule = &backgroundRouter{}
+	_ backgroundRouterFactory    = &backgroundRouter{}
 )
 
+type backgroundRouterFactory = modules.FactoryWithConfig[typesP2P.Router, *config.BackgroundConfig]
+
 // backgroundRouter implements `typesP2P.Router` for use with all P2P participants.
 type backgroundRouter struct {
 	base_modules.IntegratableModule
+	unicast.UnicastRouter
 
 	logger *modules.Logger
+	// handler is the function to call when a message is received.
+	handler typesP2P.MessageHandler
 	// host represents a libp2p network node, it encapsulates a libp2p peerstore
 	// & connection manager. `libp2p.New` configures and starts listening
 	// according to options.
 	// (see: https://pkg.go.dev/github.com/libp2p/go-libp2p#section-readme)
 	host libp2pHost.Host
+	// cancelCtx is the cancel function for the context which is provided to the
+	// gossipsub subscription. Used to terminate the `readSubscription()` go routine.",p2p/background/router.go,2023-06-27 02:42:10+00:00,2023-06-27T04:11:42Z,"There is a 1-to-1 mapping between background routers and read subscription go routines, right?",,,,,51,RIGHT,43,,line,https://api.github.com/repos/pokt-network/pocket/pulls/732,pokt-network/pocket,6b875eee002f49c4b1abe5ac9faa61f59daaa4cf
https://api.github.com/repos/pokt-network/pocket/pulls/732,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1243074862,Olshansk,8467f3a832ae26b48ed9ec481a8b99355c849c09,6fde86f231f3a1866c34e668ac226f4a6adb05d6,"@@ -47,96 +66,103 @@ type backgroundRouter struct {
 	kadDHT *dht.IpfsDHT
 	// TECHDEBT: `pstore` will likely be removed in future refactoring / simplification
 	// of the `Router` interface.
-	// pstore is the background router's peerstore.
+	// pstore is the background router's peerstore. Assigned in `backgroundRouter#setupPeerstore()`.
 	pstore typesP2P.Peerstore
 }
 
-// NewBackgroundRouter returns a `backgroundRouter` as a `typesP2P.Router`
+// Create returns a `backgroundRouter` as a `typesP2P.Router`
 // interface using the given configuration.
-func NewBackgroundRouter(bus modules.Bus, cfg *config.BackgroundConfig) (typesP2P.Router, error) {
-	// TECHDEBT(#595): add ctx to interface methods and propagate down.
-	ctx := context.TODO()
+func Create(bus modules.Bus, cfg *config.BackgroundConfig) (typesP2P.Router, error) {
+	return new(backgroundRouter).Create(bus, cfg)
+}
 
+func (*backgroundRouter) Create(bus modules.Bus, cfg *config.BackgroundConfig) (typesP2P.Router, error) {
 	networkLogger := logger.Global.CreateLoggerForModule(""backgroundRouter"")",p2p/background/router.go,2023-06-27 02:42:43+00:00,2023-06-27T04:11:42Z,s/networkLogger/bgRouterLogger,,,,,80,RIGHT,71,,line,https://api.github.com/repos/pokt-network/pocket/pulls/732,pokt-network/pocket,6b875eee002f49c4b1abe5ac9faa61f59daaa4cf
https://api.github.com/repos/pokt-network/pocket/pulls/732,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1243076876,Olshansk,8467f3a832ae26b48ed9ec481a8b99355c849c09,6fde86f231f3a1866c34e668ac226f4a6adb05d6,"@@ -12,7 +14,10 @@ func PackMessage(message proto.Message) (*PocketEnvelope, error) {
 	if err != nil {
 		return nil, err
 	}
-	return &PocketEnvelope{Content: anyMsg}, nil
+	return &PocketEnvelope{
+		Content: anyMsg,
+		Nonce:   cryptoPocket.GetNonce(),",shared/messaging/envelope.go,2023-06-27 02:46:53+00:00,2023-06-27T04:11:42Z,Damn. Makes me wonder what else we're missing,,,,19.0,19,RIGHT,16,16.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/732,pokt-network/pocket,6b875eee002f49c4b1abe5ac9faa61f59daaa4cf
https://api.github.com/repos/pokt-network/pocket/pulls/732,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1243077431,Olshansk,8467f3a832ae26b48ed9ec481a8b99355c849c09,6fde86f231f3a1866c34e668ac226f4a6adb05d6,"@@ -0,0 +1,40 @@
+//go:build test
+
+package p2p
+
+import (
+	libp2pHost ""github.com/libp2p/go-libp2p/core/host""
+	typesP2P ""github.com/pokt-network/pocket/p2p/types""
+	""github.com/pokt-network/pocket/shared/modules""
+)
+
+// WithHost associates an existing (i.e. ""started"") libp2p `host.Host`",p2p/testutil.go,2023-06-27 02:47:52+00:00,2023-06-27T04:11:42Z,NIT: No comments for the other two (even though they're obvious).,,,,11.0,11,RIGHT,11,11.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/732,pokt-network/pocket,6b875eee002f49c4b1abe5ac9faa61f59daaa4cf
https://api.github.com/repos/pokt-network/pocket/pulls/732,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1243077644,Olshansk,8467f3a832ae26b48ed9ec481a8b99355c849c09,6fde86f231f3a1866c34e668ac226f4a6adb05d6,"@@ -0,0 +1,40 @@
+//go:build test
+
+package p2p
+
+import (
+	libp2pHost ""github.com/libp2p/go-libp2p/core/host""
+	typesP2P ""github.com/pokt-network/pocket/p2p/types""
+	""github.com/pokt-network/pocket/shared/modules""
+)
+
+// WithHost associates an existing (i.e. ""started"") libp2p `host.Host`
+// with this module, instead of creating a new one on `#Start()`.
+// Primarily intended for testing.
+func WithHost(host libp2pHost.Host) modules.ModuleOption {
+	return func(m modules.InitializableModule) {
+		mod, ok := m.(*p2pModule)
+		if ok {
+			mod.host = host
+			mod.logger.Debug().Msg(""using host provided via `WithHost`"")",p2p/testutil.go,2023-06-27 02:48:16+00:00,2023-06-27T04:11:42Z,"I really like this debug comment approach. Worthwhile adding elsewhere, just in case ;)",,,,19.0,19,RIGHT,19,19.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/732,pokt-network/pocket,6b875eee002f49c4b1abe5ac9faa61f59daaa4cf
https://api.github.com/repos/pokt-network/pocket/pulls/732,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1243078220,Olshansk,8467f3a832ae26b48ed9ec481a8b99355c849c09,6fde86f231f3a1866c34e668ac226f4a6adb05d6,"@@ -76,14 +77,14 @@ func (m *p2pModule) bootstrap() error {
 
 	for _, peer := range pstore.GetPeerList() {
 		m.logger.Debug().Str(""address"", peer.GetAddress().String()).Msg(""Adding peer to router"")
-		if err := m.router.AddPeer(peer); err != nil {
+		if err := m.stakedActorRouter.AddPeer(peer); err != nil {",p2p/bootstrap.go,2023-06-27 02:49:36+00:00,2023-06-27T04:11:42Z,Things are really clearing up 🙌 ,,,,80.0,80,RIGHT,13,13.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/732,pokt-network/pocket,6b875eee002f49c4b1abe5ac9faa61f59daaa4cf
https://api.github.com/repos/pokt-network/pocket/pulls/732,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1243079651,Olshansk,8467f3a832ae26b48ed9ec481a8b99355c849c09,6fde86f231f3a1866c34e668ac226f4a6adb05d6,"@@ -47,96 +66,103 @@ type backgroundRouter struct {
 	kadDHT *dht.IpfsDHT
 	// TECHDEBT: `pstore` will likely be removed in future refactoring / simplification
 	// of the `Router` interface.
-	// pstore is the background router's peerstore.
+	// pstore is the background router's peerstore. Assigned in `backgroundRouter#setupPeerstore()`.
 	pstore typesP2P.Peerstore
 }
 
-// NewBackgroundRouter returns a `backgroundRouter` as a `typesP2P.Router`
+// Create returns a `backgroundRouter` as a `typesP2P.Router`
 // interface using the given configuration.
-func NewBackgroundRouter(bus modules.Bus, cfg *config.BackgroundConfig) (typesP2P.Router, error) {
-	// TECHDEBT(#595): add ctx to interface methods and propagate down.
-	ctx := context.TODO()
+func Create(bus modules.Bus, cfg *config.BackgroundConfig) (typesP2P.Router, error) {
+	return new(backgroundRouter).Create(bus, cfg)
+}
 
+func (*backgroundRouter) Create(bus modules.Bus, cfg *config.BackgroundConfig) (typesP2P.Router, error) {
 	networkLogger := logger.Global.CreateLoggerForModule(""backgroundRouter"")
-	networkLogger.Info().Msg(""Initializing background router"")
+	networkLogger.Info().Msg(""initializing background router"")
 
-	// seed initial peerstore with current on-chain peer info (i.e. staked actors)
-	pstore, err := cfg.PeerstoreProvider.GetStakedPeerstoreAtHeight(
-		cfg.CurrentHeightProvider.CurrentHeight(),
-	)
-	if err != nil {
+	if err := cfg.IsValid(); err != nil {
 		return nil, err
 	}
 
-	// CONSIDERATION: If switching to `NewRandomSub`, there will be a max size
-	gossipSub, err := pubsub.NewGossipSub(ctx, cfg.Host)
-	if err != nil {
-		return nil, fmt.Errorf(""creating gossip pubsub: %w"", err)
-	}
+	// TECHDEBT(#595): add ctx to interface methods and propagate down.
+	ctx, cancel := context.WithCancel(context.TODO())
 
-	dhtMode := dht.ModeAutoServer
-	// NB: don't act as a bootstrap node in peer discovery in client debug mode
-	if isClientDebugMode(bus) {
-		dhtMode = dht.ModeClient
+	rtr := &backgroundRouter{
+		logger:    networkLogger,
+		handler:   cfg.Handler,
+		host:      cfg.Host,
+		cancelCtx: cancel,
 	}
+	rtr.SetBus(bus)
 
-	kadDHT, err := dht.New(ctx, cfg.Host, dht.Mode(dhtMode))
-	if err != nil {
-		return nil, fmt.Errorf(""creating DHT: %w"", err)
+	if err := rtr.setupDependencies(ctx, cfg); err != nil {
+		return nil, err
 	}
 
-	topic, err := gossipSub.Join(protocol.BackgroundTopicStr)
-	if err != nil {
-		return nil, fmt.Errorf(""joining background topic: %w"", err)
-	}
+	go rtr.readSubscription(ctx)
 
-	// INVESTIGATE: `WithBufferSize` `SubOpt`:
-	// > WithBufferSize is a Subscribe option to customize the size of the subscribe
-	// > output buffer. The default length is 32 but it can be configured to avoid
-	// > dropping messages if the consumer is not reading fast enough.
-	// (see: https://pkg.go.dev/github.com/libp2p/go-libp2p-pubsub#WithBufferSize)
-	subscription, err := topic.Subscribe()
-	if err != nil {
-		return nil, fmt.Errorf(""subscribing to background topic: %w"", err)
-	}
+	return rtr, nil
+}
 
-	rtr := &backgroundRouter{
-		host:         cfg.Host,
-		gossipSub:    gossipSub,
-		kadDHT:       kadDHT,
-		topic:        topic,
-		subscription: subscription,
-		logger:       networkLogger,
-		pstore:       pstore,
+func (rtr *backgroundRouter) Close() error {
+	rtr.logger.Debug().Msg(""closing background router"")
+
+	rtr.cancelCtx()
+	rtr.subscription.Cancel()
+
+	var topicCloseErr error
+	if err := rtr.topic.Close(); err != context.Canceled {
+		topicCloseErr = err
 	}
 
-	return rtr, nil
+	return multierr.Append(
+		topicCloseErr,
+		rtr.kadDHT.Close(),
+	)
 }
 
 // Broadcast implements the respective `typesP2P.Router` interface  method.
-func (rtr *backgroundRouter) Broadcast(data []byte) error {
+func (rtr *backgroundRouter) Broadcast(pocketEnvelopeBz []byte) error {
+	backgroundMsg := &typesP2P.BackgroundMessage{
+		Data: pocketEnvelopeBz,
+	}
+	backgroundMsgBz, err := proto.Marshal(backgroundMsg)
+	if err != nil {
+		return err
+	}
+
 	// TECHDEBT(#595): add ctx to interface methods and propagate down.
-	return rtr.topic.Publish(context.TODO(), data)
+	return rtr.topic.Publish(context.TODO(), backgroundMsgBz)
 }
 
 // Send implements the respective `typesP2P.Router` interface  method.
-func (rtr *backgroundRouter) Send(data []byte, address cryptoPocket.Address) error {
+func (rtr *backgroundRouter) Send(pocketEnvelopeBz []byte, address cryptoPocket.Address) error {
+	rtr.logger.Warn().Str(""address"", address.String()).Msg(""sending background message to peer"")",p2p/background/router.go,2023-06-27 02:52:53+00:00,2023-06-27T04:11:43Z,"Can you upate the `Msg` with ""to peer. Should not happen but allowed by the implementation""",,,,,140,RIGHT,174,,line,https://api.github.com/repos/pokt-network/pocket/pulls/732,pokt-network/pocket,6b875eee002f49c4b1abe5ac9faa61f59daaa4cf
https://api.github.com/repos/pokt-network/pocket/pulls/732,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1243079941,Olshansk,8467f3a832ae26b48ed9ec481a8b99355c849c09,6fde86f231f3a1866c34e668ac226f4a6adb05d6,"@@ -166,6 +192,213 @@ func (rtr *backgroundRouter) RemovePeer(peer typesP2P.Peer) error {
 	return rtr.pstore.RemovePeer(peer.GetAddress())
 }
 
+func (rtr *backgroundRouter) setupUnicastRouter() error {",p2p/background/router.go,2023-06-27 02:53:37+00:00,2023-06-27T04:11:43Z,Why do you call it a UnicastRouter given that it's intended for broadcasting?,,,,200.0,195,RIGHT,213,219.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/732,pokt-network/pocket,6b875eee002f49c4b1abe5ac9faa61f59daaa4cf
https://api.github.com/repos/pokt-network/pocket/pulls/732,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1243080180,Olshansk,8467f3a832ae26b48ed9ec481a8b99355c849c09,6fde86f231f3a1866c34e668ac226f4a6adb05d6,"@@ -166,6 +192,213 @@ func (rtr *backgroundRouter) RemovePeer(peer typesP2P.Peer) error {
 	return rtr.pstore.RemovePeer(peer.GetAddress())
 }
 
+func (rtr *backgroundRouter) setupUnicastRouter() error {
+	unicastRouterCfg := config.UnicastRouterConfig{
+		Logger:         rtr.logger,
+		Host:           rtr.host,
+		ProtocolID:     protocol.BackgroundProtocolID,
+		MessageHandler: rtr.handleBackgroundMsg,
+		PeerHandler:    rtr.AddPeer,
+	}
+
+	unicastRouter, err := unicast.Create(rtr.GetBus(), &unicastRouterCfg)
+	if err != nil {
+		return fmt.Errorf(""setting up unicast router: %w"", err)
+	}
+
+	rtr.UnicastRouter = *unicastRouter
+	return nil
+}
+
+func (rtr *backgroundRouter) setupDependencies(ctx context.Context, cfg *config.BackgroundConfig) error {",p2p/background/router.go,2023-06-27 02:54:05+00:00,2023-06-27T04:11:43Z,Very nice and 🧹  😘 ,,,,218.0,213,RIGHT,231,237.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/732,pokt-network/pocket,6b875eee002f49c4b1abe5ac9faa61f59daaa4cf
https://api.github.com/repos/pokt-network/pocket/pulls/732,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1243081568,Olshansk,8467f3a832ae26b48ed9ec481a8b99355c849c09,6fde86f231f3a1866c34e668ac226f4a6adb05d6,"@@ -199,6 +219,14 @@ func createMockBus(t *testing.T, runtimeMgr modules.RuntimeMgr) *mockModules.Moc
 	mockModulesRegistry.EXPECT().GetModule(peerstore_provider.ModuleName).Return(nil, runtime.ErrModuleNotRegistered(peerstore_provider.ModuleName)).AnyTimes()
 	mockModulesRegistry.EXPECT().GetModule(current_height_provider.ModuleName).Return(nil, runtime.ErrModuleNotRegistered(current_height_provider.ModuleName)).AnyTimes()
 	mockBus.EXPECT().GetModulesRegistry().Return(mockModulesRegistry).AnyTimes()
+	mockBus.EXPECT().PublishEventToBus(gomock.AssignableToTypeOf(&messaging.PocketEnvelope{})).",p2p/utils_test.go,2023-06-27 02:57:03+00:00,2023-06-27T04:11:43Z,"Have you ever looked at `waitForEventsInternal` in consensus?

Don't think we need to change anything here, but could be an alternative approach in the future. Maybe just update the TODO you have below?",,,,222.0,222,RIGHT,69,69.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/732,pokt-network/pocket,6b875eee002f49c4b1abe5ac9faa61f59daaa4cf
https://api.github.com/repos/pokt-network/pocket/pulls/732,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1243082103,Olshansk,8467f3a832ae26b48ed9ec481a8b99355c849c09,6fde86f231f3a1866c34e668ac226f4a6adb05d6,"@@ -313,11 +341,32 @@ func prepareEventMetricsAgentMock(t *testing.T, valId string, wg *sync.WaitGroup
 	ctrl := gomock.NewController(t)
 	eventMetricsAgentMock := mockModules.NewMockEventMetricsAgent(ctrl)
 
-	eventMetricsAgentMock.EXPECT().EmitEvent(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).AnyTimes()
-	eventMetricsAgentMock.EXPECT().EmitEvent(gomock.Any(), gomock.Any(), gomock.Eq(telemetry.P2P_RAINTREE_MESSAGE_EVENT_METRIC_SEND_LABEL), gomock.Any()).Do(func(n, e any, l ...any) {
+	// DISCUSS_THIS_COMMIT: The number of times each telemetry event is expected",p2p/utils_test.go,2023-06-27 02:58:18+00:00,2023-06-27T04:11:43Z,"`network size` -> this is known
`redundant messages` -> isn't this configurable

What changed? Note, haven't spent the time diving deep yet, just doing a first high-level review.",,,,,344,RIGHT,86,,line,https://api.github.com/repos/pokt-network/pocket/pulls/732,pokt-network/pocket,6b875eee002f49c4b1abe5ac9faa61f59daaa4cf
https://api.github.com/repos/pokt-network/pocket/pulls/732,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1243115416,Olshansk,8467f3a832ae26b48ed9ec481a8b99355c849c09,6fde86f231f3a1866c34e668ac226f4a6adb05d6,"@@ -23,21 +24,25 @@ func (m *p2pModule) HandleEvent(event *anypb.Any) error {
 			return fmt.Errorf(""failed to cast event to ConsensusNewHeightEvent"")
 		}
 
-		oldPeerList := m.router.GetPeerstore().GetPeerList()
-		updatedPeerstore, err := m.pstoreProvider.GetStakedPeerstoreAtHeight(consensusNewHeightEvent.Height)
-		if err != nil {
+		if isStaked, err := m.isStakedActor(); err != nil {
 			return err
-		}
-
-		added, removed := oldPeerList.Delta(updatedPeerstore.GetPeerList())
-		for _, add := range added {
-			if err := m.router.AddPeer(add); err != nil {
+		} else if isStaked {",p2p/event_handler.go,2023-06-27 04:05:22+00:00,2023-06-27T04:11:43Z,"OPTIONAL PERSONAL STYLE NIT:  Reduce indent for readability

```go
isStaked, err := m.isStakedActor()
if err != nil {
   return err
}
if !isStaked {
   return nil
}
// business logic
```
",,,,,29,RIGHT,27,,line,https://api.github.com/repos/pokt-network/pocket/pulls/732,pokt-network/pocket,6b875eee002f49c4b1abe5ac9faa61f59daaa4cf
https://api.github.com/repos/pokt-network/pocket/pulls/732,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1247950935,dylanlott,bf96542fa6620d338b42184f7bad497f277eabe9,6fde86f231f3a1866c34e668ac226f4a6adb05d6,"@@ -166,6 +195,219 @@ func (rtr *backgroundRouter) RemovePeer(peer typesP2P.Peer) error {
 	return rtr.pstore.RemovePeer(peer.GetAddress())
 }
 
+// setupUnicastRouter configures and assigns `rtr.UnicastRouter`.
+func (rtr *backgroundRouter) setupUnicastRouter() error {
+	unicastRouterCfg := config.UnicastRouterConfig{
+		Logger:         rtr.logger,
+		Host:           rtr.host,
+		ProtocolID:     protocol.BackgroundProtocolID,
+		MessageHandler: rtr.handleBackgroundMsg,
+		PeerHandler:    rtr.AddPeer,
+	}
+
+	unicastRouter, err := unicast.Create(rtr.GetBus(), &unicastRouterCfg)
+	if err != nil {
+		return fmt.Errorf(""setting up unicast router: %w"", err)
+	}
+
+	rtr.UnicastRouter = *unicastRouter
+	return nil
+}
+
+func (rtr *backgroundRouter) setupDependencies(ctx context.Context, cfg *config.BackgroundConfig) error {
+	if err := rtr.setupUnicastRouter(); err != nil {
+		return err
+	}
+
+	if err := rtr.setupPeerDiscovery(ctx); err != nil {
+		return fmt.Errorf(""setting up peer discovery: %w"", err)
+	}
+
+	if err := rtr.setupPubsub(ctx); err != nil {
+		return fmt.Errorf(""setting up pubsub: %w"", err)
+	}
+
+	if err := rtr.setupTopic(); err != nil {
+		return fmt.Errorf(""setting up topic: %w"", err)
+	}
+
+	if err := rtr.setupSubscription(); err != nil {
+		return fmt.Errorf(""setting up subscription: %w"", err)
+	}
+
+	if err := rtr.setupPeerstore(
+		ctx,
+		cfg.PeerstoreProvider, cfg.CurrentHeightProvider); err != nil {
+		return fmt.Errorf(""setting up peerstore: %w"", err)
+	}
+	return nil
+}
+
+func (rtr *backgroundRouter) setupPeerstore(
+	ctx context.Context,
+	pstoreProvider providers.PeerstoreProvider,
+	currentHeightProvider providers.CurrentHeightProvider,
+) (err error) {
+	// seed initial peerstore with current on-chain peer info (i.e. staked actors)
+	rtr.pstore, err = pstoreProvider.GetStakedPeerstoreAtHeight(
+		currentHeightProvider.CurrentHeight(),
+	)
+	if err != nil {
+		return err
+	}
+
+	if err := rtr.bootstrap(ctx); err != nil {
+		return fmt.Errorf(""bootstrapping peerstore: %w"", err)
+	}
+
+	return nil
+}
+
+func (rtr *backgroundRouter) setupPeerDiscovery(ctx context.Context) (err error) {
+	dhtMode := dht.ModeAutoServer
+	// NB: don't act as a bootstrap node in peer discovery in client debug mode
+	if isClientDebugMode(rtr.GetBus()) {
+		dhtMode = dht.ModeClient
+	}
+
+	rtr.kadDHT, err = dht.New(ctx, rtr.host, dht.Mode(dhtMode))
+	return err
+}
+
+func (rtr *backgroundRouter) setupPubsub(ctx context.Context) (err error) {
+	// TECHDEBT(#730): integrate libp2p tracing via `pubsub.WithEventTracer()`.
+
+	// CONSIDERATION: If switching to `NewRandomSub`, there will be a max size
+	rtr.gossipSub, err = pubsub.NewGossipSub(ctx, rtr.host)
+	return err
+}
+
+func (rtr *backgroundRouter) setupTopic() (err error) {
+	if err := rtr.gossipSub.RegisterTopicValidator(
+		protocol.BackgroundTopicStr,
+		rtr.topicValidator,
+	); err != nil {
+		return fmt.Errorf(
+			""registering topic validator for topic: %q: %w"",
+			protocol.BackgroundTopicStr, err,
+		)
+	}
+
+	if rtr.topic, err = rtr.gossipSub.Join(protocol.BackgroundTopicStr); err != nil {
+		return fmt.Errorf(
+			""joining background topic: %q: %w"",
+			protocol.BackgroundTopicStr, err,
+		)
+	}
+	return nil
+}
+
+func (rtr *backgroundRouter) setupSubscription() (err error) {
+	// INVESTIGATE: `WithBufferSize` `SubOpt`:
+	// > WithBufferSize is a Subscribe option to customize the size of the subscribe
+	// > output buffer. The default length is 32 but it can be configured to avoid
+	// > dropping messages if the consumer is not reading fast enough.
+	// (see: https://pkg.go.dev/github.com/libp2p/go-libp2p-pubsub#WithBufferSize)
+	rtr.subscription, err = rtr.topic.Subscribe()
+	return err
+}
+
+func (rtr *backgroundRouter) bootstrap(ctx context.Context) error {
+	// CONSIDERATION: add `GetPeers` method to `PeerstoreProvider` interface
+	// to avoid this loop.
+	for _, peer := range rtr.pstore.GetPeerList() {
+		if err := utils.AddPeerToLibp2pHost(rtr.host, peer); err != nil {
+			return err
+		}
+
+		libp2pAddrInfo, err := utils.Libp2pAddrInfoFromPeer(peer)
+		if err != nil {
+			return fmt.Errorf(
+				""converting peer info, pokt address: %s: %w"",
+				peer.GetAddress(),
+				err,
+			)
+		}
+
+		// don't attempt to connect to self
+		if rtr.host.ID() == libp2pAddrInfo.ID {
+			return nil
+		}
+
+		if err := rtr.host.Connect(ctx, libp2pAddrInfo); err != nil {
+			return fmt.Errorf(""connecting to peer: %w"", err)
+		}
+	}
+	return nil
+}
+
+// topicValidator is used in conjunction with libp2p-pubsub's notion of ""topic
+// validaton"". It is usefed for arbitrary and concurrent pre-propagation validation",p2p/background/router.go,2023-06-30 14:44:03+00:00,2023-06-30T14:44:04Z,"```suggestion
// validaton"". It is used for arbitrary and concurrent pre-propagation validation
```",,,,,345,RIGHT,364,,line,https://api.github.com/repos/pokt-network/pocket/pulls/732,pokt-network/pocket,6b875eee002f49c4b1abe5ac9faa61f59daaa4cf
https://api.github.com/repos/pokt-network/pocket/pulls/732,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1251309944,Olshansk,4602283cbd676952b2a5c20f73758305cc833ce5,6fde86f231f3a1866c34e668ac226f4a6adb05d6,"@@ -67,105 +66,431 @@ flowchart TD
     class PN pocket_network
 ```
 
-`Routers` is where [RainTree](https://github.com/pokt-network/pocket/files/9853354/raintree.pdf) (or the simpler basic approach) is implemented. See `raintree/router.go` for the specific implementation of RainTree, but please refer to the [specifications](https://github.com/pokt-network/pocket-network-protocol/tree/main/p2p) for more details.
+`Routers` is where [RainTree](https://github.com/pokt-network/pocket/files/9853354/raintree.pdf) is implemented.
+See [`raintree/router.go`](./raintree/router.go) for the specific implementation of RainTree, but please refer to the [specifications](https://github.com/pokt-network/pocket-network-protocol/tree/main/p2p) for more details.
 
-### Raintree Router Architecture
+## Module Architecture
 
-_DISCUSS(team): If you feel this needs a diagram, please reach out to the team for additional details._
-_TODO(olshansky, BenVan): Link to RainTree visualizations once it is complete._
+### Legends
+```mermaid
+flowchart
+subgraph Legend
+    m[[`Method`]]
+    c[Component]
+
+    m -- ""unconditional usage"" --> c",p2p/README.md,2023-07-03 22:09:19+00:00,2023-07-03T23:30:11Z,I ❤️ how you're taking mermaid it to the next level,,,,100.0,81,RIGHT,57,91.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/732,pokt-network/pocket,6b875eee002f49c4b1abe5ac9faa61f59daaa4cf
https://api.github.com/repos/pokt-network/pocket/pulls/732,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1251310557,Olshansk,4602283cbd676952b2a5c20f73758305cc833ce5,6fde86f231f3a1866c34e668ac226f4a6adb05d6,"@@ -67,105 +66,431 @@ flowchart TD
     class PN pocket_network
 ```
 
-`Routers` is where [RainTree](https://github.com/pokt-network/pocket/files/9853354/raintree.pdf) (or the simpler basic approach) is implemented. See `raintree/router.go` for the specific implementation of RainTree, but please refer to the [specifications](https://github.com/pokt-network/pocket-network-protocol/tree/main/p2p) for more details.
+`Routers` is where [RainTree](https://github.com/pokt-network/pocket/files/9853354/raintree.pdf) is implemented.
+See [`raintree/router.go`](./raintree/router.go) for the specific implementation of RainTree, but please refer to the [specifications](https://github.com/pokt-network/pocket-network-protocol/tree/main/p2p) for more details.
 
-### Raintree Router Architecture
+## Module Architecture
 
-_DISCUSS(team): If you feel this needs a diagram, please reach out to the team for additional details._
-_TODO(olshansky, BenVan): Link to RainTree visualizations once it is complete._
+### Legends
+```mermaid
+flowchart
+subgraph Legend
+    m[[`Method`]]
+    c[Component]
+
+    m -- ""unconditional usage"" --> c
+    m -. ""conditional usage"" .-> c
+    m -. ""ignored"" .-x c
+end
+```
+
+```mermaid
+classDiagram
+class ConcreteType {
+  +ExportedField
+  -unexportedField
+  +ExportedMethod(argType) returnType
+  -unexportedMethod()",p2p/README.md,2023-07-03 22:11:15+00:00,2023-07-03T23:30:11Z,"Optional suggetion to use a variadic approach to this. You can apply it to the interface type as well


```suggestion
  +ExportedMethod(...args) (...returnTypes)
  -unexportedMethod(...args) (...returnTypes)
```",,92.0,RIGHT,,93,RIGHT,69,,line,https://api.github.com/repos/pokt-network/pocket/pulls/732,pokt-network/pocket,6b875eee002f49c4b1abe5ac9faa61f59daaa4cf
https://api.github.com/repos/pokt-network/pocket/pulls/732,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1251312306,Olshansk,4602283cbd676952b2a5c20f73758305cc833ce5,6fde86f231f3a1866c34e668ac226f4a6adb05d6,"@@ -67,105 +66,431 @@ flowchart TD
     class PN pocket_network
 ```
 
-`Routers` is where [RainTree](https://github.com/pokt-network/pocket/files/9853354/raintree.pdf) (or the simpler basic approach) is implemented. See `raintree/router.go` for the specific implementation of RainTree, but please refer to the [specifications](https://github.com/pokt-network/pocket-network-protocol/tree/main/p2p) for more details.
+`Routers` is where [RainTree](https://github.com/pokt-network/pocket/files/9853354/raintree.pdf) is implemented.
+See [`raintree/router.go`](./raintree/router.go) for the specific implementation of RainTree, but please refer to the [specifications](https://github.com/pokt-network/pocket-network-protocol/tree/main/p2p) for more details.
 
-### Raintree Router Architecture
+## Module Architecture
 
-_DISCUSS(team): If you feel this needs a diagram, please reach out to the team for additional details._
-_TODO(olshansky, BenVan): Link to RainTree visualizations once it is complete._
+### Legends
+```mermaid
+flowchart
+subgraph Legend
+    m[[`Method`]]
+    c[Component]
+
+    m -- ""unconditional usage"" --> c
+    m -. ""conditional usage"" .-> c
+    m -. ""ignored"" .-x c
+end
+```
+
+```mermaid
+classDiagram
+class ConcreteType {
+  +ExportedField
+  -unexportedField
+  +ExportedMethod(argType) returnType
+  -unexportedMethod()
+}
+
+class InterfaceType {
+    <<interface>>
+    +Method(argType) (returnType1, returnType2)
+}
+
+ConcreteType --|> InterfaceType : Interface realization
+
+ConcreteType --> OtherType : Direct usage
+ConcreteType --o OtherType : Composition
+ConcreteType --* OtherType : Aggregatation",p2p/README.md,2023-07-03 22:16:51+00:00,2023-07-03T23:30:11Z,"It's not really clear to me what `composition` and `aggregation` are in this context.

Is it, for example, embedding the struct in another struct?

Can you add details via text or in the diagram so it's clearer",123.0,104.0,RIGHT,124.0,105,RIGHT,81,115.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/732,pokt-network/pocket,6b875eee002f49c4b1abe5ac9faa61f59daaa4cf
https://api.github.com/repos/pokt-network/pocket/pulls/732,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1251312495,Olshansk,4602283cbd676952b2a5c20f73758305cc833ce5,6fde86f231f3a1866c34e668ac226f4a6adb05d6,"@@ -67,105 +66,431 @@ flowchart TD
     class PN pocket_network
 ```
 
-`Routers` is where [RainTree](https://github.com/pokt-network/pocket/files/9853354/raintree.pdf) (or the simpler basic approach) is implemented. See `raintree/router.go` for the specific implementation of RainTree, but please refer to the [specifications](https://github.com/pokt-network/pocket-network-protocol/tree/main/p2p) for more details.
+`Routers` is where [RainTree](https://github.com/pokt-network/pocket/files/9853354/raintree.pdf) is implemented.
+See [`raintree/router.go`](./raintree/router.go) for the specific implementation of RainTree, but please refer to the [specifications](https://github.com/pokt-network/pocket-network-protocol/tree/main/p2p) for more details.
 
-### Raintree Router Architecture
+## Module Architecture
 
-_DISCUSS(team): If you feel this needs a diagram, please reach out to the team for additional details._
-_TODO(olshansky, BenVan): Link to RainTree visualizations once it is complete._
+### Legends",p2p/README.md,2023-07-03 22:17:24+00:00,2023-07-03T23:30:11Z,Optional: TODO to generalize these legends across the whole repo?,,,,92.0,74,RIGHT,50,80.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/732,pokt-network/pocket,6b875eee002f49c4b1abe5ac9faa61f59daaa4cf
https://api.github.com/repos/pokt-network/pocket/pulls/732,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1251312547,Olshansk,4602283cbd676952b2a5c20f73758305cc833ce5,6fde86f231f3a1866c34e668ac226f4a6adb05d6,"@@ -67,105 +66,431 @@ flowchart TD
     class PN pocket_network
 ```
 
-`Routers` is where [RainTree](https://github.com/pokt-network/pocket/files/9853354/raintree.pdf) (or the simpler basic approach) is implemented. See `raintree/router.go` for the specific implementation of RainTree, but please refer to the [specifications](https://github.com/pokt-network/pocket-network-protocol/tree/main/p2p) for more details.
+`Routers` is where [RainTree](https://github.com/pokt-network/pocket/files/9853354/raintree.pdf) is implemented.
+See [`raintree/router.go`](./raintree/router.go) for the specific implementation of RainTree, but please refer to the [specifications](https://github.com/pokt-network/pocket-network-protocol/tree/main/p2p) for more details.
 
-### Raintree Router Architecture
+## Module Architecture
 
-_DISCUSS(team): If you feel this needs a diagram, please reach out to the team for additional details._
-_TODO(olshansky, BenVan): Link to RainTree visualizations once it is complete._
+### Legends
+```mermaid
+flowchart
+subgraph Legend
+    m[[`Method`]]
+    c[Component]
+
+    m -- ""unconditional usage"" --> c
+    m -. ""conditional usage"" .-> c
+    m -. ""ignored"" .-x c
+end
+```
+
+```mermaid
+classDiagram
+class ConcreteType {
+  +ExportedField
+  -unexportedField
+  +ExportedMethod(argType) returnType
+  -unexportedMethod()
+}
+
+class InterfaceType {
+    <<interface>>
+    +Method(argType) (returnType1, returnType2)
+}
+
+ConcreteType --|> InterfaceType : Interface realization
+
+ConcreteType --> OtherType : Direct usage
+ConcreteType --o OtherType : Composition
+ConcreteType --* OtherType : Aggregatation
+ConcreteType ..*  ""(cardinality)"" OtherType : Indirect (via interface)",p2p/README.md,2023-07-03 22:17:39+00:00,2023-07-03T23:30:11Z,Same for cardinality. Are you trying to imply that there is a M:N relationship between one concrete type and another?,,,,125.0,106,RIGHT,82,116.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/732,pokt-network/pocket,6b875eee002f49c4b1abe5ac9faa61f59daaa4cf
https://api.github.com/repos/pokt-network/pocket/pulls/732,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1251312577,Olshansk,4602283cbd676952b2a5c20f73758305cc833ce5,6fde86f231f3a1866c34e668ac226f4a6adb05d6,"@@ -67,105 +66,431 @@ flowchart TD
     class PN pocket_network
 ```
 
-`Routers` is where [RainTree](https://github.com/pokt-network/pocket/files/9853354/raintree.pdf) (or the simpler basic approach) is implemented. See `raintree/router.go` for the specific implementation of RainTree, but please refer to the [specifications](https://github.com/pokt-network/pocket-network-protocol/tree/main/p2p) for more details.
+`Routers` is where [RainTree](https://github.com/pokt-network/pocket/files/9853354/raintree.pdf) is implemented.
+See [`raintree/router.go`](./raintree/router.go) for the specific implementation of RainTree, but please refer to the [specifications](https://github.com/pokt-network/pocket-network-protocol/tree/main/p2p) for more details.
 
-### Raintree Router Architecture
+## Module Architecture
 
-_DISCUSS(team): If you feel this needs a diagram, please reach out to the team for additional details._
-_TODO(olshansky, BenVan): Link to RainTree visualizations once it is complete._
+### Legends
+```mermaid
+flowchart
+subgraph Legend
+    m[[`Method`]]
+    c[Component]
+
+    m -- ""unconditional usage"" --> c
+    m -. ""conditional usage"" .-> c
+    m -. ""ignored"" .-x c
+end
+```
+
+```mermaid
+classDiagram
+class ConcreteType {
+  +ExportedField
+  -unexportedField
+  +ExportedMethod(argType) returnType
+  -unexportedMethod()
+}
+
+class InterfaceType {
+    <<interface>>
+    +Method(argType) (returnType1, returnType2)
+}
+
+ConcreteType --|> InterfaceType : Interface realization
+
+ConcreteType --> OtherType : Direct usage
+ConcreteType --o OtherType : Composition
+ConcreteType --* OtherType : Aggregatation
+ConcreteType ..*  ""(cardinality)"" OtherType : Indirect (via interface)
+```
+
+### P2P Module / Router Decoupling
 
-### Message Propagation
+The P2P module encapsulates the `RaiTreeRouter` and `BackgroundRouter` submodules.",p2p/README.md,2023-07-03 22:17:46+00:00,2023-07-03T23:30:12Z,"```suggestion
The P2P module encapsulates the `RainTreeRouter` and `BackgroundRouter` submodules.
```",,,,,111,RIGHT,88,,line,https://api.github.com/repos/pokt-network/pocket/pulls/732,pokt-network/pocket,6b875eee002f49c4b1abe5ac9faa61f59daaa4cf
https://api.github.com/repos/pokt-network/pocket/pulls/732,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1251316697,Olshansk,4602283cbd676952b2a5c20f73758305cc833ce5,6fde86f231f3a1866c34e668ac226f4a6adb05d6,"@@ -67,105 +66,431 @@ flowchart TD
     class PN pocket_network
 ```
 
-`Routers` is where [RainTree](https://github.com/pokt-network/pocket/files/9853354/raintree.pdf) (or the simpler basic approach) is implemented. See `raintree/router.go` for the specific implementation of RainTree, but please refer to the [specifications](https://github.com/pokt-network/pocket-network-protocol/tree/main/p2p) for more details.
+`Routers` is where [RainTree](https://github.com/pokt-network/pocket/files/9853354/raintree.pdf) is implemented.
+See [`raintree/router.go`](./raintree/router.go) for the specific implementation of RainTree, but please refer to the [specifications](https://github.com/pokt-network/pocket-network-protocol/tree/main/p2p) for more details.
 
-### Raintree Router Architecture
+## Module Architecture
 
-_DISCUSS(team): If you feel this needs a diagram, please reach out to the team for additional details._
-_TODO(olshansky, BenVan): Link to RainTree visualizations once it is complete._
+### Legends
+```mermaid
+flowchart
+subgraph Legend
+    m[[`Method`]]
+    c[Component]
+
+    m -- ""unconditional usage"" --> c
+    m -. ""conditional usage"" .-> c
+    m -. ""ignored"" .-x c
+end
+```
+
+```mermaid
+classDiagram
+class ConcreteType {
+  +ExportedField
+  -unexportedField
+  +ExportedMethod(argType) returnType
+  -unexportedMethod()
+}
+
+class InterfaceType {
+    <<interface>>
+    +Method(argType) (returnType1, returnType2)
+}
+
+ConcreteType --|> InterfaceType : Interface realization
+
+ConcreteType --> OtherType : Direct usage
+ConcreteType --o OtherType : Composition
+ConcreteType --* OtherType : Aggregatation
+ConcreteType ..*  ""(cardinality)"" OtherType : Indirect (via interface)
+```
+
+### P2P Module / Router Decoupling
 
-### Message Propagation
+The P2P module encapsulates the `RaiTreeRouter` and `BackgroundRouter` submodules.
+The P2P module internally refers to these as the `stakedActorRouter` and `unstakedActorRouter`, respectively.
 
-Given `Local P2P Module` has a message that it needs to propagate:
+Depending on the necessary routing scheme (unicast / broadcast) and whether the peers involved are staked actors, a node will use one or both of these routers.
 
-<ul style=""list-style-type: none;"">
-    <li>1a. <code>Raintree Router</code> selects targets from the <code>Pokt Peerstore</code>, <strong>which only includes staked actors</strong></li>
-    <li>1b. <code>Background Router</code> selects targets from the libp2p <code>Peerstore</code>, <strong>which includes all P2P participants</strong></li>
-    <li>2. Libp2p <code>Host</code> manages opening and closing streams to targeted peers</li>
-    <li>3. <code>Remote P2P module</code>'s (i.e. receiver's) <code>handleStream</code> is called (having been registered via <code>setStreamHandler()</code>)</li>
-    <li>4a. <code>handleStream</code> propagates message via <code>Raintree Router</code></li>
-    <li>4b. <code>handleStream</code> propagates message via <code>Background Router</code></li>
-    <li>5a. Repeat step 1a from <code>Remote P2P Module</code>'s perspective targeting its next peers</li>
-    <li>5b. Repeat step 1b from <code>Remote P2P Module</code>'s perspective targeting its next peers</li>
-</ul>
+**Unicast**
+
+| Sender         | Receiver       | Router          | Example Usage                                        |
+|----------------|----------------|-----------------|------------------------------------------------------|
+| Staked Actor   | Staked Actor   | Raintree only   | Consensus (state sync) messages (to validators only) |",p2p/README.md,2023-07-03 22:28:45+00:00,2023-07-03T23:30:12Z,"```suggestion
| Staked Actor   | Staked Actor   | NA (Direct Send)   | Consensus (hotstuff) messages (to validators only) |
```",,,,,120,RIGHT,108,,line,https://api.github.com/repos/pokt-network/pocket/pulls/732,pokt-network/pocket,6b875eee002f49c4b1abe5ac9faa61f59daaa4cf
https://api.github.com/repos/pokt-network/pocket/pulls/732,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1251317366,Olshansk,4602283cbd676952b2a5c20f73758305cc833ce5,6fde86f231f3a1866c34e668ac226f4a6adb05d6,"@@ -67,105 +66,431 @@ flowchart TD
     class PN pocket_network
 ```
 
-`Routers` is where [RainTree](https://github.com/pokt-network/pocket/files/9853354/raintree.pdf) (or the simpler basic approach) is implemented. See `raintree/router.go` for the specific implementation of RainTree, but please refer to the [specifications](https://github.com/pokt-network/pocket-network-protocol/tree/main/p2p) for more details.
+`Routers` is where [RainTree](https://github.com/pokt-network/pocket/files/9853354/raintree.pdf) is implemented.
+See [`raintree/router.go`](./raintree/router.go) for the specific implementation of RainTree, but please refer to the [specifications](https://github.com/pokt-network/pocket-network-protocol/tree/main/p2p) for more details.
 
-### Raintree Router Architecture
+## Module Architecture
 
-_DISCUSS(team): If you feel this needs a diagram, please reach out to the team for additional details._
-_TODO(olshansky, BenVan): Link to RainTree visualizations once it is complete._
+### Legends
+```mermaid
+flowchart
+subgraph Legend
+    m[[`Method`]]
+    c[Component]
+
+    m -- ""unconditional usage"" --> c
+    m -. ""conditional usage"" .-> c
+    m -. ""ignored"" .-x c
+end
+```
+
+```mermaid
+classDiagram
+class ConcreteType {
+  +ExportedField
+  -unexportedField
+  +ExportedMethod(argType) returnType
+  -unexportedMethod()
+}
+
+class InterfaceType {
+    <<interface>>
+    +Method(argType) (returnType1, returnType2)
+}
+
+ConcreteType --|> InterfaceType : Interface realization
+
+ConcreteType --> OtherType : Direct usage
+ConcreteType --o OtherType : Composition
+ConcreteType --* OtherType : Aggregatation
+ConcreteType ..*  ""(cardinality)"" OtherType : Indirect (via interface)
+```
+
+### P2P Module / Router Decoupling
 
-### Message Propagation
+The P2P module encapsulates the `RaiTreeRouter` and `BackgroundRouter` submodules.
+The P2P module internally refers to these as the `stakedActorRouter` and `unstakedActorRouter`, respectively.
 
-Given `Local P2P Module` has a message that it needs to propagate:
+Depending on the necessary routing scheme (unicast / broadcast) and whether the peers involved are staked actors, a node will use one or both of these routers.
 
-<ul style=""list-style-type: none;"">
-    <li>1a. <code>Raintree Router</code> selects targets from the <code>Pokt Peerstore</code>, <strong>which only includes staked actors</strong></li>
-    <li>1b. <code>Background Router</code> selects targets from the libp2p <code>Peerstore</code>, <strong>which includes all P2P participants</strong></li>
-    <li>2. Libp2p <code>Host</code> manages opening and closing streams to targeted peers</li>
-    <li>3. <code>Remote P2P module</code>'s (i.e. receiver's) <code>handleStream</code> is called (having been registered via <code>setStreamHandler()</code>)</li>
-    <li>4a. <code>handleStream</code> propagates message via <code>Raintree Router</code></li>
-    <li>4b. <code>handleStream</code> propagates message via <code>Background Router</code></li>
-    <li>5a. Repeat step 1a from <code>Remote P2P Module</code>'s perspective targeting its next peers</li>
-    <li>5b. Repeat step 1b from <code>Remote P2P Module</code>'s perspective targeting its next peers</li>
-</ul>
+**Unicast**
+
+| Sender         | Receiver       | Router          | Example Usage                                        |
+|----------------|----------------|-----------------|------------------------------------------------------|
+| Staked Actor   | Staked Actor   | Raintree only   | Consensus (state sync) messages (to validators only) |
+| Unstaked Actor | Staked Actor   | Background only | Consensus (state sync) messages (to validators only) |
+| Unstaked Actor | Unstaked Actor | Background only | Consensus (state sync) & Debug (CLI) messages        |
+
+**Broadcast**
+
+| Broadcaster    | Receiver       | Router                | Example Usage                              |
+|----------------|----------------|-----------------------|--------------------------------------------|
+| Staked Actor   | Staked Actor   | Raintree + Background | Utility tx messages                        |
+| Unstaked Actor | Staked Actor   | Background only       | Utility tx messages (gossipsub redundancy) |
+| Unstaked Actor | Unstaked Actor | Background only       | Utility tx messages                        |
+
+Both router submodule implementations embed a `UnicastRouter` which enables them to send and receive messages directly to/from a single peer.
+
+**Class Diagram**
 
 ```mermaid
-flowchart TD
-  subgraph lMod[Local P2P Module]
-    subgraph lHost[Libp2p `Host`]
+classDiagram
+    class p2pModule {
+        -stakedActorRouter Router
+        -unstakedActorRouter Router
+        -handlePocketEnvelope([]byte) error
+    }
+
+    class P2PModule {
+        <<interface>>
+        GetAddress() (Address, error)
+        HandleEvent(*anypb.Any) error
+        Send([]byte, Address) error
+        Broadcast([]byte) error
+    }
+    p2pModule --|> P2PModule
+
+    class RainTreeRouter {
+        UnicastRouter
+        -handler MessageHandler
+        +Broadcast([]byte) error
+        -handleRainTreeMsg([]byte) error
+    }
+
+    class BackgroundRouter {
+        UnicastRouter
+        -handler MessageHandler
+        +Broadcast([]byte) error
+        -handleBackgroundMsg([]byte) error
+        -readSubscription(subscription *pubsub.Subscription)
+    }
+
+    class UnicastRouter {
+        -messageHandler MessageHandler
+        -peerHandler PeerHandler
+        +Send([]byte, Address) error
+        -handleStream(libp2pNetwork.Stream)
+        -readStream(libp2pNetwork.Stream)
+    }
+    RainTreeRouter --* UnicastRouter : (embedded)
+    BackgroundRouter --* UnicastRouter : (embedded)
+
+    p2pModule --o ""2"" Router
+    p2pModule ..* RainTreeRouter : (`stakedActorRouter`)
+    p2pModule ..* BackgroundRouter : (`unstakedActorRouter`)
+    
+    class Router {
+        <<interface>>
+        +Send([]byte, Address) error
+        +Broadcast([]byte) error
+    }
+    BackgroundRouter --|> Router
+    RainTreeRouter --|> Router
+```
+
+### Message Propagation & Handling
+
+**Unicast**
+
+```mermaid
+flowchart
+    subgraph lp2p[""Local P2P Module (outgoing)""]
+        lps[[`Send`]]
+        lps -. ""(iff local & remote peer are staked)"" ..-> lrtu
+        lps -. ""(if local or remote peer are not staked)"" .-> lbgu
+
+        lbgu -- ""opens stream\nto target peer"" ---> lhost
+
+        lhost[Libp2p Host]
+
+        subgraph lrt[RainTree Router]
+            subgraph lRTPS[Raintree Peerstore]
+              lStakedPS([staked actors only])
+            end
+            
+            lrtu[UnicastRouter]
+
+            lrtu -- ""network address lookup"" --> lRTPS
+        end
+
+        lrtu -- ""opens a stream\nto target peer"" ---> lhost
+
+        subgraph lbg[Background Router]
+            lbgu[UnicastRouter]
+            subgraph lBGPS[Background Peerstore]
+              lNetPS([all P2P participants])
+            end
+
+            lbgu -- ""network address lookup"" --> lBGPS
+        end
+    end
+
+    subgraph rp2p[""Remote P2P Module (incoming)""]
+        rhost[Libp2p Host]
+
+        subgraph rrt[RainTree Router]
+            rrth[[`RainTreeMessage` Handler]]
+            rrtu[UnicastRouter]
+        end
+
+        subgraph rbg[Background Router]
+            rbgh[[`BackgroundMessage` Handler]]
+            rbgu[UnicastRouter]
+            rbgu --> rbgh
+        end
+
+        rp2ph[[`PocketEnvelope` Handler]]
+        rbus[bus]
+        rhost -. ""new stream"" .-> rrtu
+        rhost -- ""new subscription message"" --> rbgu
+        rrtu --> rrth
+
+        rnd[Nonce Deduper]
+        rp2ph -- ""deduplicate msg mempool"" --> rnd
     end
-    subgraph lRT[Raintree Router]
+
+
+    rp2ph -. ""(iff not duplicate msg)\npublish event"" .-> rbus
+
+    rrth --> rp2ph
+    rbgh --> rp2ph
+
+    lhost --> rhost
+```
+
+**Broadcast**
+
+```mermaid
+flowchart
+  subgraph lp2p[""Local P2P Module (outgoing)""]
+    lpb[[`Broadcast`]]
+    lpb -. ""(iff local & remote peer are staked)"" ..-> lrtu
+    lpb -- ""(always)"" --> lbggt
+    
+    lbggt -- ""msg published\n(gossipsub protocol)"" ---> lhost
+    
+    lhost[Libp2p Host]
+
+    subgraph lrt[RainTree Router]
       subgraph lRTPS[Raintree Peerstore]
         lStakedPS([staked actors only])
       end
-
-      subgraph lPM[PeerManager]
-      end
-      lPM --> lRTPS
+      
+      lrtu[UnicastRouter]
+      
+      lrtu -- ""network address lookup"" --> lRTPS
     end
+    
+    lrtu -- ""opens a stream\nto target peer"" ---> lhost
 
-    subgraph lBG[Background Router]
+    subgraph lbg[Background Router]
+      lbggt[Gossipsub Topic]
       subgraph lBGPS[Background Peerstore]
         lNetPS([all P2P participants])
       end
+      
+      lbggt -- ""network address lookup"" --> lBGPS
+    end
+  end
 
-      subgraph lGossipSub[GossipSub]
-      end
+  subgraph rp2p[""Remote P2P Module (incoming)""]
+    rhost[Libp2p Host]
 
-      subgraph lDHT[Kademlia DHT]
-      end
+    subgraph rrt[RainTree Router]
+      rrth[[`RainTreeMessage` Handler]]
+      rrtu[UnicastRouter]
+    end
 
-      lGossipSub --> lBGPS
-      lDHT --> lBGPS
+    subgraph rbg[Background Router]
+      rbgh[[`BackgroundMessage` Handler]]
+      rbgg[Gossipsub Subscription]
+      rbggt[Gossipsub Topic]
+      rbgg --> rbgh
+      rbgh -- ""(background msg\npropagation cont.)"" ---> rbggt
     end
 
-    lRT --1a--> lHost
-    lBG --1b--> lHost
+    rp2ph[[`PocketEnvelope` Handler]]
+    rbus[bus]
+    rhost -. ""new stream"" ..-> rrtu
+    rhost -- ""new subscription message"" --> rbgg
+    rbggt -- ""(background msg\npropagation cont.)"" --> rhost
+    rrtu --> rrth
+    rrth -. ""(iff level > 0)\n(raintree msg\npropagation cont.)"" .-> rrtu
+    rrtu -- ""(raintree msg\npropagation cont.)"" --> rhost
+
+    rnd[Nonce Deduper]
+    rp2ph -- ""deduplicate msg mempool"" --> rnd
   end
 
-subgraph rMod[Remote P2P Module]
-subgraph rHost[Libp2p `Host`]
-end
-subgraph rRT[Raintree Router]
-subgraph rPS[Raintree Peerstore]
-rStakedPS([staked actors only])
-end
 
-subgraph rPM[PeerManager]
-end
+  rp2ph -. ""(iff not duplicate msg)\npublish event"" .-> rbus
 
-rPM --> rStakedPS
-end
+  rrth --> rp2ph
+  rbgh --> rp2ph
 
-subgraph rBG[Background Router]
-subgraph rBGPS[Background Peerstore]
-rNetPS([all P2P participants])
-end
+  lhost --> rhost
+```
 
-subgraph rGossipSub[GossipSub]
-end
+### Message Deduplication
 
-subgraph rDHT[Kademlia DHT]
-end
+Messages MUST be deduplicated before broadcasting their respective event over the bus since it is expected that nodes will receive duplicate messages (for multiple reasons).
 
-rGossipSub --> rBGPS
-rDHT --> rBGPS
-end
+The responsibility of deduplication is encapsulated by the P2P module, As such duplicate messages may come from multiple routers in some of these scenarios.
 
-rHost -. ""3 (setStreamHandler())"" .-> hs[[handleStream]]
+```mermaid
+classDiagram
+    class RainTreeMessage {
+        <<protobuf>>
+        +Level uint32
+        +Data []byte
+    }
+
+    class BackgroundMessage {
+        <<protobuf>>
+        +Data []byte
+    }
+    
+    class PocketEnvelope {
+        <<protobuf>>
+        +Content *anypb.Any
+        +Nonce uint64
+    }
+
+    RainTreeMessage --* PocketEnvelope : serialized as `Data`
+    BackgroundMessage --* PocketEnvelope : serialized as `Data`
+    
+    
+    class p2pModule {
+        -handlePocketEnvelope([]byte) error
+    }
+
+    class P2PModule {
+        <<interface>>
+        GetAddress() (Address, error)
+        HandleEvent(*anypb.Any) error
+        Send([]byte, address Address) error
+        Broadcast([]byte) error
+    }
+    p2pModule --|> P2PModule
+
+    class RainTreeRouter {
+        UnicastRouter
+        -handler MessageHandler
+        +Broadcast([]byte) error
+        -handleRainTreeMsg([]byte) error
+    }
+
+    class NonceDeduper {
+        Push(Nonce) error
+        Contains(Nonce) bool
+    }
+
+  class Bus {
+    <<interface>>
+    PublishEventToBus(PocketEnvelope)
+    GetBusEvent() PocketEnvelope
+  }
+  p2pModule --> Bus
+
+    class BackgroundRouter {
+        UnicastRouter
+        -handler MessageHandler
+        +Broadcast([]byte) error
+        -handleBackgroundMsg([]byte) error
+        -readSubscription(subscription *pubsub.Subscription)
+    }
+
+    class UnicastRouter {
+        -messageHandler MessageHandler
+        -peerHandler PeerHandler
+        +Send([]byte, address Address) error
+        -handleStream(stream libp2pNetwork.Stream)
+        -readStream(stream libp2pNetwork.Stream)
+    }
+    RainTreeRouter --* UnicastRouter : (embedded)
+    BackgroundRouter --* UnicastRouter : (embedded)
+
+    p2pModule ..* RainTreeRouter
+    RainTreeRouter --o RainTreeMessage
+    
+    p2pModule ..* BackgroundRouter
+    BackgroundRouter --o BackgroundMessage
+
+    p2pModule --o PocketEnvelope
+    p2pModule --* NonceDeduper
+```
 
-hs --4a--> rRT
-hs --4b--> rBG
-rBG  --""5a (cont. propagation)""--> rHost
-linkStyle 11 stroke:#ff3
-rRT  --""5b (cont. propagation)""--> rHost
-linkStyle 12 stroke:#ff3
-end
+### Peer Discovery
+Peer discovery involves pairing peer IDs to their network addresses (multiaddr).
+This pairing always has an associated TTL (time-to-live), near the end of which it must
+be refreshed.
+
+In the background gossip overlay network (`backgroundRouter`), peers will re-advertise themselves 7/8th through their TTL.
+This refreshes the libp2p peerstore automatically.
+
+In the raintree gossip overlay network (`raintreeRouter`), the libp2p peerstore is **NOT** currently refreshed _(TODO: [#859](https://github.com/pokt-network/network/isues/859))_.
+
+```mermaid
+flowchart TD
+  subgraph bus
+  end
+  
+  subgraph pers[Persistence Module]
+  end
+
+  subgraph cons[Consensus Module]
+  end
 
-lHost --2--> rHost
+  cons -- ""(staked actor set changed)\npublish event"" --> bus
+  bus --> rPM
+  rPM -- ""get staked actors\nat current height"" --> pers
+
+  subgraph p2p[""P2P Module""]
+    host[Libp2p Host]
+    host -- ""incoming\nraintree message"" --> rtu
+    host -- ""incoming\nbackground message"" --> bgu
+    host -- ""incoming\ntopic message"" --> bgr
+    host -- ""DHT peer discovery"" --> rDHT
+  
+    subgraph rt[RainTree Router]
+      subgraph rPS[Raintree Peerstore]
+        rStakedPS([staked actors only])
+      end
+
+      subgraph rPM[PeerManager]
+      end
+
+      rtu[UnicastRouter]
+      
+      rPM -- ""synchronize\n(add/remove)"" --> rPS
+      rtu -. ""(no discovery)"" .-x rPS
+    end
+
+    subgraph bg[Background Router]
+      subgraph rBGPS[Background Peerstore]
+        rNetPS([all P2P participants])
+      end
+
+      subgraph bgr[GossipSub Topic\nSubscription]
+      end
+
+      subgraph rDHT[Kademlia DHT]
+      end
+
+      bgu -- ""add if new"" --> rBGPS
+      bgr -- ""add if new"" --> rBGPS
+      rDHT -- ""continuous import"" --> rBGPS
+         
+      bgu[UnicastRouter]
+    end
+
+  end
 ```
 
-The `Network Module` is where [RainTree](https://github.com/pokt-network/pocket/files/9853354/raintree.pdf) (or the simpler basic approach) is implemented. See `raintree/network.go` for the specific implementation of RainTree, but please refer to the [specifications](https://github.com/pokt-network/pocket-network-protocol/tree/main/p2p) for more details.
+### Raintree Router Architecture
+
+_DISCUSS(team): If you feel this needs a diagram, please reach out to the team for additional details._",p2p/README.md,2023-07-03 22:30:55+00:00,2023-07-03T23:30:12Z,"```suggestion
_NOTE: If you (the reader) feel this needs a diagram, please reach out to the team for additional details._
```",,,,,492,RIGHT,529,,line,https://api.github.com/repos/pokt-network/pocket/pulls/732,pokt-network/pocket,6b875eee002f49c4b1abe5ac9faa61f59daaa4cf
https://api.github.com/repos/pokt-network/pocket/pulls/732,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1251317698,Olshansk,4602283cbd676952b2a5c20f73758305cc833ce5,6fde86f231f3a1866c34e668ac226f4a6adb05d6,"@@ -67,105 +66,431 @@ flowchart TD
     class PN pocket_network
 ```
 
-`Routers` is where [RainTree](https://github.com/pokt-network/pocket/files/9853354/raintree.pdf) (or the simpler basic approach) is implemented. See `raintree/router.go` for the specific implementation of RainTree, but please refer to the [specifications](https://github.com/pokt-network/pocket-network-protocol/tree/main/p2p) for more details.
+`Routers` is where [RainTree](https://github.com/pokt-network/pocket/files/9853354/raintree.pdf) is implemented.
+See [`raintree/router.go`](./raintree/router.go) for the specific implementation of RainTree, but please refer to the [specifications](https://github.com/pokt-network/pocket-network-protocol/tree/main/p2p) for more details.
 
-### Raintree Router Architecture
+## Module Architecture
 
-_DISCUSS(team): If you feel this needs a diagram, please reach out to the team for additional details._
-_TODO(olshansky, BenVan): Link to RainTree visualizations once it is complete._
+### Legends
+```mermaid
+flowchart
+subgraph Legend
+    m[[`Method`]]
+    c[Component]
+
+    m -- ""unconditional usage"" --> c
+    m -. ""conditional usage"" .-> c
+    m -. ""ignored"" .-x c
+end
+```
+
+```mermaid
+classDiagram
+class ConcreteType {
+  +ExportedField
+  -unexportedField
+  +ExportedMethod(argType) returnType
+  -unexportedMethod()
+}
+
+class InterfaceType {
+    <<interface>>
+    +Method(argType) (returnType1, returnType2)
+}
+
+ConcreteType --|> InterfaceType : Interface realization
+
+ConcreteType --> OtherType : Direct usage
+ConcreteType --o OtherType : Composition
+ConcreteType --* OtherType : Aggregatation
+ConcreteType ..*  ""(cardinality)"" OtherType : Indirect (via interface)
+```
+
+### P2P Module / Router Decoupling
 
-### Message Propagation
+The P2P module encapsulates the `RaiTreeRouter` and `BackgroundRouter` submodules.
+The P2P module internally refers to these as the `stakedActorRouter` and `unstakedActorRouter`, respectively.
 
-Given `Local P2P Module` has a message that it needs to propagate:
+Depending on the necessary routing scheme (unicast / broadcast) and whether the peers involved are staked actors, a node will use one or both of these routers.
 
-<ul style=""list-style-type: none;"">
-    <li>1a. <code>Raintree Router</code> selects targets from the <code>Pokt Peerstore</code>, <strong>which only includes staked actors</strong></li>
-    <li>1b. <code>Background Router</code> selects targets from the libp2p <code>Peerstore</code>, <strong>which includes all P2P participants</strong></li>
-    <li>2. Libp2p <code>Host</code> manages opening and closing streams to targeted peers</li>
-    <li>3. <code>Remote P2P module</code>'s (i.e. receiver's) <code>handleStream</code> is called (having been registered via <code>setStreamHandler()</code>)</li>
-    <li>4a. <code>handleStream</code> propagates message via <code>Raintree Router</code></li>
-    <li>4b. <code>handleStream</code> propagates message via <code>Background Router</code></li>
-    <li>5a. Repeat step 1a from <code>Remote P2P Module</code>'s perspective targeting its next peers</li>
-    <li>5b. Repeat step 1b from <code>Remote P2P Module</code>'s perspective targeting its next peers</li>
-</ul>
+**Unicast**
+
+| Sender         | Receiver       | Router          | Example Usage                                        |
+|----------------|----------------|-----------------|------------------------------------------------------|
+| Staked Actor   | Staked Actor   | Raintree only   | Consensus (state sync) messages (to validators only) |
+| Unstaked Actor | Staked Actor   | Background only | Consensus (state sync) messages (to validators only) |
+| Unstaked Actor | Unstaked Actor | Background only | Consensus (state sync) & Debug (CLI) messages        |
+
+**Broadcast**
+
+| Broadcaster    | Receiver       | Router                | Example Usage                              |
+|----------------|----------------|-----------------------|--------------------------------------------|
+| Staked Actor   | Staked Actor   | Raintree + Background | Utility tx messages                        |
+| Unstaked Actor | Staked Actor   | Background only       | Utility tx messages (gossipsub redundancy) |
+| Unstaked Actor | Unstaked Actor | Background only       | Utility tx messages                        |
+
+Both router submodule implementations embed a `UnicastRouter` which enables them to send and receive messages directly to/from a single peer.
+
+**Class Diagram**
 
 ```mermaid
-flowchart TD
-  subgraph lMod[Local P2P Module]
-    subgraph lHost[Libp2p `Host`]
+classDiagram
+    class p2pModule {
+        -stakedActorRouter Router
+        -unstakedActorRouter Router
+        -handlePocketEnvelope([]byte) error
+    }
+
+    class P2PModule {
+        <<interface>>
+        GetAddress() (Address, error)
+        HandleEvent(*anypb.Any) error
+        Send([]byte, Address) error
+        Broadcast([]byte) error
+    }
+    p2pModule --|> P2PModule
+
+    class RainTreeRouter {
+        UnicastRouter
+        -handler MessageHandler
+        +Broadcast([]byte) error
+        -handleRainTreeMsg([]byte) error
+    }
+
+    class BackgroundRouter {
+        UnicastRouter
+        -handler MessageHandler
+        +Broadcast([]byte) error
+        -handleBackgroundMsg([]byte) error
+        -readSubscription(subscription *pubsub.Subscription)
+    }
+
+    class UnicastRouter {
+        -messageHandler MessageHandler
+        -peerHandler PeerHandler
+        +Send([]byte, Address) error
+        -handleStream(libp2pNetwork.Stream)
+        -readStream(libp2pNetwork.Stream)
+    }
+    RainTreeRouter --* UnicastRouter : (embedded)
+    BackgroundRouter --* UnicastRouter : (embedded)
+
+    p2pModule --o ""2"" Router
+    p2pModule ..* RainTreeRouter : (`stakedActorRouter`)
+    p2pModule ..* BackgroundRouter : (`unstakedActorRouter`)
+    
+    class Router {
+        <<interface>>
+        +Send([]byte, Address) error
+        +Broadcast([]byte) error
+    }
+    BackgroundRouter --|> Router
+    RainTreeRouter --|> Router
+```
+
+### Message Propagation & Handling
+
+**Unicast**
+
+```mermaid
+flowchart
+    subgraph lp2p[""Local P2P Module (outgoing)""]
+        lps[[`Send`]]
+        lps -. ""(iff local & remote peer are staked)"" ..-> lrtu
+        lps -. ""(if local or remote peer are not staked)"" .-> lbgu
+
+        lbgu -- ""opens stream\nto target peer"" ---> lhost
+
+        lhost[Libp2p Host]
+
+        subgraph lrt[RainTree Router]
+            subgraph lRTPS[Raintree Peerstore]
+              lStakedPS([staked actors only])
+            end
+            
+            lrtu[UnicastRouter]
+
+            lrtu -- ""network address lookup"" --> lRTPS
+        end
+
+        lrtu -- ""opens a stream\nto target peer"" ---> lhost
+
+        subgraph lbg[Background Router]
+            lbgu[UnicastRouter]
+            subgraph lBGPS[Background Peerstore]
+              lNetPS([all P2P participants])
+            end
+
+            lbgu -- ""network address lookup"" --> lBGPS
+        end
+    end
+
+    subgraph rp2p[""Remote P2P Module (incoming)""]
+        rhost[Libp2p Host]
+
+        subgraph rrt[RainTree Router]
+            rrth[[`RainTreeMessage` Handler]]
+            rrtu[UnicastRouter]
+        end
+
+        subgraph rbg[Background Router]
+            rbgh[[`BackgroundMessage` Handler]]
+            rbgu[UnicastRouter]
+            rbgu --> rbgh
+        end
+
+        rp2ph[[`PocketEnvelope` Handler]]
+        rbus[bus]
+        rhost -. ""new stream"" .-> rrtu
+        rhost -- ""new subscription message"" --> rbgu
+        rrtu --> rrth
+
+        rnd[Nonce Deduper]
+        rp2ph -- ""deduplicate msg mempool"" --> rnd
     end
-    subgraph lRT[Raintree Router]
+
+
+    rp2ph -. ""(iff not duplicate msg)\npublish event"" .-> rbus
+
+    rrth --> rp2ph
+    rbgh --> rp2ph
+
+    lhost --> rhost
+```
+
+**Broadcast**
+
+```mermaid
+flowchart
+  subgraph lp2p[""Local P2P Module (outgoing)""]
+    lpb[[`Broadcast`]]
+    lpb -. ""(iff local & remote peer are staked)"" ..-> lrtu
+    lpb -- ""(always)"" --> lbggt
+    
+    lbggt -- ""msg published\n(gossipsub protocol)"" ---> lhost
+    
+    lhost[Libp2p Host]
+
+    subgraph lrt[RainTree Router]
       subgraph lRTPS[Raintree Peerstore]
         lStakedPS([staked actors only])
       end
-
-      subgraph lPM[PeerManager]
-      end
-      lPM --> lRTPS
+      
+      lrtu[UnicastRouter]
+      
+      lrtu -- ""network address lookup"" --> lRTPS
     end
+    
+    lrtu -- ""opens a stream\nto target peer"" ---> lhost
 
-    subgraph lBG[Background Router]
+    subgraph lbg[Background Router]
+      lbggt[Gossipsub Topic]
       subgraph lBGPS[Background Peerstore]
         lNetPS([all P2P participants])
       end
+      
+      lbggt -- ""network address lookup"" --> lBGPS
+    end
+  end
 
-      subgraph lGossipSub[GossipSub]
-      end
+  subgraph rp2p[""Remote P2P Module (incoming)""]
+    rhost[Libp2p Host]
 
-      subgraph lDHT[Kademlia DHT]
-      end
+    subgraph rrt[RainTree Router]
+      rrth[[`RainTreeMessage` Handler]]
+      rrtu[UnicastRouter]
+    end
 
-      lGossipSub --> lBGPS
-      lDHT --> lBGPS
+    subgraph rbg[Background Router]
+      rbgh[[`BackgroundMessage` Handler]]
+      rbgg[Gossipsub Subscription]
+      rbggt[Gossipsub Topic]
+      rbgg --> rbgh
+      rbgh -- ""(background msg\npropagation cont.)"" ---> rbggt
     end
 
-    lRT --1a--> lHost
-    lBG --1b--> lHost
+    rp2ph[[`PocketEnvelope` Handler]]
+    rbus[bus]
+    rhost -. ""new stream"" ..-> rrtu
+    rhost -- ""new subscription message"" --> rbgg
+    rbggt -- ""(background msg\npropagation cont.)"" --> rhost
+    rrtu --> rrth
+    rrth -. ""(iff level > 0)\n(raintree msg\npropagation cont.)"" .-> rrtu
+    rrtu -- ""(raintree msg\npropagation cont.)"" --> rhost
+
+    rnd[Nonce Deduper]
+    rp2ph -- ""deduplicate msg mempool"" --> rnd
   end
 
-subgraph rMod[Remote P2P Module]
-subgraph rHost[Libp2p `Host`]
-end
-subgraph rRT[Raintree Router]
-subgraph rPS[Raintree Peerstore]
-rStakedPS([staked actors only])
-end
 
-subgraph rPM[PeerManager]
-end
+  rp2ph -. ""(iff not duplicate msg)\npublish event"" .-> rbus
 
-rPM --> rStakedPS
-end
+  rrth --> rp2ph
+  rbgh --> rp2ph
 
-subgraph rBG[Background Router]
-subgraph rBGPS[Background Peerstore]
-rNetPS([all P2P participants])
-end
+  lhost --> rhost
+```
 
-subgraph rGossipSub[GossipSub]
-end
+### Message Deduplication
 
-subgraph rDHT[Kademlia DHT]
-end
+Messages MUST be deduplicated before broadcasting their respective event over the bus since it is expected that nodes will receive duplicate messages (for multiple reasons).
 
-rGossipSub --> rBGPS
-rDHT --> rBGPS
-end
+The responsibility of deduplication is encapsulated by the P2P module, As such duplicate messages may come from multiple routers in some of these scenarios.
 
-rHost -. ""3 (setStreamHandler())"" .-> hs[[handleStream]]
+```mermaid
+classDiagram
+    class RainTreeMessage {
+        <<protobuf>>
+        +Level uint32
+        +Data []byte
+    }
+
+    class BackgroundMessage {
+        <<protobuf>>
+        +Data []byte
+    }
+    
+    class PocketEnvelope {
+        <<protobuf>>
+        +Content *anypb.Any
+        +Nonce uint64
+    }
+
+    RainTreeMessage --* PocketEnvelope : serialized as `Data`
+    BackgroundMessage --* PocketEnvelope : serialized as `Data`
+    
+    
+    class p2pModule {
+        -handlePocketEnvelope([]byte) error
+    }
+
+    class P2PModule {
+        <<interface>>
+        GetAddress() (Address, error)
+        HandleEvent(*anypb.Any) error
+        Send([]byte, address Address) error
+        Broadcast([]byte) error
+    }
+    p2pModule --|> P2PModule
+
+    class RainTreeRouter {
+        UnicastRouter
+        -handler MessageHandler
+        +Broadcast([]byte) error
+        -handleRainTreeMsg([]byte) error
+    }
+
+    class NonceDeduper {
+        Push(Nonce) error
+        Contains(Nonce) bool
+    }
+
+  class Bus {
+    <<interface>>
+    PublishEventToBus(PocketEnvelope)
+    GetBusEvent() PocketEnvelope
+  }
+  p2pModule --> Bus
+
+    class BackgroundRouter {
+        UnicastRouter
+        -handler MessageHandler
+        +Broadcast([]byte) error
+        -handleBackgroundMsg([]byte) error
+        -readSubscription(subscription *pubsub.Subscription)
+    }
+
+    class UnicastRouter {
+        -messageHandler MessageHandler
+        -peerHandler PeerHandler
+        +Send([]byte, address Address) error
+        -handleStream(stream libp2pNetwork.Stream)
+        -readStream(stream libp2pNetwork.Stream)
+    }
+    RainTreeRouter --* UnicastRouter : (embedded)
+    BackgroundRouter --* UnicastRouter : (embedded)
+
+    p2pModule ..* RainTreeRouter
+    RainTreeRouter --o RainTreeMessage
+    
+    p2pModule ..* BackgroundRouter
+    BackgroundRouter --o BackgroundMessage
+
+    p2pModule --o PocketEnvelope
+    p2pModule --* NonceDeduper
+```
 
-hs --4a--> rRT
-hs --4b--> rBG
-rBG  --""5a (cont. propagation)""--> rHost
-linkStyle 11 stroke:#ff3
-rRT  --""5b (cont. propagation)""--> rHost
-linkStyle 12 stroke:#ff3
-end
+### Peer Discovery
+Peer discovery involves pairing peer IDs to their network addresses (multiaddr).
+This pairing always has an associated TTL (time-to-live), near the end of which it must
+be refreshed.
+
+In the background gossip overlay network (`backgroundRouter`), peers will re-advertise themselves 7/8th through their TTL.
+This refreshes the libp2p peerstore automatically.
+
+In the raintree gossip overlay network (`raintreeRouter`), the libp2p peerstore is **NOT** currently refreshed _(TODO: [#859](https://github.com/pokt-network/network/isues/859))_.
+
+```mermaid
+flowchart TD
+  subgraph bus
+  end
+  
+  subgraph pers[Persistence Module]
+  end
+
+  subgraph cons[Consensus Module]
+  end
 
-lHost --2--> rHost
+  cons -- ""(staked actor set changed)\npublish event"" --> bus
+  bus --> rPM
+  rPM -- ""get staked actors\nat current height"" --> pers
+
+  subgraph p2p[""P2P Module""]
+    host[Libp2p Host]
+    host -- ""incoming\nraintree message"" --> rtu
+    host -- ""incoming\nbackground message"" --> bgu
+    host -- ""incoming\ntopic message"" --> bgr
+    host -- ""DHT peer discovery"" --> rDHT
+  
+    subgraph rt[RainTree Router]
+      subgraph rPS[Raintree Peerstore]
+        rStakedPS([staked actors only])
+      end
+
+      subgraph rPM[PeerManager]
+      end
+
+      rtu[UnicastRouter]
+      
+      rPM -- ""synchronize\n(add/remove)"" --> rPS
+      rtu -. ""(no discovery)"" .-x rPS
+    end
+
+    subgraph bg[Background Router]
+      subgraph rBGPS[Background Peerstore]
+        rNetPS([all P2P participants])
+      end
+
+      subgraph bgr[GossipSub Topic\nSubscription]
+      end
+
+      subgraph rDHT[Kademlia DHT]
+      end
+
+      bgu -- ""add if new"" --> rBGPS
+      bgr -- ""add if new"" --> rBGPS
+      rDHT -- ""continuous import"" --> rBGPS
+         
+      bgu[UnicastRouter]
+    end
+
+  end
 ```
 
-The `Network Module` is where [RainTree](https://github.com/pokt-network/pocket/files/9853354/raintree.pdf) (or the simpler basic approach) is implemented. See `raintree/network.go` for the specific implementation of RainTree, but please refer to the [specifications](https://github.com/pokt-network/pocket-network-protocol/tree/main/p2p) for more details.
+### Raintree Router Architecture
+
+_DISCUSS(team): If you feel this needs a diagram, please reach out to the team for additional details._
+_TODO(olshansky, BenVan): Link to RainTree visualizations once it is complete._",p2p/README.md,2023-07-03 22:31:07+00:00,2023-07-03T23:30:12Z,"```suggestion
```",,,,,493,RIGHT,530,,line,https://api.github.com/repos/pokt-network/pocket/pulls/732,pokt-network/pocket,6b875eee002f49c4b1abe5ac9faa61f59daaa4cf
https://api.github.com/repos/pokt-network/pocket/pulls/732,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1251321432,Olshansk,4602283cbd676952b2a5c20f73758305cc833ce5,6fde86f231f3a1866c34e668ac226f4a6adb05d6,"@@ -68,18 +64,35 @@ func (*rainTreeRouter) Create(bus modules.Bus, cfg *config.RainTreeConfig) (type
 		selfAddr:              cfg.Addr,
 		pstoreProvider:        cfg.PeerstoreProvider,
 		currentHeightProvider: cfg.CurrentHeightProvider,
-		logger:                routerLogger,
+		logger:                rainTreeLogger,
 		handler:               cfg.Handler,
 	}
 	rtr.SetBus(bus)
 
+	height := rtr.currentHeightProvider.CurrentHeight()
+	pstore, err := rtr.pstoreProvider.GetStakedPeerstoreAtHeight(height)
+	if err != nil {
+		return nil, fmt.Errorf(""getting staked peerstore at height %d: %w"", height, err)
+	}
+	rainTreeLogger.Info().Fields(map[string]any{",p2p/raintree/router.go,2023-07-03 22:40:16+00:00,2023-07-03T23:30:12Z,Nice log 🙌 ,,,,77.0,77,RIGHT,42,26.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/732,pokt-network/pocket,6b875eee002f49c4b1abe5ac9faa61f59daaa4cf
https://api.github.com/repos/pokt-network/pocket/pulls/732,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1251322992,Olshansk,4602283cbd676952b2a5c20f73758305cc833ce5,6fde86f231f3a1866c34e668ac226f4a6adb05d6,"@@ -107,10 +109,20 @@ func waitForNetworkSimulationCompletion(t *testing.T, wg *sync.WaitGroup) {
 func createP2PModules(t *testing.T, busMocks []*mockModules.MockBus, netMock mocknet.Mocknet) (p2pModules map[string]*p2pModule) {
 	peerIDs := setupMockNetPeers(t, netMock, len(busMocks))
 
+	ctrl := gomock.NewController(t)
+	noopBackgroundRouterMock := mock_types.NewMockRouter(ctrl)
+	noopBackgroundRouterMock.EXPECT().Broadcast(gomock.Any()).Times(1)
+	noopBackgroundRouterMock.EXPECT().Close().Times(len(busMocks))
+
 	p2pModules = make(map[string]*p2pModule, len(busMocks))
 	for i := range busMocks {
 		host := netMock.Host(peerIDs[i])
-		p2pMod, err := Create(busMocks[i], WithHostOption(host))
+		p2pMod, err := Create(
+			busMocks[i],
+			WithHost(host),
+			// mock background router to prevent background message propagation.",p2p/utils_test.go,2023-07-03 22:45:28+00:00,2023-07-03T23:30:12Z,"```suggestion
			// mock background router to prevent & ignore background message propagation.
```",,,,,123,RIGHT,32,,line,https://api.github.com/repos/pokt-network/pocket/pulls/732,pokt-network/pocket,6b875eee002f49c4b1abe5ac9faa61f59daaa4cf
https://api.github.com/repos/pokt-network/pocket/pulls/732,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1251324254,Olshansk,4602283cbd676952b2a5c20f73758305cc833ce5,6fde86f231f3a1866c34e668ac226f4a6adb05d6,"@@ -313,11 +341,32 @@ func prepareEventMetricsAgentMock(t *testing.T, valId string, wg *sync.WaitGroup
 	ctrl := gomock.NewController(t)
 	eventMetricsAgentMock := mockModules.NewMockEventMetricsAgent(ctrl)
 
-	eventMetricsAgentMock.EXPECT().EmitEvent(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).AnyTimes()
-	eventMetricsAgentMock.EXPECT().EmitEvent(gomock.Any(), gomock.Any(), gomock.Eq(telemetry.P2P_RAINTREE_MESSAGE_EVENT_METRIC_SEND_LABEL), gomock.Any()).Do(func(n, e any, l ...any) {
+	// TECHDEBT: The number of times each telemetry event is expected
+	// (below) is dependent on the number of redundant messages all validators see,
+	// which is a function of the network size. Until this function is derived and
+	// implemented, we cannot predict the number of times each event is expected.
+	_ = expectedNumNetworkWrites",p2p/utils_test.go,2023-07-03 22:48:42+00:00,2023-07-03T23:30:12Z,"I realize we are documenting this as a TECHDEBT, but does it not concern you that we went from a deterministic test knowing the exact number of times a message is received to `AnyTimes` in the context of a structured broadcast protocol?",,,,348.0,348,RIGHT,90,90.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/732,pokt-network/pocket,6b875eee002f49c4b1abe5ac9faa61f59daaa4cf
https://api.github.com/repos/pokt-network/pocket/pulls/732,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1251324707,Olshansk,4602283cbd676952b2a5c20f73758305cc833ce5,6fde86f231f3a1866c34e668ac226f4a6adb05d6,"@@ -23,20 +24,26 @@ func (m *p2pModule) HandleEvent(event *anypb.Any) error {
 			return fmt.Errorf(""failed to cast event to ConsensusNewHeightEvent"")
 		}
 
-		oldPeerList := m.router.GetPeerstore().GetPeerList()
+		if isStaked, err := m.isStakedActor(); err != nil {
+			return err
+		} else if !isStaked {
+			return nil",p2p/event_handler.go,2023-07-03 22:50:03+00:00,2023-07-03T23:30:12Z,"```suggestion
			return nil // unstaked actors do not use RainTree and therefore do not need to update this router
```",,,,,30,RIGHT,21,,line,https://api.github.com/repos/pokt-network/pocket/pulls/732,pokt-network/pocket,6b875eee002f49c4b1abe5ac9faa61f59daaa4cf
https://api.github.com/repos/pokt-network/pocket/pulls/732,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1251324982,Olshansk,4602283cbd676952b2a5c20f73758305cc833ce5,6fde86f231f3a1866c34e668ac226f4a6adb05d6,"@@ -143,8 +135,12 @@ func (m *p2pModule) GetModuleName() string {
 }
 
 // Start instantiates and assigns `m.host`, unless one already exists, and
-// `m.router` (which depends on `m.host` as a required config field).
+// `m.stakedActorRouter` (which depends on `m.host` as a required config field).
 func (m *p2pModule) Start() (err error) {
+	if !m.started.CompareAndSwap(false, true) {",p2p/module.go,2023-07-03 22:50:59+00:00,2023-07-03T23:30:12Z,TIL about CompareAndSwap,,,,140.0,140,RIGHT,65,65.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/732,pokt-network/pocket,6b875eee002f49c4b1abe5ac9faa61f59daaa4cf
https://api.github.com/repos/pokt-network/pocket/pulls/732,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1251325416,Olshansk,4602283cbd676952b2a5c20f73758305cc833ce5,6fde86f231f3a1866c34e668ac226f4a6adb05d6,"@@ -180,38 +176,102 @@ func (m *p2pModule) Start() (err error) {
 }
 
 func (m *p2pModule) Stop() error {
-	err := m.host.Close()
+	m.logger.Debug().Msg(""stopping P2P module"")
+
+	if !m.started.CompareAndSwap(true, false) {
+		return fmt.Errorf(""p2p module already stopped"")
+	}
+
+	var stakedActorRouterCloseErr error
+	if m.stakedActorRouter != nil {
+		stakedActorRouterCloseErr = m.stakedActorRouter.Close()
+	}
+
+	routerCloseErrs := multierr.Append(
+		m.unstakedActorRouter.Close(),
+		stakedActorRouterCloseErr,
+	)
+
+	err := multierr.Append(
+		routerCloseErrs,
+		m.host.Close(),
+	)
 
 	// Don't reuse closed host, `#Start()` will re-create.
 	m.host = nil
+	m.stakedActorRouter = nil
+	m.unstakedActorRouter = nil
 	return err
 }
 
 func (m *p2pModule) Broadcast(msg *anypb.Any) error {
-	c := &messaging.PocketEnvelope{
+	isStaked, err := m.isStakedActor()
+	if err != nil {
+		return err
+	}
+
+	if isStaked {
+		if m.stakedActorRouter == nil {
+			return fmt.Errorf(""staked actor router not started"")",p2p/module.go,2023-07-03 22:52:16+00:00,2023-07-03T23:30:12Z,"```suggestion
			return fmt.Errorf(""cannot Broadcast messages bcause staked actor router not started"")
```",,,,,215,RIGHT,134,,line,https://api.github.com/repos/pokt-network/pocket/pulls/732,pokt-network/pocket,6b875eee002f49c4b1abe5ac9faa61f59daaa4cf
https://api.github.com/repos/pokt-network/pocket/pulls/732,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1251329963,Olshansk,4602283cbd676952b2a5c20f73758305cc833ce5,6fde86f231f3a1866c34e668ac226f4a6adb05d6,"@@ -9,31 +9,50 @@ import (
 	dht ""github.com/libp2p/go-libp2p-kad-dht""
 	pubsub ""github.com/libp2p/go-libp2p-pubsub""
 	libp2pHost ""github.com/libp2p/go-libp2p/core/host""
+	libp2pPeer ""github.com/libp2p/go-libp2p/core/peer""
+	""go.uber.org/multierr""
+	""google.golang.org/protobuf/proto""
+
 	""github.com/pokt-network/pocket/logger""
 	""github.com/pokt-network/pocket/p2p/config""
 	""github.com/pokt-network/pocket/p2p/protocol""
+	""github.com/pokt-network/pocket/p2p/providers""
 	typesP2P ""github.com/pokt-network/pocket/p2p/types""
+	""github.com/pokt-network/pocket/p2p/unicast""
 	""github.com/pokt-network/pocket/p2p/utils""
 	cryptoPocket ""github.com/pokt-network/pocket/shared/crypto""
+	""github.com/pokt-network/pocket/shared/messaging""
 	""github.com/pokt-network/pocket/shared/modules""
 	""github.com/pokt-network/pocket/shared/modules/base_modules""
 )
 
 var (
 	_ typesP2P.Router            = &backgroundRouter{}
 	_ modules.IntegratableModule = &backgroundRouter{}
+	_ backgroundRouterFactory    = &backgroundRouter{}
 )
 
+type backgroundRouterFactory = modules.FactoryWithConfig[typesP2P.Router, *config.BackgroundConfig]
+
 // backgroundRouter implements `typesP2P.Router` for use with all P2P participants.
 type backgroundRouter struct {
 	base_modules.IntegratableModule
+	unicast.UnicastRouter
 
 	logger *modules.Logger
+	// handler is the function to call when a message is received.
+	handler typesP2P.MessageHandler
 	// host represents a libp2p network node, it encapsulates a libp2p peerstore
 	// & connection manager. `libp2p.New` configures and starts listening
 	// according to options.
 	// (see: https://pkg.go.dev/github.com/libp2p/go-libp2p#section-readme)
 	host libp2pHost.Host
+	// cancelReadSubscription is the cancel function for the context which is
+	// monitored in the `#readSubscription()` go routine. Call to terminate it.
+	cancelReadSubscription context.CancelFunc",p2p/background/router.go,2023-07-03 23:04:33+00:00,2023-07-03T23:30:12Z,"```suggestion
	// only one read subscription exists per router at any point in time
	cancelReadSubscription context.CancelFunc
```",,,,53.0,52,RIGHT,44,45.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/732,pokt-network/pocket,6b875eee002f49c4b1abe5ac9faa61f59daaa4cf
https://api.github.com/repos/pokt-network/pocket/pulls/732,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1251330088,Olshansk,4602283cbd676952b2a5c20f73758305cc833ce5,6fde86f231f3a1866c34e668ac226f4a6adb05d6,"@@ -47,96 +66,106 @@ type backgroundRouter struct {
 	kadDHT *dht.IpfsDHT
 	// TECHDEBT: `pstore` will likely be removed in future refactoring / simplification
 	// of the `Router` interface.
-	// pstore is the background router's peerstore.
+	// pstore is the background router's peerstore. Assigned in `backgroundRouter#setupPeerstore()`.
 	pstore typesP2P.Peerstore
 }
 
-// NewBackgroundRouter returns a `backgroundRouter` as a `typesP2P.Router`
+// Create returns a `backgroundRouter` as a `typesP2P.Router`
 // interface using the given configuration.
-func NewBackgroundRouter(bus modules.Bus, cfg *config.BackgroundConfig) (typesP2P.Router, error) {
-	// TECHDEBT(#595): add ctx to interface methods and propagate down.
-	ctx := context.TODO()
+func Create(bus modules.Bus, cfg *config.BackgroundConfig) (typesP2P.Router, error) {
+	return new(backgroundRouter).Create(bus, cfg)
+}
 
-	networkLogger := logger.Global.CreateLoggerForModule(""backgroundRouter"")
-	networkLogger.Info().Msg(""Initializing background router"")
+func (*backgroundRouter) Create(bus modules.Bus, cfg *config.BackgroundConfig) (typesP2P.Router, error) {
+	bgRouterLogger := logger.Global.CreateLoggerForModule(""backgroundRouter"")
 
-	// seed initial peerstore with current on-chain peer info (i.e. staked actors)
-	pstore, err := cfg.PeerstoreProvider.GetStakedPeerstoreAtHeight(
-		cfg.CurrentHeightProvider.CurrentHeight(),
-	)
-	if err != nil {
+	if err := cfg.IsValid(); err != nil {
 		return nil, err
 	}
 
-	// CONSIDERATION: If switching to `NewRandomSub`, there will be a max size
-	gossipSub, err := pubsub.NewGossipSub(ctx, cfg.Host)
-	if err != nil {
-		return nil, fmt.Errorf(""creating gossip pubsub: %w"", err)
-	}
+	// TECHDEBT(#595): add ctx to interface methods and propagate down.
+	ctx, cancel := context.WithCancel(context.TODO())
 
-	dhtMode := dht.ModeAutoServer
-	// NB: don't act as a bootstrap node in peer discovery in client debug mode
-	if isClientDebugMode(bus) {
-		dhtMode = dht.ModeClient
+	rtr := &backgroundRouter{
+		logger:                 bgRouterLogger,
+		handler:                cfg.Handler,
+		host:                   cfg.Host,
+		cancelReadSubscription: cancel,
 	}
+	rtr.SetBus(bus)
 
-	kadDHT, err := dht.New(ctx, cfg.Host, dht.Mode(dhtMode))
-	if err != nil {
-		return nil, fmt.Errorf(""creating DHT: %w"", err)
-	}
+	bgRouterLogger.Info().Fields(map[string]any{
+		""host_id"":                cfg.Host.ID(),
+		""unicast_protocol_id"":    protocol.BackgroundProtocolID,
+		""broadcast_pubsub_topic"": protocol.BackgroundTopicStr,
+	}).Msg(""initializing background router"")
 
-	topic, err := gossipSub.Join(protocol.BackgroundTopicStr)
-	if err != nil {
-		return nil, fmt.Errorf(""joining background topic: %w"", err)
+	if err := rtr.setupDependencies(ctx, cfg); err != nil {
+		return nil, err
 	}
 
-	// INVESTIGATE: `WithBufferSize` `SubOpt`:
-	// > WithBufferSize is a Subscribe option to customize the size of the subscribe
-	// > output buffer. The default length is 32 but it can be configured to avoid
-	// > dropping messages if the consumer is not reading fast enough.
-	// (see: https://pkg.go.dev/github.com/libp2p/go-libp2p-pubsub#WithBufferSize)
-	subscription, err := topic.Subscribe()
-	if err != nil {
-		return nil, fmt.Errorf(""subscribing to background topic: %w"", err)
-	}
+	go rtr.readSubscription(ctx)
 
-	rtr := &backgroundRouter{
-		host:         cfg.Host,
-		gossipSub:    gossipSub,
-		kadDHT:       kadDHT,
-		topic:        topic,
-		subscription: subscription,
-		logger:       networkLogger,
-		pstore:       pstore,
+	return rtr, nil
+}
+
+func (rtr *backgroundRouter) Close() error {
+	rtr.logger.Debug().Msg(""closing background router"")
+
+	rtr.cancelReadSubscription()
+	rtr.subscription.Cancel()
+
+	var topicCloseErr error
+	if err := rtr.topic.Close(); err != context.Canceled {
+		topicCloseErr = err
 	}
 
-	return rtr, nil
+	return multierr.Append(",p2p/background/router.go,2023-07-03 23:05:04+00:00,2023-07-03T23:30:12Z,Great usage of multierr everywhere!,,,,124.0,123,RIGHT,155,156.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/732,pokt-network/pocket,6b875eee002f49c4b1abe5ac9faa61f59daaa4cf
https://api.github.com/repos/pokt-network/pocket/pulls/732,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1251330399,Olshansk,4602283cbd676952b2a5c20f73758305cc833ce5,6fde86f231f3a1866c34e668ac226f4a6adb05d6,"@@ -166,6 +195,219 @@ func (rtr *backgroundRouter) RemovePeer(peer typesP2P.Peer) error {
 	return rtr.pstore.RemovePeer(peer.GetAddress())
 }
 
+// setupUnicastRouter configures and assigns `rtr.UnicastRouter`.
+func (rtr *backgroundRouter) setupUnicastRouter() error {
+	unicastRouterCfg := config.UnicastRouterConfig{
+		Logger:         rtr.logger,
+		Host:           rtr.host,
+		ProtocolID:     protocol.BackgroundProtocolID,
+		MessageHandler: rtr.handleBackgroundMsg,
+		PeerHandler:    rtr.AddPeer,
+	}
+
+	unicastRouter, err := unicast.Create(rtr.GetBus(), &unicastRouterCfg)
+	if err != nil {
+		return fmt.Errorf(""setting up unicast router: %w"", err)
+	}
+
+	rtr.UnicastRouter = *unicastRouter
+	return nil
+}
+
+func (rtr *backgroundRouter) setupDependencies(ctx context.Context, cfg *config.BackgroundConfig) error {
+	if err := rtr.setupUnicastRouter(); err != nil {
+		return err
+	}
+
+	if err := rtr.setupPeerDiscovery(ctx); err != nil {
+		return fmt.Errorf(""setting up peer discovery: %w"", err)
+	}
+
+	if err := rtr.setupPubsub(ctx); err != nil {
+		return fmt.Errorf(""setting up pubsub: %w"", err)
+	}
+
+	if err := rtr.setupTopic(); err != nil {
+		return fmt.Errorf(""setting up topic: %w"", err)
+	}
+
+	if err := rtr.setupSubscription(); err != nil {
+		return fmt.Errorf(""setting up subscription: %w"", err)
+	}
+
+	if err := rtr.setupPeerstore(
+		ctx,
+		cfg.PeerstoreProvider, cfg.CurrentHeightProvider); err != nil {",p2p/background/router.go,2023-07-03 23:06:09+00:00,2023-07-03T23:30:12Z,"If we're multi-lining args, we gotta do it right

```suggestion
		cfg.PeerstoreProvider,
		 cfg.CurrentHeightProvider,
	 ); err != nil {
```",,,,,240,RIGHT,259,,line,https://api.github.com/repos/pokt-network/pocket/pulls/732,pokt-network/pocket,6b875eee002f49c4b1abe5ac9faa61f59daaa4cf
https://api.github.com/repos/pokt-network/pocket/pulls/732,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1251330951,Olshansk,4602283cbd676952b2a5c20f73758305cc833ce5,6fde86f231f3a1866c34e668ac226f4a6adb05d6,"@@ -166,6 +195,219 @@ func (rtr *backgroundRouter) RemovePeer(peer typesP2P.Peer) error {
 	return rtr.pstore.RemovePeer(peer.GetAddress())
 }
 
+// setupUnicastRouter configures and assigns `rtr.UnicastRouter`.
+func (rtr *backgroundRouter) setupUnicastRouter() error {
+	unicastRouterCfg := config.UnicastRouterConfig{
+		Logger:         rtr.logger,
+		Host:           rtr.host,
+		ProtocolID:     protocol.BackgroundProtocolID,
+		MessageHandler: rtr.handleBackgroundMsg,
+		PeerHandler:    rtr.AddPeer,
+	}
+
+	unicastRouter, err := unicast.Create(rtr.GetBus(), &unicastRouterCfg)
+	if err != nil {
+		return fmt.Errorf(""setting up unicast router: %w"", err)
+	}
+
+	rtr.UnicastRouter = *unicastRouter
+	return nil
+}
+
+func (rtr *backgroundRouter) setupDependencies(ctx context.Context, cfg *config.BackgroundConfig) error {
+	if err := rtr.setupUnicastRouter(); err != nil {
+		return err
+	}
+
+	if err := rtr.setupPeerDiscovery(ctx); err != nil {
+		return fmt.Errorf(""setting up peer discovery: %w"", err)
+	}
+
+	if err := rtr.setupPubsub(ctx); err != nil {
+		return fmt.Errorf(""setting up pubsub: %w"", err)
+	}
+
+	if err := rtr.setupTopic(); err != nil {
+		return fmt.Errorf(""setting up topic: %w"", err)
+	}
+
+	if err := rtr.setupSubscription(); err != nil {
+		return fmt.Errorf(""setting up subscription: %w"", err)
+	}
+
+	if err := rtr.setupPeerstore(
+		ctx,
+		cfg.PeerstoreProvider, cfg.CurrentHeightProvider); err != nil {
+		return fmt.Errorf(""setting up peerstore: %w"", err)
+	}
+	return nil
+}
+
+func (rtr *backgroundRouter) setupPeerstore(
+	ctx context.Context,
+	pstoreProvider providers.PeerstoreProvider,
+	currentHeightProvider providers.CurrentHeightProvider,
+) (err error) {
+	// seed initial peerstore with current on-chain peer info (i.e. staked actors)
+	rtr.pstore, err = pstoreProvider.GetStakedPeerstoreAtHeight(
+		currentHeightProvider.CurrentHeight(),
+	)
+	if err != nil {
+		return err
+	}
+
+	if err := rtr.bootstrap(ctx); err != nil {
+		return fmt.Errorf(""bootstrapping peerstore: %w"", err)
+	}
+
+	return nil
+}
+
+func (rtr *backgroundRouter) setupPeerDiscovery(ctx context.Context) (err error) {",p2p/background/router.go,2023-07-03 23:07:38+00:00,2023-07-03T23:30:12Z,"```suggestion
// setupPeerDiscovery sets up the Kademlia Distributed Hash Table (DHT)
func (rtr *backgroundRouter) setupPeerDiscovery(ctx context.Context) (err error) {
```",,,,271.0,266,RIGHT,285,290.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/732,pokt-network/pocket,6b875eee002f49c4b1abe5ac9faa61f59daaa4cf
https://api.github.com/repos/pokt-network/pocket/pulls/732,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1251331098,Olshansk,4602283cbd676952b2a5c20f73758305cc833ce5,6fde86f231f3a1866c34e668ac226f4a6adb05d6,"@@ -166,6 +195,219 @@ func (rtr *backgroundRouter) RemovePeer(peer typesP2P.Peer) error {
 	return rtr.pstore.RemovePeer(peer.GetAddress())
 }
 
+// setupUnicastRouter configures and assigns `rtr.UnicastRouter`.
+func (rtr *backgroundRouter) setupUnicastRouter() error {
+	unicastRouterCfg := config.UnicastRouterConfig{
+		Logger:         rtr.logger,
+		Host:           rtr.host,
+		ProtocolID:     protocol.BackgroundProtocolID,
+		MessageHandler: rtr.handleBackgroundMsg,
+		PeerHandler:    rtr.AddPeer,
+	}
+
+	unicastRouter, err := unicast.Create(rtr.GetBus(), &unicastRouterCfg)
+	if err != nil {
+		return fmt.Errorf(""setting up unicast router: %w"", err)
+	}
+
+	rtr.UnicastRouter = *unicastRouter
+	return nil
+}
+
+func (rtr *backgroundRouter) setupDependencies(ctx context.Context, cfg *config.BackgroundConfig) error {
+	if err := rtr.setupUnicastRouter(); err != nil {
+		return err
+	}
+
+	if err := rtr.setupPeerDiscovery(ctx); err != nil {
+		return fmt.Errorf(""setting up peer discovery: %w"", err)
+	}
+
+	if err := rtr.setupPubsub(ctx); err != nil {
+		return fmt.Errorf(""setting up pubsub: %w"", err)
+	}
+
+	if err := rtr.setupTopic(); err != nil {
+		return fmt.Errorf(""setting up topic: %w"", err)
+	}
+
+	if err := rtr.setupSubscription(); err != nil {
+		return fmt.Errorf(""setting up subscription: %w"", err)
+	}
+
+	if err := rtr.setupPeerstore(
+		ctx,
+		cfg.PeerstoreProvider, cfg.CurrentHeightProvider); err != nil {
+		return fmt.Errorf(""setting up peerstore: %w"", err)
+	}
+	return nil
+}
+
+func (rtr *backgroundRouter) setupPeerstore(
+	ctx context.Context,
+	pstoreProvider providers.PeerstoreProvider,
+	currentHeightProvider providers.CurrentHeightProvider,
+) (err error) {
+	// seed initial peerstore with current on-chain peer info (i.e. staked actors)
+	rtr.pstore, err = pstoreProvider.GetStakedPeerstoreAtHeight(
+		currentHeightProvider.CurrentHeight(),
+	)
+	if err != nil {
+		return err
+	}
+
+	if err := rtr.bootstrap(ctx); err != nil {
+		return fmt.Errorf(""bootstrapping peerstore: %w"", err)
+	}
+
+	return nil
+}
+
+func (rtr *backgroundRouter) setupPeerDiscovery(ctx context.Context) (err error) {
+	dhtMode := dht.ModeAutoServer
+	// NB: don't act as a bootstrap node in peer discovery in client debug mode
+	if isClientDebugMode(rtr.GetBus()) {
+		dhtMode = dht.ModeClient
+	}
+
+	rtr.kadDHT, err = dht.New(ctx, rtr.host, dht.Mode(dhtMode))
+	return err
+}
+
+func (rtr *backgroundRouter) setupPubsub(ctx context.Context) (err error) {",p2p/background/router.go,2023-07-03 23:08:07+00:00,2023-07-03T23:30:12Z,"```suggestion
// setupPubsub sets up a new gossip sub topic using libp2p
func (rtr *backgroundRouter) setupPubsub(ctx context.Context) (err error) {
```",,,,283.0,277,RIGHT,296,302.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/732,pokt-network/pocket,6b875eee002f49c4b1abe5ac9faa61f59daaa4cf
https://api.github.com/repos/pokt-network/pocket/pulls/732,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1251331451,Olshansk,4602283cbd676952b2a5c20f73758305cc833ce5,6fde86f231f3a1866c34e668ac226f4a6adb05d6,"@@ -166,6 +195,219 @@ func (rtr *backgroundRouter) RemovePeer(peer typesP2P.Peer) error {
 	return rtr.pstore.RemovePeer(peer.GetAddress())
 }
 
+// setupUnicastRouter configures and assigns `rtr.UnicastRouter`.
+func (rtr *backgroundRouter) setupUnicastRouter() error {
+	unicastRouterCfg := config.UnicastRouterConfig{
+		Logger:         rtr.logger,
+		Host:           rtr.host,
+		ProtocolID:     protocol.BackgroundProtocolID,
+		MessageHandler: rtr.handleBackgroundMsg,
+		PeerHandler:    rtr.AddPeer,
+	}
+
+	unicastRouter, err := unicast.Create(rtr.GetBus(), &unicastRouterCfg)
+	if err != nil {
+		return fmt.Errorf(""setting up unicast router: %w"", err)
+	}
+
+	rtr.UnicastRouter = *unicastRouter
+	return nil
+}
+
+func (rtr *backgroundRouter) setupDependencies(ctx context.Context, cfg *config.BackgroundConfig) error {",p2p/background/router.go,2023-07-03 23:09:18+00:00,2023-07-03T23:30:12Z,"```suggestion
func (rtr *backgroundRouter) setupDependencies(ctx context.Context, cfg *config.BackgroundConfig) error {
	// NB: The order in which the internal components are setup below is important
```",,,,218.0,217,RIGHT,236,237.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/732,pokt-network/pocket,6b875eee002f49c4b1abe5ac9faa61f59daaa4cf
https://api.github.com/repos/pokt-network/pocket/pulls/732,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1251332730,Olshansk,4602283cbd676952b2a5c20f73758305cc833ce5,6fde86f231f3a1866c34e668ac226f4a6adb05d6,"@@ -166,6 +195,219 @@ func (rtr *backgroundRouter) RemovePeer(peer typesP2P.Peer) error {
 	return rtr.pstore.RemovePeer(peer.GetAddress())
 }
 
+// setupUnicastRouter configures and assigns `rtr.UnicastRouter`.
+func (rtr *backgroundRouter) setupUnicastRouter() error {
+	unicastRouterCfg := config.UnicastRouterConfig{
+		Logger:         rtr.logger,
+		Host:           rtr.host,
+		ProtocolID:     protocol.BackgroundProtocolID,
+		MessageHandler: rtr.handleBackgroundMsg,
+		PeerHandler:    rtr.AddPeer,
+	}
+
+	unicastRouter, err := unicast.Create(rtr.GetBus(), &unicastRouterCfg)
+	if err != nil {
+		return fmt.Errorf(""setting up unicast router: %w"", err)
+	}
+
+	rtr.UnicastRouter = *unicastRouter
+	return nil
+}
+
+func (rtr *backgroundRouter) setupDependencies(ctx context.Context, cfg *config.BackgroundConfig) error {
+	if err := rtr.setupUnicastRouter(); err != nil {
+		return err
+	}
+
+	if err := rtr.setupPeerDiscovery(ctx); err != nil {
+		return fmt.Errorf(""setting up peer discovery: %w"", err)
+	}
+
+	if err := rtr.setupPubsub(ctx); err != nil {
+		return fmt.Errorf(""setting up pubsub: %w"", err)
+	}
+
+	if err := rtr.setupTopic(); err != nil {
+		return fmt.Errorf(""setting up topic: %w"", err)
+	}
+
+	if err := rtr.setupSubscription(); err != nil {
+		return fmt.Errorf(""setting up subscription: %w"", err)
+	}
+
+	if err := rtr.setupPeerstore(
+		ctx,
+		cfg.PeerstoreProvider, cfg.CurrentHeightProvider); err != nil {
+		return fmt.Errorf(""setting up peerstore: %w"", err)
+	}
+	return nil
+}
+
+func (rtr *backgroundRouter) setupPeerstore(
+	ctx context.Context,
+	pstoreProvider providers.PeerstoreProvider,
+	currentHeightProvider providers.CurrentHeightProvider,
+) (err error) {
+	// seed initial peerstore with current on-chain peer info (i.e. staked actors)
+	rtr.pstore, err = pstoreProvider.GetStakedPeerstoreAtHeight(
+		currentHeightProvider.CurrentHeight(),
+	)
+	if err != nil {
+		return err
+	}
+
+	if err := rtr.bootstrap(ctx); err != nil {
+		return fmt.Errorf(""bootstrapping peerstore: %w"", err)
+	}
+
+	return nil
+}
+
+func (rtr *backgroundRouter) setupPeerDiscovery(ctx context.Context) (err error) {
+	dhtMode := dht.ModeAutoServer
+	// NB: don't act as a bootstrap node in peer discovery in client debug mode
+	if isClientDebugMode(rtr.GetBus()) {
+		dhtMode = dht.ModeClient
+	}
+
+	rtr.kadDHT, err = dht.New(ctx, rtr.host, dht.Mode(dhtMode))
+	return err
+}
+
+func (rtr *backgroundRouter) setupPubsub(ctx context.Context) (err error) {
+	// TECHDEBT(#730): integrate libp2p tracing via `pubsub.WithEventTracer()`.
+
+	// CONSIDERATION: If switching to `NewRandomSub`, there will be a max size
+	rtr.gossipSub, err = pubsub.NewGossipSub(ctx, rtr.host)
+	return err
+}
+
+func (rtr *backgroundRouter) setupTopic() (err error) {",p2p/background/router.go,2023-07-03 23:14:17+00:00,2023-07-03T23:30:12Z,Why are we using named `err` return values in this file?,,,,291.0,285,RIGHT,304,310.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/732,pokt-network/pocket,6b875eee002f49c4b1abe5ac9faa61f59daaa4cf
https://api.github.com/repos/pokt-network/pocket/pulls/732,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1251334036,Olshansk,4602283cbd676952b2a5c20f73758305cc833ce5,6fde86f231f3a1866c34e668ac226f4a6adb05d6,"@@ -166,6 +195,219 @@ func (rtr *backgroundRouter) RemovePeer(peer typesP2P.Peer) error {
 	return rtr.pstore.RemovePeer(peer.GetAddress())
 }
 
+// setupUnicastRouter configures and assigns `rtr.UnicastRouter`.
+func (rtr *backgroundRouter) setupUnicastRouter() error {
+	unicastRouterCfg := config.UnicastRouterConfig{
+		Logger:         rtr.logger,
+		Host:           rtr.host,
+		ProtocolID:     protocol.BackgroundProtocolID,
+		MessageHandler: rtr.handleBackgroundMsg,
+		PeerHandler:    rtr.AddPeer,
+	}
+
+	unicastRouter, err := unicast.Create(rtr.GetBus(), &unicastRouterCfg)
+	if err != nil {
+		return fmt.Errorf(""setting up unicast router: %w"", err)
+	}
+
+	rtr.UnicastRouter = *unicastRouter
+	return nil
+}
+
+func (rtr *backgroundRouter) setupDependencies(ctx context.Context, cfg *config.BackgroundConfig) error {
+	if err := rtr.setupUnicastRouter(); err != nil {
+		return err
+	}
+
+	if err := rtr.setupPeerDiscovery(ctx); err != nil {
+		return fmt.Errorf(""setting up peer discovery: %w"", err)
+	}
+
+	if err := rtr.setupPubsub(ctx); err != nil {
+		return fmt.Errorf(""setting up pubsub: %w"", err)
+	}
+
+	if err := rtr.setupTopic(); err != nil {
+		return fmt.Errorf(""setting up topic: %w"", err)
+	}
+
+	if err := rtr.setupSubscription(); err != nil {
+		return fmt.Errorf(""setting up subscription: %w"", err)
+	}
+
+	if err := rtr.setupPeerstore(
+		ctx,
+		cfg.PeerstoreProvider, cfg.CurrentHeightProvider); err != nil {
+		return fmt.Errorf(""setting up peerstore: %w"", err)
+	}
+	return nil
+}
+
+func (rtr *backgroundRouter) setupPeerstore(
+	ctx context.Context,
+	pstoreProvider providers.PeerstoreProvider,
+	currentHeightProvider providers.CurrentHeightProvider,
+) (err error) {
+	// seed initial peerstore with current on-chain peer info (i.e. staked actors)
+	rtr.pstore, err = pstoreProvider.GetStakedPeerstoreAtHeight(
+		currentHeightProvider.CurrentHeight(),
+	)
+	if err != nil {
+		return err
+	}
+
+	if err := rtr.bootstrap(ctx); err != nil {
+		return fmt.Errorf(""bootstrapping peerstore: %w"", err)
+	}
+
+	return nil
+}
+
+func (rtr *backgroundRouter) setupPeerDiscovery(ctx context.Context) (err error) {
+	dhtMode := dht.ModeAutoServer
+	// NB: don't act as a bootstrap node in peer discovery in client debug mode
+	if isClientDebugMode(rtr.GetBus()) {
+		dhtMode = dht.ModeClient
+	}
+
+	rtr.kadDHT, err = dht.New(ctx, rtr.host, dht.Mode(dhtMode))
+	return err
+}
+
+func (rtr *backgroundRouter) setupPubsub(ctx context.Context) (err error) {
+	// TECHDEBT(#730): integrate libp2p tracing via `pubsub.WithEventTracer()`.
+
+	// CONSIDERATION: If switching to `NewRandomSub`, there will be a max size
+	rtr.gossipSub, err = pubsub.NewGossipSub(ctx, rtr.host)
+	return err
+}
+
+func (rtr *backgroundRouter) setupTopic() (err error) {
+	if err := rtr.gossipSub.RegisterTopicValidator(
+		protocol.BackgroundTopicStr,
+		rtr.topicValidator,
+	); err != nil {
+		return fmt.Errorf(
+			""registering topic validator for topic: %q: %w"",
+			protocol.BackgroundTopicStr, err,
+		)
+	}
+
+	if rtr.topic, err = rtr.gossipSub.Join(protocol.BackgroundTopicStr); err != nil {
+		return fmt.Errorf(
+			""joining background topic: %q: %w"",
+			protocol.BackgroundTopicStr, err,
+		)
+	}
+	return nil
+}
+
+func (rtr *backgroundRouter) setupSubscription() (err error) {
+	// INVESTIGATE: `WithBufferSize` `SubOpt`:
+	// > WithBufferSize is a Subscribe option to customize the size of the subscribe
+	// > output buffer. The default length is 32 but it can be configured to avoid
+	// > dropping messages if the consumer is not reading fast enough.
+	// (see: https://pkg.go.dev/github.com/libp2p/go-libp2p-pubsub#WithBufferSize)
+	rtr.subscription, err = rtr.topic.Subscribe()
+	return err
+}
+
+func (rtr *backgroundRouter) bootstrap(ctx context.Context) error {
+	// CONSIDERATION: add `GetPeers` method to `PeerstoreProvider` interface
+	// to avoid this loop.
+	for _, peer := range rtr.pstore.GetPeerList() {
+		if err := utils.AddPeerToLibp2pHost(rtr.host, peer); err != nil {
+			return err
+		}
+
+		libp2pAddrInfo, err := utils.Libp2pAddrInfoFromPeer(peer)
+		if err != nil {
+			return fmt.Errorf(
+				""converting peer info, pokt address: %s: %w"",
+				peer.GetAddress(),
+				err,
+			)
+		}
+
+		// don't attempt to connect to self
+		if rtr.host.ID() == libp2pAddrInfo.ID {
+			return nil
+		}
+
+		if err := rtr.host.Connect(ctx, libp2pAddrInfo); err != nil {
+			return fmt.Errorf(""connecting to peer: %w"", err)
+		}
+	}
+	return nil
+}
+
+// topicValidator is used in conjunction with libp2p-pubsub's notion of ""topic
+// validaton"". It is used for arbitrary and concurrent pre-propagation validation
+// of messages.
+//
+// (see: https://github.com/libp2p/specs/tree/master/pubsub#topic-validation
+// and https://pkg.go.dev/github.com/libp2p/go-libp2p-pubsub#PubSub.RegisterTopicValidator)
+//
+// Also note: https://pkg.go.dev/github.com/libp2p/go-libp2p-pubsub#BasicSeqnoValidator
+func (rtr *backgroundRouter) topicValidator(_ context.Context, _ libp2pPeer.ID, msg *pubsub.Message) bool {
+	var backgroundMsg typesP2P.BackgroundMessage
+	if err := proto.Unmarshal(msg.Data, &backgroundMsg); err != nil {
+		return false
+	}
+
+	if backgroundMsg.Data == nil {
+		return false",p2p/background/router.go,2023-07-03 23:18:33+00:00,2023-07-03T23:30:12Z,Do we want/need a warning/error in the other `false` cases?,,,,367.0,359,RIGHT,378,386.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/732,pokt-network/pocket,6b875eee002f49c4b1abe5ac9faa61f59daaa4cf
https://api.github.com/repos/pokt-network/pocket/pulls/732,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1251334237,Olshansk,4602283cbd676952b2a5c20f73758305cc833ce5,6fde86f231f3a1866c34e668ac226f4a6adb05d6,"@@ -166,6 +195,219 @@ func (rtr *backgroundRouter) RemovePeer(peer typesP2P.Peer) error {
 	return rtr.pstore.RemovePeer(peer.GetAddress())
 }
 
+// setupUnicastRouter configures and assigns `rtr.UnicastRouter`.
+func (rtr *backgroundRouter) setupUnicastRouter() error {
+	unicastRouterCfg := config.UnicastRouterConfig{
+		Logger:         rtr.logger,
+		Host:           rtr.host,
+		ProtocolID:     protocol.BackgroundProtocolID,
+		MessageHandler: rtr.handleBackgroundMsg,
+		PeerHandler:    rtr.AddPeer,
+	}
+
+	unicastRouter, err := unicast.Create(rtr.GetBus(), &unicastRouterCfg)
+	if err != nil {
+		return fmt.Errorf(""setting up unicast router: %w"", err)
+	}
+
+	rtr.UnicastRouter = *unicastRouter
+	return nil
+}
+
+func (rtr *backgroundRouter) setupDependencies(ctx context.Context, cfg *config.BackgroundConfig) error {
+	if err := rtr.setupUnicastRouter(); err != nil {
+		return err
+	}
+
+	if err := rtr.setupPeerDiscovery(ctx); err != nil {
+		return fmt.Errorf(""setting up peer discovery: %w"", err)
+	}
+
+	if err := rtr.setupPubsub(ctx); err != nil {
+		return fmt.Errorf(""setting up pubsub: %w"", err)
+	}
+
+	if err := rtr.setupTopic(); err != nil {
+		return fmt.Errorf(""setting up topic: %w"", err)
+	}
+
+	if err := rtr.setupSubscription(); err != nil {
+		return fmt.Errorf(""setting up subscription: %w"", err)
+	}
+
+	if err := rtr.setupPeerstore(
+		ctx,
+		cfg.PeerstoreProvider, cfg.CurrentHeightProvider); err != nil {
+		return fmt.Errorf(""setting up peerstore: %w"", err)
+	}
+	return nil
+}
+
+func (rtr *backgroundRouter) setupPeerstore(
+	ctx context.Context,
+	pstoreProvider providers.PeerstoreProvider,
+	currentHeightProvider providers.CurrentHeightProvider,
+) (err error) {
+	// seed initial peerstore with current on-chain peer info (i.e. staked actors)
+	rtr.pstore, err = pstoreProvider.GetStakedPeerstoreAtHeight(
+		currentHeightProvider.CurrentHeight(),
+	)
+	if err != nil {
+		return err
+	}
+
+	if err := rtr.bootstrap(ctx); err != nil {
+		return fmt.Errorf(""bootstrapping peerstore: %w"", err)
+	}
+
+	return nil
+}
+
+func (rtr *backgroundRouter) setupPeerDiscovery(ctx context.Context) (err error) {
+	dhtMode := dht.ModeAutoServer
+	// NB: don't act as a bootstrap node in peer discovery in client debug mode
+	if isClientDebugMode(rtr.GetBus()) {
+		dhtMode = dht.ModeClient
+	}
+
+	rtr.kadDHT, err = dht.New(ctx, rtr.host, dht.Mode(dhtMode))
+	return err
+}
+
+func (rtr *backgroundRouter) setupPubsub(ctx context.Context) (err error) {
+	// TECHDEBT(#730): integrate libp2p tracing via `pubsub.WithEventTracer()`.
+
+	// CONSIDERATION: If switching to `NewRandomSub`, there will be a max size
+	rtr.gossipSub, err = pubsub.NewGossipSub(ctx, rtr.host)
+	return err
+}
+
+func (rtr *backgroundRouter) setupTopic() (err error) {
+	if err := rtr.gossipSub.RegisterTopicValidator(
+		protocol.BackgroundTopicStr,
+		rtr.topicValidator,
+	); err != nil {
+		return fmt.Errorf(
+			""registering topic validator for topic: %q: %w"",
+			protocol.BackgroundTopicStr, err,
+		)
+	}
+
+	if rtr.topic, err = rtr.gossipSub.Join(protocol.BackgroundTopicStr); err != nil {
+		return fmt.Errorf(
+			""joining background topic: %q: %w"",
+			protocol.BackgroundTopicStr, err,
+		)
+	}
+	return nil
+}
+
+func (rtr *backgroundRouter) setupSubscription() (err error) {
+	// INVESTIGATE: `WithBufferSize` `SubOpt`:
+	// > WithBufferSize is a Subscribe option to customize the size of the subscribe
+	// > output buffer. The default length is 32 but it can be configured to avoid
+	// > dropping messages if the consumer is not reading fast enough.
+	// (see: https://pkg.go.dev/github.com/libp2p/go-libp2p-pubsub#WithBufferSize)
+	rtr.subscription, err = rtr.topic.Subscribe()
+	return err
+}
+
+func (rtr *backgroundRouter) bootstrap(ctx context.Context) error {
+	// CONSIDERATION: add `GetPeers` method to `PeerstoreProvider` interface
+	// to avoid this loop.
+	for _, peer := range rtr.pstore.GetPeerList() {
+		if err := utils.AddPeerToLibp2pHost(rtr.host, peer); err != nil {
+			return err
+		}
+
+		libp2pAddrInfo, err := utils.Libp2pAddrInfoFromPeer(peer)
+		if err != nil {
+			return fmt.Errorf(
+				""converting peer info, pokt address: %s: %w"",
+				peer.GetAddress(),
+				err,
+			)
+		}
+
+		// don't attempt to connect to self
+		if rtr.host.ID() == libp2pAddrInfo.ID {
+			return nil
+		}
+
+		if err := rtr.host.Connect(ctx, libp2pAddrInfo); err != nil {
+			return fmt.Errorf(""connecting to peer: %w"", err)
+		}
+	}
+	return nil
+}
+
+// topicValidator is used in conjunction with libp2p-pubsub's notion of ""topic
+// validaton"". It is used for arbitrary and concurrent pre-propagation validation
+// of messages.
+//
+// (see: https://github.com/libp2p/specs/tree/master/pubsub#topic-validation
+// and https://pkg.go.dev/github.com/libp2p/go-libp2p-pubsub#PubSub.RegisterTopicValidator)
+//
+// Also note: https://pkg.go.dev/github.com/libp2p/go-libp2p-pubsub#BasicSeqnoValidator
+func (rtr *backgroundRouter) topicValidator(_ context.Context, _ libp2pPeer.ID, msg *pubsub.Message) bool {
+	var backgroundMsg typesP2P.BackgroundMessage
+	if err := proto.Unmarshal(msg.Data, &backgroundMsg); err != nil {
+		return false
+	}
+
+	if backgroundMsg.Data == nil {
+		return false
+	}
+
+	networkMessage := messaging.PocketEnvelope{}
+	if err := proto.Unmarshal(backgroundMsg.Data, &networkMessage); err != nil {
+		rtr.logger.Error().Err(err).Msg(""Error decoding network message"")
+		return false
+	}
+
+	return true
+}
+
+func (rtr *backgroundRouter) readSubscription(ctx context.Context) {",p2p/background/router.go,2023-07-03 23:19:18+00:00,2023-07-03T23:30:12Z,"```suggestion
// readSubscription is a while loop for receiving and handling messages from the
// subscription. It is intended to be called as a goroutine.
func (rtr *backgroundRouter) readSubscription(ctx context.Context) {
```",,,,381.0,371,RIGHT,390,400.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/732,pokt-network/pocket,6b875eee002f49c4b1abe5ac9faa61f59daaa4cf
https://api.github.com/repos/pokt-network/pocket/pulls/732,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1251335302,Olshansk,4602283cbd676952b2a5c20f73758305cc833ce5,6fde86f231f3a1866c34e668ac226f4a6adb05d6,"@@ -67,105 +66,431 @@ flowchart TD
     class PN pocket_network
 ```
 
-`Routers` is where [RainTree](https://github.com/pokt-network/pocket/files/9853354/raintree.pdf) (or the simpler basic approach) is implemented. See `raintree/router.go` for the specific implementation of RainTree, but please refer to the [specifications](https://github.com/pokt-network/pocket-network-protocol/tree/main/p2p) for more details.
+`Routers` is where [RainTree](https://github.com/pokt-network/pocket/files/9853354/raintree.pdf) is implemented.
+See [`raintree/router.go`](./raintree/router.go) for the specific implementation of RainTree, but please refer to the [specifications](https://github.com/pokt-network/pocket-network-protocol/tree/main/p2p) for more details.
 
-### Raintree Router Architecture
+## Module Architecture
 
-_DISCUSS(team): If you feel this needs a diagram, please reach out to the team for additional details._
-_TODO(olshansky, BenVan): Link to RainTree visualizations once it is complete._
+### Legends
+```mermaid
+flowchart
+subgraph Legend
+    m[[`Method`]]
+    c[Component]
+
+    m -- ""unconditional usage"" --> c
+    m -. ""conditional usage"" .-> c
+    m -. ""ignored"" .-x c
+end
+```
+
+```mermaid
+classDiagram
+class ConcreteType {
+  +ExportedField
+  -unexportedField
+  +ExportedMethod(argType) returnType
+  -unexportedMethod()
+}
+
+class InterfaceType {
+    <<interface>>
+    +Method(argType) (returnType1, returnType2)
+}
+
+ConcreteType --|> InterfaceType : Interface realization
+
+ConcreteType --> OtherType : Direct usage
+ConcreteType --o OtherType : Composition
+ConcreteType --* OtherType : Aggregatation
+ConcreteType ..*  ""(cardinality)"" OtherType : Indirect (via interface)
+```
+
+### P2P Module / Router Decoupling
 
-### Message Propagation
+The P2P module encapsulates the `RaiTreeRouter` and `BackgroundRouter` submodules.
+The P2P module internally refers to these as the `stakedActorRouter` and `unstakedActorRouter`, respectively.
 
-Given `Local P2P Module` has a message that it needs to propagate:
+Depending on the necessary routing scheme (unicast / broadcast) and whether the peers involved are staked actors, a node will use one or both of these routers.
 
-<ul style=""list-style-type: none;"">
-    <li>1a. <code>Raintree Router</code> selects targets from the <code>Pokt Peerstore</code>, <strong>which only includes staked actors</strong></li>
-    <li>1b. <code>Background Router</code> selects targets from the libp2p <code>Peerstore</code>, <strong>which includes all P2P participants</strong></li>
-    <li>2. Libp2p <code>Host</code> manages opening and closing streams to targeted peers</li>
-    <li>3. <code>Remote P2P module</code>'s (i.e. receiver's) <code>handleStream</code> is called (having been registered via <code>setStreamHandler()</code>)</li>
-    <li>4a. <code>handleStream</code> propagates message via <code>Raintree Router</code></li>
-    <li>4b. <code>handleStream</code> propagates message via <code>Background Router</code></li>
-    <li>5a. Repeat step 1a from <code>Remote P2P Module</code>'s perspective targeting its next peers</li>
-    <li>5b. Repeat step 1b from <code>Remote P2P Module</code>'s perspective targeting its next peers</li>
-</ul>
+**Unicast**
+
+| Sender         | Receiver       | Router          | Example Usage                                        |
+|----------------|----------------|-----------------|------------------------------------------------------|
+| Staked Actor   | Staked Actor   | Raintree only   | Consensus (state sync) messages (to validators only) |
+| Unstaked Actor | Staked Actor   | Background only | Consensus (state sync) messages (to validators only) |
+| Unstaked Actor | Unstaked Actor | Background only | Consensus (state sync) & Debug (CLI) messages        |
+
+**Broadcast**
+
+| Broadcaster    | Receiver       | Router                | Example Usage                              |
+|----------------|----------------|-----------------------|--------------------------------------------|
+| Staked Actor   | Staked Actor   | Raintree + Background | Utility tx messages                        |
+| Unstaked Actor | Staked Actor   | Background only       | Utility tx messages (gossipsub redundancy) |",p2p/README.md,2023-07-03 23:23:04+00:00,2023-07-03T23:30:12Z,"```suggestion
| Unstaked Actor | Staked Actor   | Background only       | Utility tx messages (raintree redundancy) |
```",,,,,129,RIGHT,117,,line,https://api.github.com/repos/pokt-network/pocket/pulls/732,pokt-network/pocket,6b875eee002f49c4b1abe5ac9faa61f59daaa4cf
https://api.github.com/repos/pokt-network/pocket/pulls/732,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1251335677,Olshansk,4602283cbd676952b2a5c20f73758305cc833ce5,6fde86f231f3a1866c34e668ac226f4a6adb05d6,"@@ -67,105 +66,431 @@ flowchart TD
     class PN pocket_network
 ```
 
-`Routers` is where [RainTree](https://github.com/pokt-network/pocket/files/9853354/raintree.pdf) (or the simpler basic approach) is implemented. See `raintree/router.go` for the specific implementation of RainTree, but please refer to the [specifications](https://github.com/pokt-network/pocket-network-protocol/tree/main/p2p) for more details.
+`Routers` is where [RainTree](https://github.com/pokt-network/pocket/files/9853354/raintree.pdf) is implemented.
+See [`raintree/router.go`](./raintree/router.go) for the specific implementation of RainTree, but please refer to the [specifications](https://github.com/pokt-network/pocket-network-protocol/tree/main/p2p) for more details.
 
-### Raintree Router Architecture
+## Module Architecture
 
-_DISCUSS(team): If you feel this needs a diagram, please reach out to the team for additional details._
-_TODO(olshansky, BenVan): Link to RainTree visualizations once it is complete._
+### Legends
+```mermaid
+flowchart
+subgraph Legend
+    m[[`Method`]]
+    c[Component]
+
+    m -- ""unconditional usage"" --> c
+    m -. ""conditional usage"" .-> c
+    m -. ""ignored"" .-x c
+end
+```
+
+```mermaid
+classDiagram
+class ConcreteType {
+  +ExportedField
+  -unexportedField
+  +ExportedMethod(argType) returnType
+  -unexportedMethod()
+}
+
+class InterfaceType {
+    <<interface>>
+    +Method(argType) (returnType1, returnType2)
+}
+
+ConcreteType --|> InterfaceType : Interface realization
+
+ConcreteType --> OtherType : Direct usage
+ConcreteType --o OtherType : Composition
+ConcreteType --* OtherType : Aggregatation
+ConcreteType ..*  ""(cardinality)"" OtherType : Indirect (via interface)
+```
+
+### P2P Module / Router Decoupling
 
-### Message Propagation
+The P2P module encapsulates the `RaiTreeRouter` and `BackgroundRouter` submodules.
+The P2P module internally refers to these as the `stakedActorRouter` and `unstakedActorRouter`, respectively.
 
-Given `Local P2P Module` has a message that it needs to propagate:
+Depending on the necessary routing scheme (unicast / broadcast) and whether the peers involved are staked actors, a node will use one or both of these routers.
 
-<ul style=""list-style-type: none;"">
-    <li>1a. <code>Raintree Router</code> selects targets from the <code>Pokt Peerstore</code>, <strong>which only includes staked actors</strong></li>
-    <li>1b. <code>Background Router</code> selects targets from the libp2p <code>Peerstore</code>, <strong>which includes all P2P participants</strong></li>
-    <li>2. Libp2p <code>Host</code> manages opening and closing streams to targeted peers</li>
-    <li>3. <code>Remote P2P module</code>'s (i.e. receiver's) <code>handleStream</code> is called (having been registered via <code>setStreamHandler()</code>)</li>
-    <li>4a. <code>handleStream</code> propagates message via <code>Raintree Router</code></li>
-    <li>4b. <code>handleStream</code> propagates message via <code>Background Router</code></li>
-    <li>5a. Repeat step 1a from <code>Remote P2P Module</code>'s perspective targeting its next peers</li>
-    <li>5b. Repeat step 1b from <code>Remote P2P Module</code>'s perspective targeting its next peers</li>
-</ul>
+**Unicast**
+
+| Sender         | Receiver       | Router          | Example Usage                                        |
+|----------------|----------------|-----------------|------------------------------------------------------|
+| Staked Actor   | Staked Actor   | Raintree only   | Consensus (state sync) messages (to validators only) |
+| Unstaked Actor | Staked Actor   | Background only | Consensus (state sync) messages (to validators only) |
+| Unstaked Actor | Unstaked Actor | Background only | Consensus (state sync) & Debug (CLI) messages        |
+
+**Broadcast**
+
+| Broadcaster    | Receiver       | Router                | Example Usage                              |
+|----------------|----------------|-----------------------|--------------------------------------------|
+| Staked Actor   | Staked Actor   | Raintree + Background | Utility tx messages                        |
+| Unstaked Actor | Staked Actor   | Background only       | Utility tx messages (gossipsub redundancy) |
+| Unstaked Actor | Unstaked Actor | Background only       | Utility tx messages                        |
+
+Both router submodule implementations embed a `UnicastRouter` which enables them to send and receive messages directly to/from a single peer.
+
+**Class Diagram**
 
 ```mermaid
-flowchart TD
-  subgraph lMod[Local P2P Module]
-    subgraph lHost[Libp2p `Host`]
+classDiagram",p2p/README.md,2023-07-03 23:24:31+00:00,2023-07-03T23:30:12Z,Makes 💯 sense!,,,,210.0,137,RIGHT,128,201.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/732,pokt-network/pocket,6b875eee002f49c4b1abe5ac9faa61f59daaa4cf
https://api.github.com/repos/pokt-network/pocket/pulls/732,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1251336687,Olshansk,4602283cbd676952b2a5c20f73758305cc833ce5,6fde86f231f3a1866c34e668ac226f4a6adb05d6,"@@ -67,105 +66,431 @@ flowchart TD
     class PN pocket_network
 ```
 
-`Routers` is where [RainTree](https://github.com/pokt-network/pocket/files/9853354/raintree.pdf) (or the simpler basic approach) is implemented. See `raintree/router.go` for the specific implementation of RainTree, but please refer to the [specifications](https://github.com/pokt-network/pocket-network-protocol/tree/main/p2p) for more details.
+`Routers` is where [RainTree](https://github.com/pokt-network/pocket/files/9853354/raintree.pdf) is implemented.
+See [`raintree/router.go`](./raintree/router.go) for the specific implementation of RainTree, but please refer to the [specifications](https://github.com/pokt-network/pocket-network-protocol/tree/main/p2p) for more details.
 
-### Raintree Router Architecture
+## Module Architecture
 
-_DISCUSS(team): If you feel this needs a diagram, please reach out to the team for additional details._
-_TODO(olshansky, BenVan): Link to RainTree visualizations once it is complete._
+### Legends
+```mermaid
+flowchart
+subgraph Legend
+    m[[`Method`]]
+    c[Component]
+
+    m -- ""unconditional usage"" --> c
+    m -. ""conditional usage"" .-> c
+    m -. ""ignored"" .-x c
+end
+```
+
+```mermaid
+classDiagram
+class ConcreteType {
+  +ExportedField
+  -unexportedField
+  +ExportedMethod(argType) returnType
+  -unexportedMethod()
+}
+
+class InterfaceType {
+    <<interface>>
+    +Method(argType) (returnType1, returnType2)
+}
+
+ConcreteType --|> InterfaceType : Interface realization
+
+ConcreteType --> OtherType : Direct usage
+ConcreteType --o OtherType : Composition
+ConcreteType --* OtherType : Aggregatation
+ConcreteType ..*  ""(cardinality)"" OtherType : Indirect (via interface)
+```
+
+### P2P Module / Router Decoupling
 
-### Message Propagation
+The P2P module encapsulates the `RaiTreeRouter` and `BackgroundRouter` submodules.
+The P2P module internally refers to these as the `stakedActorRouter` and `unstakedActorRouter`, respectively.
 
-Given `Local P2P Module` has a message that it needs to propagate:
+Depending on the necessary routing scheme (unicast / broadcast) and whether the peers involved are staked actors, a node will use one or both of these routers.
 
-<ul style=""list-style-type: none;"">
-    <li>1a. <code>Raintree Router</code> selects targets from the <code>Pokt Peerstore</code>, <strong>which only includes staked actors</strong></li>
-    <li>1b. <code>Background Router</code> selects targets from the libp2p <code>Peerstore</code>, <strong>which includes all P2P participants</strong></li>
-    <li>2. Libp2p <code>Host</code> manages opening and closing streams to targeted peers</li>
-    <li>3. <code>Remote P2P module</code>'s (i.e. receiver's) <code>handleStream</code> is called (having been registered via <code>setStreamHandler()</code>)</li>
-    <li>4a. <code>handleStream</code> propagates message via <code>Raintree Router</code></li>
-    <li>4b. <code>handleStream</code> propagates message via <code>Background Router</code></li>
-    <li>5a. Repeat step 1a from <code>Remote P2P Module</code>'s perspective targeting its next peers</li>
-    <li>5b. Repeat step 1b from <code>Remote P2P Module</code>'s perspective targeting its next peers</li>
-</ul>
+**Unicast**
+
+| Sender         | Receiver       | Router          | Example Usage                                        |
+|----------------|----------------|-----------------|------------------------------------------------------|
+| Staked Actor   | Staked Actor   | Raintree only   | Consensus (state sync) messages (to validators only) |
+| Unstaked Actor | Staked Actor   | Background only | Consensus (state sync) messages (to validators only) |
+| Unstaked Actor | Unstaked Actor | Background only | Consensus (state sync) & Debug (CLI) messages        |
+
+**Broadcast**
+
+| Broadcaster    | Receiver       | Router                | Example Usage                              |
+|----------------|----------------|-----------------------|--------------------------------------------|
+| Staked Actor   | Staked Actor   | Raintree + Background | Utility tx messages                        |
+| Unstaked Actor | Staked Actor   | Background only       | Utility tx messages (gossipsub redundancy) |
+| Unstaked Actor | Unstaked Actor | Background only       | Utility tx messages                        |
+
+Both router submodule implementations embed a `UnicastRouter` which enables them to send and receive messages directly to/from a single peer.
+
+**Class Diagram**
 
 ```mermaid
-flowchart TD
-  subgraph lMod[Local P2P Module]
-    subgraph lHost[Libp2p `Host`]
+classDiagram
+    class p2pModule {
+        -stakedActorRouter Router
+        -unstakedActorRouter Router
+        -handlePocketEnvelope([]byte) error
+    }
+
+    class P2PModule {
+        <<interface>>
+        GetAddress() (Address, error)
+        HandleEvent(*anypb.Any) error
+        Send([]byte, Address) error
+        Broadcast([]byte) error
+    }
+    p2pModule --|> P2PModule
+
+    class RainTreeRouter {
+        UnicastRouter
+        -handler MessageHandler
+        +Broadcast([]byte) error
+        -handleRainTreeMsg([]byte) error
+    }
+
+    class BackgroundRouter {
+        UnicastRouter
+        -handler MessageHandler
+        +Broadcast([]byte) error
+        -handleBackgroundMsg([]byte) error
+        -readSubscription(subscription *pubsub.Subscription)
+    }
+
+    class UnicastRouter {
+        -messageHandler MessageHandler
+        -peerHandler PeerHandler
+        +Send([]byte, Address) error
+        -handleStream(libp2pNetwork.Stream)
+        -readStream(libp2pNetwork.Stream)
+    }
+    RainTreeRouter --* UnicastRouter : (embedded)
+    BackgroundRouter --* UnicastRouter : (embedded)
+
+    p2pModule --o ""2"" Router
+    p2pModule ..* RainTreeRouter : (`stakedActorRouter`)
+    p2pModule ..* BackgroundRouter : (`unstakedActorRouter`)
+    
+    class Router {
+        <<interface>>
+        +Send([]byte, Address) error
+        +Broadcast([]byte) error
+    }
+    BackgroundRouter --|> Router
+    RainTreeRouter --|> Router
+```
+
+### Message Propagation & Handling
+
+**Unicast**
+
+```mermaid
+flowchart
+    subgraph lp2p[""Local P2P Module (outgoing)""]
+        lps[[`Send`]]
+        lps -. ""(iff local & remote peer are staked)"" ..-> lrtu
+        lps -. ""(if local or remote peer are not staked)"" .-> lbgu
+
+        lbgu -- ""opens stream\nto target peer"" ---> lhost
+
+        lhost[Libp2p Host]
+
+        subgraph lrt[RainTree Router]
+            subgraph lRTPS[Raintree Peerstore]
+              lStakedPS([staked actors only])
+            end
+            
+            lrtu[UnicastRouter]
+
+            lrtu -- ""network address lookup"" --> lRTPS
+        end
+
+        lrtu -- ""opens a stream\nto target peer"" ---> lhost
+
+        subgraph lbg[Background Router]
+            lbgu[UnicastRouter]
+            subgraph lBGPS[Background Peerstore]
+              lNetPS([all P2P participants])
+            end
+
+            lbgu -- ""network address lookup"" --> lBGPS
+        end
+    end
+
+    subgraph rp2p[""Remote P2P Module (incoming)""]
+        rhost[Libp2p Host]
+
+        subgraph rrt[RainTree Router]
+            rrth[[`RainTreeMessage` Handler]]
+            rrtu[UnicastRouter]
+        end
+
+        subgraph rbg[Background Router]
+            rbgh[[`BackgroundMessage` Handler]]
+            rbgu[UnicastRouter]
+            rbgu --> rbgh
+        end
+
+        rp2ph[[`PocketEnvelope` Handler]]
+        rbus[bus]
+        rhost -. ""new stream"" .-> rrtu
+        rhost -- ""new subscription message"" --> rbgu
+        rrtu --> rrth
+
+        rnd[Nonce Deduper]
+        rp2ph -- ""deduplicate msg mempool"" --> rnd
     end
-    subgraph lRT[Raintree Router]
+
+
+    rp2ph -. ""(iff not duplicate msg)\npublish event"" .-> rbus
+
+    rrth --> rp2ph
+    rbgh --> rp2ph
+
+    lhost --> rhost
+```
+
+**Broadcast**
+
+```mermaid
+flowchart
+  subgraph lp2p[""Local P2P Module (outgoing)""]
+    lpb[[`Broadcast`]]
+    lpb -. ""(iff local & remote peer are staked)"" ..-> lrtu
+    lpb -- ""(always)"" --> lbggt
+    
+    lbggt -- ""msg published\n(gossipsub protocol)"" ---> lhost
+    
+    lhost[Libp2p Host]
+
+    subgraph lrt[RainTree Router]
       subgraph lRTPS[Raintree Peerstore]
         lStakedPS([staked actors only])
       end
-
-      subgraph lPM[PeerManager]
-      end
-      lPM --> lRTPS
+      
+      lrtu[UnicastRouter]
+      
+      lrtu -- ""network address lookup"" --> lRTPS
     end
+    
+    lrtu -- ""opens a stream\nto target peer"" ---> lhost
 
-    subgraph lBG[Background Router]
+    subgraph lbg[Background Router]
+      lbggt[Gossipsub Topic]
       subgraph lBGPS[Background Peerstore]
         lNetPS([all P2P participants])
       end
+      
+      lbggt -- ""network address lookup"" --> lBGPS
+    end
+  end
 
-      subgraph lGossipSub[GossipSub]
-      end
+  subgraph rp2p[""Remote P2P Module (incoming)""]
+    rhost[Libp2p Host]
 
-      subgraph lDHT[Kademlia DHT]
-      end
+    subgraph rrt[RainTree Router]
+      rrth[[`RainTreeMessage` Handler]]
+      rrtu[UnicastRouter]
+    end
 
-      lGossipSub --> lBGPS
-      lDHT --> lBGPS
+    subgraph rbg[Background Router]
+      rbgh[[`BackgroundMessage` Handler]]
+      rbgg[Gossipsub Subscription]
+      rbggt[Gossipsub Topic]
+      rbgg --> rbgh
+      rbgh -- ""(background msg\npropagation cont.)"" ---> rbggt
     end
 
-    lRT --1a--> lHost
-    lBG --1b--> lHost
+    rp2ph[[`PocketEnvelope` Handler]]
+    rbus[bus]
+    rhost -. ""new stream"" ..-> rrtu
+    rhost -- ""new subscription message"" --> rbgg
+    rbggt -- ""(background msg\npropagation cont.)"" --> rhost
+    rrtu --> rrth
+    rrth -. ""(iff level > 0)\n(raintree msg\npropagation cont.)"" .-> rrtu
+    rrtu -- ""(raintree msg\npropagation cont.)"" --> rhost
+
+    rnd[Nonce Deduper]
+    rp2ph -- ""deduplicate msg mempool"" --> rnd
   end
 
-subgraph rMod[Remote P2P Module]
-subgraph rHost[Libp2p `Host`]
-end
-subgraph rRT[Raintree Router]
-subgraph rPS[Raintree Peerstore]
-rStakedPS([staked actors only])
-end
 
-subgraph rPM[PeerManager]
-end
+  rp2ph -. ""(iff not duplicate msg)\npublish event"" .-> rbus
 
-rPM --> rStakedPS
-end
+  rrth --> rp2ph
+  rbgh --> rp2ph
 
-subgraph rBG[Background Router]
-subgraph rBGPS[Background Peerstore]
-rNetPS([all P2P participants])
-end
+  lhost --> rhost
+```
 
-subgraph rGossipSub[GossipSub]
-end
+### Message Deduplication",p2p/README.md,2023-07-03 23:27:37+00:00,2023-07-03T23:30:12Z,Can you add a note on how/when the deduplication is cleared? On node restart? Configuration? etcc,,,,407.0,334,RIGHT,356,429.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/732,pokt-network/pocket,6b875eee002f49c4b1abe5ac9faa61f59daaa4cf
https://api.github.com/repos/pokt-network/pocket/pulls/732,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1251336861,Olshansk,4602283cbd676952b2a5c20f73758305cc833ce5,6fde86f231f3a1866c34e668ac226f4a6adb05d6,"@@ -67,105 +66,431 @@ flowchart TD
     class PN pocket_network
 ```
 
-`Routers` is where [RainTree](https://github.com/pokt-network/pocket/files/9853354/raintree.pdf) (or the simpler basic approach) is implemented. See `raintree/router.go` for the specific implementation of RainTree, but please refer to the [specifications](https://github.com/pokt-network/pocket-network-protocol/tree/main/p2p) for more details.
+`Routers` is where [RainTree](https://github.com/pokt-network/pocket/files/9853354/raintree.pdf) is implemented.
+See [`raintree/router.go`](./raintree/router.go) for the specific implementation of RainTree, but please refer to the [specifications](https://github.com/pokt-network/pocket-network-protocol/tree/main/p2p) for more details.
 
-### Raintree Router Architecture
+## Module Architecture
 
-_DISCUSS(team): If you feel this needs a diagram, please reach out to the team for additional details._
-_TODO(olshansky, BenVan): Link to RainTree visualizations once it is complete._
+### Legends
+```mermaid
+flowchart
+subgraph Legend
+    m[[`Method`]]
+    c[Component]
+
+    m -- ""unconditional usage"" --> c
+    m -. ""conditional usage"" .-> c
+    m -. ""ignored"" .-x c
+end
+```
+
+```mermaid
+classDiagram
+class ConcreteType {
+  +ExportedField
+  -unexportedField
+  +ExportedMethod(argType) returnType
+  -unexportedMethod()
+}
+
+class InterfaceType {
+    <<interface>>
+    +Method(argType) (returnType1, returnType2)
+}
+
+ConcreteType --|> InterfaceType : Interface realization
+
+ConcreteType --> OtherType : Direct usage
+ConcreteType --o OtherType : Composition
+ConcreteType --* OtherType : Aggregatation
+ConcreteType ..*  ""(cardinality)"" OtherType : Indirect (via interface)
+```
+
+### P2P Module / Router Decoupling
 
-### Message Propagation
+The P2P module encapsulates the `RaiTreeRouter` and `BackgroundRouter` submodules.
+The P2P module internally refers to these as the `stakedActorRouter` and `unstakedActorRouter`, respectively.
 
-Given `Local P2P Module` has a message that it needs to propagate:
+Depending on the necessary routing scheme (unicast / broadcast) and whether the peers involved are staked actors, a node will use one or both of these routers.
 
-<ul style=""list-style-type: none;"">
-    <li>1a. <code>Raintree Router</code> selects targets from the <code>Pokt Peerstore</code>, <strong>which only includes staked actors</strong></li>
-    <li>1b. <code>Background Router</code> selects targets from the libp2p <code>Peerstore</code>, <strong>which includes all P2P participants</strong></li>
-    <li>2. Libp2p <code>Host</code> manages opening and closing streams to targeted peers</li>
-    <li>3. <code>Remote P2P module</code>'s (i.e. receiver's) <code>handleStream</code> is called (having been registered via <code>setStreamHandler()</code>)</li>
-    <li>4a. <code>handleStream</code> propagates message via <code>Raintree Router</code></li>
-    <li>4b. <code>handleStream</code> propagates message via <code>Background Router</code></li>
-    <li>5a. Repeat step 1a from <code>Remote P2P Module</code>'s perspective targeting its next peers</li>
-    <li>5b. Repeat step 1b from <code>Remote P2P Module</code>'s perspective targeting its next peers</li>
-</ul>
+**Unicast**
+
+| Sender         | Receiver       | Router          | Example Usage                                        |
+|----------------|----------------|-----------------|------------------------------------------------------|
+| Staked Actor   | Staked Actor   | Raintree only   | Consensus (state sync) messages (to validators only) |
+| Unstaked Actor | Staked Actor   | Background only | Consensus (state sync) messages (to validators only) |
+| Unstaked Actor | Unstaked Actor | Background only | Consensus (state sync) & Debug (CLI) messages        |
+
+**Broadcast**
+
+| Broadcaster    | Receiver       | Router                | Example Usage                              |
+|----------------|----------------|-----------------------|--------------------------------------------|
+| Staked Actor   | Staked Actor   | Raintree + Background | Utility tx messages                        |
+| Unstaked Actor | Staked Actor   | Background only       | Utility tx messages (gossipsub redundancy) |
+| Unstaked Actor | Unstaked Actor | Background only       | Utility tx messages                        |
+
+Both router submodule implementations embed a `UnicastRouter` which enables them to send and receive messages directly to/from a single peer.
+
+**Class Diagram**
 
 ```mermaid
-flowchart TD
-  subgraph lMod[Local P2P Module]
-    subgraph lHost[Libp2p `Host`]
+classDiagram
+    class p2pModule {
+        -stakedActorRouter Router
+        -unstakedActorRouter Router
+        -handlePocketEnvelope([]byte) error
+    }
+
+    class P2PModule {
+        <<interface>>
+        GetAddress() (Address, error)
+        HandleEvent(*anypb.Any) error
+        Send([]byte, Address) error
+        Broadcast([]byte) error
+    }
+    p2pModule --|> P2PModule
+
+    class RainTreeRouter {
+        UnicastRouter
+        -handler MessageHandler
+        +Broadcast([]byte) error
+        -handleRainTreeMsg([]byte) error
+    }
+
+    class BackgroundRouter {
+        UnicastRouter
+        -handler MessageHandler
+        +Broadcast([]byte) error
+        -handleBackgroundMsg([]byte) error
+        -readSubscription(subscription *pubsub.Subscription)
+    }
+
+    class UnicastRouter {
+        -messageHandler MessageHandler
+        -peerHandler PeerHandler
+        +Send([]byte, Address) error
+        -handleStream(libp2pNetwork.Stream)
+        -readStream(libp2pNetwork.Stream)
+    }
+    RainTreeRouter --* UnicastRouter : (embedded)
+    BackgroundRouter --* UnicastRouter : (embedded)
+
+    p2pModule --o ""2"" Router
+    p2pModule ..* RainTreeRouter : (`stakedActorRouter`)
+    p2pModule ..* BackgroundRouter : (`unstakedActorRouter`)
+    
+    class Router {
+        <<interface>>
+        +Send([]byte, Address) error
+        +Broadcast([]byte) error
+    }
+    BackgroundRouter --|> Router
+    RainTreeRouter --|> Router
+```
+
+### Message Propagation & Handling
+
+**Unicast**
+
+```mermaid
+flowchart
+    subgraph lp2p[""Local P2P Module (outgoing)""]
+        lps[[`Send`]]
+        lps -. ""(iff local & remote peer are staked)"" ..-> lrtu
+        lps -. ""(if local or remote peer are not staked)"" .-> lbgu
+
+        lbgu -- ""opens stream\nto target peer"" ---> lhost
+
+        lhost[Libp2p Host]
+
+        subgraph lrt[RainTree Router]
+            subgraph lRTPS[Raintree Peerstore]
+              lStakedPS([staked actors only])
+            end
+            
+            lrtu[UnicastRouter]
+
+            lrtu -- ""network address lookup"" --> lRTPS
+        end
+
+        lrtu -- ""opens a stream\nto target peer"" ---> lhost
+
+        subgraph lbg[Background Router]
+            lbgu[UnicastRouter]
+            subgraph lBGPS[Background Peerstore]
+              lNetPS([all P2P participants])
+            end
+
+            lbgu -- ""network address lookup"" --> lBGPS
+        end
+    end
+
+    subgraph rp2p[""Remote P2P Module (incoming)""]
+        rhost[Libp2p Host]
+
+        subgraph rrt[RainTree Router]
+            rrth[[`RainTreeMessage` Handler]]
+            rrtu[UnicastRouter]
+        end
+
+        subgraph rbg[Background Router]
+            rbgh[[`BackgroundMessage` Handler]]
+            rbgu[UnicastRouter]
+            rbgu --> rbgh
+        end
+
+        rp2ph[[`PocketEnvelope` Handler]]
+        rbus[bus]
+        rhost -. ""new stream"" .-> rrtu
+        rhost -- ""new subscription message"" --> rbgu
+        rrtu --> rrth
+
+        rnd[Nonce Deduper]
+        rp2ph -- ""deduplicate msg mempool"" --> rnd
     end
-    subgraph lRT[Raintree Router]
+
+
+    rp2ph -. ""(iff not duplicate msg)\npublish event"" .-> rbus
+
+    rrth --> rp2ph
+    rbgh --> rp2ph
+
+    lhost --> rhost
+```
+
+**Broadcast**
+
+```mermaid
+flowchart
+  subgraph lp2p[""Local P2P Module (outgoing)""]
+    lpb[[`Broadcast`]]
+    lpb -. ""(iff local & remote peer are staked)"" ..-> lrtu
+    lpb -- ""(always)"" --> lbggt
+    
+    lbggt -- ""msg published\n(gossipsub protocol)"" ---> lhost
+    
+    lhost[Libp2p Host]
+
+    subgraph lrt[RainTree Router]
       subgraph lRTPS[Raintree Peerstore]
         lStakedPS([staked actors only])
       end
-
-      subgraph lPM[PeerManager]
-      end
-      lPM --> lRTPS
+      
+      lrtu[UnicastRouter]
+      
+      lrtu -- ""network address lookup"" --> lRTPS
     end
+    
+    lrtu -- ""opens a stream\nto target peer"" ---> lhost
 
-    subgraph lBG[Background Router]
+    subgraph lbg[Background Router]
+      lbggt[Gossipsub Topic]
       subgraph lBGPS[Background Peerstore]
         lNetPS([all P2P participants])
       end
+      
+      lbggt -- ""network address lookup"" --> lBGPS
+    end
+  end
 
-      subgraph lGossipSub[GossipSub]
-      end
+  subgraph rp2p[""Remote P2P Module (incoming)""]
+    rhost[Libp2p Host]
 
-      subgraph lDHT[Kademlia DHT]
-      end
+    subgraph rrt[RainTree Router]
+      rrth[[`RainTreeMessage` Handler]]
+      rrtu[UnicastRouter]
+    end
 
-      lGossipSub --> lBGPS
-      lDHT --> lBGPS
+    subgraph rbg[Background Router]
+      rbgh[[`BackgroundMessage` Handler]]
+      rbgg[Gossipsub Subscription]
+      rbggt[Gossipsub Topic]
+      rbgg --> rbgh
+      rbgh -- ""(background msg\npropagation cont.)"" ---> rbggt
     end
 
-    lRT --1a--> lHost
-    lBG --1b--> lHost
+    rp2ph[[`PocketEnvelope` Handler]]
+    rbus[bus]
+    rhost -. ""new stream"" ..-> rrtu
+    rhost -- ""new subscription message"" --> rbgg
+    rbggt -- ""(background msg\npropagation cont.)"" --> rhost
+    rrtu --> rrth
+    rrth -. ""(iff level > 0)\n(raintree msg\npropagation cont.)"" .-> rrtu
+    rrtu -- ""(raintree msg\npropagation cont.)"" --> rhost
+
+    rnd[Nonce Deduper]
+    rp2ph -- ""deduplicate msg mempool"" --> rnd
   end
 
-subgraph rMod[Remote P2P Module]
-subgraph rHost[Libp2p `Host`]
-end
-subgraph rRT[Raintree Router]
-subgraph rPS[Raintree Peerstore]
-rStakedPS([staked actors only])
-end
 
-subgraph rPM[PeerManager]
-end
+  rp2ph -. ""(iff not duplicate msg)\npublish event"" .-> rbus
 
-rPM --> rStakedPS
-end
+  rrth --> rp2ph
+  rbgh --> rp2ph
 
-subgraph rBG[Background Router]
-subgraph rBGPS[Background Peerstore]
-rNetPS([all P2P participants])
-end
+  lhost --> rhost
+```
 
-subgraph rGossipSub[GossipSub]
-end
+### Message Deduplication
 
-subgraph rDHT[Kademlia DHT]
-end
+Messages MUST be deduplicated before broadcasting their respective event over the bus since it is expected that nodes will receive duplicate messages (for multiple reasons).
 
-rGossipSub --> rBGPS
-rDHT --> rBGPS
-end
+The responsibility of deduplication is encapsulated by the P2P module, As such duplicate messages may come from multiple routers in some of these scenarios.
 
-rHost -. ""3 (setStreamHandler())"" .-> hs[[handleStream]]
+```mermaid
+classDiagram
+    class RainTreeMessage {
+        <<protobuf>>
+        +Level uint32
+        +Data []byte
+    }
+
+    class BackgroundMessage {
+        <<protobuf>>
+        +Data []byte
+    }
+    
+    class PocketEnvelope {
+        <<protobuf>>
+        +Content *anypb.Any
+        +Nonce uint64
+    }
+
+    RainTreeMessage --* PocketEnvelope : serialized as `Data`
+    BackgroundMessage --* PocketEnvelope : serialized as `Data`
+    
+    
+    class p2pModule {
+        -handlePocketEnvelope([]byte) error
+    }
+
+    class P2PModule {
+        <<interface>>
+        GetAddress() (Address, error)
+        HandleEvent(*anypb.Any) error
+        Send([]byte, address Address) error
+        Broadcast([]byte) error
+    }
+    p2pModule --|> P2PModule
+
+    class RainTreeRouter {
+        UnicastRouter
+        -handler MessageHandler
+        +Broadcast([]byte) error
+        -handleRainTreeMsg([]byte) error
+    }
+
+    class NonceDeduper {
+        Push(Nonce) error
+        Contains(Nonce) bool
+    }
+
+  class Bus {
+    <<interface>>
+    PublishEventToBus(PocketEnvelope)
+    GetBusEvent() PocketEnvelope
+  }
+  p2pModule --> Bus
+
+    class BackgroundRouter {
+        UnicastRouter
+        -handler MessageHandler
+        +Broadcast([]byte) error
+        -handleBackgroundMsg([]byte) error
+        -readSubscription(subscription *pubsub.Subscription)
+    }
+
+    class UnicastRouter {
+        -messageHandler MessageHandler
+        -peerHandler PeerHandler
+        +Send([]byte, address Address) error
+        -handleStream(stream libp2pNetwork.Stream)
+        -readStream(stream libp2pNetwork.Stream)
+    }
+    RainTreeRouter --* UnicastRouter : (embedded)
+    BackgroundRouter --* UnicastRouter : (embedded)
+
+    p2pModule ..* RainTreeRouter
+    RainTreeRouter --o RainTreeMessage
+    
+    p2pModule ..* BackgroundRouter
+    BackgroundRouter --o BackgroundMessage
+
+    p2pModule --o PocketEnvelope
+    p2pModule --* NonceDeduper
+```
 
-hs --4a--> rRT
-hs --4b--> rBG
-rBG  --""5a (cont. propagation)""--> rHost
-linkStyle 11 stroke:#ff3
-rRT  --""5b (cont. propagation)""--> rHost
-linkStyle 12 stroke:#ff3
-end
+### Peer Discovery
+Peer discovery involves pairing peer IDs to their network addresses (multiaddr).",p2p/README.md,2023-07-03 23:28:14+00:00,2023-07-03T23:30:12Z,"```suggestion

Peer discovery involves pairing peer IDs to their network addresses (multiaddr).
```",,,,504.0,424,RIGHT,459,540.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/732,pokt-network/pocket,6b875eee002f49c4b1abe5ac9faa61f59daaa4cf
https://api.github.com/repos/pokt-network/pocket/pulls/732,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1251336939,Olshansk,4602283cbd676952b2a5c20f73758305cc833ce5,6fde86f231f3a1866c34e668ac226f4a6adb05d6,"@@ -67,105 +66,431 @@ flowchart TD
     class PN pocket_network
 ```
 
-`Routers` is where [RainTree](https://github.com/pokt-network/pocket/files/9853354/raintree.pdf) (or the simpler basic approach) is implemented. See `raintree/router.go` for the specific implementation of RainTree, but please refer to the [specifications](https://github.com/pokt-network/pocket-network-protocol/tree/main/p2p) for more details.
+`Routers` is where [RainTree](https://github.com/pokt-network/pocket/files/9853354/raintree.pdf) is implemented.
+See [`raintree/router.go`](./raintree/router.go) for the specific implementation of RainTree, but please refer to the [specifications](https://github.com/pokt-network/pocket-network-protocol/tree/main/p2p) for more details.
 
-### Raintree Router Architecture
+## Module Architecture
 
-_DISCUSS(team): If you feel this needs a diagram, please reach out to the team for additional details._
-_TODO(olshansky, BenVan): Link to RainTree visualizations once it is complete._
+### Legends
+```mermaid
+flowchart
+subgraph Legend
+    m[[`Method`]]
+    c[Component]
+
+    m -- ""unconditional usage"" --> c
+    m -. ""conditional usage"" .-> c
+    m -. ""ignored"" .-x c
+end
+```
+
+```mermaid
+classDiagram
+class ConcreteType {
+  +ExportedField
+  -unexportedField
+  +ExportedMethod(argType) returnType
+  -unexportedMethod()
+}
+
+class InterfaceType {
+    <<interface>>
+    +Method(argType) (returnType1, returnType2)
+}
+
+ConcreteType --|> InterfaceType : Interface realization
+
+ConcreteType --> OtherType : Direct usage
+ConcreteType --o OtherType : Composition
+ConcreteType --* OtherType : Aggregatation
+ConcreteType ..*  ""(cardinality)"" OtherType : Indirect (via interface)
+```
+
+### P2P Module / Router Decoupling
 
-### Message Propagation
+The P2P module encapsulates the `RaiTreeRouter` and `BackgroundRouter` submodules.
+The P2P module internally refers to these as the `stakedActorRouter` and `unstakedActorRouter`, respectively.
 
-Given `Local P2P Module` has a message that it needs to propagate:
+Depending on the necessary routing scheme (unicast / broadcast) and whether the peers involved are staked actors, a node will use one or both of these routers.
 
-<ul style=""list-style-type: none;"">
-    <li>1a. <code>Raintree Router</code> selects targets from the <code>Pokt Peerstore</code>, <strong>which only includes staked actors</strong></li>
-    <li>1b. <code>Background Router</code> selects targets from the libp2p <code>Peerstore</code>, <strong>which includes all P2P participants</strong></li>
-    <li>2. Libp2p <code>Host</code> manages opening and closing streams to targeted peers</li>
-    <li>3. <code>Remote P2P module</code>'s (i.e. receiver's) <code>handleStream</code> is called (having been registered via <code>setStreamHandler()</code>)</li>
-    <li>4a. <code>handleStream</code> propagates message via <code>Raintree Router</code></li>
-    <li>4b. <code>handleStream</code> propagates message via <code>Background Router</code></li>
-    <li>5a. Repeat step 1a from <code>Remote P2P Module</code>'s perspective targeting its next peers</li>
-    <li>5b. Repeat step 1b from <code>Remote P2P Module</code>'s perspective targeting its next peers</li>
-</ul>
+**Unicast**
+
+| Sender         | Receiver       | Router          | Example Usage                                        |
+|----------------|----------------|-----------------|------------------------------------------------------|
+| Staked Actor   | Staked Actor   | Raintree only   | Consensus (state sync) messages (to validators only) |
+| Unstaked Actor | Staked Actor   | Background only | Consensus (state sync) messages (to validators only) |
+| Unstaked Actor | Unstaked Actor | Background only | Consensus (state sync) & Debug (CLI) messages        |
+
+**Broadcast**
+
+| Broadcaster    | Receiver       | Router                | Example Usage                              |
+|----------------|----------------|-----------------------|--------------------------------------------|
+| Staked Actor   | Staked Actor   | Raintree + Background | Utility tx messages                        |
+| Unstaked Actor | Staked Actor   | Background only       | Utility tx messages (gossipsub redundancy) |
+| Unstaked Actor | Unstaked Actor | Background only       | Utility tx messages                        |
+
+Both router submodule implementations embed a `UnicastRouter` which enables them to send and receive messages directly to/from a single peer.
+
+**Class Diagram**
 
 ```mermaid
-flowchart TD
-  subgraph lMod[Local P2P Module]
-    subgraph lHost[Libp2p `Host`]
+classDiagram
+    class p2pModule {
+        -stakedActorRouter Router
+        -unstakedActorRouter Router
+        -handlePocketEnvelope([]byte) error
+    }
+
+    class P2PModule {
+        <<interface>>
+        GetAddress() (Address, error)
+        HandleEvent(*anypb.Any) error
+        Send([]byte, Address) error
+        Broadcast([]byte) error
+    }
+    p2pModule --|> P2PModule
+
+    class RainTreeRouter {
+        UnicastRouter
+        -handler MessageHandler
+        +Broadcast([]byte) error
+        -handleRainTreeMsg([]byte) error
+    }
+
+    class BackgroundRouter {
+        UnicastRouter
+        -handler MessageHandler
+        +Broadcast([]byte) error
+        -handleBackgroundMsg([]byte) error
+        -readSubscription(subscription *pubsub.Subscription)
+    }
+
+    class UnicastRouter {
+        -messageHandler MessageHandler
+        -peerHandler PeerHandler
+        +Send([]byte, Address) error
+        -handleStream(libp2pNetwork.Stream)
+        -readStream(libp2pNetwork.Stream)
+    }
+    RainTreeRouter --* UnicastRouter : (embedded)
+    BackgroundRouter --* UnicastRouter : (embedded)
+
+    p2pModule --o ""2"" Router
+    p2pModule ..* RainTreeRouter : (`stakedActorRouter`)
+    p2pModule ..* BackgroundRouter : (`unstakedActorRouter`)
+    
+    class Router {
+        <<interface>>
+        +Send([]byte, Address) error
+        +Broadcast([]byte) error
+    }
+    BackgroundRouter --|> Router
+    RainTreeRouter --|> Router
+```
+
+### Message Propagation & Handling
+
+**Unicast**
+
+```mermaid
+flowchart
+    subgraph lp2p[""Local P2P Module (outgoing)""]
+        lps[[`Send`]]
+        lps -. ""(iff local & remote peer are staked)"" ..-> lrtu
+        lps -. ""(if local or remote peer are not staked)"" .-> lbgu
+
+        lbgu -- ""opens stream\nto target peer"" ---> lhost
+
+        lhost[Libp2p Host]
+
+        subgraph lrt[RainTree Router]
+            subgraph lRTPS[Raintree Peerstore]
+              lStakedPS([staked actors only])
+            end
+            
+            lrtu[UnicastRouter]
+
+            lrtu -- ""network address lookup"" --> lRTPS
+        end
+
+        lrtu -- ""opens a stream\nto target peer"" ---> lhost
+
+        subgraph lbg[Background Router]
+            lbgu[UnicastRouter]
+            subgraph lBGPS[Background Peerstore]
+              lNetPS([all P2P participants])
+            end
+
+            lbgu -- ""network address lookup"" --> lBGPS
+        end
+    end
+
+    subgraph rp2p[""Remote P2P Module (incoming)""]
+        rhost[Libp2p Host]
+
+        subgraph rrt[RainTree Router]
+            rrth[[`RainTreeMessage` Handler]]
+            rrtu[UnicastRouter]
+        end
+
+        subgraph rbg[Background Router]
+            rbgh[[`BackgroundMessage` Handler]]
+            rbgu[UnicastRouter]
+            rbgu --> rbgh
+        end
+
+        rp2ph[[`PocketEnvelope` Handler]]
+        rbus[bus]
+        rhost -. ""new stream"" .-> rrtu
+        rhost -- ""new subscription message"" --> rbgu
+        rrtu --> rrth
+
+        rnd[Nonce Deduper]
+        rp2ph -- ""deduplicate msg mempool"" --> rnd
     end
-    subgraph lRT[Raintree Router]
+
+
+    rp2ph -. ""(iff not duplicate msg)\npublish event"" .-> rbus
+
+    rrth --> rp2ph
+    rbgh --> rp2ph
+
+    lhost --> rhost
+```
+
+**Broadcast**
+
+```mermaid
+flowchart
+  subgraph lp2p[""Local P2P Module (outgoing)""]
+    lpb[[`Broadcast`]]
+    lpb -. ""(iff local & remote peer are staked)"" ..-> lrtu
+    lpb -- ""(always)"" --> lbggt
+    
+    lbggt -- ""msg published\n(gossipsub protocol)"" ---> lhost
+    
+    lhost[Libp2p Host]
+
+    subgraph lrt[RainTree Router]
       subgraph lRTPS[Raintree Peerstore]
         lStakedPS([staked actors only])
       end
-
-      subgraph lPM[PeerManager]
-      end
-      lPM --> lRTPS
+      
+      lrtu[UnicastRouter]
+      
+      lrtu -- ""network address lookup"" --> lRTPS
     end
+    
+    lrtu -- ""opens a stream\nto target peer"" ---> lhost
 
-    subgraph lBG[Background Router]
+    subgraph lbg[Background Router]
+      lbggt[Gossipsub Topic]
       subgraph lBGPS[Background Peerstore]
         lNetPS([all P2P participants])
       end
+      
+      lbggt -- ""network address lookup"" --> lBGPS
+    end
+  end
 
-      subgraph lGossipSub[GossipSub]
-      end
+  subgraph rp2p[""Remote P2P Module (incoming)""]
+    rhost[Libp2p Host]
 
-      subgraph lDHT[Kademlia DHT]
-      end
+    subgraph rrt[RainTree Router]
+      rrth[[`RainTreeMessage` Handler]]
+      rrtu[UnicastRouter]
+    end
 
-      lGossipSub --> lBGPS
-      lDHT --> lBGPS
+    subgraph rbg[Background Router]
+      rbgh[[`BackgroundMessage` Handler]]
+      rbgg[Gossipsub Subscription]
+      rbggt[Gossipsub Topic]
+      rbgg --> rbgh
+      rbgh -- ""(background msg\npropagation cont.)"" ---> rbggt
     end
 
-    lRT --1a--> lHost
-    lBG --1b--> lHost
+    rp2ph[[`PocketEnvelope` Handler]]
+    rbus[bus]
+    rhost -. ""new stream"" ..-> rrtu
+    rhost -- ""new subscription message"" --> rbgg
+    rbggt -- ""(background msg\npropagation cont.)"" --> rhost
+    rrtu --> rrth
+    rrth -. ""(iff level > 0)\n(raintree msg\npropagation cont.)"" .-> rrtu
+    rrtu -- ""(raintree msg\npropagation cont.)"" --> rhost
+
+    rnd[Nonce Deduper]
+    rp2ph -- ""deduplicate msg mempool"" --> rnd
   end
 
-subgraph rMod[Remote P2P Module]
-subgraph rHost[Libp2p `Host`]
-end
-subgraph rRT[Raintree Router]
-subgraph rPS[Raintree Peerstore]
-rStakedPS([staked actors only])
-end
 
-subgraph rPM[PeerManager]
-end
+  rp2ph -. ""(iff not duplicate msg)\npublish event"" .-> rbus
 
-rPM --> rStakedPS
-end
+  rrth --> rp2ph
+  rbgh --> rp2ph
 
-subgraph rBG[Background Router]
-subgraph rBGPS[Background Peerstore]
-rNetPS([all P2P participants])
-end
+  lhost --> rhost
+```
 
-subgraph rGossipSub[GossipSub]
-end
+### Message Deduplication
 
-subgraph rDHT[Kademlia DHT]
-end
+Messages MUST be deduplicated before broadcasting their respective event over the bus since it is expected that nodes will receive duplicate messages (for multiple reasons).
 
-rGossipSub --> rBGPS
-rDHT --> rBGPS
-end
+The responsibility of deduplication is encapsulated by the P2P module, As such duplicate messages may come from multiple routers in some of these scenarios.
 
-rHost -. ""3 (setStreamHandler())"" .-> hs[[handleStream]]
+```mermaid
+classDiagram
+    class RainTreeMessage {
+        <<protobuf>>
+        +Level uint32
+        +Data []byte
+    }
+
+    class BackgroundMessage {
+        <<protobuf>>
+        +Data []byte
+    }
+    
+    class PocketEnvelope {
+        <<protobuf>>
+        +Content *anypb.Any
+        +Nonce uint64
+    }
+
+    RainTreeMessage --* PocketEnvelope : serialized as `Data`
+    BackgroundMessage --* PocketEnvelope : serialized as `Data`
+    
+    
+    class p2pModule {
+        -handlePocketEnvelope([]byte) error
+    }
+
+    class P2PModule {
+        <<interface>>
+        GetAddress() (Address, error)
+        HandleEvent(*anypb.Any) error
+        Send([]byte, address Address) error
+        Broadcast([]byte) error
+    }
+    p2pModule --|> P2PModule
+
+    class RainTreeRouter {
+        UnicastRouter
+        -handler MessageHandler
+        +Broadcast([]byte) error
+        -handleRainTreeMsg([]byte) error
+    }
+
+    class NonceDeduper {
+        Push(Nonce) error
+        Contains(Nonce) bool
+    }
+
+  class Bus {
+    <<interface>>
+    PublishEventToBus(PocketEnvelope)
+    GetBusEvent() PocketEnvelope
+  }
+  p2pModule --> Bus
+
+    class BackgroundRouter {
+        UnicastRouter
+        -handler MessageHandler
+        +Broadcast([]byte) error
+        -handleBackgroundMsg([]byte) error
+        -readSubscription(subscription *pubsub.Subscription)
+    }
+
+    class UnicastRouter {
+        -messageHandler MessageHandler
+        -peerHandler PeerHandler
+        +Send([]byte, address Address) error
+        -handleStream(stream libp2pNetwork.Stream)
+        -readStream(stream libp2pNetwork.Stream)
+    }
+    RainTreeRouter --* UnicastRouter : (embedded)
+    BackgroundRouter --* UnicastRouter : (embedded)
+
+    p2pModule ..* RainTreeRouter
+    RainTreeRouter --o RainTreeMessage
+    
+    p2pModule ..* BackgroundRouter
+    BackgroundRouter --o BackgroundMessage
+
+    p2pModule --o PocketEnvelope
+    p2pModule --* NonceDeduper
+```
 
-hs --4a--> rRT
-hs --4b--> rBG
-rBG  --""5a (cont. propagation)""--> rHost
-linkStyle 11 stroke:#ff3
-rRT  --""5b (cont. propagation)""--> rHost
-linkStyle 12 stroke:#ff3
-end
+### Peer Discovery
+Peer discovery involves pairing peer IDs to their network addresses (multiaddr).
+This pairing always has an associated TTL (time-to-live), near the end of which it must
+be refreshed.
+
+In the background gossip overlay network (`backgroundRouter`), peers will re-advertise themselves 7/8th through their TTL.",p2p/README.md,2023-07-03 23:28:36+00:00,2023-07-03T23:30:13Z,What do you mean by 7/8th?,,,,,428,RIGHT,463,,line,https://api.github.com/repos/pokt-network/pocket/pulls/732,pokt-network/pocket,6b875eee002f49c4b1abe5ac9faa61f59daaa4cf
https://api.github.com/repos/pokt-network/pocket/pulls/732,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1251337249,Olshansk,4602283cbd676952b2a5c20f73758305cc833ce5,6fde86f231f3a1866c34e668ac226f4a6adb05d6,"@@ -67,105 +66,431 @@ flowchart TD
     class PN pocket_network
 ```
 
-`Routers` is where [RainTree](https://github.com/pokt-network/pocket/files/9853354/raintree.pdf) (or the simpler basic approach) is implemented. See `raintree/router.go` for the specific implementation of RainTree, but please refer to the [specifications](https://github.com/pokt-network/pocket-network-protocol/tree/main/p2p) for more details.
+`Routers` is where [RainTree](https://github.com/pokt-network/pocket/files/9853354/raintree.pdf) is implemented.
+See [`raintree/router.go`](./raintree/router.go) for the specific implementation of RainTree, but please refer to the [specifications](https://github.com/pokt-network/pocket-network-protocol/tree/main/p2p) for more details.
 
-### Raintree Router Architecture
+## Module Architecture
 
-_DISCUSS(team): If you feel this needs a diagram, please reach out to the team for additional details._
-_TODO(olshansky, BenVan): Link to RainTree visualizations once it is complete._
+### Legends
+```mermaid
+flowchart
+subgraph Legend
+    m[[`Method`]]
+    c[Component]
+
+    m -- ""unconditional usage"" --> c
+    m -. ""conditional usage"" .-> c
+    m -. ""ignored"" .-x c
+end
+```
+
+```mermaid
+classDiagram
+class ConcreteType {
+  +ExportedField
+  -unexportedField
+  +ExportedMethod(argType) returnType
+  -unexportedMethod()
+}
+
+class InterfaceType {
+    <<interface>>
+    +Method(argType) (returnType1, returnType2)
+}
+
+ConcreteType --|> InterfaceType : Interface realization
+
+ConcreteType --> OtherType : Direct usage
+ConcreteType --o OtherType : Composition
+ConcreteType --* OtherType : Aggregatation
+ConcreteType ..*  ""(cardinality)"" OtherType : Indirect (via interface)
+```
+
+### P2P Module / Router Decoupling
 
-### Message Propagation
+The P2P module encapsulates the `RaiTreeRouter` and `BackgroundRouter` submodules.
+The P2P module internally refers to these as the `stakedActorRouter` and `unstakedActorRouter`, respectively.
 
-Given `Local P2P Module` has a message that it needs to propagate:
+Depending on the necessary routing scheme (unicast / broadcast) and whether the peers involved are staked actors, a node will use one or both of these routers.
 
-<ul style=""list-style-type: none;"">
-    <li>1a. <code>Raintree Router</code> selects targets from the <code>Pokt Peerstore</code>, <strong>which only includes staked actors</strong></li>
-    <li>1b. <code>Background Router</code> selects targets from the libp2p <code>Peerstore</code>, <strong>which includes all P2P participants</strong></li>
-    <li>2. Libp2p <code>Host</code> manages opening and closing streams to targeted peers</li>
-    <li>3. <code>Remote P2P module</code>'s (i.e. receiver's) <code>handleStream</code> is called (having been registered via <code>setStreamHandler()</code>)</li>
-    <li>4a. <code>handleStream</code> propagates message via <code>Raintree Router</code></li>
-    <li>4b. <code>handleStream</code> propagates message via <code>Background Router</code></li>
-    <li>5a. Repeat step 1a from <code>Remote P2P Module</code>'s perspective targeting its next peers</li>
-    <li>5b. Repeat step 1b from <code>Remote P2P Module</code>'s perspective targeting its next peers</li>
-</ul>
+**Unicast**
+
+| Sender         | Receiver       | Router          | Example Usage                                        |
+|----------------|----------------|-----------------|------------------------------------------------------|
+| Staked Actor   | Staked Actor   | Raintree only   | Consensus (state sync) messages (to validators only) |
+| Unstaked Actor | Staked Actor   | Background only | Consensus (state sync) messages (to validators only) |
+| Unstaked Actor | Unstaked Actor | Background only | Consensus (state sync) & Debug (CLI) messages        |
+
+**Broadcast**
+
+| Broadcaster    | Receiver       | Router                | Example Usage                              |
+|----------------|----------------|-----------------------|--------------------------------------------|
+| Staked Actor   | Staked Actor   | Raintree + Background | Utility tx messages                        |
+| Unstaked Actor | Staked Actor   | Background only       | Utility tx messages (gossipsub redundancy) |
+| Unstaked Actor | Unstaked Actor | Background only       | Utility tx messages                        |
+
+Both router submodule implementations embed a `UnicastRouter` which enables them to send and receive messages directly to/from a single peer.
+
+**Class Diagram**
 
 ```mermaid
-flowchart TD
-  subgraph lMod[Local P2P Module]
-    subgraph lHost[Libp2p `Host`]
+classDiagram
+    class p2pModule {
+        -stakedActorRouter Router
+        -unstakedActorRouter Router
+        -handlePocketEnvelope([]byte) error
+    }
+
+    class P2PModule {
+        <<interface>>
+        GetAddress() (Address, error)
+        HandleEvent(*anypb.Any) error
+        Send([]byte, Address) error
+        Broadcast([]byte) error
+    }
+    p2pModule --|> P2PModule
+
+    class RainTreeRouter {
+        UnicastRouter
+        -handler MessageHandler
+        +Broadcast([]byte) error
+        -handleRainTreeMsg([]byte) error
+    }
+
+    class BackgroundRouter {
+        UnicastRouter
+        -handler MessageHandler
+        +Broadcast([]byte) error
+        -handleBackgroundMsg([]byte) error
+        -readSubscription(subscription *pubsub.Subscription)
+    }
+
+    class UnicastRouter {
+        -messageHandler MessageHandler
+        -peerHandler PeerHandler
+        +Send([]byte, Address) error
+        -handleStream(libp2pNetwork.Stream)
+        -readStream(libp2pNetwork.Stream)
+    }
+    RainTreeRouter --* UnicastRouter : (embedded)
+    BackgroundRouter --* UnicastRouter : (embedded)
+
+    p2pModule --o ""2"" Router
+    p2pModule ..* RainTreeRouter : (`stakedActorRouter`)
+    p2pModule ..* BackgroundRouter : (`unstakedActorRouter`)
+    
+    class Router {
+        <<interface>>
+        +Send([]byte, Address) error
+        +Broadcast([]byte) error
+    }
+    BackgroundRouter --|> Router
+    RainTreeRouter --|> Router
+```
+
+### Message Propagation & Handling
+
+**Unicast**
+
+```mermaid
+flowchart
+    subgraph lp2p[""Local P2P Module (outgoing)""]
+        lps[[`Send`]]
+        lps -. ""(iff local & remote peer are staked)"" ..-> lrtu
+        lps -. ""(if local or remote peer are not staked)"" .-> lbgu
+
+        lbgu -- ""opens stream\nto target peer"" ---> lhost
+
+        lhost[Libp2p Host]
+
+        subgraph lrt[RainTree Router]
+            subgraph lRTPS[Raintree Peerstore]
+              lStakedPS([staked actors only])
+            end
+            
+            lrtu[UnicastRouter]
+
+            lrtu -- ""network address lookup"" --> lRTPS
+        end
+
+        lrtu -- ""opens a stream\nto target peer"" ---> lhost
+
+        subgraph lbg[Background Router]
+            lbgu[UnicastRouter]
+            subgraph lBGPS[Background Peerstore]
+              lNetPS([all P2P participants])
+            end
+
+            lbgu -- ""network address lookup"" --> lBGPS
+        end
+    end
+
+    subgraph rp2p[""Remote P2P Module (incoming)""]
+        rhost[Libp2p Host]
+
+        subgraph rrt[RainTree Router]
+            rrth[[`RainTreeMessage` Handler]]
+            rrtu[UnicastRouter]
+        end
+
+        subgraph rbg[Background Router]
+            rbgh[[`BackgroundMessage` Handler]]
+            rbgu[UnicastRouter]
+            rbgu --> rbgh
+        end
+
+        rp2ph[[`PocketEnvelope` Handler]]
+        rbus[bus]
+        rhost -. ""new stream"" .-> rrtu
+        rhost -- ""new subscription message"" --> rbgu
+        rrtu --> rrth
+
+        rnd[Nonce Deduper]
+        rp2ph -- ""deduplicate msg mempool"" --> rnd
     end
-    subgraph lRT[Raintree Router]
+
+
+    rp2ph -. ""(iff not duplicate msg)\npublish event"" .-> rbus
+
+    rrth --> rp2ph
+    rbgh --> rp2ph
+
+    lhost --> rhost
+```
+
+**Broadcast**
+
+```mermaid
+flowchart
+  subgraph lp2p[""Local P2P Module (outgoing)""]
+    lpb[[`Broadcast`]]
+    lpb -. ""(iff local & remote peer are staked)"" ..-> lrtu
+    lpb -- ""(always)"" --> lbggt
+    
+    lbggt -- ""msg published\n(gossipsub protocol)"" ---> lhost
+    
+    lhost[Libp2p Host]
+
+    subgraph lrt[RainTree Router]
       subgraph lRTPS[Raintree Peerstore]
         lStakedPS([staked actors only])
       end
-
-      subgraph lPM[PeerManager]
-      end
-      lPM --> lRTPS
+      
+      lrtu[UnicastRouter]
+      
+      lrtu -- ""network address lookup"" --> lRTPS
     end
+    
+    lrtu -- ""opens a stream\nto target peer"" ---> lhost
 
-    subgraph lBG[Background Router]
+    subgraph lbg[Background Router]
+      lbggt[Gossipsub Topic]
       subgraph lBGPS[Background Peerstore]
         lNetPS([all P2P participants])
       end
+      
+      lbggt -- ""network address lookup"" --> lBGPS
+    end
+  end
 
-      subgraph lGossipSub[GossipSub]
-      end
+  subgraph rp2p[""Remote P2P Module (incoming)""]
+    rhost[Libp2p Host]
 
-      subgraph lDHT[Kademlia DHT]
-      end
+    subgraph rrt[RainTree Router]
+      rrth[[`RainTreeMessage` Handler]]
+      rrtu[UnicastRouter]
+    end
 
-      lGossipSub --> lBGPS
-      lDHT --> lBGPS
+    subgraph rbg[Background Router]
+      rbgh[[`BackgroundMessage` Handler]]
+      rbgg[Gossipsub Subscription]
+      rbggt[Gossipsub Topic]
+      rbgg --> rbgh
+      rbgh -- ""(background msg\npropagation cont.)"" ---> rbggt
     end
 
-    lRT --1a--> lHost
-    lBG --1b--> lHost
+    rp2ph[[`PocketEnvelope` Handler]]
+    rbus[bus]
+    rhost -. ""new stream"" ..-> rrtu
+    rhost -- ""new subscription message"" --> rbgg
+    rbggt -- ""(background msg\npropagation cont.)"" --> rhost
+    rrtu --> rrth
+    rrth -. ""(iff level > 0)\n(raintree msg\npropagation cont.)"" .-> rrtu
+    rrtu -- ""(raintree msg\npropagation cont.)"" --> rhost
+
+    rnd[Nonce Deduper]
+    rp2ph -- ""deduplicate msg mempool"" --> rnd
   end
 
-subgraph rMod[Remote P2P Module]
-subgraph rHost[Libp2p `Host`]
-end
-subgraph rRT[Raintree Router]
-subgraph rPS[Raintree Peerstore]
-rStakedPS([staked actors only])
-end
 
-subgraph rPM[PeerManager]
-end
+  rp2ph -. ""(iff not duplicate msg)\npublish event"" .-> rbus
 
-rPM --> rStakedPS
-end
+  rrth --> rp2ph
+  rbgh --> rp2ph
 
-subgraph rBG[Background Router]
-subgraph rBGPS[Background Peerstore]
-rNetPS([all P2P participants])
-end
+  lhost --> rhost
+```
 
-subgraph rGossipSub[GossipSub]
-end
+### Message Deduplication
 
-subgraph rDHT[Kademlia DHT]
-end
+Messages MUST be deduplicated before broadcasting their respective event over the bus since it is expected that nodes will receive duplicate messages (for multiple reasons).
 
-rGossipSub --> rBGPS
-rDHT --> rBGPS
-end
+The responsibility of deduplication is encapsulated by the P2P module, As such duplicate messages may come from multiple routers in some of these scenarios.
 
-rHost -. ""3 (setStreamHandler())"" .-> hs[[handleStream]]
+```mermaid
+classDiagram
+    class RainTreeMessage {
+        <<protobuf>>
+        +Level uint32
+        +Data []byte
+    }
+
+    class BackgroundMessage {
+        <<protobuf>>
+        +Data []byte
+    }
+    
+    class PocketEnvelope {
+        <<protobuf>>
+        +Content *anypb.Any
+        +Nonce uint64
+    }
+
+    RainTreeMessage --* PocketEnvelope : serialized as `Data`
+    BackgroundMessage --* PocketEnvelope : serialized as `Data`
+    
+    
+    class p2pModule {
+        -handlePocketEnvelope([]byte) error
+    }
+
+    class P2PModule {
+        <<interface>>
+        GetAddress() (Address, error)
+        HandleEvent(*anypb.Any) error
+        Send([]byte, address Address) error
+        Broadcast([]byte) error
+    }
+    p2pModule --|> P2PModule
+
+    class RainTreeRouter {
+        UnicastRouter
+        -handler MessageHandler
+        +Broadcast([]byte) error
+        -handleRainTreeMsg([]byte) error
+    }
+
+    class NonceDeduper {
+        Push(Nonce) error
+        Contains(Nonce) bool
+    }
+
+  class Bus {
+    <<interface>>
+    PublishEventToBus(PocketEnvelope)
+    GetBusEvent() PocketEnvelope
+  }
+  p2pModule --> Bus
+
+    class BackgroundRouter {
+        UnicastRouter
+        -handler MessageHandler
+        +Broadcast([]byte) error
+        -handleBackgroundMsg([]byte) error
+        -readSubscription(subscription *pubsub.Subscription)
+    }
+
+    class UnicastRouter {
+        -messageHandler MessageHandler
+        -peerHandler PeerHandler
+        +Send([]byte, address Address) error
+        -handleStream(stream libp2pNetwork.Stream)
+        -readStream(stream libp2pNetwork.Stream)
+    }
+    RainTreeRouter --* UnicastRouter : (embedded)
+    BackgroundRouter --* UnicastRouter : (embedded)
+
+    p2pModule ..* RainTreeRouter
+    RainTreeRouter --o RainTreeMessage
+    
+    p2pModule ..* BackgroundRouter
+    BackgroundRouter --o BackgroundMessage
+
+    p2pModule --o PocketEnvelope
+    p2pModule --* NonceDeduper
+```
 
-hs --4a--> rRT
-hs --4b--> rBG
-rBG  --""5a (cont. propagation)""--> rHost
-linkStyle 11 stroke:#ff3
-rRT  --""5b (cont. propagation)""--> rHost
-linkStyle 12 stroke:#ff3
-end
+### Peer Discovery
+Peer discovery involves pairing peer IDs to their network addresses (multiaddr).
+This pairing always has an associated TTL (time-to-live), near the end of which it must
+be refreshed.
+
+In the background gossip overlay network (`backgroundRouter`), peers will re-advertise themselves 7/8th through their TTL.
+This refreshes the libp2p peerstore automatically.
+
+In the raintree gossip overlay network (`raintreeRouter`), the libp2p peerstore is **NOT** currently refreshed _(TODO: [#859](https://github.com/pokt-network/network/isues/859))_.
+
+```mermaid
+flowchart TD
+  subgraph bus
+  end
+  
+  subgraph pers[Persistence Module]
+  end
+
+  subgraph cons[Consensus Module]
+  end
 
-lHost --2--> rHost
+  cons -- ""(staked actor set changed)\npublish event"" --> bus
+  bus --> rPM
+  rPM -- ""get staked actors\nat current height"" --> pers
+
+  subgraph p2p[""P2P Module""]
+    host[Libp2p Host]
+    host -- ""incoming\nraintree message"" --> rtu
+    host -- ""incoming\nbackground message"" --> bgu
+    host -- ""incoming\ntopic message"" --> bgr
+    host -- ""DHT peer discovery"" --> rDHT
+  
+    subgraph rt[RainTree Router]
+      subgraph rPS[Raintree Peerstore]
+        rStakedPS([staked actors only])
+      end
+
+      subgraph rPM[PeerManager]
+      end
+
+      rtu[UnicastRouter]
+      
+      rPM -- ""synchronize\n(add/remove)"" --> rPS
+      rtu -. ""(no discovery)"" .-x rPS
+    end
+
+    subgraph bg[Background Router]
+      subgraph rBGPS[Background Peerstore]
+        rNetPS([all P2P participants])
+      end
+
+      subgraph bgr[GossipSub Topic\nSubscription]
+      end
+
+      subgraph rDHT[Kademlia DHT]
+      end
+
+      bgu -- ""add if new"" --> rBGPS
+      bgr -- ""add if new"" --> rBGPS
+      rDHT -- ""continuous import"" --> rBGPS
+         
+      bgu[UnicastRouter]
+    end
+
+  end
 ```",p2p/README.md,2023-07-03 23:29:52+00:00,2023-07-03T23:30:13Z,"I glossed over the remaining diagrams and makes sense to me (at a high level) but just notifying that there might be micro-typos I haven't caught.

It'll be super useful for anyone (myself included) when debugging and jumping into P2P",,,,568.0,488,RIGHT,524,604.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/732,pokt-network/pocket,6b875eee002f49c4b1abe5ac9faa61f59daaa4cf
https://api.github.com/repos/pokt-network/pocket/pulls/732,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1251722903,bryanchriswhite,4602283cbd676952b2a5c20f73758305cc833ce5,6fde86f231f3a1866c34e668ac226f4a6adb05d6,"@@ -180,38 +176,102 @@ func (m *p2pModule) Start() (err error) {
 }
 
 func (m *p2pModule) Stop() error {
-	err := m.host.Close()
+	m.logger.Debug().Msg(""stopping P2P module"")
+
+	if !m.started.CompareAndSwap(true, false) {
+		return fmt.Errorf(""p2p module already stopped"")
+	}
+
+	var stakedActorRouterCloseErr error
+	if m.stakedActorRouter != nil {
+		stakedActorRouterCloseErr = m.stakedActorRouter.Close()
+	}
+
+	routerCloseErrs := multierr.Append(
+		m.unstakedActorRouter.Close(),
+		stakedActorRouterCloseErr,
+	)
+
+	err := multierr.Append(
+		routerCloseErrs,
+		m.host.Close(),
+	)
 
 	// Don't reuse closed host, `#Start()` will re-create.
 	m.host = nil
+	m.stakedActorRouter = nil
+	m.unstakedActorRouter = nil
 	return err
 }
 
 func (m *p2pModule) Broadcast(msg *anypb.Any) error {
-	c := &messaging.PocketEnvelope{
+	isStaked, err := m.isStakedActor()
+	if err != nil {
+		return err
+	}
+
+	if isStaked {
+		if m.stakedActorRouter == nil {
+			return fmt.Errorf(""staked actor router not started"")
+		}
+	}
+
+	if m.unstakedActorRouter == nil {
+		return fmt.Errorf(""unstaked actor router not started"")",p2p/module.go,2023-07-04 08:58:38+00:00,2023-07-04T08:58:38Z,"```suggestion
		return fmt.Errorf(""broadcasting: unstaked actor router not started"")
```",,,,,220,RIGHT,139,,line,https://api.github.com/repos/pokt-network/pocket/pulls/732,pokt-network/pocket,6b875eee002f49c4b1abe5ac9faa61f59daaa4cf
https://api.github.com/repos/pokt-network/pocket/pulls/732,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1251837041,bryanchriswhite,4602283cbd676952b2a5c20f73758305cc833ce5,6fde86f231f3a1866c34e668ac226f4a6adb05d6,"@@ -199,6 +219,14 @@ func createMockBus(t *testing.T, runtimeMgr modules.RuntimeMgr) *mockModules.Moc
 	mockModulesRegistry.EXPECT().GetModule(peerstore_provider.ModuleName).Return(nil, runtime.ErrModuleNotRegistered(peerstore_provider.ModuleName)).AnyTimes()
 	mockModulesRegistry.EXPECT().GetModule(current_height_provider.ModuleName).Return(nil, runtime.ErrModuleNotRegistered(current_height_provider.ModuleName)).AnyTimes()
 	mockBus.EXPECT().GetModulesRegistry().Return(mockModulesRegistry).AnyTimes()
+	mockBus.EXPECT().PublishEventToBus(gomock.AssignableToTypeOf(&messaging.PocketEnvelope{})).
+		Do(func(envelope *messaging.PocketEnvelope) {
+			fmt.Println(""[valId: unknown] Read"")
+			fmt.Printf(""content type: %s\n"", envelope.Content.GetTypeUrl())
+			if readWriteWaitGroup != nil {
+				readWriteWaitGroup.Done()
+			}
+		}).AnyTimes() // TODO: specific times",p2p/utils_test.go,2023-07-04 10:27:19+00:00,2023-07-04T10:27:19Z,"```suggestion
		}).AnyTimes() // TECHDEBT: assert number of times. Consider `waitForEventsInternal` or similar as in consensus.
```",,,,,229,RIGHT,76,,line,https://api.github.com/repos/pokt-network/pocket/pulls/732,pokt-network/pocket,6b875eee002f49c4b1abe5ac9faa61f59daaa4cf
https://api.github.com/repos/pokt-network/pocket/pulls/732,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1253757894,Olshansk,4f879217cbd947cb98258e447397b7cc8f063884,6fde86f231f3a1866c34e668ac226f4a6adb05d6,"@@ -71,7 +71,22 @@ See [`raintree/router.go`](./raintree/router.go) for the specific implementation
 
 ## Module Architecture
 
+### Architecture Design Language",p2p/README.md,2023-07-05 23:40:04+00:00,2023-07-05T23:46:21Z,Please add a TODO to move this (and the definitions you have below) into `shared` since this text is not just relevant to `p2p`,,,,78.0,74,RIGHT,4,54.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/732,pokt-network/pocket,6b875eee002f49c4b1abe5ac9faa61f59daaa4cf
https://api.github.com/repos/pokt-network/pocket/pulls/732,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1253758605,Olshansk,4f879217cbd947cb98258e447397b7cc8f063884,6fde86f231f3a1866c34e668ac226f4a6adb05d6,"@@ -106,9 +121,48 @@ ConcreteType --* OtherType : Aggregatation
 ConcreteType ..*  ""(cardinality)"" OtherType : Indirect (via interface)
 ```
 
+#### Interface Realization
+",p2p/README.md,2023-07-05 23:41:46+00:00,2023-07-05T23:46:21Z,"```suggestion

_tl;dr An instance (i.e. client) implements an interface (i.e. supplier)_

```",,,,129.0,125,RIGHT,45,120.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/732,pokt-network/pocket,6b875eee002f49c4b1abe5ac9faa61f59daaa4cf
https://api.github.com/repos/pokt-network/pocket/pulls/732,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1253759012,Olshansk,4f879217cbd947cb98258e447397b7cc8f063884,6fde86f231f3a1866c34e668ac226f4a6adb05d6,"@@ -106,9 +121,48 @@ ConcreteType --* OtherType : Aggregatation
 ConcreteType ..*  ""(cardinality)"" OtherType : Indirect (via interface)
 ```
 
+#### Interface Realization
+
+> Realization is a specialized abstraction relationship between two sets of model elements, one representing a specification (the supplier) and the other represents an implementation of the latter (the client).
+
+> Realization can be used to model stepwise refinement, optimizations, transformations, templates, model synthesis, framework composition, etc.
+
+_(see: [UML Realization](https://www.uml-diagrams.org/realization.html))_
+
+#### Direct Usage
+",p2p/README.md,2023-07-05 23:42:35+00:00,2023-07-05T23:46:21Z,"```suggestion

_tl;dr One instance (i.e. client) is dependant on another instance (i.e. supplier) to function properly. _ 

```",,,,139.0,133,RIGHT,53,130.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/732,pokt-network/pocket,6b875eee002f49c4b1abe5ac9faa61f59daaa4cf
https://api.github.com/repos/pokt-network/pocket/pulls/732,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1253759301,Olshansk,4f879217cbd947cb98258e447397b7cc8f063884,6fde86f231f3a1866c34e668ac226f4a6adb05d6,"@@ -106,9 +121,48 @@ ConcreteType --* OtherType : Aggregatation
 ConcreteType ..*  ""(cardinality)"" OtherType : Indirect (via interface)
 ```
 
+#### Interface Realization
+
+> Realization is a specialized abstraction relationship between two sets of model elements, one representing a specification (the supplier) and the other represents an implementation of the latter (the client).
+
+> Realization can be used to model stepwise refinement, optimizations, transformations, templates, model synthesis, framework composition, etc.
+
+_(see: [UML Realization](https://www.uml-diagrams.org/realization.html))_
+
+#### Direct Usage
+
+> Dependency is a directed relationship which is used to show that some UML element or a set of elements requires, needs or depends on other model elements for specification or implementation. Because of this, dependency is called a supplier - client relationship, where supplier provides something to the client, and thus the client is in some sense incomplete while semantically or structurally dependent on the supplier element(s). Modification of the supplier may impact the client elements.
+
+> Usage is a dependency in which one named element (client) requires another named element (supplier) for its full definition or implementation.
+
+_(see: [UML Dependency](https://www.uml-diagrams.org/dependency.html))_
+
+#### Composition
+",p2p/README.md,2023-07-05 23:43:18+00:00,2023-07-05T23:46:21Z,"```suggestion

_tl;dr Deleting an instance also deletes all the instances it holds_

```",,,,149.0,141,RIGHT,61,140.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/732,pokt-network/pocket,6b875eee002f49c4b1abe5ac9faa61f59daaa4cf
https://api.github.com/repos/pokt-network/pocket/pulls/732,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1253759436,Olshansk,4f879217cbd947cb98258e447397b7cc8f063884,6fde86f231f3a1866c34e668ac226f4a6adb05d6,"@@ -106,9 +121,48 @@ ConcreteType --* OtherType : Aggregatation
 ConcreteType ..*  ""(cardinality)"" OtherType : Indirect (via interface)
 ```
 
+#### Interface Realization
+
+> Realization is a specialized abstraction relationship between two sets of model elements, one representing a specification (the supplier) and the other represents an implementation of the latter (the client).
+
+> Realization can be used to model stepwise refinement, optimizations, transformations, templates, model synthesis, framework composition, etc.
+
+_(see: [UML Realization](https://www.uml-diagrams.org/realization.html))_
+
+#### Direct Usage
+
+> Dependency is a directed relationship which is used to show that some UML element or a set of elements requires, needs or depends on other model elements for specification or implementation. Because of this, dependency is called a supplier - client relationship, where supplier provides something to the client, and thus the client is in some sense incomplete while semantically or structurally dependent on the supplier element(s). Modification of the supplier may impact the client elements.
+
+> Usage is a dependency in which one named element (client) requires another named element (supplier) for its full definition or implementation.
+
+_(see: [UML Dependency](https://www.uml-diagrams.org/dependency.html))_
+
+#### Composition
+
+> A ""strong"" form of aggregation
+
+> If a composite (whole) is deleted, all of its composite parts are ""normally"" deleted with it.
+
+_(see: [UML Shared composition](https://www.uml-diagrams.org/composition.html))_
+
+#### Aggregation
+",p2p/README.md,2023-07-05 23:43:40+00:00,2023-07-05T23:46:21Z,"```suggestion

_tl;dr Deleting an instance does not necessarily delete instances it depends on_


```",,,,159.0,149,RIGHT,69,150.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/732,pokt-network/pocket,6b875eee002f49c4b1abe5ac9faa61f59daaa4cf
https://api.github.com/repos/pokt-network/pocket/pulls/732,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1253759645,Olshansk,4f879217cbd947cb98258e447397b7cc8f063884,6fde86f231f3a1866c34e668ac226f4a6adb05d6,"@@ -106,9 +121,48 @@ ConcreteType --* OtherType : Aggregatation
 ConcreteType ..*  ""(cardinality)"" OtherType : Indirect (via interface)
 ```
 
+#### Interface Realization
+
+> Realization is a specialized abstraction relationship between two sets of model elements, one representing a specification (the supplier) and the other represents an implementation of the latter (the client).
+
+> Realization can be used to model stepwise refinement, optimizations, transformations, templates, model synthesis, framework composition, etc.
+
+_(see: [UML Realization](https://www.uml-diagrams.org/realization.html))_
+
+#### Direct Usage
+
+> Dependency is a directed relationship which is used to show that some UML element or a set of elements requires, needs or depends on other model elements for specification or implementation. Because of this, dependency is called a supplier - client relationship, where supplier provides something to the client, and thus the client is in some sense incomplete while semantically or structurally dependent on the supplier element(s). Modification of the supplier may impact the client elements.
+
+> Usage is a dependency in which one named element (client) requires another named element (supplier) for its full definition or implementation.
+
+_(see: [UML Dependency](https://www.uml-diagrams.org/dependency.html))_
+
+#### Composition
+
+> A ""strong"" form of aggregation
+
+> If a composite (whole) is deleted, all of its composite parts are ""normally"" deleted with it.
+
+_(see: [UML Shared composition](https://www.uml-diagrams.org/composition.html))_
+
+#### Aggregation
+
+> A ""weak"" form of composition
+
+> Shared part could be included in several composites, and if some or all of the composites are deleted, shared part may still exist.
+
+_(see: [UML Shared aggregation](https://www.uml-diagrams.org/aggregation.html))_
+
+#### Cardinality
+",p2p/README.md,2023-07-05 23:44:17+00:00,2023-07-05T23:46:21Z,"```suggestion

_tl;dr An M:N relationship defines how M instances of one type work with N instances of another type._

```",,,,170.0,157,RIGHT,77,161.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/732,pokt-network/pocket,6b875eee002f49c4b1abe5ac9faa61f59daaa4cf
https://api.github.com/repos/pokt-network/pocket/pulls/732,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1254315920,bryanchriswhite,8c0b8c3b0702bbfe0d920e0f8ff8803ad36acf67,6fde86f231f3a1866c34e668ac226f4a6adb05d6,"@@ -50,7 +57,7 @@ func (m *p2pModule) HandleEvent(event *anypb.Any) error {
 		m.logger.Debug().Fields(messaging.TransitionEventToMap(stateMachineTransitionEvent)).Msg(""Received state machine transition event"")
 
 		if stateMachineTransitionEvent.NewState == string(coreTypes.StateMachineState_P2P_Bootstrapping) {
-			if m.router.GetPeerstore().Size() == 0 {
+			if m.stakedActorRouter.GetPeerstore().Size() == 0 {",p2p/event_handler.go,2023-07-06 11:39:40+00:00,2023-07-06T11:39:40Z,need to check `m.isStakedActor()` here...,,,,,60,RIGHT,48,,line,https://api.github.com/repos/pokt-network/pocket/pulls/732,pokt-network/pocket,6b875eee002f49c4b1abe5ac9faa61f59daaa4cf
https://api.github.com/repos/pokt-network/pocket/pulls/732,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1254998224,Olshansk,8c0b8c3b0702bbfe0d920e0f8ff8803ad36acf67,6fde86f231f3a1866c34e668ac226f4a6adb05d6,"@@ -114,6 +123,73 @@ func TestBackgroundRouter_RemovePeer(t *testing.T) {
 	require.Len(t, existingPeerstoreAddrs, 1)
 }
 
+func TestBackgroundRouter_Validation(t *testing.T) {
+	ctx := context.Background()
+	libp2pMockNet := mocknet.New()
+
+	invalidWireFormatData := []byte(""test message"")",p2p/background/router_test.go,2023-07-06 22:50:34+00:00,2023-07-06T22:56:38Z,"```suggestion
	invalidWireFormatData := []byte(""not a serialized proto"")
```",,,,,130,RIGHT,62,,line,https://api.github.com/repos/pokt-network/pocket/pulls/732,pokt-network/pocket,6b875eee002f49c4b1abe5ac9faa61f59daaa4cf
https://api.github.com/repos/pokt-network/pocket/pulls/732,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1254998430,Olshansk,8c0b8c3b0702bbfe0d920e0f8ff8803ad36acf67,6fde86f231f3a1866c34e668ac226f4a6adb05d6,"@@ -114,6 +123,73 @@ func TestBackgroundRouter_RemovePeer(t *testing.T) {
 	require.Len(t, existingPeerstoreAddrs, 1)
 }
 
+func TestBackgroundRouter_Validation(t *testing.T) {
+	ctx := context.Background()
+	libp2pMockNet := mocknet.New()
+
+	invalidWireFormatData := []byte(""test message"")
+	invalidPocketEnvelope := &anypb.Any{
+		TypeUrl: ""/test"",",p2p/background/router_test.go,2023-07-06 22:50:49+00:00,2023-07-06T22:56:38Z,"```suggestion
		TypeUrl: ""/notADefinedProtoMessage"",
```",,,,,132,RIGHT,64,,line,https://api.github.com/repos/pokt-network/pocket/pulls/732,pokt-network/pocket,6b875eee002f49c4b1abe5ac9faa61f59daaa4cf
https://api.github.com/repos/pokt-network/pocket/pulls/732,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1254999127,Olshansk,8c0b8c3b0702bbfe0d920e0f8ff8803ad36acf67,6fde86f231f3a1866c34e668ac226f4a6adb05d6,"@@ -114,6 +123,73 @@ func TestBackgroundRouter_RemovePeer(t *testing.T) {
 	require.Len(t, existingPeerstoreAddrs, 1)
 }
 
+func TestBackgroundRouter_Validation(t *testing.T) {
+	ctx := context.Background()
+	libp2pMockNet := mocknet.New()
+
+	invalidWireFormatData := []byte(""test message"")
+	invalidPocketEnvelope := &anypb.Any{
+		TypeUrl: ""/test"",
+		Value:   invalidWireFormatData,
+	}
+	invalidPocketEnvelopeBz, err := proto.Marshal(invalidPocketEnvelope)
+	require.NoError(t, err)
+
+	invalidMessages := [][]byte{
+		invalidWireFormatData,
+		invalidPocketEnvelopeBz,
+	}
+
+	receivedChan := make(chan struct{})
+
+	receiverPrivKey, receiverPeer := newTestPeer(t)
+	receiverHost := newTestHost(t, libp2pMockNet, receiverPrivKey)
+	receiverRouter := newRouterWithSelfPeerAndHost(t, receiverPeer, receiverHost, func(data []byte) error {
+		receivedChan <- struct{}{}
+		return nil
+	})
+
+	t.Cleanup(func() {
+		err := receiverRouter.Close()
+		require.NoError(t, err)
+	})
+
+	senderPrivKey, _ := newTestPeer(t)
+	senderHost := newTestHost(t, libp2pMockNet, senderPrivKey)
+	gossipPubsub, err := pubsub.NewGossipSub(ctx, senderHost)
+	require.NoError(t, err)
+
+	err = libp2pMockNet.LinkAll()
+	require.NoError(t, err)
+
+	receiverAddrInfo, err := utils.Libp2pAddrInfoFromPeer(receiverPeer)
+	require.NoError(t, err)
+
+	err = senderHost.Connect(ctx, receiverAddrInfo)
+	require.NoError(t, err)
+
+	topic, err := gossipPubsub.Join(protocol.BackgroundTopicStr)
+	require.NoError(t, err)
+
+	for _, invalidMessageBz := range invalidMessages {
+		err = topic.Publish(ctx, invalidMessageBz)
+		require.NoError(t, err)
+	}
+
+	select {
+	case <-time.After(time.Second * 2):
+		// TECHDEBT: find a better way to prove that pre-propagation validation
+		// works as expected. Ideally, we should be able to distinguish which",p2p/background/router_test.go,2023-07-06 22:52:14+00:00,2023-07-06T22:56:38Z,"Wdym by `Ideally, we should be able to distinguish which invalid message was received in the event of failure.`

Can't we filter based on the message type/content?",,,,,182,RIGHT,114,,line,https://api.github.com/repos/pokt-network/pocket/pulls/732,pokt-network/pocket,6b875eee002f49c4b1abe5ac9faa61f59daaa4cf
https://api.github.com/repos/pokt-network/pocket/pulls/732,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1254999449,Olshansk,8c0b8c3b0702bbfe0d920e0f8ff8803ad36acf67,6fde86f231f3a1866c34e668ac226f4a6adb05d6,"@@ -114,6 +123,73 @@ func TestBackgroundRouter_RemovePeer(t *testing.T) {
 	require.Len(t, existingPeerstoreAddrs, 1)
 }
 
+func TestBackgroundRouter_Validation(t *testing.T) {
+	ctx := context.Background()
+	libp2pMockNet := mocknet.New()
+
+	invalidWireFormatData := []byte(""test message"")
+	invalidPocketEnvelope := &anypb.Any{
+		TypeUrl: ""/test"",
+		Value:   invalidWireFormatData,
+	}
+	invalidPocketEnvelopeBz, err := proto.Marshal(invalidPocketEnvelope)
+	require.NoError(t, err)
+
+	invalidMessages := [][]byte{
+		invalidWireFormatData,
+		invalidPocketEnvelopeBz,
+	}
+
+	receivedChan := make(chan struct{})
+
+	receiverPrivKey, receiverPeer := newTestPeer(t)
+	receiverHost := newTestHost(t, libp2pMockNet, receiverPrivKey)
+	receiverRouter := newRouterWithSelfPeerAndHost(t, receiverPeer, receiverHost, func(data []byte) error {
+		receivedChan <- struct{}{}
+		return nil
+	})
+
+	t.Cleanup(func() {
+		err := receiverRouter.Close()
+		require.NoError(t, err)
+	})
+
+	senderPrivKey, _ := newTestPeer(t)
+	senderHost := newTestHost(t, libp2pMockNet, senderPrivKey)
+	gossipPubsub, err := pubsub.NewGossipSub(ctx, senderHost)
+	require.NoError(t, err)
+
+	err = libp2pMockNet.LinkAll()
+	require.NoError(t, err)
+
+	receiverAddrInfo, err := utils.Libp2pAddrInfoFromPeer(receiverPeer)
+	require.NoError(t, err)
+
+	err = senderHost.Connect(ctx, receiverAddrInfo)
+	require.NoError(t, err)
+
+	topic, err := gossipPubsub.Join(protocol.BackgroundTopicStr)
+	require.NoError(t, err)
+
+	for _, invalidMessageBz := range invalidMessages {
+		err = topic.Publish(ctx, invalidMessageBz)
+		require.NoError(t, err)
+	}
+
+	select {
+	case <-time.After(time.Second * 2):
+		// TECHDEBT: find a better way to prove that pre-propagation validation
+		// works as expected. Ideally, we should be able to distinguish which
+		// invalid message was received in the event of failure.
+		//
+		// CONSIDERATION: we could use the telemetry module mock to set expectations
+		// for validation failure telemetry calls, which would probably be useful in
+		// their own right.
+	case <-receivedChan:
+		t.Fatal(""expected message to not be received"")",p2p/background/router_test.go,2023-07-06 22:52:55+00:00,2023-07-06T22:56:38Z,"```suggestion
		t.Fatal(""no messages should have been received by the host"")
```",,,,,189,RIGHT,121,,line,https://api.github.com/repos/pokt-network/pocket/pulls/732,pokt-network/pocket,6b875eee002f49c4b1abe5ac9faa61f59daaa4cf
https://api.github.com/repos/pokt-network/pocket/pulls/732,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1254999792,Olshansk,8c0b8c3b0702bbfe0d920e0f8ff8803ad36acf67,6fde86f231f3a1866c34e668ac226f4a6adb05d6,"@@ -138,30 +214,44 @@ func TestBackgroundRouter_Broadcast(t *testing.T) {
 		libp2pMockNet   = mocknet.New()
 	)
 
-	// setup 4 libp2p hosts to listen for incoming streams from the test backgroundRouter
+	testPocketEnvelope, err := messaging.PackMessage(&anypb.Any{
+		TypeUrl: ""/test"",
+		Value:   []byte(testMsg),
+	})
+	require.NoError(t, err)
+
+	testPocketEnvelopeBz, err := proto.Marshal(testPocketEnvelope)
+	require.NoError(t, err)
+
+	// setup 4 receiver routers to listen for incoming messages from the sender router
 	for i := 0; i < numPeers; i++ {
 		broadcastWaitgroup.Add(1)
 		bootstrapWaitgroup.Add(1)
 
-		privKey, selfPeer := newTestPeer(t)
+		privKey, peer := newTestPeer(t)
 		host := newTestHost(t, libp2pMockNet, privKey)
 		testHosts = append(testHosts, host)
 		expectedPeerIDs[i] = host.ID().String()
-		rtr := newRouterWithSelfPeerAndHost(t, selfPeer, host)
-		go readSubscription(t, ctx, &broadcastWaitgroup, rtr, &seenMessagesMutext, seenMessages)
+		newRouterWithSelfPeerAndHost(t, peer, host, func(data []byte) error {
+			seenMessagesMutext.Lock()
+			broadcastWaitgroup.Done()
+			seenMessages[host.ID().String()] = struct{}{}
+			seenMessagesMutext.Unlock()",p2p/background/router_test.go,2023-07-06 22:53:47+00:00,2023-07-06T22:56:38Z,"```suggestion
			seenMessagesMutext.Lock()
			defer seenMessagesMutext.Unlock()
			seenMessages[host.ID().String()] = struct{}{}
			broadcastWaitgroup.Done()
```",,236.0,RIGHT,,239,RIGHT,158,,line,https://api.github.com/repos/pokt-network/pocket/pulls/732,pokt-network/pocket,6b875eee002f49c4b1abe5ac9faa61f59daaa4cf
https://api.github.com/repos/pokt-network/pocket/pulls/732,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1259026877,Olshansk,66afa18ac78651237ed6add951b3ff1e7113fbbc,6fde86f231f3a1866c34e668ac226f4a6adb05d6,"@@ -124,69 +127,112 @@ func TestBackgroundRouter_RemovePeer(t *testing.T) {
 }
 
 func TestBackgroundRouter_Validation(t *testing.T) {
-	ctx := context.Background()
-	libp2pMockNet := mocknet.New()
-
-	invalidWireFormatData := []byte(""test message"")
-	invalidPocketEnvelope := &anypb.Any{
-		TypeUrl: ""/test"",
-		Value:   invalidWireFormatData,
+	invalidProtoMessage := anypb.Any{
+		TypeUrl: ""/notADefinedProtobufType"",
+		Value:   []byte(""not a serialized protobuf""),
 	}
-	invalidPocketEnvelopeBz, err := proto.Marshal(invalidPocketEnvelope)
-	require.NoError(t, err)
 
-	invalidMessages := [][]byte{
-		invalidWireFormatData,
-		invalidPocketEnvelopeBz,
+	testCases := []struct {
+		name  string
+		msgBz []byte
+	}{
+		{
+			name: ""invalid BackgroundMessage"",
+			// NB: `msgBz` would normally be a serialized `BackgroundMessage`.
+			msgBz: mustMarshal(t, &invalidProtoMessage),
+		},
+		{
+			name: ""empty PocketEnvelope"",
+			msgBz: mustMarshal(t, &typesP2P.BackgroundMessage{
+				// NB: `Data` is normally a serialized `PocketEnvelope`.",p2p/background/router_test.go,2023-07-11 00:18:19+00:00,2023-07-11T00:22:55Z,Appreciate the comments 🙌 ,,,,147.0,147,RIGHT,63,80.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/732,pokt-network/pocket,6b875eee002f49c4b1abe5ac9faa61f59daaa4cf
https://api.github.com/repos/pokt-network/pocket/pulls/732,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1259026924,Olshansk,66afa18ac78651237ed6add951b3ff1e7113fbbc,6fde86f231f3a1866c34e668ac226f4a6adb05d6,"@@ -124,69 +127,112 @@ func TestBackgroundRouter_RemovePeer(t *testing.T) {
 }
 
 func TestBackgroundRouter_Validation(t *testing.T) {
-	ctx := context.Background()
-	libp2pMockNet := mocknet.New()
-
-	invalidWireFormatData := []byte(""test message"")
-	invalidPocketEnvelope := &anypb.Any{
-		TypeUrl: ""/test"",
-		Value:   invalidWireFormatData,
+	invalidProtoMessage := anypb.Any{
+		TypeUrl: ""/notADefinedProtobufType"",
+		Value:   []byte(""not a serialized protobuf""),
 	}
-	invalidPocketEnvelopeBz, err := proto.Marshal(invalidPocketEnvelope)
-	require.NoError(t, err)
 
-	invalidMessages := [][]byte{
-		invalidWireFormatData,
-		invalidPocketEnvelopeBz,
+	testCases := []struct {
+		name  string
+		msgBz []byte
+	}{
+		{
+			name: ""invalid BackgroundMessage"",
+			// NB: `msgBz` would normally be a serialized `BackgroundMessage`.
+			msgBz: mustMarshal(t, &invalidProtoMessage),
+		},
+		{
+			name: ""empty PocketEnvelope"",
+			msgBz: mustMarshal(t, &typesP2P.BackgroundMessage{
+				// NB: `Data` is normally a serialized `PocketEnvelope`.
+				Data: nil,
+			}),
+		},
+		{
+			name: ""invalid PoketEnvelope"",
+			msgBz: mustMarshal(t, &typesP2P.BackgroundMessage{
+				// NB: `Data` is normally a serialized `PocketEnvelope`.
+				Data: mustMarshal(t, &invalidProtoMessage),
+			}),
+		},
 	}
 
-	receivedChan := make(chan struct{})
+	// Set up test router as the receiver.
+	ctx := context.Background()
+	libp2pMockNet := mocknet.New()
 
+	receivedChan := make(chan []byte, 1)
 	receiverPrivKey, receiverPeer := newTestPeer(t)
 	receiverHost := newTestHost(t, libp2pMockNet, receiverPrivKey)
-	receiverRouter := newRouterWithSelfPeerAndHost(t, receiverPeer, receiverHost, func(data []byte) error {
-		receivedChan <- struct{}{}
-		return nil
-	})
+	receiverRouter := newRouterWithSelfPeerAndHost(
+		t, receiverPeer,
+		receiverHost,
+		func(data []byte) error {
+			receivedChan <- data",p2p/background/router_test.go,2023-07-11 00:18:26+00:00,2023-07-11T00:22:55Z,Nice change,,,,171.0,171,RIGHT,92,104.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/732,pokt-network/pocket,6b875eee002f49c4b1abe5ac9faa61f59daaa4cf
https://api.github.com/repos/pokt-network/pocket/pulls/732,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1259393528,bryanchriswhite,66afa18ac78651237ed6add951b3ff1e7113fbbc,6fde86f231f3a1866c34e668ac226f4a6adb05d6,"@@ -67,105 +68,506 @@ flowchart TD
     class PN pocket_network
 ```
 
-`Routers` is where [RainTree](https://github.com/pokt-network/pocket/files/9853354/raintree.pdf) (or the simpler basic approach) is implemented. See `raintree/router.go` for the specific implementation of RainTree, but please refer to the [specifications](https://github.com/pokt-network/pocket-network-protocol/tree/main/p2p) for more details.
+`Routers` is where [RainTree](https://github.com/pokt-network/pocket/files/9853354/raintree.pdf) is implemented.
+See [`raintree/router.go`](./raintree/router.go) for the specific implementation of RainTree, but please refer to the [specifications](https://github.com/pokt-network/pocket-network-protocol/tree/main/p2p) for more details.
 
-### Raintree Router Architecture
+## Module Architecture
+
+_(TODO: move ""arch. design lang."" & ""legends"" sections into `shared` to support common usage)_
 
-_DISCUSS(team): If you feel this needs a diagram, please reach out to the team for additional details._
-_TODO(olshansky, BenVan): Link to RainTree visualizations once it is complete._
+### Architecture Design Language
 
-### Message Propagation
+The architecture design language expressed in this documentation is based on [UML](https://www.uml-diagrams.org/).
+Due to limitations in the current version of mermaid, class diagrams are much more adherant to the UML component specification.
+Component diagrams however are much more loosely inspired by their UML counterparts.
 
-Given `Local P2P Module` has a message that it needs to propagate:
+Regardless, each architecture diagram should be accompanied by a legend which covers all the design language features used to provide disambiguation. 
 
-<ul style=""list-style-type: none;"">
-    <li>1a. <code>Raintree Router</code> selects targets from the <code>Pokt Peerstore</code>, <strong>which only includes staked actors</strong></li>
-    <li>1b. <code>Background Router</code> selects targets from the libp2p <code>Peerstore</code>, <strong>which includes all P2P participants</strong></li>
-    <li>2. Libp2p <code>Host</code> manages opening and closing streams to targeted peers</li>
-    <li>3. <code>Remote P2P module</code>'s (i.e. receiver's) <code>handleStream</code> is called (having been registered via <code>setStreamHandler()</code>)</li>
-    <li>4a. <code>handleStream</code> propagates message via <code>Raintree Router</code></li>
-    <li>4b. <code>handleStream</code> propagates message via <code>Background Router</code></li>
-    <li>5a. Repeat step 1a from <code>Remote P2P Module</code>'s perspective targeting its next peers</li>
-    <li>5b. Repeat step 1b from <code>Remote P2P Module</code>'s perspective targeting its next peers</li>
-</ul>
+References:
+- [Class Diagrams](https://www.uml-diagrams.org/class-diagrams-overview.html)
+- [Component Diagrams](https://www.uml-diagrams.org/component-diagrams.html)
+
+  _NOTE: mermaid does not support ports, interfaces, ... in component diagrams (""flowcharts)._
+
+### Legends
 
 ```mermaid
-flowchart TD
-  subgraph lMod[Local P2P Module]
-    subgraph lHost[Libp2p `Host`]
+flowchart
+subgraph Legend
+    m[[`Method`]]
+    c[Component]
+
+    m -- ""unconditional usage"" --> c
+    m -. ""conditional usage"" .-> c
+    m -. ""ignored"" .-x c
+end
+```
+
+```mermaid
+classDiagram
+class ConcreteType {
+  +ExportedField
+  -unexportedField
+  +ExportedMethod(...argTypes) (...returnTypes)
+  -unexportedMethod(...argTypes) (...returnTypes)
+}
+
+class InterfaceType {
+    <<interface>>
+    +Method(...argTypes) (...returnTypes)
+}
+
+ConcreteType --|> InterfaceType : Interface realization
+
+ConcreteType --> OtherType : Direct usage
+ConcreteType --o OtherType : Composition
+ConcreteType --* OtherType : Aggregatation
+ConcreteType ..*  ""(cardinality)"" OtherType : Indirect (via interface)
+```
+
+#### Interface Realization
+
+_TL;DR An instance (i.e. client) implements the associated interface (i.e. supplierl)._
+
+> Realization is a specialized abstraction relationship between two sets of model elements, one representing a specification (the supplier) and the other represents an implementation of the latter (the client).
+
+> Realization can be used to model stepwise refinement, optimizations, transformations, templates, model synthesis, framework composition, etc.
+
+_(see: [UML Realization](https://www.uml-diagrams.org/realization.html))_
+
+#### Direct Usage
+
+_TL;DR one instance (i.e. client) is dependent the associated instance(s) (i.e. supplier) to function properly._
+
+> Dependency is a directed relationship which is used to show that some UML element or a set of elements requires, needs or depends on other model elements for specification or implementation. Because of this, dependency is called a supplier - client relationship, where supplier provides something to the client, and thus the client is in some sense incomplete while semantically or structurally dependent on the supplier element(s). Modification of the supplier may impact the client elements.
+
+> Usage is a dependency in which one named element (client) requires another named element (supplier) for its full definition or implementation.
+
+_(see: [UML Dependency](https://www.uml-diagrams.org/dependency.html))_
+
+#### Composition
+
+_TL;DR deleting an instance also deletes the associated instance(s)._
+
+> A ""strong"" form of aggregation
+
+> If a composite (whole) is deleted, all of its composite parts are ""normally"" deleted with it.
+
+_(see: [UML Shared composition](https://www.uml-diagrams.org/composition.html))_
+
+#### Aggregation
+
+
+_TL;DR deleting an instance does not necessarily delete the associated instance(s)._
+
+> A ""weak"" form of aggregation
+
+> Shared part could be included in several composites, and if some or all of the composites are deleted, shared part may still exist.
+
+_(see: [UML Shared aggregation](https://www.uml-diagrams.org/aggregation.html))_
+
+#### Cardinality
+
+_TL;DR indicates a number, or range of instances associated (i.e. supplier(s))_
+
+Cardinality indicates the number or range of simultaneous instances of supplier that are associated with the client.
+Applicable to multiple association types.
+Can be expressed arbitrarily (e.g. wildcards, variable, equation, etc.)
+
+_(see: [UML Association](https://www.uml-diagrams.org/association.html#association-end))_
+
+
+### P2P Module / Router Decoupling
+
+The P2P module encapsulates the `RainTreeRouter` and `BackgroundRouter` submodules.
+The P2P module internally refers to these as the `stakedActorRouter` and `unstakedActorRouter`, respectively.
+
+Depending on the necessary routing scheme (unicast / broadcast) and whether the peers involved are staked actors, a node will use one or both of these routers.
+
+**Unicast**
+
+| Sender         | Receiver       | Router          | Example Usage                                        |
+|----------------|----------------|-----------------|------------------------------------------------------|
+| Staked Actor   | Staked Actor   | Raintree only   | Consensus (state sync) messages (to validators only) |
+| Unstaked Actor | Staked Actor   | Background only | Consensus (state sync) messages (to validators only) |
+| Unstaked Actor | Unstaked Actor | Background only | Consensus (state sync) & Debug (CLI) messages        |
+
+**Broadcast**
+
+| Broadcaster    | Receiver       | Router                | Example Usage                                     |
+|----------------|----------------|-----------------------|---------------------------------------------------|
+| Staked Actor   | Staked Actor   | Raintree + Background | Utility tx messages                               |
+| Unstaked Actor | Staked Actor   | Background only       | Utility tx messages (libp2p gossipsub redundancy) |
+| Unstaked Actor | Unstaked Actor | Background only       | Utility tx messages                               |",p2p/README.md,2023-07-11 08:31:30+00:00,2023-07-11T08:31:31Z,"```suggestion
**Unicast**

| Sender         | Receiver       | Router          | Example Usage                                                        |
|----------------|----------------|-----------------|----------------------------------------------------------------------|
| Staked Actor   | Staked Actor   | Raintree only   | Consensus hotstuff messages (validators only) & state sync responses |
| Staked Actor   | Untaked Actor  | Background only | Consensus state sync responses                                       |
| Unstaked Actor | Staked Actor   | Background only | Consensus state sync responses, debug messages                       |
| Unstaked Actor | Unstaked Actor | Background only | Consensus state sync responses, debug messages                       |

**Broadcast**

| Broadcaster    | Receiver       | Router                | Example Usage                                                   |
|----------------|----------------|-----------------------|-----------------------------------------------------------------|
| Staked Actor   | Staked Actor   | Raintree + Background | Utility tx messages, consensus state sync requests              |
| Staked Actor   | Untaked Actor  | Background only       | Utility tx messages (redundancy), consensus state sync requests |
| Unstaked Actor | Staked Actor   | Background only       | Utility tx messages (redundancy), consensus state sync requests |
| Unstaked Actor | Unstaked Actor | Background only       | Utility tx messages, consensus state sync requests              |
```",,187.0,RIGHT,,201,RIGHT,192,,line,https://api.github.com/repos/pokt-network/pocket/pulls/732,pokt-network/pocket,6b875eee002f49c4b1abe5ac9faa61f59daaa4cf
https://api.github.com/repos/pokt-network/pocket/pulls/757,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1195791621,dylanlott,88f1044638c863dbc408c94cd76cae22a85f25b3,990f665b7cd139fcc00113c9981e5f4728401941,"@@ -242,18 +242,15 @@ refresh_debug_keybase: ## Refreshes the debug keybase with the latest keys from
 
 .PHONY: clean_mocks
 clean_mocks: ## Use `clean_mocks` to delete mocks before recreating them. Also useful to cleanup code that was generated from a different branch
-	$(eval modules_dir = ""shared/modules"")
-	find ${modules_dir}/mocks -type f ! -name ""mocks.go"" -exec rm {} \;
-	$(eval p2p_type_mocks_dir = ""p2p/types/mocks"")
-	find ${p2p_type_mocks_dir} -type f ! -name ""mocks.go"" -exec rm {} \;
+	find . -type f ! -name ""mocks.go"" -not -path ""./vendor/*"" -name ""*_mock.go"" -exec rm {} \;
 
 .PHONY: mockgen
 mockgen: clean_mocks ## Use `mockgen` to generate mocks used for testing purposes of all the modules.
 	$(eval modules_dir = ""shared/modules"")
 	go generate ./${modules_dir}
 	echo ""Mocks generated in ${modules_dir}/mocks""
 
-	$(eval DIRS = p2p persistence)",Makefile,2023-05-16 23:55:11+00:00,2023-05-17T15:58:28Z,What did this switch do? ,,,,256.0,256,LEFT,16,16.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/757,pokt-network/pocket,837fc6ff5a5cbb04c9b67386b7ed379b2292faef
https://api.github.com/repos/pokt-network/pocket/pulls/739,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1192737246,dylanlott,7a82707fe0ecc76842e605d09622aee2722201ae,7a82707fe0ecc76842e605d09622aee2722201ae,"@@ -45,189 +35,164 @@ const (
 	chainId    = ""0001""
 )
 
-func init() {
-	cs, err := getClientset()
-	if err != nil {
-		logger.Fatal().Err(err).Msg(""failed to get clientset"")
-	}
-	clientset = cs
-	vkmap, err := pocketk8s.FetchValidatorPrivateKeys(clientset)
+type rootSuite struct {
+	gocuke.TestingT",e2e/tests/steps_init_test.go,2023-05-12 19:39:37+00:00,2023-05-12T20:12:33Z,This embed works out really nicely 👍,,,,39.0,39,RIGHT,49,49.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/739,pokt-network/pocket,d919451c2363ab4ec33c132b835c1266b6fd4537
https://api.github.com/repos/pokt-network/pocket/pulls/739,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1192739697,dylanlott,7a82707fe0ecc76842e605d09622aee2722201ae,7a82707fe0ecc76842e605d09622aee2722201ae,"@@ -45,189 +35,164 @@ const (
 	chainId    = ""0001""
 )
 
-func init() {
-	cs, err := getClientset()
-	if err != nil {
-		logger.Fatal().Err(err).Msg(""failed to get clientset"")
-	}
-	clientset = cs
-	vkmap, err := pocketk8s.FetchValidatorPrivateKeys(clientset)
+type rootSuite struct {
+	gocuke.TestingT
+
+	// validatorKeys is hydrated by the clientset with credentials for all validators.
+	// validatorKeys maps validator IDs to their private key as a hex string.
+	validatorKeys map[string]string
+	// clientset is the kubernetes API we acquire from the user's $HOME/.kube/config
+	clientset *kubernetes.Clientset
+	// validator holds command results between runs and reports errors to the test suite
+	validator *validatorPod
+	// validatorA maps to suffix ID 001 of the kube pod that we use as our control agent
+}
+
+func (s *rootSuite) Before() {
+	clientSet, err := getClientset(s)
+	require.NoErrorf(s, err, ""failed to get clientset"")
+
+	vkmap, err := pocketk8s.FetchValidatorPrivateKeys(clientSet)
 	if err != nil {
-		logger.Fatal().Err(err).Msg(""failed to get validator key map"")
+		e2eLogger.Fatal().Err(err).Msg(""failed to get validator key map"")
 	}
-	validatorKeys = vkmap
+
+	s.validator = new(validatorPod)
+	s.clientset = clientSet
+	s.validatorKeys = vkmap
 }
 
 // TestFeatures runs the e2e tests specified in any .features files in this directory
 // * This test suite assumes that a LocalNet is running that can be accessed by `kubectl`
 func TestFeatures(t *testing.T) {
-	suite := godog.TestSuite{
-		ScenarioInitializer: InitializeScenario,
-		Options: &godog.Options{
-			Format:   ""pretty"",
-			Paths:    []string{""./""},
-			TestingT: t,
-		},
-	}
-	if suite.Run() != 0 {
-		t.Fatal(""non-zero status returned, failed to run feature tests"")
-	}
+	gocuke.NewRunner(t, &rootSuite{}).Path(""*.feature"").Run()
 }
 
 // InitializeScenario registers step regexes to function handlers
-func InitializeScenario(ctx *godog.ScenarioContext) {
-	ctx.Step(`^the user runs the command ""([^""]*)""$`, theUserRunsTheCommand)
-	ctx.Step(`^the user should be able to see standard output containing ""([^""]*)""$`, theUserShouldBeAbleToSeeStandardOutputContaining)
-	ctx.Step(`^the user has a validator$`, theUserHasAValidator)
-	ctx.Step(`^the validator should have exited without error$`, theValidatorShouldHaveExitedWithoutError)
-	ctx.Step(`^the user stakes their validator with amount (\d+) uPOKT$`, theUserStakesTheirValidatorWith)
-	ctx.Step(`^the user should be able to unstake their validator$`, theUserShouldBeAbleToUnstakeTheirValidator)
-	ctx.Step(`^the user sends (\d+) uPOKT to another address$`, theUserSendsToAnotherAddress)
-}
 
-func theUserHasAValidator() error {
-	res, err := validator.RunCommand(""help"")
-	validator.result = res
-	if err != nil {
-		return err
-	}
-	return nil
+func (s *rootSuite) TheUserHasAValidator() {
+	res, err := s.validator.RunCommand(""help"")
+	require.NoError(s, err)",e2e/tests/steps_init_test.go,2023-05-12 19:43:21+00:00,2023-05-12T20:12:33Z,Having the require syntax is definitely an improvement for test functions.,,,,75.0,75,RIGHT,114,114.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/739,pokt-network/pocket,d919451c2363ab4ec33c132b835c1266b6fd4537
https://api.github.com/repos/pokt-network/pocket/pulls/753,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1206742414,h5law,d089187997b1b24863309c86260dd14f4cef2be6,cb4bf216d5ad4cbd3c24efb032723c1f5ed6d0c5,"@@ -0,0 +1,45 @@
+package testutil
+
+import (
+	""bufio""
+	""os""
+	""path/filepath""
+	""regexp""
+	""runtime""
+
+	cryptoPocket ""github.com/pokt-network/pocket/shared/crypto""
+	""github.com/stretchr/testify/require""
+)
+
+var (
+	privKeyManifestKeyRegex = regexp.MustCompile(`\s+""\d+"":\s+(\w+)\s+`)
+)
+
+func LoadLocalnetPrivateKeys(t require.TestingT, keyCount int) (privKeys []cryptoPocket.PrivateKey) {
+	_, filename, _, _ := runtime.Caller(0)
+	pkgDir := filepath.Dir(filename)
+	relativePathToKeys := filepath.Join(pkgDir, "".."", "".."", ""build"", ""localnet"", ""manifests"", ""private-keys.yaml"")
+
+	privKeyManifest, err := os.Open(relativePathToKeys)
+	require.NoError(t, err)
+
+	privKeys = make([]cryptoPocket.PrivateKey, 0, keyCount)
+
+	// scann through file & extract private keys
+	scanner := bufio.NewScanner(privKeyManifest)
+	scanner.Split(bufio.ScanLines)
+
+	for i, done := 0, false; i < keyCount && !done; {
+		done = !scanner.Scan()
+		line := scanner.Text()
+		matches := privKeyManifestKeyRegex.FindStringSubmatch(line)",internal/testutil/keys.go,2023-05-26 12:57:30+00:00,2023-05-26T12:57:31Z,I wonder how this compares to [this function](https://github.com/pokt-network/pocket/blob/main/build/debug_keybase/main.go#L155) performance wise. Decode YAML into struct and extract the keys vs. Regex,,,,,35,RIGHT,35,,line,https://api.github.com/repos/pokt-network/pocket/pulls/753,pokt-network/pocket,cb4bf216d5ad4cbd3c24efb032723c1f5ed6d0c5
https://api.github.com/repos/pokt-network/pocket/pulls/753,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1206743209,h5law,d089187997b1b24863309c86260dd14f4cef2be6,cb4bf216d5ad4cbd3c24efb032723c1f5ed6d0c5,"@@ -0,0 +1,23 @@
+package testutil_test
+
+import (
+	""testing""
+
+	""github.com/pokt-network/pocket/internal/testutil""
+	""github.com/stretchr/testify/require""
+)
+
+func TestLoadLocalnetPrivateKeys(t *testing.T) {
+	keyCount := 1000",internal/testutil/keys_test.go,2023-05-26 12:58:05+00:00,2023-05-26T12:58:06Z,This may need to be 3996 unless you are only checking validators,,,,,11,RIGHT,11,,line,https://api.github.com/repos/pokt-network/pocket/pulls/753,pokt-network/pocket,cb4bf216d5ad4cbd3c24efb032723c1f5ed6d0c5
https://api.github.com/repos/pokt-network/pocket/pulls/753,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1206747110,h5law,d089187997b1b24863309c86260dd14f4cef2be6,cb4bf216d5ad4cbd3c24efb032723c1f5ed6d0c5,"@@ -3,6 +3,9 @@ package e2e_tests
 import (
 	""context""
 	""fmt""
+	""github.com/pokt-network/pocket/internal/testutil/p2p""
+	""github.com/pokt-network/pocket/internal/testutil/persistence""",consensus/e2e_tests/utils_test.go,2023-05-26 13:00:59+00:00,2023-05-26T13:01:00Z,"```suggestion
	persistence_testutil ""github.com/pokt-network/pocket/internal/testutil/persistence""
```",,,,,7,RIGHT,5,,line,https://api.github.com/repos/pokt-network/pocket/pulls/753,pokt-network/pocket,cb4bf216d5ad4cbd3c24efb032723c1f5ed6d0c5
https://api.github.com/repos/pokt-network/pocket/pulls/753,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1206747453,h5law,d089187997b1b24863309c86260dd14f4cef2be6,cb4bf216d5ad4cbd3c24efb032723c1f5ed6d0c5,"@@ -3,6 +3,9 @@ package e2e_tests
 import (
 	""context""
 	""fmt""
+	""github.com/pokt-network/pocket/internal/testutil/p2p""",consensus/e2e_tests/utils_test.go,2023-05-26 13:01:12+00:00,2023-05-26T13:01:12Z,"```suggestion
	p2p_testutil ""github.com/pokt-network/pocket/internal/testutil/p2p""
```",,,,,6,RIGHT,4,,line,https://api.github.com/repos/pokt-network/pocket/pulls/753,pokt-network/pocket,cb4bf216d5ad4cbd3c24efb032723c1f5ed6d0c5
https://api.github.com/repos/pokt-network/pocket/pulls/753,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1206751065,h5law,d089187997b1b24863309c86260dd14f4cef2be6,cb4bf216d5ad4cbd3c24efb032723c1f5ed6d0c5,"@@ -0,0 +1,93 @@
+package testutil
+
+import (
+	""github.com/golang/mock/gomock""
+	""github.com/pokt-network/pocket/p2p/providers/current_height_provider""
+	""github.com/pokt-network/pocket/p2p/providers/peerstore_provider""
+	""github.com/pokt-network/pocket/runtime""
+	""github.com/pokt-network/pocket/shared/messaging""
+	""github.com/regen-network/gocuke""",internal/testutil/bus.go,2023-05-26 13:03:54+00:00,2023-05-26T13:03:54Z,"```suggestion
	""github.com/pokt-network/gocuke""
```

Now you have published releases should these update?",,,,,9,RIGHT,9,,line,https://api.github.com/repos/pokt-network/pocket/pulls/753,pokt-network/pocket,cb4bf216d5ad4cbd3c24efb032723c1f5ed6d0c5
https://api.github.com/repos/pokt-network/pocket/pulls/753,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1206752730,h5law,d089187997b1b24863309c86260dd14f4cef2be6,cb4bf216d5ad4cbd3c24efb032723c1f5ed6d0c5,"@@ -2,6 +2,10 @@ module github.com/pokt-network/pocket
 
 go 1.18
 
+replace github.com/regen-network/gocuke v0.6.2 => ../gocuke",go.mod,2023-05-26 13:04:55+00:00,2023-05-26T13:04:56Z,"Mentioned this below, your new `pokt-network/gocuke` package and same for mockdns can be used here instead?",,,,,5,RIGHT,4,,line,https://api.github.com/repos/pokt-network/pocket/pulls/753,pokt-network/pocket,cb4bf216d5ad4cbd3c24efb032723c1f5ed6d0c5
https://api.github.com/repos/pokt-network/pocket/pulls/737,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1195872473,Olshansk,79d691fb741afb89ae2c361dfa95e49c4a15c297,1e6aad9882250a655c410bff253458fec4b37bb9,"@@ -0,0 +1,115 @@
+package main
+
+// Monitors Pods created by StatefulSets, and if Pods are in `CrashLoopBackOff` status,
+// and they have different image tag - kill them so StatefulSet would recreate the Pod with new image.
+
+import (
+	""context""
+	""errors""
+	""strings""
+
+	pocketk8s ""github.com/pokt-network/pocket/shared/k8s""
+	corev1 ""k8s.io/api/core/v1""
+	metav1 ""k8s.io/apimachinery/pkg/apis/meta/v1""
+	watch ""k8s.io/apimachinery/pkg/watch""
+	""k8s.io/client-go/kubernetes""
+	appstypedv1 ""k8s.io/client-go/kubernetes/typed/apps/v1""
+	coretypedv1 ""k8s.io/client-go/kubernetes/typed/core/v1""
+)
+
+// Loop through existing pods and set up a watch for new pods so we don't hit Kubernetes API all the time",build/localnet/cluster-manager/sts_kill.go,2023-05-17 02:52:22+00:00,2023-05-17T03:59:56Z,"```suggestion
// Loop through existing pods and set up a watch for new Pods so we don't hit Kubernetes API all the time
```",,,,,20,RIGHT,20,,line,https://api.github.com/repos/pokt-network/pocket/pulls/737,pokt-network/pocket,470f4fea2cbd51f6f46dcf83750ad8d175f956fe
https://api.github.com/repos/pokt-network/pocket/pulls/737,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1195873088,Olshansk,79d691fb741afb89ae2c361dfa95e49c4a15c297,1e6aad9882250a655c410bff253458fec4b37bb9,"@@ -0,0 +1,115 @@
+package main
+
+// Monitors Pods created by StatefulSets, and if Pods are in `CrashLoopBackOff` status,
+// and they have different image tag - kill them so StatefulSet would recreate the Pod with new image.
+
+import (
+	""context""
+	""errors""
+	""strings""
+
+	pocketk8s ""github.com/pokt-network/pocket/shared/k8s""
+	corev1 ""k8s.io/api/core/v1""
+	metav1 ""k8s.io/apimachinery/pkg/apis/meta/v1""
+	watch ""k8s.io/apimachinery/pkg/watch""
+	""k8s.io/client-go/kubernetes""
+	appstypedv1 ""k8s.io/client-go/kubernetes/typed/apps/v1""
+	coretypedv1 ""k8s.io/client-go/kubernetes/typed/core/v1""
+)
+
+// Loop through existing pods and set up a watch for new pods so we don't hit Kubernetes API all the time
+func initDeleteCrashedPods(client *kubernetes.Clientset) {",build/localnet/cluster-manager/sts_kill.go,2023-05-17 02:53:54+00:00,2023-05-17T03:59:56Z,"Thoughts on `initCrashedPodsDeleter`/`initCrashedPodsCleaner`/`initCrashedPodsRemover`/`initCrashedPodsCollector`?

For example, in a GC world, we'd call it `initGarbageCollector` not `initCollectGarabage`",,,,,21,RIGHT,21,,line,https://api.github.com/repos/pokt-network/pocket/pulls/737,pokt-network/pocket,470f4fea2cbd51f6f46dcf83750ad8d175f956fe
https://api.github.com/repos/pokt-network/pocket/pulls/737,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1195873484,Olshansk,79d691fb741afb89ae2c361dfa95e49c4a15c297,1e6aad9882250a655c410bff253458fec4b37bb9,"@@ -0,0 +1,115 @@
+package main
+
+// Monitors Pods created by StatefulSets, and if Pods are in `CrashLoopBackOff` status,
+// and they have different image tag - kill them so StatefulSet would recreate the Pod with new image.
+
+import (
+	""context""
+	""errors""
+	""strings""
+
+	pocketk8s ""github.com/pokt-network/pocket/shared/k8s""
+	corev1 ""k8s.io/api/core/v1""
+	metav1 ""k8s.io/apimachinery/pkg/apis/meta/v1""
+	watch ""k8s.io/apimachinery/pkg/watch""
+	""k8s.io/client-go/kubernetes""
+	appstypedv1 ""k8s.io/client-go/kubernetes/typed/apps/v1""
+	coretypedv1 ""k8s.io/client-go/kubernetes/typed/core/v1""
+)
+
+// Loop through existing pods and set up a watch for new pods so we don't hit Kubernetes API all the time
+func initDeleteCrashedPods(client *kubernetes.Clientset) {
+	stsClient := client.AppsV1().StatefulSets(pocketk8s.CurrentNamespace)
+	podClient := client.CoreV1().Pods(pocketk8s.CurrentNamespace)
+
+	// Loop through all existing Pods and delete the ones that are in CrashLoopBackOff status
+	podList, _ := podClient.List(context.TODO(), metav1.ListOptions{})",build/localnet/cluster-manager/sts_kill.go,2023-05-17 02:54:43+00:00,2023-05-17T03:59:56Z,"Don't ignore the error, just do a log if it's not nil",,,,,26,RIGHT,26,,line,https://api.github.com/repos/pokt-network/pocket/pulls/737,pokt-network/pocket,470f4fea2cbd51f6f46dcf83750ad8d175f956fe
https://api.github.com/repos/pokt-network/pocket/pulls/737,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1195873945,Olshansk,79d691fb741afb89ae2c361dfa95e49c4a15c297,1e6aad9882250a655c410bff253458fec4b37bb9,"@@ -0,0 +1,115 @@
+package main
+
+// Monitors Pods created by StatefulSets, and if Pods are in `CrashLoopBackOff` status,
+// and they have different image tag - kill them so StatefulSet would recreate the Pod with new image.
+
+import (
+	""context""
+	""errors""
+	""strings""
+
+	pocketk8s ""github.com/pokt-network/pocket/shared/k8s""
+	corev1 ""k8s.io/api/core/v1""
+	metav1 ""k8s.io/apimachinery/pkg/apis/meta/v1""
+	watch ""k8s.io/apimachinery/pkg/watch""
+	""k8s.io/client-go/kubernetes""
+	appstypedv1 ""k8s.io/client-go/kubernetes/typed/apps/v1""
+	coretypedv1 ""k8s.io/client-go/kubernetes/typed/core/v1""
+)
+
+// Loop through existing pods and set up a watch for new pods so we don't hit Kubernetes API all the time
+func initDeleteCrashedPods(client *kubernetes.Clientset) {
+	stsClient := client.AppsV1().StatefulSets(pocketk8s.CurrentNamespace)
+	podClient := client.CoreV1().Pods(pocketk8s.CurrentNamespace)
+
+	// Loop through all existing Pods and delete the ones that are in CrashLoopBackOff status
+	podList, _ := podClient.List(context.TODO(), metav1.ListOptions{})
+	for i := range podList.Items {",build/localnet/cluster-manager/sts_kill.go,2023-05-17 02:55:51+00:00,2023-05-17T03:59:56Z,"why not do a `for _, pod := range podList.Items {`?",,,,,27,RIGHT,27,,line,https://api.github.com/repos/pokt-network/pocket/pulls/737,pokt-network/pocket,470f4fea2cbd51f6f46dcf83750ad8d175f956fe
https://api.github.com/repos/pokt-network/pocket/pulls/737,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1195874055,Olshansk,79d691fb741afb89ae2c361dfa95e49c4a15c297,1e6aad9882250a655c410bff253458fec4b37bb9,"@@ -0,0 +1,115 @@
+package main
+
+// Monitors Pods created by StatefulSets, and if Pods are in `CrashLoopBackOff` status,
+// and they have different image tag - kill them so StatefulSet would recreate the Pod with new image.
+
+import (
+	""context""
+	""errors""
+	""strings""
+
+	pocketk8s ""github.com/pokt-network/pocket/shared/k8s""
+	corev1 ""k8s.io/api/core/v1""
+	metav1 ""k8s.io/apimachinery/pkg/apis/meta/v1""
+	watch ""k8s.io/apimachinery/pkg/watch""
+	""k8s.io/client-go/kubernetes""
+	appstypedv1 ""k8s.io/client-go/kubernetes/typed/apps/v1""
+	coretypedv1 ""k8s.io/client-go/kubernetes/typed/core/v1""
+)
+
+// Loop through existing pods and set up a watch for new pods so we don't hit Kubernetes API all the time
+func initDeleteCrashedPods(client *kubernetes.Clientset) {
+	stsClient := client.AppsV1().StatefulSets(pocketk8s.CurrentNamespace)
+	podClient := client.CoreV1().Pods(pocketk8s.CurrentNamespace)
+
+	// Loop through all existing Pods and delete the ones that are in CrashLoopBackOff status
+	podList, _ := podClient.List(context.TODO(), metav1.ListOptions{})
+	for i := range podList.Items {
+		pod := podList.Items[i]
+		err := deleteCrashedPods(&pod, stsClient, podClient)
+		if err != nil {",build/localnet/cluster-manager/sts_kill.go,2023-05-17 02:56:06+00:00,2023-05-17T03:59:56Z,"```suggestion
		if err := deleteCrashedPods(&pod, stsClient, podClient); err != nil {
```",,29.0,RIGHT,,30,RIGHT,30,,line,https://api.github.com/repos/pokt-network/pocket/pulls/737,pokt-network/pocket,470f4fea2cbd51f6f46dcf83750ad8d175f956fe
https://api.github.com/repos/pokt-network/pocket/pulls/737,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1195874598,Olshansk,79d691fb741afb89ae2c361dfa95e49c4a15c297,1e6aad9882250a655c410bff253458fec4b37bb9,"@@ -0,0 +1,115 @@
+package main
+
+// Monitors Pods created by StatefulSets, and if Pods are in `CrashLoopBackOff` status,
+// and they have different image tag - kill them so StatefulSet would recreate the Pod with new image.
+
+import (
+	""context""
+	""errors""
+	""strings""
+
+	pocketk8s ""github.com/pokt-network/pocket/shared/k8s""
+	corev1 ""k8s.io/api/core/v1""
+	metav1 ""k8s.io/apimachinery/pkg/apis/meta/v1""
+	watch ""k8s.io/apimachinery/pkg/watch""
+	""k8s.io/client-go/kubernetes""
+	appstypedv1 ""k8s.io/client-go/kubernetes/typed/apps/v1""
+	coretypedv1 ""k8s.io/client-go/kubernetes/typed/core/v1""
+)
+
+// Loop through existing pods and set up a watch for new pods so we don't hit Kubernetes API all the time
+func initDeleteCrashedPods(client *kubernetes.Clientset) {
+	stsClient := client.AppsV1().StatefulSets(pocketk8s.CurrentNamespace)
+	podClient := client.CoreV1().Pods(pocketk8s.CurrentNamespace)
+
+	// Loop through all existing Pods and delete the ones that are in CrashLoopBackOff status
+	podList, _ := podClient.List(context.TODO(), metav1.ListOptions{})
+	for i := range podList.Items {
+		pod := podList.Items[i]
+		err := deleteCrashedPods(&pod, stsClient, podClient)
+		if err != nil {
+			logger.Error().Err(err).Msg(""error deleting crashed pod on init"")
+		}
+	}
+
+	// Set up a watch for new Pods
+	w, err := podClient.Watch(context.TODO(), metav1.ListOptions{})
+	if err != nil {
+		logger.Error().Err(err).Msg(""error setting up watch for new pods"")
+	}
+	for event := range w.ResultChan() {
+		switch event.Type {
+		case watch.Added, watch.Modified:
+			pod, ok := event.Object.(*corev1.Pod)
+			if !ok {
+				continue",build/localnet/cluster-manager/sts_kill.go,2023-05-17 02:57:18+00:00,2023-05-17T03:59:56Z,Let's log a warning here with details,,,,,45,RIGHT,45,,line,https://api.github.com/repos/pokt-network/pocket/pulls/737,pokt-network/pocket,470f4fea2cbd51f6f46dcf83750ad8d175f956fe
https://api.github.com/repos/pokt-network/pocket/pulls/737,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1195874645,Olshansk,79d691fb741afb89ae2c361dfa95e49c4a15c297,1e6aad9882250a655c410bff253458fec4b37bb9,"@@ -0,0 +1,115 @@
+package main
+
+// Monitors Pods created by StatefulSets, and if Pods are in `CrashLoopBackOff` status,
+// and they have different image tag - kill them so StatefulSet would recreate the Pod with new image.
+
+import (
+	""context""
+	""errors""
+	""strings""
+
+	pocketk8s ""github.com/pokt-network/pocket/shared/k8s""
+	corev1 ""k8s.io/api/core/v1""
+	metav1 ""k8s.io/apimachinery/pkg/apis/meta/v1""
+	watch ""k8s.io/apimachinery/pkg/watch""
+	""k8s.io/client-go/kubernetes""
+	appstypedv1 ""k8s.io/client-go/kubernetes/typed/apps/v1""
+	coretypedv1 ""k8s.io/client-go/kubernetes/typed/core/v1""
+)
+
+// Loop through existing pods and set up a watch for new pods so we don't hit Kubernetes API all the time
+func initDeleteCrashedPods(client *kubernetes.Clientset) {
+	stsClient := client.AppsV1().StatefulSets(pocketk8s.CurrentNamespace)
+	podClient := client.CoreV1().Pods(pocketk8s.CurrentNamespace)
+
+	// Loop through all existing Pods and delete the ones that are in CrashLoopBackOff status
+	podList, _ := podClient.List(context.TODO(), metav1.ListOptions{})
+	for i := range podList.Items {
+		pod := podList.Items[i]
+		err := deleteCrashedPods(&pod, stsClient, podClient)
+		if err != nil {
+			logger.Error().Err(err).Msg(""error deleting crashed pod on init"")
+		}
+	}
+
+	// Set up a watch for new Pods
+	w, err := podClient.Watch(context.TODO(), metav1.ListOptions{})
+	if err != nil {
+		logger.Error().Err(err).Msg(""error setting up watch for new pods"")
+	}
+	for event := range w.ResultChan() {
+		switch event.Type {
+		case watch.Added, watch.Modified:
+			pod, ok := event.Object.(*corev1.Pod)
+			if !ok {
+				continue
+			}
+
+			err := deleteCrashedPods(pod, stsClient, podClient)",build/localnet/cluster-manager/sts_kill.go,2023-05-17 02:57:25+00:00,2023-05-17T03:59:56Z,Single line,,,,,48,RIGHT,48,,line,https://api.github.com/repos/pokt-network/pocket/pulls/737,pokt-network/pocket,470f4fea2cbd51f6f46dcf83750ad8d175f956fe
https://api.github.com/repos/pokt-network/pocket/pulls/737,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1195874868,Olshansk,79d691fb741afb89ae2c361dfa95e49c4a15c297,1e6aad9882250a655c410bff253458fec4b37bb9,"@@ -0,0 +1,115 @@
+package main
+
+// Monitors Pods created by StatefulSets, and if Pods are in `CrashLoopBackOff` status,
+// and they have different image tag - kill them so StatefulSet would recreate the Pod with new image.
+
+import (
+	""context""
+	""errors""
+	""strings""
+
+	pocketk8s ""github.com/pokt-network/pocket/shared/k8s""
+	corev1 ""k8s.io/api/core/v1""
+	metav1 ""k8s.io/apimachinery/pkg/apis/meta/v1""
+	watch ""k8s.io/apimachinery/pkg/watch""
+	""k8s.io/client-go/kubernetes""
+	appstypedv1 ""k8s.io/client-go/kubernetes/typed/apps/v1""
+	coretypedv1 ""k8s.io/client-go/kubernetes/typed/core/v1""
+)
+
+// Loop through existing pods and set up a watch for new pods so we don't hit Kubernetes API all the time
+func initDeleteCrashedPods(client *kubernetes.Clientset) {
+	stsClient := client.AppsV1().StatefulSets(pocketk8s.CurrentNamespace)
+	podClient := client.CoreV1().Pods(pocketk8s.CurrentNamespace)
+
+	// Loop through all existing Pods and delete the ones that are in CrashLoopBackOff status
+	podList, _ := podClient.List(context.TODO(), metav1.ListOptions{})
+	for i := range podList.Items {
+		pod := podList.Items[i]
+		err := deleteCrashedPods(&pod, stsClient, podClient)
+		if err != nil {
+			logger.Error().Err(err).Msg(""error deleting crashed pod on init"")
+		}
+	}
+
+	// Set up a watch for new Pods
+	w, err := podClient.Watch(context.TODO(), metav1.ListOptions{})
+	if err != nil {
+		logger.Error().Err(err).Msg(""error setting up watch for new pods"")
+	}
+	for event := range w.ResultChan() {
+		switch event.Type {
+		case watch.Added, watch.Modified:
+			pod, ok := event.Object.(*corev1.Pod)
+			if !ok {
+				continue
+			}
+
+			err := deleteCrashedPods(pod, stsClient, podClient)
+			if err != nil {
+				logger.Error().Err(err).Msg(""error deleting crashed pod on watch"")
+			}
+		}
+	}
+}
+
+func deleteCrashedPods(pod *corev1.Pod, stsClient appstypedv1.StatefulSetInterface, podClient coretypedv1.PodInterface) error {",build/localnet/cluster-manager/sts_kill.go,2023-05-17 02:57:59+00:00,2023-05-17T03:59:56Z,"multiline method header for easier readability
```suggestion
func deleteCrashedPods(
	pod *corev1.Pod,
	stsClient appstypedv1.StatefulSetInterface,
	podClient coretypedv1.PodInterface,
) error {
```",,,,,56,RIGHT,56,,line,https://api.github.com/repos/pokt-network/pocket/pulls/737,pokt-network/pocket,470f4fea2cbd51f6f46dcf83750ad8d175f956fe
https://api.github.com/repos/pokt-network/pocket/pulls/737,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1195875371,Olshansk,79d691fb741afb89ae2c361dfa95e49c4a15c297,1e6aad9882250a655c410bff253458fec4b37bb9,"@@ -0,0 +1,115 @@
+package main
+
+// Monitors Pods created by StatefulSets, and if Pods are in `CrashLoopBackOff` status,
+// and they have different image tag - kill them so StatefulSet would recreate the Pod with new image.
+
+import (
+	""context""
+	""errors""
+	""strings""
+
+	pocketk8s ""github.com/pokt-network/pocket/shared/k8s""
+	corev1 ""k8s.io/api/core/v1""
+	metav1 ""k8s.io/apimachinery/pkg/apis/meta/v1""
+	watch ""k8s.io/apimachinery/pkg/watch""
+	""k8s.io/client-go/kubernetes""
+	appstypedv1 ""k8s.io/client-go/kubernetes/typed/apps/v1""
+	coretypedv1 ""k8s.io/client-go/kubernetes/typed/core/v1""
+)
+
+// Loop through existing pods and set up a watch for new pods so we don't hit Kubernetes API all the time
+func initDeleteCrashedPods(client *kubernetes.Clientset) {
+	stsClient := client.AppsV1().StatefulSets(pocketk8s.CurrentNamespace)
+	podClient := client.CoreV1().Pods(pocketk8s.CurrentNamespace)
+
+	// Loop through all existing Pods and delete the ones that are in CrashLoopBackOff status
+	podList, _ := podClient.List(context.TODO(), metav1.ListOptions{})
+	for i := range podList.Items {
+		pod := podList.Items[i]
+		err := deleteCrashedPods(&pod, stsClient, podClient)
+		if err != nil {
+			logger.Error().Err(err).Msg(""error deleting crashed pod on init"")
+		}
+	}
+
+	// Set up a watch for new Pods
+	w, err := podClient.Watch(context.TODO(), metav1.ListOptions{})
+	if err != nil {
+		logger.Error().Err(err).Msg(""error setting up watch for new pods"")
+	}
+	for event := range w.ResultChan() {
+		switch event.Type {
+		case watch.Added, watch.Modified:
+			pod, ok := event.Object.(*corev1.Pod)
+			if !ok {
+				continue
+			}
+
+			err := deleteCrashedPods(pod, stsClient, podClient)
+			if err != nil {
+				logger.Error().Err(err).Msg(""error deleting crashed pod on watch"")
+			}
+		}
+	}
+}
+
+func deleteCrashedPods(pod *corev1.Pod, stsClient appstypedv1.StatefulSetInterface, podClient coretypedv1.PodInterface) error {
+	// If annotation is present, we monitor the Pod",build/localnet/cluster-manager/sts_kill.go,2023-05-17 02:59:18+00:00,2023-05-17T03:59:56Z,"Whenever you have this much indentation, it's hard to read and manage so you know there's room for improvement. In this specific case, you can do:

```go
containerToMonitor, ok := pod.Annotations[""cluster-manager-delete-on-crash-container""]
if !ok {
	return nil
}
// remaining business logic
```",,,,,57,RIGHT,57,,line,https://api.github.com/repos/pokt-network/pocket/pulls/737,pokt-network/pocket,470f4fea2cbd51f6f46dcf83750ad8d175f956fe
https://api.github.com/repos/pokt-network/pocket/pulls/737,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1195875649,Olshansk,79d691fb741afb89ae2c361dfa95e49c4a15c297,1e6aad9882250a655c410bff253458fec4b37bb9,"@@ -0,0 +1,115 @@
+package main
+
+// Monitors Pods created by StatefulSets, and if Pods are in `CrashLoopBackOff` status,
+// and they have different image tag - kill them so StatefulSet would recreate the Pod with new image.
+
+import (
+	""context""
+	""errors""
+	""strings""
+
+	pocketk8s ""github.com/pokt-network/pocket/shared/k8s""
+	corev1 ""k8s.io/api/core/v1""
+	metav1 ""k8s.io/apimachinery/pkg/apis/meta/v1""
+	watch ""k8s.io/apimachinery/pkg/watch""
+	""k8s.io/client-go/kubernetes""
+	appstypedv1 ""k8s.io/client-go/kubernetes/typed/apps/v1""
+	coretypedv1 ""k8s.io/client-go/kubernetes/typed/core/v1""
+)
+
+// Loop through existing pods and set up a watch for new pods so we don't hit Kubernetes API all the time
+func initDeleteCrashedPods(client *kubernetes.Clientset) {
+	stsClient := client.AppsV1().StatefulSets(pocketk8s.CurrentNamespace)
+	podClient := client.CoreV1().Pods(pocketk8s.CurrentNamespace)
+
+	// Loop through all existing Pods and delete the ones that are in CrashLoopBackOff status
+	podList, _ := podClient.List(context.TODO(), metav1.ListOptions{})
+	for i := range podList.Items {
+		pod := podList.Items[i]
+		err := deleteCrashedPods(&pod, stsClient, podClient)
+		if err != nil {
+			logger.Error().Err(err).Msg(""error deleting crashed pod on init"")
+		}
+	}
+
+	// Set up a watch for new Pods
+	w, err := podClient.Watch(context.TODO(), metav1.ListOptions{})
+	if err != nil {
+		logger.Error().Err(err).Msg(""error setting up watch for new pods"")
+	}
+	for event := range w.ResultChan() {
+		switch event.Type {
+		case watch.Added, watch.Modified:
+			pod, ok := event.Object.(*corev1.Pod)
+			if !ok {
+				continue
+			}
+
+			err := deleteCrashedPods(pod, stsClient, podClient)
+			if err != nil {
+				logger.Error().Err(err).Msg(""error deleting crashed pod on watch"")
+			}
+		}
+	}
+}
+
+func deleteCrashedPods(pod *corev1.Pod, stsClient appstypedv1.StatefulSetInterface, podClient coretypedv1.PodInterface) error {
+	// If annotation is present, we monitor the Pod
+	if containerToMonitor, ok := pod.Annotations[""cluster-manager-delete-on-crash-container""]; ok {
+		for ci := range pod.Spec.Containers {
+			podContainer := pod.Spec.Containers[ci]",build/localnet/cluster-manager/sts_kill.go,2023-05-17 02:59:52+00:00,2023-05-17T03:59:56Z,"Remove this line and do `for _, podContainer := range pod.Spec.Containers {`",,,,,60,RIGHT,60,,line,https://api.github.com/repos/pokt-network/pocket/pulls/737,pokt-network/pocket,470f4fea2cbd51f6f46dcf83750ad8d175f956fe
https://api.github.com/repos/pokt-network/pocket/pulls/737,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1195875925,Olshansk,79d691fb741afb89ae2c361dfa95e49c4a15c297,1e6aad9882250a655c410bff253458fec4b37bb9,"@@ -0,0 +1,115 @@
+package main
+
+// Monitors Pods created by StatefulSets, and if Pods are in `CrashLoopBackOff` status,
+// and they have different image tag - kill them so StatefulSet would recreate the Pod with new image.
+
+import (
+	""context""
+	""errors""
+	""strings""
+
+	pocketk8s ""github.com/pokt-network/pocket/shared/k8s""
+	corev1 ""k8s.io/api/core/v1""
+	metav1 ""k8s.io/apimachinery/pkg/apis/meta/v1""
+	watch ""k8s.io/apimachinery/pkg/watch""
+	""k8s.io/client-go/kubernetes""
+	appstypedv1 ""k8s.io/client-go/kubernetes/typed/apps/v1""
+	coretypedv1 ""k8s.io/client-go/kubernetes/typed/core/v1""
+)
+
+// Loop through existing pods and set up a watch for new pods so we don't hit Kubernetes API all the time
+func initDeleteCrashedPods(client *kubernetes.Clientset) {
+	stsClient := client.AppsV1().StatefulSets(pocketk8s.CurrentNamespace)
+	podClient := client.CoreV1().Pods(pocketk8s.CurrentNamespace)
+
+	// Loop through all existing Pods and delete the ones that are in CrashLoopBackOff status
+	podList, _ := podClient.List(context.TODO(), metav1.ListOptions{})
+	for i := range podList.Items {
+		pod := podList.Items[i]
+		err := deleteCrashedPods(&pod, stsClient, podClient)
+		if err != nil {
+			logger.Error().Err(err).Msg(""error deleting crashed pod on init"")
+		}
+	}
+
+	// Set up a watch for new Pods
+	w, err := podClient.Watch(context.TODO(), metav1.ListOptions{})
+	if err != nil {
+		logger.Error().Err(err).Msg(""error setting up watch for new pods"")
+	}
+	for event := range w.ResultChan() {
+		switch event.Type {
+		case watch.Added, watch.Modified:
+			pod, ok := event.Object.(*corev1.Pod)
+			if !ok {
+				continue
+			}
+
+			err := deleteCrashedPods(pod, stsClient, podClient)
+			if err != nil {
+				logger.Error().Err(err).Msg(""error deleting crashed pod on watch"")
+			}
+		}
+	}
+}
+
+func deleteCrashedPods(pod *corev1.Pod, stsClient appstypedv1.StatefulSetInterface, podClient coretypedv1.PodInterface) error {
+	// If annotation is present, we monitor the Pod
+	if containerToMonitor, ok := pod.Annotations[""cluster-manager-delete-on-crash-container""]; ok {
+		for ci := range pod.Spec.Containers {
+			podContainer := pod.Spec.Containers[ci]
+			if podContainer.Name == containerToMonitor {",build/localnet/cluster-manager/sts_kill.go,2023-05-17 03:00:24+00:00,2023-05-17T03:59:56Z,"Avoid the extra indent.

```
if podContainer.Name != containerToMintor {
	continue
}
// remaining business logic
```",,,,,61,RIGHT,61,,line,https://api.github.com/repos/pokt-network/pocket/pulls/737,pokt-network/pocket,470f4fea2cbd51f6f46dcf83750ad8d175f956fe
https://api.github.com/repos/pokt-network/pocket/pulls/737,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1195876164,Olshansk,79d691fb741afb89ae2c361dfa95e49c4a15c297,1e6aad9882250a655c410bff253458fec4b37bb9,"@@ -0,0 +1,115 @@
+package main
+
+// Monitors Pods created by StatefulSets, and if Pods are in `CrashLoopBackOff` status,
+// and they have different image tag - kill them so StatefulSet would recreate the Pod with new image.
+
+import (
+	""context""
+	""errors""
+	""strings""
+
+	pocketk8s ""github.com/pokt-network/pocket/shared/k8s""
+	corev1 ""k8s.io/api/core/v1""
+	metav1 ""k8s.io/apimachinery/pkg/apis/meta/v1""
+	watch ""k8s.io/apimachinery/pkg/watch""
+	""k8s.io/client-go/kubernetes""
+	appstypedv1 ""k8s.io/client-go/kubernetes/typed/apps/v1""
+	coretypedv1 ""k8s.io/client-go/kubernetes/typed/core/v1""
+)
+
+// Loop through existing pods and set up a watch for new pods so we don't hit Kubernetes API all the time
+func initDeleteCrashedPods(client *kubernetes.Clientset) {
+	stsClient := client.AppsV1().StatefulSets(pocketk8s.CurrentNamespace)
+	podClient := client.CoreV1().Pods(pocketk8s.CurrentNamespace)
+
+	// Loop through all existing Pods and delete the ones that are in CrashLoopBackOff status
+	podList, _ := podClient.List(context.TODO(), metav1.ListOptions{})
+	for i := range podList.Items {
+		pod := podList.Items[i]
+		err := deleteCrashedPods(&pod, stsClient, podClient)
+		if err != nil {
+			logger.Error().Err(err).Msg(""error deleting crashed pod on init"")
+		}
+	}
+
+	// Set up a watch for new Pods
+	w, err := podClient.Watch(context.TODO(), metav1.ListOptions{})
+	if err != nil {
+		logger.Error().Err(err).Msg(""error setting up watch for new pods"")
+	}
+	for event := range w.ResultChan() {
+		switch event.Type {
+		case watch.Added, watch.Modified:
+			pod, ok := event.Object.(*corev1.Pod)
+			if !ok {
+				continue
+			}
+
+			err := deleteCrashedPods(pod, stsClient, podClient)
+			if err != nil {
+				logger.Error().Err(err).Msg(""error deleting crashed pod on watch"")
+			}
+		}
+	}
+}
+
+func deleteCrashedPods(pod *corev1.Pod, stsClient appstypedv1.StatefulSetInterface, podClient coretypedv1.PodInterface) error {
+	// If annotation is present, we monitor the Pod
+	if containerToMonitor, ok := pod.Annotations[""cluster-manager-delete-on-crash-container""]; ok {
+		for ci := range pod.Spec.Containers {
+			podContainer := pod.Spec.Containers[ci]
+			if podContainer.Name == containerToMonitor {
+				for pi := range pod.Status.ContainerStatuses {
+					containerStatus := pod.Status.ContainerStatuses[pi]
+
+					// Only proceed if container is in some sort of Err status
+					if containerStatus.State.Waiting != nil &&
+						(strings.HasPrefix(containerStatus.State.Waiting.Reason, ""Err"") ||
+							strings.HasSuffix(containerStatus.State.Waiting.Reason, ""BackOff"")) {",build/localnet/cluster-manager/sts_kill.go,2023-05-17 03:00:57+00:00,2023-05-17T03:59:56Z,Create a helper for these two repfix checks,,67.0,RIGHT,,68,RIGHT,68,,line,https://api.github.com/repos/pokt-network/pocket/pulls/737,pokt-network/pocket,470f4fea2cbd51f6f46dcf83750ad8d175f956fe
https://api.github.com/repos/pokt-network/pocket/pulls/737,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1195876464,Olshansk,79d691fb741afb89ae2c361dfa95e49c4a15c297,1e6aad9882250a655c410bff253458fec4b37bb9,"@@ -0,0 +1,115 @@
+package main
+
+// Monitors Pods created by StatefulSets, and if Pods are in `CrashLoopBackOff` status,
+// and they have different image tag - kill them so StatefulSet would recreate the Pod with new image.
+
+import (
+	""context""
+	""errors""
+	""strings""
+
+	pocketk8s ""github.com/pokt-network/pocket/shared/k8s""
+	corev1 ""k8s.io/api/core/v1""
+	metav1 ""k8s.io/apimachinery/pkg/apis/meta/v1""
+	watch ""k8s.io/apimachinery/pkg/watch""
+	""k8s.io/client-go/kubernetes""
+	appstypedv1 ""k8s.io/client-go/kubernetes/typed/apps/v1""
+	coretypedv1 ""k8s.io/client-go/kubernetes/typed/core/v1""
+)
+
+// Loop through existing pods and set up a watch for new pods so we don't hit Kubernetes API all the time
+func initDeleteCrashedPods(client *kubernetes.Clientset) {
+	stsClient := client.AppsV1().StatefulSets(pocketk8s.CurrentNamespace)
+	podClient := client.CoreV1().Pods(pocketk8s.CurrentNamespace)
+
+	// Loop through all existing Pods and delete the ones that are in CrashLoopBackOff status
+	podList, _ := podClient.List(context.TODO(), metav1.ListOptions{})
+	for i := range podList.Items {
+		pod := podList.Items[i]
+		err := deleteCrashedPods(&pod, stsClient, podClient)
+		if err != nil {
+			logger.Error().Err(err).Msg(""error deleting crashed pod on init"")
+		}
+	}
+
+	// Set up a watch for new Pods
+	w, err := podClient.Watch(context.TODO(), metav1.ListOptions{})
+	if err != nil {
+		logger.Error().Err(err).Msg(""error setting up watch for new pods"")
+	}
+	for event := range w.ResultChan() {
+		switch event.Type {
+		case watch.Added, watch.Modified:
+			pod, ok := event.Object.(*corev1.Pod)
+			if !ok {
+				continue
+			}
+
+			err := deleteCrashedPods(pod, stsClient, podClient)
+			if err != nil {
+				logger.Error().Err(err).Msg(""error deleting crashed pod on watch"")
+			}
+		}
+	}
+}
+
+func deleteCrashedPods(pod *corev1.Pod, stsClient appstypedv1.StatefulSetInterface, podClient coretypedv1.PodInterface) error {
+	// If annotation is present, we monitor the Pod
+	if containerToMonitor, ok := pod.Annotations[""cluster-manager-delete-on-crash-container""]; ok {
+		for ci := range pod.Spec.Containers {
+			podContainer := pod.Spec.Containers[ci]
+			if podContainer.Name == containerToMonitor {
+				for pi := range pod.Status.ContainerStatuses {
+					containerStatus := pod.Status.ContainerStatuses[pi]
+
+					// Only proceed if container is in some sort of Err status
+					if containerStatus.State.Waiting != nil &&
+						(strings.HasPrefix(containerStatus.State.Waiting.Reason, ""Err"") ||
+							strings.HasSuffix(containerStatus.State.Waiting.Reason, ""BackOff"")) {
+						// Get StatefulSet that created the Pod
+						var stsName string
+						for _, ownerRef := range pod.OwnerReferences {
+							if ownerRef.Kind == ""StatefulSet"" {
+								stsName = ownerRef.Name
+								break
+							}
+						}
+
+						if stsName == """" {
+							return errors.New(""no StatefulSet found for this pod"")",build/localnet/cluster-manager/sts_kill.go,2023-05-17 03:01:36+00:00,2023-05-17T03:59:56Z,Do we want to return an error or just log it and continue?,,,,,79,RIGHT,79,,line,https://api.github.com/repos/pokt-network/pocket/pulls/737,pokt-network/pocket,470f4fea2cbd51f6f46dcf83750ad8d175f956fe
https://api.github.com/repos/pokt-network/pocket/pulls/737,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1195876965,Olshansk,79d691fb741afb89ae2c361dfa95e49c4a15c297,1e6aad9882250a655c410bff253458fec4b37bb9,"@@ -0,0 +1,115 @@
+package main
+
+// Monitors Pods created by StatefulSets, and if Pods are in `CrashLoopBackOff` status,
+// and they have different image tag - kill them so StatefulSet would recreate the Pod with new image.
+
+import (
+	""context""
+	""errors""
+	""strings""
+
+	pocketk8s ""github.com/pokt-network/pocket/shared/k8s""
+	corev1 ""k8s.io/api/core/v1""
+	metav1 ""k8s.io/apimachinery/pkg/apis/meta/v1""
+	watch ""k8s.io/apimachinery/pkg/watch""
+	""k8s.io/client-go/kubernetes""
+	appstypedv1 ""k8s.io/client-go/kubernetes/typed/apps/v1""
+	coretypedv1 ""k8s.io/client-go/kubernetes/typed/core/v1""
+)
+
+// Loop through existing pods and set up a watch for new pods so we don't hit Kubernetes API all the time
+func initDeleteCrashedPods(client *kubernetes.Clientset) {
+	stsClient := client.AppsV1().StatefulSets(pocketk8s.CurrentNamespace)
+	podClient := client.CoreV1().Pods(pocketk8s.CurrentNamespace)
+
+	// Loop through all existing Pods and delete the ones that are in CrashLoopBackOff status
+	podList, _ := podClient.List(context.TODO(), metav1.ListOptions{})
+	for i := range podList.Items {
+		pod := podList.Items[i]
+		err := deleteCrashedPods(&pod, stsClient, podClient)
+		if err != nil {
+			logger.Error().Err(err).Msg(""error deleting crashed pod on init"")
+		}
+	}
+
+	// Set up a watch for new Pods
+	w, err := podClient.Watch(context.TODO(), metav1.ListOptions{})
+	if err != nil {
+		logger.Error().Err(err).Msg(""error setting up watch for new pods"")
+	}
+	for event := range w.ResultChan() {
+		switch event.Type {
+		case watch.Added, watch.Modified:
+			pod, ok := event.Object.(*corev1.Pod)
+			if !ok {
+				continue
+			}
+
+			err := deleteCrashedPods(pod, stsClient, podClient)
+			if err != nil {
+				logger.Error().Err(err).Msg(""error deleting crashed pod on watch"")
+			}
+		}
+	}
+}
+
+func deleteCrashedPods(pod *corev1.Pod, stsClient appstypedv1.StatefulSetInterface, podClient coretypedv1.PodInterface) error {
+	// If annotation is present, we monitor the Pod
+	if containerToMonitor, ok := pod.Annotations[""cluster-manager-delete-on-crash-container""]; ok {
+		for ci := range pod.Spec.Containers {
+			podContainer := pod.Spec.Containers[ci]
+			if podContainer.Name == containerToMonitor {
+				for pi := range pod.Status.ContainerStatuses {
+					containerStatus := pod.Status.ContainerStatuses[pi]
+
+					// Only proceed if container is in some sort of Err status
+					if containerStatus.State.Waiting != nil &&
+						(strings.HasPrefix(containerStatus.State.Waiting.Reason, ""Err"") ||
+							strings.HasSuffix(containerStatus.State.Waiting.Reason, ""BackOff"")) {
+						// Get StatefulSet that created the Pod
+						var stsName string
+						for _, ownerRef := range pod.OwnerReferences {
+							if ownerRef.Kind == ""StatefulSet"" {
+								stsName = ownerRef.Name
+								break
+							}
+						}
+
+						if stsName == """" {
+							return errors.New(""no StatefulSet found for this pod"")
+						}
+
+						sts, err := stsClient.Get(context.TODO(), stsName, metav1.GetOptions{})
+						if err != nil {
+							return err
+						}
+
+						// Loop through all containers in the StatefulSet and find the one we monitor
+						for sci := range sts.Spec.Template.Spec.Containers {
+							stsContainer := sts.Spec.Template.Spec.Containers[sci]
+							if stsContainer.Name == containerToMonitor {
+
+								// Loop through all containers in the Pod and find the one we monitor
+								// If images are different, delete the Pod
+								if stsContainer.Image != podContainer.Image {
+									deletePolicy := metav1.DeletePropagationForeground
+
+									if err := podClient.Delete(context.TODO(), pod.Name, metav1.DeleteOptions{
+										PropagationPolicy: &deletePolicy,
+									}); err != nil {
+										return err
+									} else {",build/localnet/cluster-manager/sts_kill.go,2023-05-17 03:02:39+00:00,2023-05-17T03:59:57Z,you don't need an else,,,,,101,RIGHT,101,,line,https://api.github.com/repos/pokt-network/pocket/pulls/737,pokt-network/pocket,470f4fea2cbd51f6f46dcf83750ad8d175f956fe
https://api.github.com/repos/pokt-network/pocket/pulls/737,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1195899033,Olshansk,79d691fb741afb89ae2c361dfa95e49c4a15c297,1e6aad9882250a655c410bff253458fec4b37bb9,"@@ -0,0 +1,63 @@
+name: E2E test on DevNet
+
+# Only trigger, when the build workflow succeeded, and allow manual triggering.
+on:
+  workflow_dispatch:
+  workflow_run:
+    workflows: [""Test, build and push artifacts""]
+    types:
+      - completed
+
+jobs:
+  e2e-tests:
+    runs-on: ubuntu-latest
+    needs: build-images
+    if: contains(github.event.pull_request.labels.*.name, 'e2e-devnet-test')",.github/workflows/e2e-test.yml,2023-05-17 03:53:57+00:00,2023-05-17T03:59:57Z,"Can you document the use of `e2e-devnet-test` somewhere?

---

Nvm: https://github.com/pokt-network/pocket/pull/761",,,,14.0,15,RIGHT,15,14.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/737,pokt-network/pocket,470f4fea2cbd51f6f46dcf83750ad8d175f956fe
https://api.github.com/repos/pokt-network/pocket/pulls/737,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1198196866,Olshansk,e1a66e9061d1b1d9f05135c1f3bc3fdac2a7db0d,1e6aad9882250a655c410bff253458fec4b37bb9,"@@ -0,0 +1,134 @@
+package main
+
+// Monitors Pods created by StatefulSets, and if the Pods are in a `CrashLoopBackOff` status,
+// and they have a different image tag - kill them. StatefulSet would then recreate the Pod with a new image.
+
+import (
+	""context""
+	""errors""
+	""strings""
+
+	pocketk8s ""github.com/pokt-network/pocket/shared/k8s""
+	corev1 ""k8s.io/api/core/v1""
+	metav1 ""k8s.io/apimachinery/pkg/apis/meta/v1""
+	watch ""k8s.io/apimachinery/pkg/watch""
+	""k8s.io/client-go/kubernetes""
+	appstypedv1 ""k8s.io/client-go/kubernetes/typed/apps/v1""
+	coretypedv1 ""k8s.io/client-go/kubernetes/typed/core/v1""
+)
+
+// Loop through existing pods and set up a watch for new Pods so we don't hit Kubernetes API all the time
+func initCrashedPodsDeleter(client *kubernetes.Clientset) {
+	stsClient := client.AppsV1().StatefulSets(pocketk8s.CurrentNamespace)
+	podClient := client.CoreV1().Pods(pocketk8s.CurrentNamespace)
+
+	// Loop through all existing Pods and delete the ones that are in CrashLoopBackOff status
+	podList, err := podClient.List(context.TODO(), metav1.ListOptions{})
+	if err != nil {
+		logger.Error().Err(err).Msg(""error listing pods on init"")
+	}
+
+	for i := range podList.Items {
+		pod := podList.Items[i]",build/localnet/cluster-manager/crashed_pods_deleter.go,2023-05-18 19:00:11+00:00,2023-05-18T20:42:37Z,Ditto my comment from the previous PR,,,,,32,RIGHT,32,,line,https://api.github.com/repos/pokt-network/pocket/pulls/737,pokt-network/pocket,470f4fea2cbd51f6f46dcf83750ad8d175f956fe
https://api.github.com/repos/pokt-network/pocket/pulls/737,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1198251082,Olshansk,e1a66e9061d1b1d9f05135c1f3bc3fdac2a7db0d,1e6aad9882250a655c410bff253458fec4b37bb9,"@@ -0,0 +1,62 @@
+name: E2E test on DevNet
+
+# Only trigger, when the build workflow succeeded, and allow manual triggering.
+on:
+  workflow_dispatch:
+  workflow_run:
+    workflows: [""Test, build and push artifacts""]
+    types:
+      - completed
+
+jobs:
+  e2e-tests:
+    runs-on: ubuntu-latest
+    if: contains(github.event.pull_request.labels.*.name, 'e2e-devnet-test')
+    env:
+      ARGO_SERVER: ""workflows.dev-us-east4-1.poktnodes.network:8443""
+      ARGO_HTTP1: true
+      ARGO_SECURE: true
+    permissions:
+      contents: ""read""
+      id-token: ""write""
+
+    steps:
+      - id: ""auth""
+        uses: ""google-github-actions/auth@v1""
+        with:
+          credentials_json: ""${{ secrets.ARGO_WORKFLOW_EXTERNAL }}""
+
+      - id: ""get-credentials""
+        uses: ""google-github-actions/get-gke-credentials@v1""
+        with:
+          cluster_name: ""nodes-gcp-dev-us-east4-1""
+          location: ""us-east4""
+
+      - id: ""install-argo""",.github/workflows/e2e-test.yml,2023-05-18 20:00:06+00:00,2023-05-18T20:42:37Z,Do github actions always require a clean slate?,,,,35.0,35,RIGHT,35,35.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/737,pokt-network/pocket,470f4fea2cbd51f6f46dcf83750ad8d175f956fe
https://api.github.com/repos/pokt-network/pocket/pulls/737,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1198251617,Olshansk,e1a66e9061d1b1d9f05135c1f3bc3fdac2a7db0d,1e6aad9882250a655c410bff253458fec4b37bb9,"@@ -0,0 +1,62 @@
+name: E2E test on DevNet
+
+# Only trigger, when the build workflow succeeded, and allow manual triggering.
+on:
+  workflow_dispatch:
+  workflow_run:
+    workflows: [""Test, build and push artifacts""]
+    types:
+      - completed
+
+jobs:
+  e2e-tests:
+    runs-on: ubuntu-latest
+    if: contains(github.event.pull_request.labels.*.name, 'e2e-devnet-test')
+    env:
+      ARGO_SERVER: ""workflows.dev-us-east4-1.poktnodes.network:8443""
+      ARGO_HTTP1: true
+      ARGO_SECURE: true
+    permissions:
+      contents: ""read""
+      id-token: ""write""
+
+    steps:
+      - id: ""auth""
+        uses: ""google-github-actions/auth@v1""
+        with:
+          credentials_json: ""${{ secrets.ARGO_WORKFLOW_EXTERNAL }}""
+
+      - id: ""get-credentials""
+        uses: ""google-github-actions/get-gke-credentials@v1""
+        with:
+          cluster_name: ""nodes-gcp-dev-us-east4-1""
+          location: ""us-east4""
+
+      - id: ""install-argo""
+        run: |
+          curl -sLO https://github.com/argoproj/argo-workflows/releases/download/v3.4.7/argo-linux-amd64.gz
+          gunzip argo-linux-amd64.gz
+          chmod +x argo-linux-amd64
+          mv ./argo-linux-amd64 /usr/local/bin/argo
+          argo version
+
+      - id: ""wait-for-infra""
+        shell: bash
+        run: |
+          start_time=$(date +%s) # store current time
+          timeout=900 # timeout in seconds",.github/workflows/e2e-test.yml,2023-05-18 20:00:45+00:00,2023-05-18T20:42:37Z,"To help the reader

```suggestion
          timeout=900 # 15 minute timeout in seconds
```",,,,,47,RIGHT,47,,line,https://api.github.com/repos/pokt-network/pocket/pulls/737,pokt-network/pocket,470f4fea2cbd51f6f46dcf83750ad8d175f956fe
https://api.github.com/repos/pokt-network/pocket/pulls/737,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1198278538,Olshansk,6de718cf0c8336a61979165a6d2512329d01c22f,1e6aad9882250a655c410bff253458fec4b37bb9,"@@ -0,0 +1,62 @@
+name: E2E test on DevNet
+
+# Only trigger, when the build workflow succeeded, and allow manual triggering.
+on:
+  workflow_dispatch:
+  workflow_run:
+    workflows: [""Test, build and push artifacts""]
+    types:
+      - completed
+
+jobs:
+  e2e-tests:
+    runs-on: ubuntu-latest
+    if: contains(github.event.pull_request.labels.*.name, 'e2e-devnet-test')
+    env:
+      ARGO_SERVER: ""workflows.dev-us-east4-1.poktnodes.network:8443""
+      ARGO_HTTP1: true
+      ARGO_SECURE: true
+    permissions:
+      contents: ""read""
+      id-token: ""write""
+
+    steps:
+      - id: ""auth""
+        uses: ""google-github-actions/auth@v1""
+        with:
+          credentials_json: ""${{ secrets.ARGO_WORKFLOW_EXTERNAL }}""
+
+      - id: ""get-credentials""
+        uses: ""google-github-actions/get-gke-credentials@v1""
+        with:
+          cluster_name: ""nodes-gcp-dev-us-east4-1""
+          location: ""us-east4""
+
+      - id: ""install-argo""
+        run: |
+          curl -sLO https://github.com/argoproj/argo-workflows/releases/download/v3.4.7/argo-linux-amd64.gz
+          gunzip argo-linux-amd64.gz
+          chmod +x argo-linux-amd64
+          mv ./argo-linux-amd64 /usr/local/bin/argo
+          argo version
+
+      - id: ""wait-for-infra""
+        shell: bash
+        run: |
+          start_time=$(date +%s) # store current time
+          timeout=900 # timeout in seconds
+
+          until argo template get dev-e2e-tests --namespace=devnet-issue-${{ github.event.pull_request.number }}; do
+              current_time=$(date +%s)
+              elapsed_time=$(( current_time - start_time ))
+              if (( elapsed_time > timeout )); then
+                  echo ""Timeout of $timeout seconds reached. Exiting...""
+                  exit 1
+              fi
+              echo ""Waiting for devnet-issue-${{ github.event.pull_request.number }} to be provisioned...""
+              sleep 5
+          done
+
+      - id: ""run-e2e-tests""
+        run: |
+          argo submit --wait --log --namespace devnet-issue-${{ github.event.pull_request.number }} --from 'wftmpl/dev-e2e-tests' --parameter gitsha=""${{ github.event.pull_request.head.sha }}""",.github/workflows/e2e-test.yml,2023-05-18 20:34:39+00:00,2023-05-18T20:42:37Z,Just curious: Is this a common pattern you've seen elsewhere? Using a github action that does an `argo submit`?,,,,62.0,62,RIGHT,62,62.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/737,pokt-network/pocket,470f4fea2cbd51f6f46dcf83750ad8d175f956fe
https://api.github.com/repos/pokt-network/pocket/pulls/737,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1198279968,Olshansk,6de718cf0c8336a61979165a6d2512329d01c22f,1e6aad9882250a655c410bff253458fec4b37bb9,"@@ -0,0 +1,135 @@
+package main
+
+// Monitors Pods created by StatefulSets, and if the Pods are in a `CrashLoopBackOff` status,
+// and they have a different image tag - kill them. StatefulSet would then recreate the Pod with a new image.
+
+import (
+	""context""
+	""errors""
+	""strings""
+
+	pocketk8s ""github.com/pokt-network/pocket/shared/k8s""
+	corev1 ""k8s.io/api/core/v1""
+	metav1 ""k8s.io/apimachinery/pkg/apis/meta/v1""
+	watch ""k8s.io/apimachinery/pkg/watch""
+	""k8s.io/client-go/kubernetes""
+	appstypedv1 ""k8s.io/client-go/kubernetes/typed/apps/v1""
+	coretypedv1 ""k8s.io/client-go/kubernetes/typed/core/v1""
+)
+
+// Loop through existing pods and set up a watch for new Pods so we don't hit Kubernetes API all the time
+func initCrashedPodsDeleter(client *kubernetes.Clientset) {
+	stsClient := client.AppsV1().StatefulSets(pocketk8s.CurrentNamespace)
+	podClient := client.CoreV1().Pods(pocketk8s.CurrentNamespace)
+
+	// Loop through all existing Pods and delete the ones that are in CrashLoopBackOff status
+	podList, err := podClient.List(context.TODO(), metav1.ListOptions{})
+	if err != nil {
+		logger.Error().Err(err).Msg(""error listing pods on init"")
+	}
+
+	for i := range podList.Items {
+		pod := &podList.Items[i]
+		if err := deleteCrashedPods(pod, stsClient, podClient); err != nil {
+			logger.Error().Err(err).Msg(""error deleting crashed pod on init"")
+		}
+	}
+
+	// Set up a watch for new Pods
+	w, err := podClient.Watch(context.TODO(), metav1.ListOptions{})
+	if err != nil {
+		logger.Error().Err(err).Msg(""error setting up watch for new pods"")
+	}
+	for event := range w.ResultChan() {
+		switch event.Type {
+		case watch.Added, watch.Modified:
+			pod, ok := event.Object.(*corev1.Pod)
+			if !ok {
+				logger.Error().Msg(""error casting pod on watch"")
+				continue
+			}
+
+			if err := deleteCrashedPods(pod, stsClient, podClient); err != nil {
+				logger.Error().Err(err).Msg(""error deleting crashed pod on watch"")
+			}
+		}
+	}
+}
+
+func containerErroneousStatus(status *corev1.ContainerStatus) bool {",build/localnet/cluster-manager/crashed_pods_deleter.go,2023-05-18 20:36:35+00:00,2023-05-18T20:42:37Z,`s/containerErroneousStatus/isContainerStatusErroneous`,,,,,59,RIGHT,59,,line,https://api.github.com/repos/pokt-network/pocket/pulls/737,pokt-network/pocket,470f4fea2cbd51f6f46dcf83750ad8d175f956fe
https://api.github.com/repos/pokt-network/pocket/pulls/737,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1198280403,Olshansk,6de718cf0c8336a61979165a6d2512329d01c22f,1e6aad9882250a655c410bff253458fec4b37bb9,"@@ -0,0 +1,135 @@
+package main
+
+// Monitors Pods created by StatefulSets, and if the Pods are in a `CrashLoopBackOff` status,
+// and they have a different image tag - kill them. StatefulSet would then recreate the Pod with a new image.
+
+import (
+	""context""
+	""errors""
+	""strings""
+
+	pocketk8s ""github.com/pokt-network/pocket/shared/k8s""
+	corev1 ""k8s.io/api/core/v1""
+	metav1 ""k8s.io/apimachinery/pkg/apis/meta/v1""
+	watch ""k8s.io/apimachinery/pkg/watch""
+	""k8s.io/client-go/kubernetes""
+	appstypedv1 ""k8s.io/client-go/kubernetes/typed/apps/v1""
+	coretypedv1 ""k8s.io/client-go/kubernetes/typed/core/v1""
+)
+
+// Loop through existing pods and set up a watch for new Pods so we don't hit Kubernetes API all the time
+func initCrashedPodsDeleter(client *kubernetes.Clientset) {
+	stsClient := client.AppsV1().StatefulSets(pocketk8s.CurrentNamespace)
+	podClient := client.CoreV1().Pods(pocketk8s.CurrentNamespace)
+
+	// Loop through all existing Pods and delete the ones that are in CrashLoopBackOff status
+	podList, err := podClient.List(context.TODO(), metav1.ListOptions{})
+	if err != nil {
+		logger.Error().Err(err).Msg(""error listing pods on init"")
+	}
+
+	for i := range podList.Items {
+		pod := &podList.Items[i]
+		if err := deleteCrashedPods(pod, stsClient, podClient); err != nil {
+			logger.Error().Err(err).Msg(""error deleting crashed pod on init"")
+		}
+	}
+
+	// Set up a watch for new Pods
+	w, err := podClient.Watch(context.TODO(), metav1.ListOptions{})
+	if err != nil {
+		logger.Error().Err(err).Msg(""error setting up watch for new pods"")
+	}
+	for event := range w.ResultChan() {
+		switch event.Type {
+		case watch.Added, watch.Modified:
+			pod, ok := event.Object.(*corev1.Pod)
+			if !ok {
+				logger.Error().Msg(""error casting pod on watch"")
+				continue
+			}
+
+			if err := deleteCrashedPods(pod, stsClient, podClient); err != nil {
+				logger.Error().Err(err).Msg(""error deleting crashed pod on watch"")
+			}
+		}
+	}
+}
+
+func containerErroneousStatus(status *corev1.ContainerStatus) bool {
+	return status.State.Waiting != nil &&
+		(strings.HasPrefix(status.State.Waiting.Reason, ""Err"") ||
+			strings.HasSuffix(status.State.Waiting.Reason, ""BackOff""))
+}
+
+func deleteCrashedPods(
+	pod *corev1.Pod,
+	stsClient appstypedv1.StatefulSetInterface,
+	podClient coretypedv1.PodInterface,
+) error {
+	// If annotation is present, we monitor the Pod
+	containerToMonitor, ok := pod.Annotations[""cluster-manager-delete-on-crash-container""]
+	if !ok {
+		return nil
+	}
+
+	for ci := range pod.Spec.Containers {
+		podContainer := &pod.Spec.Containers[ci]
+
+		// Only proceed if container is the one we monitor
+		if podContainer.Name != containerToMonitor {
+			continue
+		}
+
+		for si := range pod.Status.ContainerStatuses {
+			containerStatus := &pod.Status.ContainerStatuses[si]
+
+			// Only proceed if container is in some sort of Err status
+			if containerErroneousStatus(containerStatus) {",build/localnet/cluster-manager/crashed_pods_deleter.go,2023-05-18 20:37:09+00:00,2023-05-18T20:42:37Z,"if !containerErroneousStatus(containerStatus) {
	continue
}
// reduce the indent of everywhthing else",,,,,88,RIGHT,88,,line,https://api.github.com/repos/pokt-network/pocket/pulls/737,pokt-network/pocket,470f4fea2cbd51f6f46dcf83750ad8d175f956fe
https://api.github.com/repos/pokt-network/pocket/pulls/737,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1198281465,Olshansk,6de718cf0c8336a61979165a6d2512329d01c22f,1e6aad9882250a655c410bff253458fec4b37bb9,"@@ -0,0 +1,135 @@
+package main
+
+// Monitors Pods created by StatefulSets, and if the Pods are in a `CrashLoopBackOff` status,
+// and they have a different image tag - kill them. StatefulSet would then recreate the Pod with a new image.
+
+import (
+	""context""
+	""errors""
+	""strings""
+
+	pocketk8s ""github.com/pokt-network/pocket/shared/k8s""
+	corev1 ""k8s.io/api/core/v1""
+	metav1 ""k8s.io/apimachinery/pkg/apis/meta/v1""
+	watch ""k8s.io/apimachinery/pkg/watch""
+	""k8s.io/client-go/kubernetes""
+	appstypedv1 ""k8s.io/client-go/kubernetes/typed/apps/v1""
+	coretypedv1 ""k8s.io/client-go/kubernetes/typed/core/v1""
+)
+
+// Loop through existing pods and set up a watch for new Pods so we don't hit Kubernetes API all the time
+func initCrashedPodsDeleter(client *kubernetes.Clientset) {
+	stsClient := client.AppsV1().StatefulSets(pocketk8s.CurrentNamespace)
+	podClient := client.CoreV1().Pods(pocketk8s.CurrentNamespace)
+
+	// Loop through all existing Pods and delete the ones that are in CrashLoopBackOff status",build/localnet/cluster-manager/crashed_pods_deleter.go,2023-05-18 20:38:31+00:00,2023-05-18T20:42:37Z,Just wanted to call out that your comment are great in this PR,,,,26.0,25,RIGHT,25,26.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/737,pokt-network/pocket,470f4fea2cbd51f6f46dcf83750ad8d175f956fe
https://api.github.com/repos/pokt-network/pocket/pulls/737,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1198282247,Olshansk,6de718cf0c8336a61979165a6d2512329d01c22f,1e6aad9882250a655c410bff253458fec4b37bb9,"@@ -0,0 +1,135 @@
+package main
+
+// Monitors Pods created by StatefulSets, and if the Pods are in a `CrashLoopBackOff` status,
+// and they have a different image tag - kill them. StatefulSet would then recreate the Pod with a new image.
+
+import (
+	""context""
+	""errors""
+	""strings""
+
+	pocketk8s ""github.com/pokt-network/pocket/shared/k8s""
+	corev1 ""k8s.io/api/core/v1""
+	metav1 ""k8s.io/apimachinery/pkg/apis/meta/v1""
+	watch ""k8s.io/apimachinery/pkg/watch""
+	""k8s.io/client-go/kubernetes""
+	appstypedv1 ""k8s.io/client-go/kubernetes/typed/apps/v1""
+	coretypedv1 ""k8s.io/client-go/kubernetes/typed/core/v1""
+)
+
+// Loop through existing pods and set up a watch for new Pods so we don't hit Kubernetes API all the time
+func initCrashedPodsDeleter(client *kubernetes.Clientset) {",build/localnet/cluster-manager/crashed_pods_deleter.go,2023-05-18 20:39:33+00:00,2023-05-18T20:42:37Z,Can you add a comment that this is a blocking function and intended to be called as a goroutine?,,,,22.0,21,RIGHT,21,22.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/737,pokt-network/pocket,470f4fea2cbd51f6f46dcf83750ad8d175f956fe
https://api.github.com/repos/pokt-network/pocket/pulls/737,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1198284387,Olshansk,6de718cf0c8336a61979165a6d2512329d01c22f,1e6aad9882250a655c410bff253458fec4b37bb9,"@@ -21,4 +21,41 @@ spec:
       env:
         - name: RPC_HOST
           value: pocket-full-nodes
-  serviceAccountName: cluster-manager-account
+  serviceAccountName: cluster-manager",build/localnet/manifests/cluster-manager.yaml,2023-05-18 20:42:17+00:00,2023-05-18T20:42:37Z,"Was going to ask you questions but ChatGPT explained everything :)

![ChatGPT-Explaining_Kubernetes_Manifest_Components](https://github.com/pokt-network/pocket/assets/1892194/ec6f8c3c-233a-406b-a422-4172c3d619f9)
",,,,24.0,24,RIGHT,5,5.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/737,pokt-network/pocket,470f4fea2cbd51f6f46dcf83750ad8d175f956fe
https://api.github.com/repos/pokt-network/pocket/pulls/764,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1197029831,dylanlott,dc4b562798739d2bb92b100330daebeeee5f20d5,e29f979674a92dba8197de8231b467b87a07b09d,"@@ -10,7 +10,7 @@ import (
 )
 
 const (
-	cliExecutableName = ""client""
+	cliExecutableName = ""p1""",app/client/cli/cmd.go,2023-05-17 20:40:18+00:00,2023-05-17T20:40:30Z,"A lot of infra relies on this path indirectly and any change will need to be thoroughly vetted through that process. I'm not opposed to a name change on good grounds, but I'm not understanding how this is worthwhile. In the past, `pocket` has been avoided because it wasn't descriptive in context, so `client` could certainly be improved upon. `p1` is similarly vague, I would argue. Naming is a hard problem 😅",,,,13.0,13,RIGHT,5,5.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/764,pokt-network/pocket,24fa3cf5cc41dbc96e508db9674358cbdac65b3a
https://api.github.com/repos/pokt-network/pocket/pulls/763,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1199510858,Olshansk,a87e5cdb98f814c2886ab63dafc592ff594c9ba2,33b5b58c03980782c40bfbffa64b5c92ed91a0c5,"@@ -7,6 +7,16 @@ and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0
 
 ## [Unreleased]
 
+## [0.0.0.51] - 2023-05-19
+
+- Added `Handler` field to `RainTreeConfig` & `BackgroundConfig`
+- Refactored `rainTreeRouter` logging methods
+- Renamed `rainTreeRouter#HandleNetworkData()` to `#handleRainTreeMsg()`
+- Renamed `p2pModule#handleNetworkData()` to `#handleAppData()`
+- Added -tags=test to all test make targets",p2p/CHANGELOG.md,2023-05-20 00:38:44+00:00,2023-05-22T21:27:54Z,I like how you found a spot to fit this in :),,,,16.0,16,RIGHT,10,10.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/763,pokt-network/pocket,fba11c3f7cf66379028a9396e6eb4b66f0c43199
https://api.github.com/repos/pokt-network/pocket/pulls/763,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1199511224,Olshansk,a87e5cdb98f814c2886ab63dafc592ff594c9ba2,33b5b58c03980782c40bfbffa64b5c92ed91a0c5,"@@ -341,95 +326,11 @@ func (m *p2pModule) isClientDebugMode() bool {
 	return m.GetBus().GetRuntimeMgr().GetConfig().ClientDebugMode
 }
 
-// handleStream is called each time a peer establishes a new stream with this
-// module's libp2p `host.Host`.
-func (m *p2pModule) handleStream(stream libp2pNetwork.Stream) {
-	m.logger.Debug().Msg(""handling incoming stream"")
-	peer, err := utils.PeerFromLibp2pStream(stream)
-	if err != nil {
-		m.logger.Error().Err(err).
-			Str(""address"", peer.GetAddress().String()).
-			Msg(""parsing remote peer identity"")
-
-		if err = stream.Reset(); err != nil {
-			m.logger.Error().Err(err).Msg(""resetting stream"")
-		}
-		return
-	}
-
-	if err := m.router.AddPeer(peer); err != nil {
-		m.logger.Error().Err(err).
-			Str(""address"", peer.GetAddress().String()).
-			Msg(""adding remote peer to router"")
-	}
-
-	go m.readStream(stream)
-}
-
-// readStream is intended to be called in a goroutine. It continuously reads from
-// the given stream for handling at the network level. Used for handling ""direct""
-// messages (i.e. one specific target node).
-func (m *p2pModule) readStream(stream libp2pNetwork.Stream) {
-	// Time out if no data is sent to free resources.
-	if err := stream.SetReadDeadline(newReadStreamDeadline()); err != nil {
-		// NB: tests using libp2p's `mocknet` rely on this not returning an error.
-		// `SetReadDeadline` not supported by `mocknet` streams.
-		m.logger.Debug().Err(err).Msg(""setting stream read deadline"")
-	}
-
-	// debug logging: stream scope stats
-	// (see: https://pkg.go.dev/github.com/libp2p/go-libp2p@v0.27.0/core/network#StreamScope)
-	if err := utils.LogScopeStatFactory(
-		&logger.Global.Logger,
-		""stream scope (read-side)"",
-	)(stream.Scope()); err != nil {
-		m.logger.Debug().Err(err).Msg(""logging stream scope stats"")
-	}
-	// ---
-
-	data, err := io.ReadAll(stream)
-	if err != nil {
-		m.logger.Error().Err(err).Msg(""reading from stream"")
-		if err := stream.Reset(); err != nil {
-			m.logger.Debug().Err(err).Msg(""resetting stream (read-side)"")
-		}
-		return
-	}
-
-	if err := stream.Reset(); err != nil {
-		m.logger.Debug().Err(err).Msg(""resetting stream (read-side)"")
-	}
-
-	// debug logging
-	remotePeer, err := utils.PeerFromLibp2pStream(stream)
-	if err != nil {
-		m.logger.Debug().Err(err).Msg(""getting remote remotePeer"")
-	} else {
-		utils.LogIncomingMsg(m.logger, m.cfg.Hostname, remotePeer)
-	}
-	// ---
-
-	if err := m.handleNetworkData(data); err != nil {
-		m.logger.Error().Err(err).Msg(""handling network data"")
-	}
-}
-
-// handleNetworkData passes a network message to the configured
-// `Router`implementation for routing.
-func (m *p2pModule) handleNetworkData(data []byte) error {
-	appMsgData, err := m.router.HandleNetworkData(data)
-	if err != nil {
-		return err
-	}
-
-	// There was no error, but we don't need to forward this to the app-specific bus.
-	// For example, the message has already been handled by the application.
-	if appMsgData == nil {
-		return nil
-	}
-
+// handleAppData deserializes the received `PocketEnvelope` data and publishes
+// a copy of its `Content` to the application event bus.
+func (m *p2pModule) handleAppData(data []byte) error {",p2p/module.go,2023-05-20 00:41:11+00:00,2023-05-22T21:27:54Z,Thought on `s/data/pocketEnvelopeData`?,,,,,331,RIGHT,143,,line,https://api.github.com/repos/pokt-network/pocket/pulls/763,pokt-network/pocket,fba11c3f7cf66379028a9396e6eb4b66f0c43199
https://api.github.com/repos/pokt-network/pocket/pulls/763,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1199511314,Olshansk,a87e5cdb98f814c2886ab63dafc592ff594c9ba2,33b5b58c03980782c40bfbffa64b5c92ed91a0c5,"@@ -341,95 +326,11 @@ func (m *p2pModule) isClientDebugMode() bool {
 	return m.GetBus().GetRuntimeMgr().GetConfig().ClientDebugMode
 }
 
-// handleStream is called each time a peer establishes a new stream with this
-// module's libp2p `host.Host`.
-func (m *p2pModule) handleStream(stream libp2pNetwork.Stream) {
-	m.logger.Debug().Msg(""handling incoming stream"")
-	peer, err := utils.PeerFromLibp2pStream(stream)
-	if err != nil {
-		m.logger.Error().Err(err).
-			Str(""address"", peer.GetAddress().String()).
-			Msg(""parsing remote peer identity"")
-
-		if err = stream.Reset(); err != nil {
-			m.logger.Error().Err(err).Msg(""resetting stream"")
-		}
-		return
-	}
-
-	if err := m.router.AddPeer(peer); err != nil {
-		m.logger.Error().Err(err).
-			Str(""address"", peer.GetAddress().String()).
-			Msg(""adding remote peer to router"")
-	}
-
-	go m.readStream(stream)
-}
-
-// readStream is intended to be called in a goroutine. It continuously reads from
-// the given stream for handling at the network level. Used for handling ""direct""
-// messages (i.e. one specific target node).
-func (m *p2pModule) readStream(stream libp2pNetwork.Stream) {
-	// Time out if no data is sent to free resources.
-	if err := stream.SetReadDeadline(newReadStreamDeadline()); err != nil {
-		// NB: tests using libp2p's `mocknet` rely on this not returning an error.
-		// `SetReadDeadline` not supported by `mocknet` streams.
-		m.logger.Debug().Err(err).Msg(""setting stream read deadline"")
-	}
-
-	// debug logging: stream scope stats
-	// (see: https://pkg.go.dev/github.com/libp2p/go-libp2p@v0.27.0/core/network#StreamScope)
-	if err := utils.LogScopeStatFactory(
-		&logger.Global.Logger,
-		""stream scope (read-side)"",
-	)(stream.Scope()); err != nil {
-		m.logger.Debug().Err(err).Msg(""logging stream scope stats"")
-	}
-	// ---
-
-	data, err := io.ReadAll(stream)
-	if err != nil {
-		m.logger.Error().Err(err).Msg(""reading from stream"")
-		if err := stream.Reset(); err != nil {
-			m.logger.Debug().Err(err).Msg(""resetting stream (read-side)"")
-		}
-		return
-	}
-
-	if err := stream.Reset(); err != nil {
-		m.logger.Debug().Err(err).Msg(""resetting stream (read-side)"")
-	}
-
-	// debug logging
-	remotePeer, err := utils.PeerFromLibp2pStream(stream)
-	if err != nil {
-		m.logger.Debug().Err(err).Msg(""getting remote remotePeer"")
-	} else {
-		utils.LogIncomingMsg(m.logger, m.cfg.Hostname, remotePeer)
-	}
-	// ---
-
-	if err := m.handleNetworkData(data); err != nil {
-		m.logger.Error().Err(err).Msg(""handling network data"")
-	}
-}
-
-// handleNetworkData passes a network message to the configured
-// `Router`implementation for routing.
-func (m *p2pModule) handleNetworkData(data []byte) error {
-	appMsgData, err := m.router.HandleNetworkData(data)
-	if err != nil {
-		return err
-	}
-
-	// There was no error, but we don't need to forward this to the app-specific bus.
-	// For example, the message has already been handled by the application.
-	if appMsgData == nil {
-		return nil
-	}
-
+// handleAppData deserializes the received `PocketEnvelope` data and publishes
+// a copy of its `Content` to the application event bus.
+func (m *p2pModule) handleAppData(data []byte) error {
 	networkMessage := messaging.PocketEnvelope{}",p2p/module.go,2023-05-20 00:41:32+00:00,2023-05-22T21:27:54Z,s/networkMessages/pocketEnvelope,,,,,332,RIGHT,144,,line,https://api.github.com/repos/pokt-network/pocket/pulls/763,pokt-network/pocket,fba11c3f7cf66379028a9396e6eb4b66f0c43199
https://api.github.com/repos/pokt-network/pocket/pulls/763,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1199511708,Olshansk,a87e5cdb98f814c2886ab63dafc592ff594c9ba2,33b5b58c03980782c40bfbffa64b5c92ed91a0c5,"@@ -1,3 +1,5 @@
+//go:build test",p2p/module_raintree_test.go,2023-05-20 00:44:19+00:00,2023-05-22T21:27:54Z,"Should we add a linter for this? Dima recently added a custom one in `build/linters/tests.go` and it looks like we have access to the `File.Name` via the dsl matcher, but I don't know if there's any easy way to check for the first line.

Can be done in a separate commit, not a blocker.

```
type File struct {
	// Name is a file base name.
	Name String

	// PkgPath is a file package path.
	// Examples: ""io/ioutil"", ""strings"", ""github.com/quasilyte/go-ruleguard/dsl"".
	PkgPath String
}
```",,,,1.0,1,RIGHT,1,1.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/763,pokt-network/pocket,fba11c3f7cf66379028a9396e6eb4b66f0c43199
https://api.github.com/repos/pokt-network/pocket/pulls/763,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1201120109,Olshansk,a87e5cdb98f814c2886ab63dafc592ff594c9ba2,33b5b58c03980782c40bfbffa64b5c92ed91a0c5,"@@ -0,0 +1,31 @@
+package raintree
+
+import (
+	libp2pNetwork ""github.com/libp2p/go-libp2p/core/network""
+
+	""github.com/pokt-network/pocket/logger""
+	""github.com/pokt-network/pocket/p2p/utils""
+)
+
+// logStream logs the incoming stream and its scope stats
+func (rtr *rainTreeRouter) logStream(stream libp2pNetwork.Stream) {
+	rtr.logStreamScopeStats(stream)
+
+	remotePeer, err := utils.PeerFromLibp2pStream(stream)
+	if err != nil {
+		rtr.logger.Debug().Err(err).Msg(""getting remote remotePeer"")",p2p/raintree/logging.go,2023-05-22 21:17:25+00:00,2023-05-22T21:27:54Z,"Why did you go with `Debug` instead of `Error` here?

Ditto below",,,,16.0,16,RIGHT,16,16.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/763,pokt-network/pocket,fba11c3f7cf66379028a9396e6eb4b66f0c43199
https://api.github.com/repos/pokt-network/pocket/pulls/763,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1201126522,Olshansk,a87e5cdb98f814c2886ab63dafc592ff594c9ba2,33b5b58c03980782c40bfbffa64b5c92ed91a0c5,"@@ -0,0 +1,13 @@
+//go:build test
+
+package raintree
+
+import libp2pNetwork ""github.com/libp2p/go-libp2p/core/network""
+
+// RainTreeRouter exports `rainTreeRouter` for testing purposes.",p2p/raintree/testutil.go,2023-05-22 21:20:23+00:00,2023-05-22T21:27:54Z,I like this design 💯 ,,,,7.0,7,RIGHT,7,7.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/763,pokt-network/pocket,fba11c3f7cf66379028a9396e6eb4b66f0c43199
https://api.github.com/repos/pokt-network/pocket/pulls/763,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1201128404,Olshansk,a87e5cdb98f814c2886ab63dafc592ff594c9ba2,33b5b58c03980782c40bfbffa64b5c92ed91a0c5,"@@ -282,6 +298,79 @@ func (rtr *rainTreeRouter) Size() int {
 	return rtr.peersManager.GetPeerstore().Size()
 }
 
+// handleStream ensures the peerstore contains the remote peer and then reads
+// the incoming stream in a new go routine.
+func (rtr *rainTreeRouter) handleStream(stream libp2pNetwork.Stream) {
+	rtr.logger.Debug().Msg(""handling incoming stream"")
+	peer, err := utils.PeerFromLibp2pStream(stream)
+	if err != nil {
+		rtr.logger.Error().Err(err).
+			Str(""address"", peer.GetAddress().String()).
+			Msg(""parsing remote peer identity"")
+
+		if err = stream.Reset(); err != nil {
+			rtr.logger.Error().Err(err).Msg(""resetting stream"")
+		}
+		return
+	}
+
+	if err := rtr.AddPeer(peer); err != nil {
+		rtr.logger.Error().Err(err).
+			Str(""address"", peer.GetAddress().String()).
+			Msg(""adding remote peer to router"")
+	}
+
+	go rtr.readStream(stream)
+}
+
+// readStream reads the incoming stream, extracts the serialized `PocketEnvelope`
+// data from the incoming `RainTreeMessage`, and passes it to the application by
+// calling the configured `rtr.handler`.
+func (rtr *rainTreeRouter) readStream(stream libp2pNetwork.Stream) {
+	// Time out if no data is sent to free resources.
+	if err := stream.SetReadDeadline(newReadStreamDeadline()); err != nil {
+		// NB: tests using libp2p's `mocknet` rely on this not returning an error.
+		// `SetReadDeadline` not supported by `mocknet` streams.
+		rtr.logger.Debug().Err(err).Msg(""setting stream read deadline"")",p2p/raintree/router.go,2023-05-22 21:22:27+00:00,2023-05-22T21:27:54Z,Ditto. Noticed you're using Debug instead of Err for a lot of these. Why is that?,,,,,334,RIGHT,110,,line,https://api.github.com/repos/pokt-network/pocket/pulls/763,pokt-network/pocket,fba11c3f7cf66379028a9396e6eb4b66f0c43199
https://api.github.com/repos/pokt-network/pocket/pulls/763,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1201129100,Olshansk,a87e5cdb98f814c2886ab63dafc592ff594c9ba2,33b5b58c03980782c40bfbffa64b5c92ed91a0c5,"@@ -282,6 +298,79 @@ func (rtr *rainTreeRouter) Size() int {
 	return rtr.peersManager.GetPeerstore().Size()
 }
 
+// handleStream ensures the peerstore contains the remote peer and then reads
+// the incoming stream in a new go routine.
+func (rtr *rainTreeRouter) handleStream(stream libp2pNetwork.Stream) {
+	rtr.logger.Debug().Msg(""handling incoming stream"")
+	peer, err := utils.PeerFromLibp2pStream(stream)
+	if err != nil {
+		rtr.logger.Error().Err(err).
+			Str(""address"", peer.GetAddress().String()).
+			Msg(""parsing remote peer identity"")
+
+		if err = stream.Reset(); err != nil {
+			rtr.logger.Error().Err(err).Msg(""resetting stream"")
+		}
+		return
+	}
+
+	if err := rtr.AddPeer(peer); err != nil {
+		rtr.logger.Error().Err(err).
+			Str(""address"", peer.GetAddress().String()).
+			Msg(""adding remote peer to router"")
+	}
+
+	go rtr.readStream(stream)
+}
+
+// readStream reads the incoming stream, extracts the serialized `PocketEnvelope`
+// data from the incoming `RainTreeMessage`, and passes it to the application by
+// calling the configured `rtr.handler`.
+func (rtr *rainTreeRouter) readStream(stream libp2pNetwork.Stream) {
+	// Time out if no data is sent to free resources.
+	if err := stream.SetReadDeadline(newReadStreamDeadline()); err != nil {
+		// NB: tests using libp2p's `mocknet` rely on this not returning an error.",p2p/raintree/router.go,2023-05-22 21:23:18+00:00,2023-05-22T21:27:54Z,I think you should move this to the method header and add that the function is intended to be called in a goroutine.,,,,,332,RIGHT,108,,line,https://api.github.com/repos/pokt-network/pocket/pulls/763,pokt-network/pocket,fba11c3f7cf66379028a9396e6eb4b66f0c43199
https://api.github.com/repos/pokt-network/pocket/pulls/763,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1201129799,Olshansk,a87e5cdb98f814c2886ab63dafc592ff594c9ba2,33b5b58c03980782c40bfbffa64b5c92ed91a0c5,"@@ -282,6 +298,79 @@ func (rtr *rainTreeRouter) Size() int {
 	return rtr.peersManager.GetPeerstore().Size()
 }
 
+// handleStream ensures the peerstore contains the remote peer and then reads
+// the incoming stream in a new go routine.
+func (rtr *rainTreeRouter) handleStream(stream libp2pNetwork.Stream) {
+	rtr.logger.Debug().Msg(""handling incoming stream"")
+	peer, err := utils.PeerFromLibp2pStream(stream)
+	if err != nil {
+		rtr.logger.Error().Err(err).
+			Str(""address"", peer.GetAddress().String()).
+			Msg(""parsing remote peer identity"")
+
+		if err = stream.Reset(); err != nil {
+			rtr.logger.Error().Err(err).Msg(""resetting stream"")
+		}
+		return
+	}
+
+	if err := rtr.AddPeer(peer); err != nil {
+		rtr.logger.Error().Err(err).
+			Str(""address"", peer.GetAddress().String()).
+			Msg(""adding remote peer to router"")
+	}
+
+	go rtr.readStream(stream)
+}
+
+// readStream reads the incoming stream, extracts the serialized `PocketEnvelope`
+// data from the incoming `RainTreeMessage`, and passes it to the application by
+// calling the configured `rtr.handler`.
+func (rtr *rainTreeRouter) readStream(stream libp2pNetwork.Stream) {
+	// Time out if no data is sent to free resources.
+	if err := stream.SetReadDeadline(newReadStreamDeadline()); err != nil {
+		// NB: tests using libp2p's `mocknet` rely on this not returning an error.
+		// `SetReadDeadline` not supported by `mocknet` streams.
+		rtr.logger.Debug().Err(err).Msg(""setting stream read deadline"")
+	}
+
+	// log incoming stream
+	rtr.logStream(stream)
+
+	// read stream
+	data, err := io.ReadAll(stream)
+	if err != nil {
+		rtr.logger.Error().Err(err).Msg(""reading from stream"")
+		if err := stream.Reset(); err != nil {
+			rtr.logger.Debug().Err(err).Msg(""resetting stream (read-side)"")
+		}
+		return
+	}
+
+	// done reading; reset to signal this to remote peer",p2p/raintree/router.go,2023-05-22 21:24:01+00:00,2023-05-22T21:27:54Z,"Add a note that if we don't do this, we can easily max out the number of open network connections on the receiver's side",,,,350.0,350,RIGHT,126,126.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/763,pokt-network/pocket,fba11c3f7cf66379028a9396e6eb4b66f0c43199
https://api.github.com/repos/pokt-network/pocket/pulls/763,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1201133126,Olshansk,a87e5cdb98f814c2886ab63dafc592ff594c9ba2,33b5b58c03980782c40bfbffa64b5c92ed91a0c5,"@@ -282,6 +298,79 @@ func (rtr *rainTreeRouter) Size() int {
 	return rtr.peersManager.GetPeerstore().Size()
 }
 
+// handleStream ensures the peerstore contains the remote peer and then reads
+// the incoming stream in a new go routine.
+func (rtr *rainTreeRouter) handleStream(stream libp2pNetwork.Stream) {
+	rtr.logger.Debug().Msg(""handling incoming stream"")
+	peer, err := utils.PeerFromLibp2pStream(stream)
+	if err != nil {
+		rtr.logger.Error().Err(err).
+			Str(""address"", peer.GetAddress().String()).
+			Msg(""parsing remote peer identity"")
+
+		if err = stream.Reset(); err != nil {
+			rtr.logger.Error().Err(err).Msg(""resetting stream"")
+		}
+		return
+	}
+
+	if err := rtr.AddPeer(peer); err != nil {
+		rtr.logger.Error().Err(err).
+			Str(""address"", peer.GetAddress().String()).
+			Msg(""adding remote peer to router"")
+	}
+
+	go rtr.readStream(stream)
+}
+
+// readStream reads the incoming stream, extracts the serialized `PocketEnvelope`
+// data from the incoming `RainTreeMessage`, and passes it to the application by
+// calling the configured `rtr.handler`.
+func (rtr *rainTreeRouter) readStream(stream libp2pNetwork.Stream) {
+	// Time out if no data is sent to free resources.
+	if err := stream.SetReadDeadline(newReadStreamDeadline()); err != nil {
+		// NB: tests using libp2p's `mocknet` rely on this not returning an error.
+		// `SetReadDeadline` not supported by `mocknet` streams.
+		rtr.logger.Debug().Err(err).Msg(""setting stream read deadline"")
+	}
+
+	// log incoming stream
+	rtr.logStream(stream)
+
+	// read stream
+	data, err := io.ReadAll(stream)
+	if err != nil {
+		rtr.logger.Error().Err(err).Msg(""reading from stream"")
+		if err := stream.Reset(); err != nil {
+			rtr.logger.Debug().Err(err).Msg(""resetting stream (read-side)"")
+		}
+		return
+	}
+
+	// done reading; reset to signal this to remote peer
+	if err := stream.Reset(); err != nil {
+		rtr.logger.Debug().Err(err).Msg(""resetting stream (read-side)"")
+	}
+
+	// extract `PocketEnvelope` from `RainTreeMessage` (& continue propagation)
+	appMsgData, err := rtr.handleRainTreeMsg(data)",p2p/raintree/router.go,2023-05-22 21:26:40+00:00,2023-05-22T21:27:54Z,"`s/appMsgData/pocketEnvelopeBz` ?

I realize you were staying consistent with what we had before but doesn't hurt to be more explicit seeing how we're already here.",,,,,356,RIGHT,132,,line,https://api.github.com/repos/pokt-network/pocket/pulls/763,pokt-network/pocket,fba11c3f7cf66379028a9396e6eb4b66f0c43199
https://api.github.com/repos/pokt-network/pocket/pulls/763,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1202800963,dylanlott,77d91f1c082818529d91387c03a34b0e73562acc,33b5b58c03980782c40bfbffa64b5c92ed91a0c5,"@@ -339,102 +339,102 @@ generate_node_state_machine_diagram: ## (Re)generates the Node State Machine dia
 
 .PHONY: test_all
 test_all: ## Run all go unit tests
-	go test -p=1 -count=1 ./...
+	go test -p=1 -count=1 -tags=test ./...
 
 .PHONY: test_e2e
 test_e2e: kubectl_check ## Run all E2E tests
 	echo ""IMPROVE(#759): Make sure you ran 'make localnet_up' in case this fails with infrastructure related errors.""
-	go test ${VERBOSE_TEST} -count=1 ./e2e/tests/... -tags=e2e
+	go test ${VERBOSE_TEST} -count=1 -tags=test,e2e ./e2e/tests/...
 
 .PHONY: test_all_with_json_coverage
 test_all_with_json_coverage: generate_rpc_openapi ## Run all go unit tests, output results & coverage into json & coverage files
-	go test -p=1 -count=1 -json ./... -covermode=count -coverprofile=coverage.out | tee test_results.json | jq
+	go test -p=1 -count=1 -tags=test -json ./... -covermode=count -coverprofile=coverage.out | tee test_results.json | jq
 
 .PHONY: test_race
 test_race: ## Identify all unit tests that may result in race conditions
-	go test ${VERBOSE_TEST} -race -count=1 ./...
+	go test ${VERBOSE_TEST} -race -count=1 -tags=test ./...
 
 .PHONY: test_app
 test_app: ## Run all go app module unit tests
-	go test ${VERBOSE_TEST} -p=1 -count=1  ./app/...
+	go test ${VERBOSE_TEST} -p=1 -count=1 -tags=test ./app/...
 
 .PHONY: test_utility
 test_utility: ## Run all go utility module unit tests
-	go test ${VERBOSE_TEST} -p=1 -count=1  ./utility/...
+	go test ${VERBOSE_TEST} -p=1 -count=1 -tags=test./utility/...",Makefile,2023-05-23 18:05:59+00:00,2023-05-23T18:08:03Z,I think you need a space between test and ./utility ,,,,,363,RIGHT,31,,line,https://api.github.com/repos/pokt-network/pocket/pulls/763,pokt-network/pocket,fba11c3f7cf66379028a9396e6eb4b66f0c43199
https://api.github.com/repos/pokt-network/pocket/pulls/763,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1204582402,bryanchriswhite,77d91f1c082818529d91387c03a34b0e73562acc,33b5b58c03980782c40bfbffa64b5c92ed91a0c5,"@@ -339,102 +339,102 @@ generate_node_state_machine_diagram: ## (Re)generates the Node State Machine dia
 
 .PHONY: test_all
 test_all: ## Run all go unit tests
-	go test -p=1 -count=1 ./...
+	go test -p=1 -count=1 -tags=test ./...
 
 .PHONY: test_e2e
 test_e2e: kubectl_check ## Run all E2E tests
 	echo ""IMPROVE(#759): Make sure you ran 'make localnet_up' in case this fails with infrastructure related errors.""
-	go test ${VERBOSE_TEST} -count=1 ./e2e/tests/... -tags=e2e
+	go test ${VERBOSE_TEST} -count=1 -tags=test,e2e ./e2e/tests/...
 
 .PHONY: test_all_with_json_coverage
 test_all_with_json_coverage: generate_rpc_openapi ## Run all go unit tests, output results & coverage into json & coverage files
-	go test -p=1 -count=1 -json ./... -covermode=count -coverprofile=coverage.out | tee test_results.json | jq
+	go test -p=1 -count=1 -tags=test -json ./... -covermode=count -coverprofile=coverage.out | tee test_results.json | jq
 
 .PHONY: test_race
 test_race: ## Identify all unit tests that may result in race conditions
-	go test ${VERBOSE_TEST} -race -count=1 ./...
+	go test ${VERBOSE_TEST} -race -count=1 -tags=test ./...
 
 .PHONY: test_app
 test_app: ## Run all go app module unit tests
-	go test ${VERBOSE_TEST} -p=1 -count=1  ./app/...
+	go test ${VERBOSE_TEST} -p=1 -count=1 -tags=test ./app/...
 
 .PHONY: test_utility
 test_utility: ## Run all go utility module unit tests
-	go test ${VERBOSE_TEST} -p=1 -count=1  ./utility/...
+	go test ${VERBOSE_TEST} -p=1 -count=1 -tags=test./utility/...",Makefile,2023-05-24 18:01:03+00:00,2023-05-24T18:01:04Z,"```suggestion
	go test ${VERBOSE_TEST} -p=1 -count=1 -tags=test ./utility/...
```",,,,,363,RIGHT,31,,line,https://api.github.com/repos/pokt-network/pocket/pulls/763,pokt-network/pocket,fba11c3f7cf66379028a9396e6eb4b66f0c43199
https://api.github.com/repos/pokt-network/pocket/pulls/763,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1210762055,Olshansk,33b5b58c03980782c40bfbffa64b5c92ed91a0c5,33b5b58c03980782c40bfbffa64b5c92ed91a0c5,"@@ -282,6 +298,81 @@ func (rtr *rainTreeRouter) Size() int {
 	return rtr.peersManager.GetPeerstore().Size()
 }
 
+// handleStream ensures the peerstore contains the remote peer and then reads
+// the incoming stream in a new go routine.
+func (rtr *rainTreeRouter) handleStream(stream libp2pNetwork.Stream) {
+	rtr.logger.Debug().Msg(""handling incoming stream"")",p2p/raintree/router.go,2023-05-30 19:58:51+00:00,2023-05-30T20:20:37Z,"Optional NIT: Since you use logging quite extensively here, it might be an opportunity to create a local logger with a source

```go
logger := rtr.logger.With().Fields(map[string]interface{}{
	""source"": ""handleStream"",
}).Logger()
```

Ditto bellow.",,,,304.0,304,RIGHT,80,80.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/763,pokt-network/pocket,fba11c3f7cf66379028a9396e6eb4b66f0c43199
https://api.github.com/repos/pokt-network/pocket/pulls/767,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1199315184,okdas,3c3cfe7a2ec5c592c1190e9b58dfe0d17dbcd2db,b3b8aaf009fa13b29749c2ecc540ace1121732c0,"@@ -6,13 +6,7 @@ on:
   workflow_dispatch:
   push:
     branches: [main]
-    paths-ignore:",.github/workflows/main.yml,2023-05-19 19:47:30+00:00,2023-05-19T19:47:31Z,"Given that we now depend on the most recent gitsha from the pull request (PR) to include a container image, we should not hinder the continuous integration (CI) process from generating an image in cases where only a documentation change is made.",,,,9.0,9,LEFT,4,4.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/767,pokt-network/pocket,cb0a0ab2039aef70f964e6a136a229772922b352
https://api.github.com/repos/pokt-network/pocket/pulls/767,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1199511569,okdas,c57c6e88a363ae1d2ad35a5ed7761dbb7cb3424f,b3b8aaf009fa13b29749c2ecc540ace1121732c0,"@@ -151,3 +145,57 @@ jobs:
           cache-to: type=gha,mode=max
           build-args: |
             TARGET_GOLANG_VERSION=${{ env.TARGET_GOLANG_VERSION }}
+
+
+  # Run e2e tests on devnet IF the PR has a label ""e2e-devnet-test""
+  e2e-tests:",.github/workflows/main.yml,2023-05-20 00:43:26+00:00,2023-05-20T01:07:10Z,"I missed a clarification in the Github Actions documentation that old implementation would only work on the default branch, so having a separate workflow did not work. Going to have a larger main workflow instead.",,,,159.0,151,RIGHT,21,29.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/767,pokt-network/pocket,cb0a0ab2039aef70f964e6a136a229772922b352
https://api.github.com/repos/pokt-network/pocket/pulls/767,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1201272101,Olshansk,63cc793925b60fe29d70b190799d4326dae33857,b3b8aaf009fa13b29749c2ecc540ace1121732c0,"@@ -151,3 +145,58 @@ jobs:
           cache-to: type=gha,mode=max
           build-args: |
             TARGET_GOLANG_VERSION=${{ env.TARGET_GOLANG_VERSION }}
+
+
+  # Run e2e tests on devnet IF the PR has a label ""e2e-devnet-test""",.github/workflows/main.yml,2023-05-22 23:03:39+00:00,2023-05-22T23:09:34Z,"```suggestion
  # Run e2e tests on devnet if the PR has a label ""e2e-devnet-test""
```",,,,,150,RIGHT,20,,line,https://api.github.com/repos/pokt-network/pocket/pulls/767,pokt-network/pocket,cb0a0ab2039aef70f964e6a136a229772922b352
https://api.github.com/repos/pokt-network/pocket/pulls/767,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1201280226,Olshansk,63cc793925b60fe29d70b190799d4326dae33857,b3b8aaf009fa13b29749c2ecc540ace1121732c0,"@@ -170,6 +170,8 @@ service:
   annotations: {}",charts/pocket/values.yaml,2023-05-22 23:08:13+00:00,2023-05-22T23:09:34Z,"Was going to ask you some stuff, but learnt everything from ChatGPT.

![Screenshot 2023-05-22 at 4 07 50 PM](https://github.com/pokt-network/pocket/assets/1892194/531f40f7-dfc5-46ef-9223-86802bc8f8a8)
",,,,170.0,170,RIGHT,1,1.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/767,pokt-network/pocket,cb0a0ab2039aef70f964e6a136a229772922b352
https://api.github.com/repos/pokt-network/pocket/pulls/710,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1182035174,Olshansk,b6be2a930185debeb449f91b51d6c70a44a35401,fe90c0d0aa25c0b57cb2a9c2e3205c015ebc3ddf,"@@ -319,10 +319,11 @@ generate_rpc_openapi: go_oapi-codegen ## (Re)generates the RPC server and client
 	oapi-codegen  --config ./rpc/client.gen.config.yml ./rpc/v1/openapi.yaml > ./rpc/client.gen.go
 	echo ""OpenAPI client and server generated""
 
+SWAGGER_PORT=127.0.0.1:8080
 .PHONY: swagger-ui
 swagger-ui: ## Starts a local Swagger UI instance for the RPC API
 	echo ""Attempting to start Swagger UI at http://localhost:8080\n\n""
-	docker run -p 8080:8080 -e SWAGGER_JSON=/v1/openapi.yaml -v $(shell pwd)/rpc/v1:/v1 swaggerapi/swagger-ui
+	docker run --name pocket-swagger-ui --rm -p $(SWAGGER_PORT):8080 -e SWAGGER_JSON=/v1/openapi.yaml -v $(shell pwd)/rpc/v1:/v1 swaggerapi/swagger-ui",Makefile,2023-05-02 02:46:03+00:00,2023-05-02T03:12:02Z,"Unlreated but I thought you'd appreciate this CLI util I discovered recently: https://github.com/jkfran/killport

Kill a process listening on a port ",,,,327.0,326,RIGHT,9,32.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/710,pokt-network/pocket,dbc0deb6a7aec39359745e9be952a4992689052a
https://api.github.com/repos/pokt-network/pocket/pulls/710,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1184450214,Olshansk,b6be2a930185debeb449f91b51d6c70a44a35401,fe90c0d0aa25c0b57cb2a9c2e3205c015ebc3ddf,"@@ -0,0 +1,57 @@
+{",build/config/fisherman.json,2023-05-04 01:21:59+00:00,2023-05-04T02:46:47Z,"NIT regarding file nameing.

1. Can you rename `fisherman.json` to `fisherman1.json` in case we add more; ditto for the servicer
2. Can you rename the `config*.json` to `validator*.json` so everything is semantically identified",,,,,1,RIGHT,1,,line,https://api.github.com/repos/pokt-network/pocket/pulls/710,pokt-network/pocket,dbc0deb6a7aec39359745e9be952a4992689052a
https://api.github.com/repos/pokt-network/pocket/pulls/710,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1184450861,Olshansk,b6be2a930185debeb449f91b51d6c70a44a35401,fe90c0d0aa25c0b57cb2a9c2e3205c015ebc3ddf,"@@ -0,0 +1,57 @@
+{
+  ""root_directory"": ""/go/src/github.com/pocket-network"",
+  ""private_key"": ""90ccfd6ba76d876e02ba09440af67582e0f4a37cbda2ce4c30b251132b670eda2777a49cdfde21867a538ddcfca05002f0115b1955a75b80e965ed63fc95f809"",
+  ""use_lib_p2p"": false,",build/config/fisherman.json,2023-05-04 01:22:42+00:00,2023-05-04T02:46:47Z,I believe this is deprecated now and can be removed. Ditto in servicer.json,,,,,4,RIGHT,4,,line,https://api.github.com/repos/pokt-network/pocket/pulls/710,pokt-network/pocket,dbc0deb6a7aec39359745e9be952a4992689052a
https://api.github.com/repos/pokt-network/pocket/pulls/710,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1184472746,Olshansk,b6be2a930185debeb449f91b51d6c70a44a35401,fe90c0d0aa25c0b57cb2a9c2e3205c015ebc3ddf,"@@ -0,0 +1,26 @@
+package rpc
+
+import (
+	""net/http""
+
+	""github.com/labstack/echo/v4""
+)
+
+func (s *rpcServer) PostV1ServicerRelay(ctx echo.Context) error {
+
+	// TODO: Move to the servicer module",rpc/handlers_servicer.go,2023-05-04 02:03:43+00:00,2023-05-04T02:46:47Z,Any reason not to do it in this PR?,,,,,11,RIGHT,11,,line,https://api.github.com/repos/pokt-network/pocket/pulls/710,pokt-network/pocket,dbc0deb6a7aec39359745e9be952a4992689052a
https://api.github.com/repos/pokt-network/pocket/pulls/710,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1184472786,Olshansk,b6be2a930185debeb449f91b51d6c70a44a35401,fe90c0d0aa25c0b57cb2a9c2e3205c015ebc3ddf,"@@ -0,0 +1,26 @@
+package rpc
+
+import (
+	""net/http""
+
+	""github.com/labstack/echo/v4""
+)
+
+func (s *rpcServer) PostV1ServicerRelay(ctx echo.Context) error {
+",rpc/handlers_servicer.go,2023-05-04 02:03:47+00:00,2023-05-04T02:46:47Z,"```suggestion
```",,,,,10,RIGHT,10,,line,https://api.github.com/repos/pokt-network/pocket/pulls/710,pokt-network/pocket,dbc0deb6a7aec39359745e9be952a4992689052a
https://api.github.com/repos/pokt-network/pocket/pulls/710,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1184473147,Olshansk,b6be2a930185debeb449f91b51d6c70a44a35401,fe90c0d0aa25c0b57cb2a9c2e3205c015ebc3ddf,"@@ -0,0 +1,26 @@
+package rpc
+
+import (
+	""net/http""
+
+	""github.com/labstack/echo/v4""
+)
+
+func (s *rpcServer) PostV1ServicerRelay(ctx echo.Context) error {
+
+	// TODO: Move to the servicer module
+	servicerModuleName := ""servicer""
+	found := false
+	for _, am := range s.GetBus().GetUtilityModule().GetActorModules() {",rpc/handlers_servicer.go,2023-05-04 02:04:51+00:00,2023-05-04T02:46:47Z,NIT: I think you can simply this using `slices.IndexFunc` https://stackoverflow.com/a/38654444/768439,,,,,14,RIGHT,14,,line,https://api.github.com/repos/pokt-network/pocket/pulls/710,pokt-network/pocket,dbc0deb6a7aec39359745e9be952a4992689052a
https://api.github.com/repos/pokt-network/pocket/pulls/710,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1184473258,Olshansk,b6be2a930185debeb449f91b51d6c70a44a35401,fe90c0d0aa25c0b57cb2a9c2e3205c015ebc3ddf,"@@ -91,6 +91,122 @@ paths:
           content:
             text/plain:
               example: ""description of failure""
+  /v1/servicer/relay:",rpc/v1/openapi.yaml,2023-05-04 02:05:18+00:00,2023-05-04T02:46:47Z,Make sure to rebase on top of @h5law's recent changes since I anticipate merge conflicts.,,,,,94,RIGHT,4,,line,https://api.github.com/repos/pokt-network/pocket/pulls/710,pokt-network/pocket,dbc0deb6a7aec39359745e9be952a4992689052a
https://api.github.com/repos/pokt-network/pocket/pulls/710,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1184474002,Olshansk,b6be2a930185debeb449f91b51d6c70a44a35401,fe90c0d0aa25c0b57cb2a9c2e3205c015ebc3ddf,"@@ -0,0 +1,75 @@
+package portal",utility/portal/module.go,2023-05-04 02:07:50+00:00,2023-05-04T02:46:47Z,"Let's remove the portal package for now because we added it to the spec after we started working on V1. 

I anticipate there will be a separate piece of work to add it in (the enum, this package, etc...) in the future, so I want to reduce the confusion.",,,,,1,RIGHT,1,,line,https://api.github.com/repos/pokt-network/pocket/pulls/710,pokt-network/pocket,dbc0deb6a7aec39359745e9be952a4992689052a
https://api.github.com/repos/pokt-network/pocket/pulls/710,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1184474824,Olshansk,b6be2a930185debeb449f91b51d6c70a44a35401,fe90c0d0aa25c0b57cb2a9c2e3205c015ebc3ddf,"@@ -1,35 +1,54 @@
 package utility
 
 import (
+	""errors""
+
 	""github.com/pokt-network/pocket/logger""
 	""github.com/pokt-network/pocket/runtime/configs""
 	""github.com/pokt-network/pocket/shared/mempool""
 	""github.com/pokt-network/pocket/shared/modules""
 	""github.com/pokt-network/pocket/shared/modules/base_modules""
+	""github.com/pokt-network/pocket/utility/fisherman""
+	fisherman_module ""github.com/pokt-network/pocket/utility/fisherman""",utility/module.go,2023-05-04 02:10:08+00:00,2023-05-04T02:46:47Z,"I think we should go with just `fisherman` instead of `fisherman_module`; ditto elsewhere

https://go.dev/blog/package-names

<img width=""851"" alt=""Screenshot 2023-05-03 at 7 09 53 PM"" src=""https://user-images.githubusercontent.com/1892194/236096025-6c88a5d5-efe0-4075-a91f-36d270dae6e3.png"">


",,,,,12,RIGHT,12,,line,https://api.github.com/repos/pokt-network/pocket/pulls/710,pokt-network/pocket,dbc0deb6a7aec39359745e9be952a4992689052a
https://api.github.com/repos/pokt-network/pocket/pulls/710,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1184482817,Olshansk,b6be2a930185debeb449f91b51d6c70a44a35401,fe90c0d0aa25c0b57cb2a9c2e3205c015ebc3ddf,"@@ -44,12 +63,94 @@ func (*utilityModule) Create(bus modules.Bus, options ...modules.ModuleOption) (
 
 	m.config = utilityCfg
 	m.mempool = types.NewTxFIFOMempool(utilityCfg.MaxMempoolTransactionBytes, utilityCfg.MaxMempoolTransactions)
+	m.logger = logger.Global.CreateLoggerForModule(m.GetModuleName())
+
+	return m, enableActorModules(cfg, m, bus)
+}
+
+// enableActorModules enables the actor-specific modules and adds them to the utility module's actorModules to be started later.
+func enableActorModules(cfg *configs.Config, m *utilityModule, bus modules.Bus) error {
+	fishermanCfg := cfg.Fisherman
+	servicerCfg := cfg.Servicer
+	validatorCfg := cfg.Validator
+	portalCfg := cfg.Portal
+
+	if servicerCfg.Enabled {
+		servicer, err := servicer_module.CreateServicer(bus)
+		if err != nil {
+			m.logger.Error().Err(err).Msg(""failed to create servicer module"")
+			return err
+		}
+		m.servicer = &servicer
+		m.actorModules = append(m.actorModules, servicer)
+	}
+
+	if fishermanCfg.Enabled {
+		fisherman, err := fisherman.CreateFisherman(bus)
+		if err != nil {
+			m.logger.Error().Err(err).Msg(""failed to create fisherman module"")
+			return err
+		}
+		m.fisherman = &fisherman
+		m.actorModules = append(m.actorModules, fisherman)
+	}
+
+	if validatorCfg.Enabled {
+		validator, err := validator_module.CreateValidator(bus)
+		if err != nil {
+			m.logger.Error().Err(err).Msg(""failed to create validator module"")
+			return err
+		}
+		m.validator = &validator
+		m.actorModules = append(m.actorModules, validator)
+	}
+
+	if portalCfg.Enabled {
+		portal, err := portal_module.CreatePortal(bus)
+		if err != nil {
+			m.logger.Error().Err(err).Msg(""failed to create portal module"")
+			return err
+		}
+		m.portal = &portal
+		m.actorModules = append(m.actorModules, portal)
+	}
 
-	return m, nil
+	actors := m.GetActorModuleNames()
+	if len(m.actorModules) > 1 {",utility/module.go,2023-05-04 02:31:51+00:00,2023-05-04T02:46:47Z,Can you move this into a helper function call `validateActorModuleExclusivity` with a `TODO` comment to figure out all the rules we want to enable?,,,,,119,RIGHT,117,,line,https://api.github.com/repos/pokt-network/pocket/pulls/710,pokt-network/pocket,dbc0deb6a7aec39359745e9be952a4992689052a
https://api.github.com/repos/pokt-network/pocket/pulls/710,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1184484515,Olshansk,b6be2a930185debeb449f91b51d6c70a44a35401,fe90c0d0aa25c0b57cb2a9c2e3205c015ebc3ddf,"@@ -44,12 +63,94 @@ func (*utilityModule) Create(bus modules.Bus, options ...modules.ModuleOption) (
 
 	m.config = utilityCfg
 	m.mempool = types.NewTxFIFOMempool(utilityCfg.MaxMempoolTransactionBytes, utilityCfg.MaxMempoolTransactions)
+	m.logger = logger.Global.CreateLoggerForModule(m.GetModuleName())
+
+	return m, enableActorModules(cfg, m, bus)
+}
+
+// enableActorModules enables the actor-specific modules and adds them to the utility module's actorModules to be started later.
+func enableActorModules(cfg *configs.Config, m *utilityModule, bus modules.Bus) error {
+	fishermanCfg := cfg.Fisherman
+	servicerCfg := cfg.Servicer
+	validatorCfg := cfg.Validator
+	portalCfg := cfg.Portal
+
+	if servicerCfg.Enabled {
+		servicer, err := servicer_module.CreateServicer(bus)
+		if err != nil {
+			m.logger.Error().Err(err).Msg(""failed to create servicer module"")
+			return err
+		}
+		m.servicer = &servicer
+		m.actorModules = append(m.actorModules, servicer)
+	}
+
+	if fishermanCfg.Enabled {
+		fisherman, err := fisherman.CreateFisherman(bus)
+		if err != nil {
+			m.logger.Error().Err(err).Msg(""failed to create fisherman module"")
+			return err
+		}
+		m.fisherman = &fisherman
+		m.actorModules = append(m.actorModules, fisherman)
+	}
+
+	if validatorCfg.Enabled {
+		validator, err := validator_module.CreateValidator(bus)
+		if err != nil {
+			m.logger.Error().Err(err).Msg(""failed to create validator module"")
+			return err
+		}
+		m.validator = &validator
+		m.actorModules = append(m.actorModules, validator)
+	}
+
+	if portalCfg.Enabled {
+		portal, err := portal_module.CreatePortal(bus)
+		if err != nil {
+			m.logger.Error().Err(err).Msg(""failed to create portal module"")
+			return err
+		}
+		m.portal = &portal
+		m.actorModules = append(m.actorModules, portal)
+	}
 
-	return m, nil
+	actors := m.GetActorModuleNames()
+	if len(m.actorModules) > 1 {
+		// only case where this is allowed is if the node is a validator and a servicer
+		if !(validatorCfg.Enabled && servicerCfg.Enabled) {
+			m.logger.Error().Strs(""actors"", actors).Msg(ErrInvalidActorsEnabled)",utility/module.go,2023-05-04 02:34:43+00:00,2023-05-04T02:46:47Z,We also have a `StringLogArrayMarshaler` helper that might be useful here,,,,,122,RIGHT,120,,line,https://api.github.com/repos/pokt-network/pocket/pulls/710,pokt-network/pocket,dbc0deb6a7aec39359745e9be952a4992689052a
https://api.github.com/repos/pokt-network/pocket/pulls/710,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1184485178,Olshansk,b6be2a930185debeb449f91b51d6c70a44a35401,fe90c0d0aa25c0b57cb2a9c2e3205c015ebc3ddf,"@@ -0,0 +1,14 @@
+
+syntax = ""proto3"";
+
+package configs;
+
+option go_package = ""github.com/pokt-network/pocket/runtime/configs"";
+
+// FishermanConfig defines the configuration for the node acting as a fisherman. Fishermen grade and enforce the quality of the Web3 access provided by Servicers
+// TODO(0xbigboss): Add fields",runtime/configs/proto/fisherman_config.proto,2023-05-04 02:37:13+00:00,2023-05-04T02:46:47Z,"If you can't think of it right now, let's remove the TODOs/INVESTIGATE and add things as we implement e2e features. Ditto for the other configs.

I'm working on those in a notion doc for now

<img width=""583"" alt=""Screenshot 2023-05-03 at 7 36 52 PM"" src=""https://user-images.githubusercontent.com/1892194/236098709-d41c1840-1153-4d16-b35a-8dd1527307b9.png"">
",,,,,9,RIGHT,9,,line,https://api.github.com/repos/pokt-network/pocket/pulls/710,pokt-network/pocket,dbc0deb6a7aec39359745e9be952a4992689052a
https://api.github.com/repos/pokt-network/pocket/pulls/710,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1184485702,Olshansk,b6be2a930185debeb449f91b51d6c70a44a35401,fe90c0d0aa25c0b57cb2a9c2e3205c015ebc3ddf,"@@ -0,0 +1,75 @@
+package validator
+
+import (
+	""github.com/pokt-network/pocket/logger""
+	""github.com/pokt-network/pocket/shared/modules""
+	""github.com/pokt-network/pocket/shared/modules/base_modules""
+)
+
+const (
+	ValidatorModuleName = ""validator""
+)
+
+type ValidatorModule interface {
+	modules.Module
+
+	// TODO: add validator module functions here
+	ValidatorUtility
+}
+
+// TODO_IN_THIS_COMMIT: exists to help with type assertions, drop once you've added your own functions
+type ValidatorUtility interface {
+	Stake()
+}
+
+type validator struct {
+	base_modules.IntegratableModule
+	logger *modules.Logger
+}
+
+// type assertions for validator module
+var (
+	_ ValidatorModule = &validator{}
+	// TODO: add validator module functions here",utility/validator/module.go,2023-05-04 02:39:02+00:00,2023-05-04T02:46:47Z,As long as you do `_ ValidatorUtility = &validator{}` it'll enforce all the functions,,,,,33,RIGHT,33,,line,https://api.github.com/repos/pokt-network/pocket/pulls/710,pokt-network/pocket,dbc0deb6a7aec39359745e9be952a4992689052a
https://api.github.com/repos/pokt-network/pocket/pulls/710,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1184485848,Olshansk,b6be2a930185debeb449f91b51d6c70a44a35401,fe90c0d0aa25c0b57cb2a9c2e3205c015ebc3ddf,"@@ -0,0 +1,75 @@
+package validator
+
+import (
+	""github.com/pokt-network/pocket/logger""
+	""github.com/pokt-network/pocket/shared/modules""
+	""github.com/pokt-network/pocket/shared/modules/base_modules""
+)
+
+const (
+	ValidatorModuleName = ""validator""
+)
+
+type ValidatorModule interface {",utility/validator/module.go,2023-05-04 02:39:21+00:00,2023-05-04T02:46:47Z,"I see the approach you took here. Still thinking about, but I do think it's a good start!",,,,,13,RIGHT,13,,line,https://api.github.com/repos/pokt-network/pocket/pulls/710,pokt-network/pocket,dbc0deb6a7aec39359745e9be952a4992689052a
https://api.github.com/repos/pokt-network/pocket/pulls/710,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1184486711,Olshansk,b6be2a930185debeb449f91b51d6c70a44a35401,fe90c0d0aa25c0b57cb2a9c2e3205c015ebc3ddf,"@@ -28,6 +29,10 @@ type Config struct {
 	Logger      *LoggerConfig      `json:""logger""`
 	RPC         *RPCConfig         `json:""rpc""`
 	Keybase     *KeybaseConfig     `json:""keybase""` // Determines and configures which keybase to use, `file` or `vault`. IMPROVE(#626): See for rationale around proto design. We have proposed a better config design, but did not implement it due to viper limitations
+	Validator   *ValidatorConfig   `json:""validator""`
+	Servicer    *ServicerConfig    `json:""servicer""`
+	Fisherman   *FishermanConfig   `json:""fisherman""`
+	Portal      *PortalConfig      `json:""portal""`",runtime/configs/config.go,2023-05-04 02:41:30+00:00,2023-05-04T02:46:47Z,"I think we should either remove `Portal` from this PR completely or make sure it's account for everything.

For example:
- `runtime/genesis/proto/genesis.proto`
- `ActorType` in `actor.proto`

Personally, I think one PR to add Portal everywhere later is the way to go
",,,,,36,RIGHT,15,,line,https://api.github.com/repos/pokt-network/pocket/pulls/710,pokt-network/pocket,dbc0deb6a7aec39359745e9be952a4992689052a
https://api.github.com/repos/pokt-network/pocket/pulls/710,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1184487445,Olshansk,b6be2a930185debeb449f91b51d6c70a44a35401,fe90c0d0aa25c0b57cb2a9c2e3205c015ebc3ddf,"@@ -0,0 +1,75 @@
+package fisherman
+
+import (
+	""github.com/pokt-network/pocket/logger""
+	""github.com/pokt-network/pocket/shared/modules""
+	""github.com/pokt-network/pocket/shared/modules/base_modules""
+)
+
+const (
+	FishermanModuleName = ""fisherman""
+)
+
+type FishermanModule interface {
+	modules.Module
+
+	// TODO: add fisherman module functions here
+	FishermanUtility
+}
+
+// TODO_IN_THIS_COMMIT: exists to help with type assertions, drop once you've added your own functions
+type FishermanUtility interface {",utility/fisherman/module.go,2023-05-04 02:44:09+00:00,2023-05-04T02:46:47Z,Let's move the `XXInterface` of each actor in `shared/utility_module.go` so its easy to understand and add functionality everywhere.,,,,,21,RIGHT,21,,line,https://api.github.com/repos/pokt-network/pocket/pulls/710,pokt-network/pocket,dbc0deb6a7aec39359745e9be952a4992689052a
https://api.github.com/repos/pokt-network/pocket/pulls/710,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1186519245,okdas,43839c2200d2bc25bdffc772cc9e921b4a6741df,fe90c0d0aa25c0b57cb2a9c2e3205c015ebc3ddf,"@@ -2,7 +2,6 @@ apiVersion: apps/v1
 kind: Deployment
 metadata:
   name: dev-cli-client
-  namespace: default",build/localnet/manifests/cli-client.yaml,2023-05-05 21:42:53+00:00,2023-05-05T23:15:33Z,"@0xBigBoss what's the reasoning for not using the default namespace? It has been added to reduce friction for users, but I can see how one might want to apply manifests in non-default namespace.",,,,5.0,5,LEFT,4,4.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/710,pokt-network/pocket,dbc0deb6a7aec39359745e9be952a4992689052a
https://api.github.com/repos/pokt-network/pocket/pulls/710,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1186545073,okdas,43839c2200d2bc25bdffc772cc9e921b4a6741df,fe90c0d0aa25c0b57cb2a9c2e3205c015ebc3ddf,"@@ -159,25 +169,75 @@ k8s_resource('dev-cli-client', labels=['client'])
 k8s_yaml(['manifests/cluster-manager.yaml'])
 k8s_resource('pocket-v1-cluster-manager', labels=['cluster-manager'])
 
-check_helm_dependencies_for_chart(root_dir + ""/charts/pocket"")
+chart_dir = root_dir + ""/charts/pocket""
+check_helm_dependencies_for_chart(chart_dir)
+
+actor_number = 0
+
+def formatted_actor_number(n):
+    return local('printf ""%03d"" ' + str(n))
+
 for x in range(localnet_config[""validators""][""count""]):
-    validator_number = x + 1
-    formatted_validator_number = local('printf ""%03d"" ' + str(validator_number))
+    actor_number = actor_number + 1
+    formatted_number = formatted_actor_number(actor_number)
+
+    k8s_yaml(helm(chart_dir,
+        name=""validator-%s-pocket"" % formatted_number,
+        set=[
+            ""global.postgresql.auth.postgresPassword=LocalNetPassword"",
+            ""image.repository=validator-image"",
+            ""privateKeySecretKeyRef.name=validators-private-keys"",
+            ""privateKeySecretKeyRef.key=%s"" % formatted_number,
+            ""genesis.preProvisionedGenesis.enabled=false"",
+            ""genesis.externalConfigMap.name=v1-localnet-genesis"",
+            ""genesis.externalConfigMap.key=genesis.json"",
+            ""postgresql.primary.persistence.enabled=false"",
+        ],
+        values=[chart_dir + ""/pocket-validator-overrides.yaml""] if os.path.exists(chart_dir + ""/pocket-validator-overrides.yaml"") else [],))
+
+    k8s_resource(""validator-%s-pocket"" % formatted_number, labels=['pocket-validators'])
 
-    k8s_yaml(helm(root_dir + ""/charts/pocket"",
-        name=""validator-%s"" % formatted_validator_number,
-        namespace=""default"",
+for x in range(localnet_config[""servicers""][""count""]):
+    actor_number = actor_number + 1
+    formatted_number = formatted_actor_number(actor_number)
+
+    k8s_yaml(helm(chart_dir,
+        name=""servicer-%s-pocket"" % formatted_number,
         set=[
             ""global.postgresql.auth.postgresPassword=LocalNetPassword"",
             ""image.repository=validator-image"",
             ""privateKeySecretKeyRef.name=validators-private-keys"",",build/localnet/Tiltfile,2023-05-05 22:51:32+00:00,2023-05-05T23:15:33Z,"Would different actors such as watcher (😄) and servicer work with the same keys as the validator? In #727, I added more keys for servicers but haven't added any for the watcher yet due to confusion with names. :)",,,,,209,RIGHT,75,,line,https://api.github.com/repos/pokt-network/pocket/pulls/710,pokt-network/pocket,dbc0deb6a7aec39359745e9be952a4992689052a
https://api.github.com/repos/pokt-network/pocket/pulls/710,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1212353566,Olshansk,8539e8eae9c4a9c14177235911cd10ce1b14c1b8,fe90c0d0aa25c0b57cb2a9c2e3205c015ebc3ddf,"@@ -106,7 +106,7 @@ func NewDebugCommand() *cobra.Command {
 // persistentPreRun is called by both debug and debug sub-commands before runs
 func persistentPreRun(cmd *cobra.Command, _ []string) {
 	// TECHDEBT: this is to keep backwards compatibility with localnet
-	configPath = runtime.GetEnv(""CONFIG_PATH"", ""build/config/config1.json"")
+	configPath = runtime.GetEnv(""CONFIG_PATH"", ""build/config/config.node1.validator.json"")",app/client/cli/debug.go,2023-05-31 21:49:38+00:00,2023-06-01T01:44:49Z,"Do you think we still need the `nodeX` prefix if we add an `actor` suffix?

Thinking of just going with `config.validator1.json`?",,,,,109,RIGHT,5,,line,https://api.github.com/repos/pokt-network/pocket/pulls/710,pokt-network/pocket,dbc0deb6a7aec39359745e9be952a4992689052a
https://api.github.com/repos/pokt-network/pocket/pulls/710,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1212355281,Olshansk,8539e8eae9c4a9c14177235911cd10ce1b14c1b8,fe90c0d0aa25c0b57cb2a9c2e3205c015ebc3ddf,"@@ -884,6 +884,33 @@ func queryCommands() []*cobra.Command {
 				return rpcResponseCodeUnhealthy(statusCode, resp)
 			},
 		},
+		{
+			Use:     ""NodeRoles"",
+			Short:   ""Get current the node roles"",
+			Long:    ""Queries the node RPC to returns the type of utility actor(s) running on the node"",
+			Aliases: []string{""noderoles""},
+			RunE: func(cmd *cobra.Command, args []string) error {
+				client, err := rpc.NewClientWithResponses(remoteCLIURL)
+				if err != nil {
+					return err
+				}
+				response, err := client.PostV1QueryNodeRoles(cmd.Context())
+				if err != nil {
+					return unableToConnectToRpc(err)
+				}
+				statusCode := response.StatusCode
+				body, err := io.ReadAll(response.Body)
+				if err != nil {
+					fmt.Fprintf(os.Stderr, ""❌ Error reading response body: %s\n"", err.Error())",app/client/cli/query.go,2023-05-31 21:52:24+00:00,2023-06-01T01:44:49Z,Do you explicitly want to avoid printing to stdout? Wondering about the use of `fprintf` vs `printf`?.,,,,904.0,904,RIGHT,21,21.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/710,pokt-network/pocket,dbc0deb6a7aec39359745e9be952a4992689052a
https://api.github.com/repos/pokt-network/pocket/pulls/710,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1212355528,Olshansk,8539e8eae9c4a9c14177235911cd10ce1b14c1b8,fe90c0d0aa25c0b57cb2a9c2e3205c015ebc3ddf,"@@ -0,0 +1,56 @@
+{",build/config/config.node5.servicer.json,2023-05-31 21:52:50+00:00,2023-06-01T01:44:49Z,Ditto regarding file naming. E.g. `config.servicer1.json`,,,,,1,RIGHT,1,,line,https://api.github.com/repos/pokt-network/pocket/pulls/710,pokt-network/pocket,dbc0deb6a7aec39359745e9be952a4992689052a
https://api.github.com/repos/pokt-network/pocket/pulls/710,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1212356265,Olshansk,8539e8eae9c4a9c14177235911cd10ce1b14c1b8,fe90c0d0aa25c0b57cb2a9c2e3205c015ebc3ddf,"@@ -4095,27 +4095,38 @@
   ],
   ""servicers"": [
     {
-      ""address"": ""43d9ea9d9ad9c58bb96ec41340f83cb2cabb6496"",
-      ""public_key"": ""16cd0a304c38d76271f74dd3c90325144425d904ef1b9a6fbab9b201d75a998b"",
+      ""address"": ""00104055c00bed7c983a48aac7dc6335d7c607a7"",
+      ""public_key"": ""dfe357de55649e6d2ce889acf15eb77e94ab3c5756fe46d3c7538d37f27f115e"",
       ""chains"": [""0001""],
       ""service_url"": ""node1.consensus:42069"",",build/config/genesis.json,2023-05-31 21:53:59+00:00,2023-06-01T01:44:49Z,NIT: Any chance you could tend to some of my techdebt and replace the `.consensus` in the URLs with `validator` so its self explanatory and clear.,,,,,4101,RIGHT,9,,line,https://api.github.com/repos/pokt-network/pocket/pulls/710,pokt-network/pocket,dbc0deb6a7aec39359745e9be952a4992689052a
https://api.github.com/repos/pokt-network/pocket/pulls/710,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1212356838,Olshansk,8539e8eae9c4a9c14177235911cd10ce1b14c1b8,fe90c0d0aa25c0b57cb2a9c2e3205c015ebc3ddf,"@@ -0,0 +1,56 @@
+{
+  ""root_directory"": ""/go/src/github.com/pocket-network"",
+  ""private_key"": ""e4ad8d293ebf5287e2403e6483ecb6c4e80b22b2d3effc8698dfe34eb35fc9466ac62bddc541432cff818a02bab732f815ef2e6f7099e7dddc793d62d482b451"",
+  ""consensus"": {
+    ""max_mempool_bytes"": 500000000,
+    ""pacemaker_config"": {
+      ""timeout_msec"": 10000,
+      ""manual"": true,
+      ""debug_time_between_steps_msec"": 1000
+    },
+    ""private_key"": ""e4ad8d293ebf5287e2403e6483ecb6c4e80b22b2d3effc8698dfe34eb35fc9466ac62bddc541432cff818a02bab732f815ef2e6f7099e7dddc793d62d482b451"",
+    ""server_mode_enabled"": true
+  },
+  ""utility"": {
+    ""max_mempool_transaction_bytes"": 1073741824,
+    ""max_mempool_transactions"": 9000
+  },
+  ""persistence"": {
+    ""postgres_url"": ""postgres://postgres:postgres@pocket-db:5432/postgres"",
+    ""node_schema"": ""node5"",",build/config/config.node5.servicer.json,2023-05-31 21:54:47+00:00,2023-06-01T01:44:49Z,"if we choose to rename the nodes, we should also update the `node_schemas` to reflect it appropriately",,,,,20,RIGHT,20,,line,https://api.github.com/repos/pokt-network/pocket/pulls/710,pokt-network/pocket,dbc0deb6a7aec39359745e9be952a4992689052a
https://api.github.com/repos/pokt-network/pocket/pulls/710,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1212359369,Olshansk,8539e8eae9c4a9c14177235911cd10ce1b14c1b8,fe90c0d0aa25c0b57cb2a9c2e3205c015ebc3ddf,"@@ -143,6 +135,78 @@ services:
   # environment:
   #   - DEBUG_PORT=7084
 
+  node5.servicer:
+    logging: *loki-logging
+    container_name: node5.servicer
+    image: pocket/servicer:latest
+    command: >
+      sh -c '
+      if [ ""$NODE5_SERVICER_ENABLED"" = ""true"" ]; then
+        build/scripts/watch.sh \
+          build/config/config.node5.servicer.json \
+          build/config/genesis.json;
+      else
+        echo ""😴 Going to sleep. Servicer is not enabled."";
+        sleep infinity;",build/deployments/docker-compose.yaml,2023-05-31 21:58:10+00:00,2023-06-01T01:44:50Z,Why do we want to keep the container awake if the role is not enabled? Trying to understand if an exit might be sufficient.,,,,,150,RIGHT,121,,line,https://api.github.com/repos/pokt-network/pocket/pulls/710,pokt-network/pocket,dbc0deb6a7aec39359745e9be952a4992689052a
https://api.github.com/repos/pokt-network/pocket/pulls/710,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1212361559,Olshansk,8539e8eae9c4a9c14177235911cd10ce1b14c1b8,fe90c0d0aa25c0b57cb2a9c2e3205c015ebc3ddf,"@@ -2,7 +2,6 @@ apiVersion: apps/v1
 kind: Deployment
 metadata:
   name: dev-cli-client",build/localnet/manifests/cli-client.yaml,2023-05-31 22:01:13+00:00,2023-06-01T01:44:50Z,"```suggestion
  name: dev-cli-client
  # namespace: default # default namespace commented out to allow user override
```",,,,4.0,4,RIGHT,3,3.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/710,pokt-network/pocket,dbc0deb6a7aec39359745e9be952a4992689052a
https://api.github.com/repos/pokt-network/pocket/pulls/710,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1212364897,Olshansk,8539e8eae9c4a9c14177235911cd10ce1b14c1b8,fe90c0d0aa25c0b57cb2a9c2e3205c015ebc3ddf,"@@ -35,7 +35,7 @@ type blockStore struct {
 // NewBlockStore initializes a new blockstore with the given path.
 // * If """" is provided as the path, an in-memory store is used.
 func NewBlockStore(path string) (BlockStore, error) {
-	if path == """" {
+	if path == "":memory:"" {",persistence/blockstore/block_store.go,2023-05-31 22:04:57+00:00,2023-06-01T01:44:50Z,Very SQLite of you ;),,,,38.0,38,RIGHT,5,5.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/710,pokt-network/pocket,dbc0deb6a7aec39359745e9be952a4992689052a
https://api.github.com/repos/pokt-network/pocket/pulls/710,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1212365355,Olshansk,8539e8eae9c4a9c14177235911cd10ce1b14c1b8,fe90c0d0aa25c0b57cb2a9c2e3205c015ebc3ddf,"@@ -83,6 +83,12 @@ func (s *rpcServer) PostV1ClientGetSession(ctx echo.Context) error {
 // TECHDEBT: This will need to be changed when the HandleRelay function is actually implemented
 // because it copies data structures from v0. For example, AATs are no longer necessary in v1.
 func (s *rpcServer) PostV1ClientRelay(ctx echo.Context) error {
+	var utility = s.GetBus().GetUtilityModule()",rpc/handlers.go,2023-05-31 22:05:41+00:00,2023-06-01T01:44:50Z,"```suggestion
	utility := s.GetBus().GetUtilityModule()
```",,,,,86,RIGHT,4,,line,https://api.github.com/repos/pokt-network/pocket/pulls/710,pokt-network/pocket,dbc0deb6a7aec39359745e9be952a4992689052a
https://api.github.com/repos/pokt-network/pocket/pulls/710,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1212384117,Olshansk,8539e8eae9c4a9c14177235911cd10ce1b14c1b8,fe90c0d0aa25c0b57cb2a9c2e3205c015ebc3ddf,"@@ -0,0 +1,65 @@
+package fisherman
+
+import (
+	""github.com/pokt-network/pocket/logger""
+	""github.com/pokt-network/pocket/shared/modules""
+	""github.com/pokt-network/pocket/shared/modules/base_modules""
+)
+
+const (
+	FishermanModuleName = ""fisherman""
+)
+
+type FishermanModule interface {
+	modules.Module
+	FishermanUtility
+}
+
+type FishermanUtility interface{}",utility/fisherman/module.go,2023-05-31 22:34:48+00:00,2023-06-01T01:44:50Z,"Thoughts on moving this into `utility_modules.go` under `shared`?

This way it's really easy for someone to come in and see the functionality (and potentially hack on an alternative) rather than going deeper into the codebase.

Ditto for the other interfaces.",,,,,18,RIGHT,18,,line,https://api.github.com/repos/pokt-network/pocket/pulls/710,pokt-network/pocket,dbc0deb6a7aec39359745e9be952a4992689052a
https://api.github.com/repos/pokt-network/pocket/pulls/710,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1212384563,Olshansk,8539e8eae9c4a9c14177235911cd10ce1b14c1b8,fe90c0d0aa25c0b57cb2a9c2e3205c015ebc3ddf,"@@ -4229,7 +4240,10 @@ func TestNewManagerFromReaders(t *testing.T) {
 						Timeout: 30000,
 						UseCors: false,
 					},
-					Keybase: defaultCfg.Keybase,
+					Keybase:   defaultCfg.Keybase,
+					Servicer:  &configs.ServicerConfig{Enabled: true},
+					Validator: &configs.ValidatorConfig{Enabled: true},",runtime/manager_test.go,2023-05-31 22:35:43+00:00,2023-06-01T01:44:50Z,"NIT: Have default configs for this, similar to Fisherman, for consistency.",,4244.0,RIGHT,,4245,RIGHT,62,,line,https://api.github.com/repos/pokt-network/pocket/pulls/710,pokt-network/pocket,dbc0deb6a7aec39359745e9be952a4992689052a
https://api.github.com/repos/pokt-network/pocket/pulls/710,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1212401259,Olshansk,8539e8eae9c4a9c14177235911cd10ce1b14c1b8,fe90c0d0aa25c0b57cb2a9c2e3205c015ebc3ddf,"@@ -15,9 +15,21 @@ import (
 	""golang.org/x/exp/slices""
 )
 
+const (
+	NodeIsNotServicerErr = ""node is not a servicer""
+)
+
 // TODO: Implement this
 func (u *utilityModule) HandleRelay(relay *coreTypes.Relay) (*coreTypes.RelayResponse, error) {
-	return nil, nil
+
+	if u.svc == nil {
+		return nil, fmt.Errorf(NodeIsNotServicerErr)
+	}
+
+	return &coreTypes.RelayResponse{",utility/session.go,2023-05-31 23:05:30+00:00,2023-06-01T01:44:50Z,"@adshmh is actively working on this in a different PR so a merge conflict will happen sooner or later!

Can you just add a TECHDEBT above the `RelayResponse` initialization saying to fill this out properly?",,,,,29,RIGHT,16,,line,https://api.github.com/repos/pokt-network/pocket/pulls/710,pokt-network/pocket,dbc0deb6a7aec39359745e9be952a4992689052a
https://api.github.com/repos/pokt-network/pocket/pulls/710,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1212401485,Olshansk,8539e8eae9c4a9c14177235911cd10ce1b14c1b8,fe90c0d0aa25c0b57cb2a9c2e3205c015ebc3ddf,"@@ -0,0 +1,65 @@
+package validator
+
+import (
+	""github.com/pokt-network/pocket/logger""
+	""github.com/pokt-network/pocket/shared/modules""
+	""github.com/pokt-network/pocket/shared/modules/base_modules""
+)
+
+const (
+	ValidatorModuleName = ""validator""
+)
+
+type ValidatorModule interface {
+	modules.Module
+	ValidatorUtility
+}
+
+type ValidatorUtility interface{}
+
+type validator struct {
+	base_modules.IntegratableModule
+	logger *modules.Logger
+}
+
+// type assertions for validator module",utility/validator/module.go,2023-05-31 23:06:04+00:00,2023-06-01T01:44:50Z,No need for the comment - it's self explanatory. DItto elsewhere.,,,,,25,RIGHT,25,,line,https://api.github.com/repos/pokt-network/pocket/pulls/710,pokt-network/pocket,dbc0deb6a7aec39359745e9be952a4992689052a
https://api.github.com/repos/pokt-network/pocket/pulls/710,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1212402048,Olshansk,8539e8eae9c4a9c14177235911cd10ce1b14c1b8,fe90c0d0aa25c0b57cb2a9c2e3205c015ebc3ddf,"@@ -180,3 +187,27 @@ func WithNodeSchema(schema string) func(*Config) {
 		cfg.Persistence.NodeSchema = schema
 	}
 }
+
+// CreateTempConfig creates a temporary config for testing purposes only",runtime/configs/config.go,2023-05-31 23:07:07+00:00,2023-06-01T01:44:50Z,"```suggestion
// CreateTempConfig creates a temporary config for testing purposes only
// TECHDEBT(#796): Move into an independent file with the
```

cc @bryanchriswhite just for visibility",,,,191.0,191,RIGHT,33,43.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/710,pokt-network/pocket,dbc0deb6a7aec39359745e9be952a4992689052a
https://api.github.com/repos/pokt-network/pocket/pulls/710,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1212402189,Olshansk,8539e8eae9c4a9c14177235911cd10ce1b14c1b8,fe90c0d0aa25c0b57cb2a9c2e3205c015ebc3ddf,"@@ -180,3 +187,27 @@ func WithNodeSchema(schema string) func(*Config) {
 		cfg.Persistence.NodeSchema = schema
 	}
 }
+
+// CreateTempConfig creates a temporary config for testing purposes only
+func CreateTempConfig(cfg *Config) (*Config, error) {
+	tmpfile, err := os.CreateTemp("""", ""test_config_*.json"")
+	defer os.Remove(tmpfile.Name())",runtime/configs/config.go,2023-05-31 23:07:25+00:00,2023-06-01T01:44:50Z,I believe the `defer` should take place after the error check,,,,,194,RIGHT,36,,line,https://api.github.com/repos/pokt-network/pocket/pulls/710,pokt-network/pocket,dbc0deb6a7aec39359745e9be952a4992689052a
https://api.github.com/repos/pokt-network/pocket/pulls/710,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1212402737,Olshansk,8539e8eae9c4a9c14177235911cd10ce1b14c1b8,fe90c0d0aa25c0b57cb2a9c2e3205c015ebc3ddf,"@@ -94,23 +94,26 @@ func newTestRuntimeConfig(
 	numFisherman int,
 	genesisOpts ...test_artifacts.GenesisOption,
 ) *runtime.Manager {
-	cfg := &configs.Config{
+	cfg, err := configs.CreateTempConfig(&configs.Config{
 		Utility: &configs.UtilityConfig{
 			MaxMempoolTransactionBytes: 1000000,
 			MaxMempoolTransactions:     1000,
 		},
 		Persistence: &configs.PersistenceConfig{
 			PostgresUrl:       dbURL,
 			NodeSchema:        ""test_schema"",
-			BlockStorePath:    """", // in memory
-			TxIndexerPath:     """", // in memory
-			TreesStoreDir:     """", // in memory
+			BlockStorePath:    "":memory:"",
+			TxIndexerPath:     "":memory:"",
+			TreesStoreDir:     "":memory:"",
 			MaxConnsCount:     50,
 			MinConnsCount:     1,
 			MaxConnLifetime:   ""5m"",
 			MaxConnIdleTime:   ""1m"",
 			HealthCheckPeriod: ""30s"",
 		},
+	})
+	if err != nil {
+		panic(err)",utility/main_test.go,2023-05-31 23:08:31+00:00,2023-06-01T01:44:50Z,`log.Fatalf` instead?,,,,,116,RIGHT,27,,line,https://api.github.com/repos/pokt-network/pocket/pulls/710,pokt-network/pocket,dbc0deb6a7aec39359745e9be952a4992689052a
https://api.github.com/repos/pokt-network/pocket/pulls/710,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1212403183,Olshansk,8539e8eae9c4a9c14177235911cd10ce1b14c1b8,fe90c0d0aa25c0b57cb2a9c2e3205c015ebc3ddf,"@@ -1,35 +1,51 @@
 package utility
 
 import (
+	""errors""
+
 	""github.com/pokt-network/pocket/logger""
 	""github.com/pokt-network/pocket/runtime/configs""
 	""github.com/pokt-network/pocket/shared/mempool""
 	""github.com/pokt-network/pocket/shared/modules""
 	""github.com/pokt-network/pocket/shared/modules/base_modules""
+	""github.com/pokt-network/pocket/utility/fisherman""
+	""github.com/pokt-network/pocket/utility/servicer""
 	""github.com/pokt-network/pocket/utility/types""
+	""github.com/pokt-network/pocket/utility/validator""
+)
+
+const (
+	ErrInvalidActorsEnabled = ""invalid actors combination enabled""
 )
 
 var (
 	_ modules.UtilityModule = &utilityModule{}
-	_ modules.Module        = &utilityModule{}
 )
 
 type utilityModule struct {
 	base_modules.IntegratableModule
-	base_modules.InterruptableModule
+
+	logger *modules.Logger
 
 	config *configs.UtilityConfig
 
-	logger  *modules.Logger
 	mempool mempool.TXMempool
+
+	actorModules []modules.Module
+
+	vld validator.ValidatorModule
+	svc servicer.ServicerModule
+	fsh fisherman.FishermanModule
 }
 
 func Create(bus modules.Bus, options ...modules.ModuleOption) (modules.Module, error) {
 	return new(utilityModule).Create(bus, options...)
 }
 
 func (*utilityModule) Create(bus modules.Bus, options ...modules.ModuleOption) (modules.Module, error) {
-	m := &utilityModule{}
+	m := &utilityModule{
+		actorModules: []modules.Module{},",utility/module.go,2023-05-31 23:09:24+00:00,2023-06-01T01:44:50Z,"```suggestion
		actorModules: make([]modules.Module{}, 0),
```",,,,,47,RIGHT,51,,line,https://api.github.com/repos/pokt-network/pocket/pulls/710,pokt-network/pocket,dbc0deb6a7aec39359745e9be952a4992689052a
https://api.github.com/repos/pokt-network/pocket/pulls/710,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1212404729,Olshansk,8539e8eae9c4a9c14177235911cd10ce1b14c1b8,fe90c0d0aa25c0b57cb2a9c2e3205c015ebc3ddf,"@@ -1,35 +1,51 @@
 package utility
 
 import (
+	""errors""
+
 	""github.com/pokt-network/pocket/logger""
 	""github.com/pokt-network/pocket/runtime/configs""
 	""github.com/pokt-network/pocket/shared/mempool""
 	""github.com/pokt-network/pocket/shared/modules""
 	""github.com/pokt-network/pocket/shared/modules/base_modules""
+	""github.com/pokt-network/pocket/utility/fisherman""
+	""github.com/pokt-network/pocket/utility/servicer""
 	""github.com/pokt-network/pocket/utility/types""
+	""github.com/pokt-network/pocket/utility/validator""
+)
+
+const (
+	ErrInvalidActorsEnabled = ""invalid actors combination enabled""
 )
 
 var (
 	_ modules.UtilityModule = &utilityModule{}
-	_ modules.Module        = &utilityModule{}
 )
 
 type utilityModule struct {
 	base_modules.IntegratableModule
-	base_modules.InterruptableModule
+
+	logger *modules.Logger
 
 	config *configs.UtilityConfig
 
-	logger  *modules.Logger
 	mempool mempool.TXMempool
+
+	actorModules []modules.Module",utility/module.go,2023-05-31 23:11:57+00:00,2023-06-01T01:44:50Z,"Rather than having 4 fields, why not make it a map with the key being the sting and having internal helpers that access it and cast it to the appropriate role?

Just some pseudo-code to show the idea:

```go

actorModule [string]modules.Module


func (u *utilityModule) getFishermanModule() validator.ValidatorModule {
	return u.actorModules[validatorModuleName].(validator.ValidatorModule)
}",,,,,34,RIGHT,37,,line,https://api.github.com/repos/pokt-network/pocket/pulls/710,pokt-network/pocket,dbc0deb6a7aec39359745e9be952a4992689052a
https://api.github.com/repos/pokt-network/pocket/pulls/710,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1212405045,Olshansk,8539e8eae9c4a9c14177235911cd10ce1b14c1b8,fe90c0d0aa25c0b57cb2a9c2e3205c015ebc3ddf,"@@ -60,3 +139,39 @@ func (u *utilityModule) GetModuleName() string {
 func (u *utilityModule) GetMempool() mempool.TXMempool {
 	return u.mempool
 }
+
+func (u *utilityModule) GetLogger() *modules.Logger {",utility/module.go,2023-05-31 23:12:33+00:00,2023-06-01T01:44:50Z,Where is this used? Remove if not needed,,,,,143,RIGHT,139,,line,https://api.github.com/repos/pokt-network/pocket/pulls/710,pokt-network/pocket,dbc0deb6a7aec39359745e9be952a4992689052a
https://api.github.com/repos/pokt-network/pocket/pulls/710,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1212473345,Olshansk,8539e8eae9c4a9c14177235911cd10ce1b14c1b8,fe90c0d0aa25c0b57cb2a9c2e3205c015ebc3ddf,"@@ -44,12 +60,75 @@ func (*utilityModule) Create(bus modules.Bus, options ...modules.ModuleOption) (
 
 	m.config = utilityCfg
 	m.mempool = types.NewTxFIFOMempool(utilityCfg.MaxMempoolTransactionBytes, utilityCfg.MaxMempoolTransactions)
+	m.logger = logger.Global.CreateLoggerForModule(m.GetModuleName())
+
+	return m, enableActorModules(cfg, m, bus)
+}
+
+// enableActorModules enables the actor-specific modules and adds them to the utility module's actorModules to be started later.
+func enableActorModules(cfg *configs.Config, m *utilityModule, bus modules.Bus) error {",utility/module.go,2023-06-01 01:38:48+00:00,2023-06-01T01:44:50Z,"If you make this a receiver function of the module, there would be no need to bus in any parameters

```go
func (u *utilityModule) enableActorModules() error {
```",,,,,69,RIGHT,66,,line,https://api.github.com/repos/pokt-network/pocket/pulls/710,pokt-network/pocket,dbc0deb6a7aec39359745e9be952a4992689052a
https://api.github.com/repos/pokt-network/pocket/pulls/710,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1212474469,Olshansk,8539e8eae9c4a9c14177235911cd10ce1b14c1b8,fe90c0d0aa25c0b57cb2a9c2e3205c015ebc3ddf,"@@ -60,3 +139,39 @@ func (u *utilityModule) GetModuleName() string {
 func (u *utilityModule) GetMempool() mempool.TXMempool {
 	return u.mempool
 }
+
+func (u *utilityModule) GetLogger() *modules.Logger {
+	return u.logger
+}
+
+func (u *utilityModule) GetActorModules() []modules.Module {
+	return u.actorModules
+}
+
+func (u *utilityModule) GetServicerModule() modules.Module {
+	return u.svc
+}
+
+// validateActorModuleExclusivity validates that the actor modules are enabled in a valid combination.
+// TODO: There are probably more rules that need to be added here.
+func validateActorModuleExclusivity(m *utilityModule, cfg *configs.Config) error {",utility/module.go,2023-06-01 01:41:08+00:00,2023-06-01T01:44:50Z,"DItto above.

1. Do not pass in `utilityModule`, make it a receiver
2. Config is already part of the `utilityModule` so access that directly",,,,,157,RIGHT,153,,line,https://api.github.com/repos/pokt-network/pocket/pulls/710,pokt-network/pocket,dbc0deb6a7aec39359745e9be952a4992689052a
https://api.github.com/repos/pokt-network/pocket/pulls/710,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1212475628,Olshansk,8539e8eae9c4a9c14177235911cd10ce1b14c1b8,fe90c0d0aa25c0b57cb2a9c2e3205c015ebc3ddf,"@@ -0,0 +1,99 @@
+package utility
+
+import (
+	""testing""
+
+	""github.com/golang/mock/gomock""
+	""github.com/pokt-network/pocket/runtime""
+	""github.com/pokt-network/pocket/runtime/configs""
+	""github.com/pokt-network/pocket/shared/modules""
+	mocks ""github.com/pokt-network/pocket/shared/modules/mocks""
+	""github.com/stretchr/testify/assert""
+)
+
+func TestEnableActorModules(t *testing.T) {
+	tests := []struct {
+		name                 string
+		config               *configs.Config
+		expectedError        string
+		expectedNames        []string
+		expectedActorModules []modules.Module
+		expectedLogMessages  []string
+	}{
+		{
+			name: ""servicer only"",
+			config: &configs.Config{
+				Servicer: &configs.ServicerConfig{Enabled: true},
+			},
+			expectedNames: []string{""servicer""},
+		},
+		{
+			name: ""fisherman only"",
+			config: &configs.Config{
+				Fisherman: &configs.FishermanConfig{Enabled: true},
+			},
+			expectedNames: []string{""fisherman""},
+		},
+		{
+			name: ""validator only"",
+			config: &configs.Config{
+				Validator: &configs.ValidatorConfig{Enabled: true},
+			},
+			expectedNames: []string{""validator""},
+		},
+		{
+			name: ""validator and servicer"",
+			config: &configs.Config{
+				Validator: &configs.ValidatorConfig{Enabled: true},
+				Servicer:  &configs.ServicerConfig{Enabled: true},
+			},
+			expectedNames: []string{""validator"", ""servicer""},
+		},
+		{
+			name: ""multiple actors not allowed"",
+			config: &configs.Config{
+				Validator: &configs.ValidatorConfig{Enabled: true},
+				Fisherman: &configs.FishermanConfig{Enabled: true},
+			},
+			expectedError: ErrInvalidActorsEnabled,
+		},
+	}
+
+	for _, test := range tests {
+		t.Run(test.name, func(t *testing.T) {
+			ctrl := gomock.NewController(t)
+			defer ctrl.Finish()
+
+			mockRunMgr := mocks.NewMockRuntimeMgr(ctrl)
+			cfg, err := configs.CreateTempConfig(test.config)
+			assert.NoError(t, err)
+
+			mockRunMgr.EXPECT().GetConfig().Return(cfg).AnyTimes()
+
+			bus, err := runtime.CreateBus(mockRunMgr)
+			assert.NoError(t, err)
+
+			// Call enableActorModules with the test config
+			m, err := Create(bus)
+
+			// Verify error output
+			if test.expectedError == """" {
+				assert.NoError(t, err)",utility/module_enable_actors_test.go,2023-06-01 01:44:04+00:00,2023-06-01T01:44:50Z,"Use `require` instead of `assert`.

![Screenshot 2023-05-31 at 6 43 40 PM](https://github.com/pokt-network/pocket/assets/1892194/f3daee94-aba2-4102-abaf-24a4a78f2bb8)

https://github.com/stretchr/testify#require-package
",,,,,81,RIGHT,81,,line,https://api.github.com/repos/pokt-network/pocket/pulls/710,pokt-network/pocket,dbc0deb6a7aec39359745e9be952a4992689052a
https://api.github.com/repos/pokt-network/pocket/pulls/710,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1218591360,Olshansk,4b0eaf89b2b5c9bca8ac80ce0b7d423e9b81d0dc,fe90c0d0aa25c0b57cb2a9c2e3205c015ebc3ddf,"@@ -21,15 +21,11 @@ const (
 
 // TODO: Implement this
 func (u *utilityModule) HandleRelay(relay *coreTypes.Relay) (*coreTypes.RelayResponse, error) {
-
-	if u.svc == nil {
+	if u.servicer == nil {
+		// if u.GetServicerModule() == nil {",utility/session.go,2023-06-05 21:03:40+00:00,2023-06-05T21:03:40Z,remove?,,,,,25,RIGHT,7,,line,https://api.github.com/repos/pokt-network/pocket/pulls/710,pokt-network/pocket,dbc0deb6a7aec39359745e9be952a4992689052a
https://api.github.com/repos/pokt-network/pocket/pulls/710,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1220275171,Olshansk,ec97a7f1578431b5d4ef0790f4eecb2f7337e6c1,fe90c0d0aa25c0b57cb2a9c2e3205c015ebc3ddf,"@@ -143,16 +141,32 @@ func (u *utilityModule) GetActorModules() map[string]modules.Module {
 	return u.actorModules
 }
 
-func (u *utilityModule) GetServicerModule() modules.ServicerModule {
-	return u.actorModules[servicer.ServicerModuleName]
+func (u *utilityModule) GetServicerModule() (modules.ServicerModule, error) {
+	m, ok := u.actorModules[servicer.ServicerModuleName].(modules.ServicerModule)
+	if !ok {",utility/module.go,2023-06-06 20:18:32+00:00,2023-06-06T20:25:04Z,"OPTIONAL NIT:

I think doing the following is more readable and shorter, but not a blocker

```go
if m, ok := u.actorModules[servicer.ServicerModuleName].(modules.ServicerModule); ok {
	return m, nil
}
u.logger.Warn(...)
...
```",,,,,146,RIGHT,17,,line,https://api.github.com/repos/pokt-network/pocket/pulls/710,pokt-network/pocket,dbc0deb6a7aec39359745e9be952a4992689052a
https://api.github.com/repos/pokt-network/pocket/pulls/710,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1220277268,Olshansk,ec97a7f1578431b5d4ef0790f4eecb2f7337e6c1,fe90c0d0aa25c0b57cb2a9c2e3205c015ebc3ddf,"@@ -143,16 +141,32 @@ func (u *utilityModule) GetActorModules() map[string]modules.Module {
 	return u.actorModules
 }
 
-func (u *utilityModule) GetServicerModule() modules.ServicerModule {
-	return u.actorModules[servicer.ServicerModuleName]
+func (u *utilityModule) GetServicerModule() (modules.ServicerModule, error) {
+	m, ok := u.actorModules[servicer.ServicerModuleName].(modules.ServicerModule)
+	if !ok {
+		u.logger.Warn().Err(errors.New(""failed to cast servicer module"")).Msg(""failed to get servicer module"")
+		return nil, errors.New(""failed to cast servicer module"")
+	}
+	return m, nil
 }
 
-func (u *utilityModule) GetFishermanModule() modules.FishermanModule {
-	return u.actorModules[fisherman.FishermanModuleName]
+func (u *utilityModule) GetFishermanModule() (modules.FishermanModule, error) {
+	m, ok := u.actorModules[fisherman.FishermanModuleName].(modules.FishermanModule)",utility/module.go,2023-06-06 20:20:14+00:00,2023-06-06T20:25:04Z,Can we ever be in a situation where the map does not contain the key so we get a panic because we try to typeast a nill?,,,,,154,RIGHT,27,,line,https://api.github.com/repos/pokt-network/pocket/pulls/710,pokt-network/pocket,dbc0deb6a7aec39359745e9be952a4992689052a
https://api.github.com/repos/pokt-network/pocket/pulls/710,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1220279710,Olshansk,ec97a7f1578431b5d4ef0790f4eecb2f7337e6c1,fe90c0d0aa25c0b57cb2a9c2e3205c015ebc3ddf,"@@ -28,30 +45,325 @@ func CreateServicer(bus modules.Bus, options ...modules.ModuleOption) (modules.S
 }
 
 func (*servicer) Create(bus modules.Bus, options ...modules.ModuleOption) (modules.Module, error) {
-	m := &servicer{}
+	s := &servicer{}
 
 	for _, option := range options {
-		option(m)
+		option(s)
 	}
 
-	bus.RegisterModule(m)
+	bus.RegisterModule(s)
+
+	s.logger = logger.Global.CreateLoggerForModule(s.GetModuleName())
 
-	m.logger = logger.Global.CreateLoggerForModule(m.GetModuleName())
+	cfg := bus.GetRuntimeMgr().GetConfig()
+	s.config = cfg.Servicer
 
-	return m, nil
+	return s, nil
 }
 
 // TODO: implement this function
-func (m *servicer) Start() error {
-	m.logger.Info().Msg(""🧬 Servicer module started 🧬"")
+func (s *servicer) Start() error {
+	s.logger.Info().Msg(""🧬 Servicer module started 🧬"")
 	return nil
 }
 
-func (m *servicer) Stop() error {
-	m.logger.Info().Msg(""🧬 Servicer module stopped 🧬"")
+func (s *servicer) Stop() error {
+	s.logger.Info().Msg(""🧬 Servicer module stopped 🧬"")
 	return nil
 }
 
-func (m *servicer) GetModuleName() string {
+func (s *servicer) GetModuleName() string {
 	return ServicerModuleName
 }
+
+// HandleRelay processes a relay after performing validation.
+// It also updates the servicer's internal state to keep track of served relays.
+func (s *servicer) HandleRelay(relay *coreTypes.Relay) (*coreTypes.RelayResponse, error) {
+	if relay == nil {
+		return nil, fmt.Errorf(""cannot serve nil relay"")
+	}
+
+	if err := s.admitRelay(relay); err != nil {
+		return nil, fmt.Errorf(""Error admitting relay: %w"", err)
+	}
+
+	// TODO: implement Persist Relay
+	// TODO: implement execution
+	// TODO: implement state maintenance
+	// TODO: validate the response from the node?
+	// TODO: (QUESTION) Should we persist SignedRPC?
+	return nil, nil
+}
+
+// validateRelayMeta ensures the relay metadata is valid for being handled by the servicer
+// REFACTOR: move the meta-specific validation to a Validator method on RelayMeta struct
+func (s servicer) validateRelayMeta(meta *coreTypes.RelayMeta, currentHeight int64) error {
+	if meta == nil {
+		return fmt.Errorf(""empty relay metadata"")
+	}
+
+	if meta.RelayChain == nil {
+		return fmt.Errorf(""relay chain unspecified"")
+	}
+
+	// TODO: supported chains: needs to be crossed-checked with the world state from the persistence layer
+	if err := s.validateRelayChainSupport(meta.RelayChain, currentHeight); err != nil {
+		return fmt.Errorf(""validation of support for relay chain %s failed: %w"", meta.RelayChain.Id, err)
+	}
+
+	return nil
+}
+
+func (s servicer) validateRelayChainSupport(relayChain *coreTypes.Identifiable, currentHeight int64) error {
+	if !slices.Contains(s.config.Chains, relayChain.Id) {
+		return fmt.Errorf(""chain %s not supported by servicer %s configuration"", relayChain.Id, s.config.Address)
+	}
+
+	// DISCUSS: either update NewReadContext to take a uint64, or the GetCurrentHeight to return an int64.
+	readCtx, err := s.GetBus().GetPersistenceModule().NewReadContext(currentHeight)
+	if err != nil {
+		return fmt.Errorf(""error getting persistence context at height %d: %w"", currentHeight, err)
+	}
+	defer readCtx.Release() //nolint:errcheck // We only need to make sure the readCtx is released
+
+	// DISCUSS: should we update the GetServicer signature to take a string instead?
+	servicer, err := readCtx.GetServicer([]byte(s.config.Address), currentHeight)
+	if err != nil {
+		return fmt.Errorf(""error reading servicer from persistence: %w"", err)
+	}
+
+	if !slices.Contains(servicer.Chains, relayChain.Id) {
+		return fmt.Errorf(""chain %s not supported by servicer %s configuration fetched from persistence"", relayChain.Id, s.config.Address)
+	}
+
+	return nil
+}
+
+// TODO: implement
+// validateApplication makes sure the application has not received more relays than allocated in the current session.
+func (s servicer) validateApplication(meta *coreTypes.RelayMeta, session *coreTypes.Session) error {
+	/*
+		// if maxRelaysPerSession, overServiced := calculateAppSessionTokens(); overServiced {
+			return fmt.Errorf(""application %s has exceeded its allocated relays %d for the session %d"", meta.ApplicationPublicKey, maxRelaysPerSession)
+		}
+	*/
+	return nil
+}
+
+// validateServicer makes sure the servicer is A) active in the current session, and B) has not served more than its allocated relays for the session
+func (s servicer) validateServicer(meta *coreTypes.RelayMeta, session *coreTypes.Session) error {
+	if meta.ServicerPublicKey != s.config.PublicKey {
+		return fmt.Errorf(""relay servicer key %s does not match this servicer instance %s"", meta.ServicerPublicKey, s.config.PublicKey)
+	}
+
+	var found bool
+	for _, servicer := range session.Servicers {
+		if servicer != nil && servicer.PublicKey == meta.ServicerPublicKey {
+			found = true
+			break
+		}
+	}
+
+	if !found {
+		return fmt.Errorf(""relay servicer key %s not found in session %d with %d servicers"", meta.ServicerPublicKey, session.SessionNumber, len(session.Servicers))
+	}
+
+	// TODO: implement isServicerMaxedOut
+	return nil
+}
+
+// admitRelay decides whether the relay should be served
+func (s servicer) admitRelay(relay *coreTypes.Relay) error {
+	// TODO: utility module should initialize the servicer (if this module instance is a servicer)
+	const errPrefix = ""Error admitting relay""
+
+	if relay == nil {
+		return fmt.Errorf(""%s: relay is nil"", errPrefix)
+	}
+
+	height := s.GetBus().GetConsensusModule().CurrentHeight()
+	if err := s.validateRelayMeta(relay.Meta, int64(height)); err != nil {
+		return fmt.Errorf(""%w: %s"", errValidateRelayMeta, err.Error())
+	}
+
+	// TODO: update the CLI to include ApplicationAddress(or Application Public Key) in the RelayMeta
+	session, err := s.GetBus().GetUtilityModule().GetSession(relay.Meta.ApplicationAddress, int64(height), relay.Meta.RelayChain.Id, relay.Meta.GeoZone.Id)
+	if err != nil {
+		return fmt.Errorf(""%s: failed to get a session for height %d for relay meta %s: %w"", errPrefix, height, relay.Meta, err)
+	}
+
+	// TODO: (REFACTOR) use a loop to run all validators: would also remove the need for passing the session around
+	if err := validateRelayBlockHeight(relay.Meta, session); err != nil {
+		return fmt.Errorf(""%w: %s"", errValidateBlockHeight, err.Error())
+	}
+
+	if err := s.validateApplication(relay.Meta, session); err != nil {
+		return fmt.Errorf(""%s: relay failed application validation: %w"", errPrefix, err)
+	}
+
+	if err := s.validateServicer(relay.Meta, session); err != nil {
+		return fmt.Errorf(""%s: relay failed servicer instance validation: %w"", errPrefix, err)
+	}
+
+	return nil
+}
+
+// IMPROVE: Add session height tolerance to account for session rollovers
+func validateRelayBlockHeight(relayMeta *coreTypes.RelayMeta, session *coreTypes.Session) error {
+	sessionStartingBlock := session.SessionNumber * session.NumSessionBlocks
+	sessionLastBlock := sessionStartingBlock + session.SessionHeight
+
+	if relayMeta.BlockHeight >= sessionStartingBlock && relayMeta.BlockHeight <= sessionLastBlock {
+		return nil
+	}
+
+	return fmt.Errorf(""relay block height %d not within session ID %s starting block %d and last block %d"",
+		relayMeta.BlockHeight,
+		session.Id,
+		sessionStartingBlock,
+		sessionLastBlock)
+}
+
+// TECHDEBT: These structures were copied as placeholders from v0 and need to be updated to reflect changes in v1",utility/servicer/module.go,2023-06-06 20:22:18+00:00,2023-06-06T20:25:04Z,"Can you move these into `service/relay.go` and make the TECHDEBT more explicit. We are likely going to change all of these but I want to keep deleting them outside the scope of this PR. 

 cc @adshmh for context",,,,,227,RIGHT,228,,line,https://api.github.com/repos/pokt-network/pocket/pulls/710,pokt-network/pocket,dbc0deb6a7aec39359745e9be952a4992689052a
https://api.github.com/repos/pokt-network/pocket/pulls/710,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1220280915,Olshansk,ec97a7f1578431b5d4ef0790f4eecb2f7337e6c1,fe90c0d0aa25c0b57cb2a9c2e3205c015ebc3ddf,"@@ -21,11 +22,13 @@ const (
 
 // TODO: Implement this
 func (u *utilityModule) HandleRelay(relay *coreTypes.Relay) (*coreTypes.RelayResponse, error) {
-	if u.servicer == nil {
-		// if u.GetServicerModule() == nil {
-		return nil, fmt.Errorf(NodeIsNotServicerErr)
+	sm, err := u.GetServicerModule()
+",utility/session.go,2023-06-06 20:23:08+00:00,2023-06-06T20:25:04Z,"```suggestion
```",,,,,26,RIGHT,16,,line,https://api.github.com/repos/pokt-network/pocket/pulls/710,pokt-network/pocket,dbc0deb6a7aec39359745e9be952a4992689052a
https://api.github.com/repos/pokt-network/pocket/pulls/769,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1201161937,Olshansk,4829711ef2d51cc802105d988dccabf7b668e772,e3779cdd406028b8d5249f6b4afbe442b5edeadb,"@@ -334,13 +351,56 @@ func (m *p2pModule) handleAppData(data []byte) error {
 		return fmt.Errorf(""decoding network message: %w"", err)
 	}
 
+	if ok, err := m.checkNonce(networkMessage.GetNonce()); err != nil {
+		return fmt.Errorf(""handling network data: %w"", err)",p2p/module.go,2023-05-22 21:35:13+00:00,2023-05-22T21:56:21Z,"```suggestion
		return fmt.Errorf(""handling app data: %w"", err)
```",,,,,355,RIGHT,73,,line,https://api.github.com/repos/pokt-network/pocket/pulls/769,pokt-network/pocket,89eea03c454e90b88a4570af6f38f5241a3f22db
https://api.github.com/repos/pokt-network/pocket/pulls/769,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1201173758,Olshansk,4829711ef2d51cc802105d988dccabf7b668e772,e3779cdd406028b8d5249f6b4afbe442b5edeadb,"@@ -334,13 +351,56 @@ func (m *p2pModule) handleAppData(data []byte) error {
 		return fmt.Errorf(""decoding network message: %w"", err)
 	}
 
+	if ok, err := m.checkNonce(networkMessage.GetNonce()); err != nil {
+		return fmt.Errorf(""handling network data: %w"", err)
+	} else if !ok {
+		// skip passing redundant message to application layer
+		return nil
+	}
+
+	// DISCUSS_THIS_COMMIT: is there an explicit reason for constructing a new
+	// `PocketEnvelop` literal with content rather than passing `networkMessage`?
+	// (e.g. avoid blindly passing additional fields as the protobuf type changes)
 	event := messaging.PocketEnvelope{
 		Content: networkMessage.Content,
 	}
 	m.GetBus().PublishEventToBus(&event)
 	return nil
 }
 
+// checkNonce ensures the nonce has not been observed with i the deuper's capacity
+// of recent messages. Adds the nonce to the deduper if it has not been observed.
+// DISCUSS(#278): Add more tests to verify this is sufficient for deduping purposes.
+func (m *p2pModule) checkNonce(nonce utils.Nonce) (ok bool, err error) {
+	if contains := m.nonceDeduper.Contains(nonce); contains {
+		m.logger.Debug().
+			Uint64(""nonce"", nonce).
+			Msgf(""message already processed, skipping"")
+
+		m.redundantNonceTelemetry(nonce)",p2p/module.go,2023-05-22 21:37:56+00:00,2023-05-22T21:56:21Z,Nice,,,,,380,RIGHT,98,,line,https://api.github.com/repos/pokt-network/pocket/pulls/769,pokt-network/pocket,89eea03c454e90b88a4570af6f38f5241a3f22db
https://api.github.com/repos/pokt-network/pocket/pulls/769,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1201175804,Olshansk,4829711ef2d51cc802105d988dccabf7b668e772,e3779cdd406028b8d5249f6b4afbe442b5edeadb,"@@ -334,13 +351,56 @@ func (m *p2pModule) handleAppData(data []byte) error {
 		return fmt.Errorf(""decoding network message: %w"", err)
 	}
 
+	if ok, err := m.checkNonce(networkMessage.GetNonce()); err != nil {
+		return fmt.Errorf(""handling network data: %w"", err)
+	} else if !ok {
+		// skip passing redundant message to application layer
+		return nil
+	}
+
+	// DISCUSS_THIS_COMMIT: is there an explicit reason for constructing a new
+	// `PocketEnvelop` literal with content rather than passing `networkMessage`?
+	// (e.g. avoid blindly passing additional fields as the protobuf type changes)
 	event := messaging.PocketEnvelope{
 		Content: networkMessage.Content,
 	}
 	m.GetBus().PublishEventToBus(&event)
 	return nil
 }
 
+// checkNonce ensures the nonce has not been observed with i the deuper's capacity",p2p/module.go,2023-05-22 21:38:22+00:00,2023-05-22T21:56:21Z,"```suggestion
// checkNonce ensures the nonce has not been observed within the deuper's capacity
```",,,,,371,RIGHT,89,,line,https://api.github.com/repos/pokt-network/pocket/pulls/769,pokt-network/pocket,89eea03c454e90b88a4570af6f38f5241a3f22db
https://api.github.com/repos/pokt-network/pocket/pulls/769,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1201178153,Olshansk,4829711ef2d51cc802105d988dccabf7b668e772,e3779cdd406028b8d5249f6b4afbe442b5edeadb,"@@ -334,13 +351,56 @@ func (m *p2pModule) handleAppData(data []byte) error {
 		return fmt.Errorf(""decoding network message: %w"", err)
 	}
 
+	if ok, err := m.checkNonce(networkMessage.GetNonce()); err != nil {
+		return fmt.Errorf(""handling network data: %w"", err)
+	} else if !ok {
+		// skip passing redundant message to application layer
+		return nil
+	}
+
+	// DISCUSS_THIS_COMMIT: is there an explicit reason for constructing a new
+	// `PocketEnvelop` literal with content rather than passing `networkMessage`?
+	// (e.g. avoid blindly passing additional fields as the protobuf type changes)
 	event := messaging.PocketEnvelope{
 		Content: networkMessage.Content,
 	}
 	m.GetBus().PublishEventToBus(&event)
 	return nil
 }
 
+// checkNonce ensures the nonce has not been observed with i the deuper's capacity
+// of recent messages. Adds the nonce to the deduper if it has not been observed.
+// DISCUSS(#278): Add more tests to verify this is sufficient for deduping purposes.
+func (m *p2pModule) checkNonce(nonce utils.Nonce) (ok bool, err error) {",p2p/module.go,2023-05-22 21:38:51+00:00,2023-05-22T21:56:21Z,"```suggestion
func (m *p2pModule) checkNonce(nonce utils.Nonce) (bool, error) {
```",,,,,374,RIGHT,92,,line,https://api.github.com/repos/pokt-network/pocket/pulls/769,pokt-network/pocket,89eea03c454e90b88a4570af6f38f5241a3f22db
https://api.github.com/repos/pokt-network/pocket/pulls/769,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1201183095,Olshansk,4829711ef2d51cc802105d988dccabf7b668e772,e3779cdd406028b8d5249f6b4afbe442b5edeadb,"@@ -334,13 +351,56 @@ func (m *p2pModule) handleAppData(data []byte) error {
 		return fmt.Errorf(""decoding network message: %w"", err)
 	}
 
+	if ok, err := m.checkNonce(networkMessage.GetNonce()); err != nil {
+		return fmt.Errorf(""handling network data: %w"", err)
+	} else if !ok {
+		// skip passing redundant message to application layer
+		return nil
+	}
+
+	// DISCUSS_THIS_COMMIT: is there an explicit reason for constructing a new
+	// `PocketEnvelop` literal with content rather than passing `networkMessage`?
+	// (e.g. avoid blindly passing additional fields as the protobuf type changes)
 	event := messaging.PocketEnvelope{
 		Content: networkMessage.Content,
 	}
 	m.GetBus().PublishEventToBus(&event)
 	return nil
 }
 
+// checkNonce ensures the nonce has not been observed with i the deuper's capacity
+// of recent messages. Adds the nonce to the deduper if it has not been observed.
+// DISCUSS(#278): Add more tests to verify this is sufficient for deduping purposes.
+func (m *p2pModule) checkNonce(nonce utils.Nonce) (ok bool, err error) {",p2p/module.go,2023-05-22 21:40:22+00:00,2023-05-22T21:56:21Z,"Can you rename `checkNonse` to something more ""functional"" like `wasNonceObserved` or `isDuplicateNonce` so there is no ambiguity as to what the boolean return value contains. ",,,,,374,RIGHT,92,,line,https://api.github.com/repos/pokt-network/pocket/pulls/769,pokt-network/pocket,89eea03c454e90b88a4570af6f38f5241a3f22db
https://api.github.com/repos/pokt-network/pocket/pulls/769,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1201201707,Olshansk,4829711ef2d51cc802105d988dccabf7b668e772,e3779cdd406028b8d5249f6b4afbe442b5edeadb,"@@ -8,4 +8,5 @@ option go_package = ""github.com/pokt-network/pocket/shared/messaging"";
 
 message PocketEnvelope {
   google.protobuf.Any content = 1;
+  uint64 nonce = 2; // DISCUSS: need entropy at this level?",shared/messaging/proto/pocket_envelope.proto,2023-05-22 21:52:32+00:00,2023-05-22T21:56:21Z,"```suggestion
  uint64 nonce = 2; // TECHDEBT: should this be the same as the nonce in `Transaction`?
```",,,,,11,RIGHT,4,,line,https://api.github.com/repos/pokt-network/pocket/pulls/769,pokt-network/pocket,89eea03c454e90b88a4570af6f38f5241a3f22db
https://api.github.com/repos/pokt-network/pocket/pulls/769,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1201206914,Olshansk,4829711ef2d51cc802105d988dccabf7b668e772,e3779cdd406028b8d5249f6b4afbe442b5edeadb,"@@ -334,13 +351,56 @@ func (m *p2pModule) handleAppData(data []byte) error {
 		return fmt.Errorf(""decoding network message: %w"", err)
 	}
 
+	if ok, err := m.checkNonce(networkMessage.GetNonce()); err != nil {
+		return fmt.Errorf(""handling network data: %w"", err)
+	} else if !ok {
+		// skip passing redundant message to application layer
+		return nil
+	}
+
+	// DISCUSS_THIS_COMMIT: is there an explicit reason for constructing a new",p2p/module.go,2023-05-22 21:55:55+00:00,2023-05-22T21:56:21Z,"I do not remember the exact reasoning. Your example/reasoning seems accurate, and I believe our attempt at making sure the nonce wasn't propagated was once of the reasons.

I believe one of the reasons was to pass a structure by value, rather than by reference, in case downstream functionality may try to modify it. ",,,,,361,RIGHT,79,,line,https://api.github.com/repos/pokt-network/pocket/pulls/769,pokt-network/pocket,89eea03c454e90b88a4570af6f38f5241a3f22db
https://api.github.com/repos/pokt-network/pocket/pulls/769,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1209519522,bryanchriswhite,5692257435509e1720f1e8789587d61e91a83ef5,e3779cdd406028b8d5249f6b4afbe442b5edeadb,"@@ -333,13 +350,62 @@ func (m *p2pModule) handlePocketEnvelope(pocketEnvelopeBz []byte) error {
 		return fmt.Errorf(""decoding network message: %w"", err)
 	}
 
+	if m.isNonceAlreadyObserved(poktEnvelope.Nonce) {
+		// skip passing redundant message to application layer
+		return nil
+	}
+
+	if err := m.observeNonce(poktEnvelope.Nonce); err != nil {
+		return fmt.Errorf(""pocket envelope nonce: %w"", err)
+	}
+
+	// NB: Explicitly constructing a new `PocketEnvelop` literal with content
+	// rather than forwarding `poktEnvelope` to avoid blindly passing additional
+	// fields as the protobuf type changes. Additionally, strips the `Nonce` field.
 	event := messaging.PocketEnvelope{
 		Content: poktEnvelope.Content,
 	}
 	m.GetBus().PublishEventToBus(&event)
 	return nil
 }
 
+// observeNonce adds the nonce to the deduper if it has not been observed.
+func (m *p2pModule) observeNonce(nonce utils.Nonce) error {
+	// Add the nonce to the deduper
+	if err := m.nonceDeduper.Push(nonce); err != nil {
+		return err
+	}
+	return nil
+}
+
+// isNonceAlreadyObserved returns whether the nonce has been observed within the
+// deuper's capacity of recent messages.
+// DISCUSS(#278): Add more tests to verify this is sufficient for deduping purposes.
+func (m *p2pModule) isNonceAlreadyObserved(nonce utils.Nonce) bool {
+	if contains := m.nonceDeduper.Contains(nonce); contains {
+		m.logger.Debug().
+			Uint64(""nonce"", nonce).
+			Msgf(""message already processed, skipping"")
+
+		m.redundantNonceTelemetry(nonce)
+		return false
+	}
+	return true",p2p/module.go,2023-05-29 19:16:56+00:00,2023-05-29T19:16:56Z,"```suggestion
		return true
	}
	return false
```",,391.0,RIGHT,,393,RIGHT,112,,line,https://api.github.com/repos/pokt-network/pocket/pulls/769,pokt-network/pocket,89eea03c454e90b88a4570af6f38f5241a3f22db
https://api.github.com/repos/pokt-network/pocket/pulls/769,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1210786291,Olshansk,df657b8adb383754dd9e8abbdcfe7c4ec9f0c58b,e3779cdd406028b8d5249f6b4afbe442b5edeadb,"@@ -333,13 +350,62 @@ func (m *p2pModule) handlePocketEnvelope(pocketEnvelopeBz []byte) error {
 		return fmt.Errorf(""decoding network message: %w"", err)
 	}
 
+	if m.isNonceAlreadyObserved(poktEnvelope.Nonce) {
+		// skip passing redundant message to application layer",p2p/module.go,2023-05-30 20:22:56+00:00,2023-05-30T20:27:15Z,"Consider logging this, at least in the debug level.",,,,354.0,354,RIGHT,73,73.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/769,pokt-network/pocket,89eea03c454e90b88a4570af6f38f5241a3f22db
https://api.github.com/repos/pokt-network/pocket/pulls/769,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1210786888,Olshansk,df657b8adb383754dd9e8abbdcfe7c4ec9f0c58b,e3779cdd406028b8d5249f6b4afbe442b5edeadb,"@@ -333,13 +350,62 @@ func (m *p2pModule) handlePocketEnvelope(pocketEnvelopeBz []byte) error {
 		return fmt.Errorf(""decoding network message: %w"", err)
 	}
 
+	if m.isNonceAlreadyObserved(poktEnvelope.Nonce) {
+		// skip passing redundant message to application layer
+		return nil
+	}
+
+	if err := m.observeNonce(poktEnvelope.Nonce); err != nil {
+		return fmt.Errorf(""pocket envelope nonce: %w"", err)
+	}
+
+	// NB: Explicitly constructing a new `PocketEnvelop` literal with content",p2p/module.go,2023-05-30 20:23:41+00:00,2023-05-30T20:27:15Z,"```suggestion
	// NB: Explicitly constructing a new `PocketEnvelope` literal with content
```",,,,,362,RIGHT,81,,line,https://api.github.com/repos/pokt-network/pocket/pulls/769,pokt-network/pocket,89eea03c454e90b88a4570af6f38f5241a3f22db
https://api.github.com/repos/pokt-network/pocket/pulls/769,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1210787794,Olshansk,df657b8adb383754dd9e8abbdcfe7c4ec9f0c58b,e3779cdd406028b8d5249f6b4afbe442b5edeadb,"@@ -333,13 +350,62 @@ func (m *p2pModule) handlePocketEnvelope(pocketEnvelopeBz []byte) error {
 		return fmt.Errorf(""decoding network message: %w"", err)
 	}
 
+	if m.isNonceAlreadyObserved(poktEnvelope.Nonce) {
+		// skip passing redundant message to application layer
+		return nil
+	}
+
+	if err := m.observeNonce(poktEnvelope.Nonce); err != nil {
+		return fmt.Errorf(""pocket envelope nonce: %w"", err)
+	}
+
+	// NB: Explicitly constructing a new `PocketEnvelop` literal with content
+	// rather than forwarding `poktEnvelope` to avoid blindly passing additional
+	// fields as the protobuf type changes. Additionally, strips the `Nonce` field.
 	event := messaging.PocketEnvelope{
 		Content: poktEnvelope.Content,
 	}
 	m.GetBus().PublishEventToBus(&event)
 	return nil
 }
 
+// observeNonce adds the nonce to the deduper if it has not been observed.
+func (m *p2pModule) observeNonce(nonce utils.Nonce) error {
+	// Add the nonce to the deduper",p2p/module.go,2023-05-30 20:24:40+00:00,2023-05-30T20:27:15Z,Can we just do `return m.nonceDeduper.Push(nonce)`,,,,374.0,374,RIGHT,93,93.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/769,pokt-network/pocket,89eea03c454e90b88a4570af6f38f5241a3f22db
https://api.github.com/repos/pokt-network/pocket/pulls/769,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1210788486,Olshansk,df657b8adb383754dd9e8abbdcfe7c4ec9f0c58b,e3779cdd406028b8d5249f6b4afbe442b5edeadb,"@@ -333,13 +350,62 @@ func (m *p2pModule) handlePocketEnvelope(pocketEnvelopeBz []byte) error {
 		return fmt.Errorf(""decoding network message: %w"", err)
 	}
 
+	if m.isNonceAlreadyObserved(poktEnvelope.Nonce) {
+		// skip passing redundant message to application layer
+		return nil
+	}
+
+	if err := m.observeNonce(poktEnvelope.Nonce); err != nil {
+		return fmt.Errorf(""pocket envelope nonce: %w"", err)
+	}
+
+	// NB: Explicitly constructing a new `PocketEnvelop` literal with content
+	// rather than forwarding `poktEnvelope` to avoid blindly passing additional
+	// fields as the protobuf type changes. Additionally, strips the `Nonce` field.
 	event := messaging.PocketEnvelope{
 		Content: poktEnvelope.Content,
 	}
 	m.GetBus().PublishEventToBus(&event)
 	return nil
 }
 
+// observeNonce adds the nonce to the deduper if it has not been observed.
+func (m *p2pModule) observeNonce(nonce utils.Nonce) error {
+	// Add the nonce to the deduper
+	if err := m.nonceDeduper.Push(nonce); err != nil {
+		return err
+	}
+	return nil
+}
+
+// isNonceAlreadyObserved returns whether the nonce has been observed within the
+// deuper's capacity of recent messages.
+// DISCUSS(#278): Add more tests to verify this is sufficient for deduping purposes.",p2p/module.go,2023-05-30 20:25:24+00:00,2023-05-30T20:27:15Z,Can you link to this PR w/ a comment in the discussion after we merge it in?,,,,380.0,383,RIGHT,102,99.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/769,pokt-network/pocket,89eea03c454e90b88a4570af6f38f5241a3f22db
https://api.github.com/repos/pokt-network/pocket/pulls/769,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1210789849,Olshansk,df657b8adb383754dd9e8abbdcfe7c4ec9f0c58b,e3779cdd406028b8d5249f6b4afbe442b5edeadb,"@@ -333,13 +350,62 @@ func (m *p2pModule) handlePocketEnvelope(pocketEnvelopeBz []byte) error {
 		return fmt.Errorf(""decoding network message: %w"", err)
 	}
 
+	if m.isNonceAlreadyObserved(poktEnvelope.Nonce) {
+		// skip passing redundant message to application layer
+		return nil
+	}
+
+	if err := m.observeNonce(poktEnvelope.Nonce); err != nil {
+		return fmt.Errorf(""pocket envelope nonce: %w"", err)
+	}
+
+	// NB: Explicitly constructing a new `PocketEnvelop` literal with content
+	// rather than forwarding `poktEnvelope` to avoid blindly passing additional
+	// fields as the protobuf type changes. Additionally, strips the `Nonce` field.
 	event := messaging.PocketEnvelope{
 		Content: poktEnvelope.Content,
 	}
 	m.GetBus().PublishEventToBus(&event)
 	return nil
 }
 
+// observeNonce adds the nonce to the deduper if it has not been observed.
+func (m *p2pModule) observeNonce(nonce utils.Nonce) error {
+	// Add the nonce to the deduper
+	if err := m.nonceDeduper.Push(nonce); err != nil {
+		return err
+	}
+	return nil
+}
+
+// isNonceAlreadyObserved returns whether the nonce has been observed within the
+// deuper's capacity of recent messages.
+// DISCUSS(#278): Add more tests to verify this is sufficient for deduping purposes.
+func (m *p2pModule) isNonceAlreadyObserved(nonce utils.Nonce) bool {
+	if contains := m.nonceDeduper.Contains(nonce); contains {",p2p/module.go,2023-05-30 20:26:56+00:00,2023-05-30T20:27:15Z,"NIT: If you do `!contains` and return `false`, you wouldn't have to indent all the business logic.",,,,,385,RIGHT,104,,line,https://api.github.com/repos/pokt-network/pocket/pulls/769,pokt-network/pocket,89eea03c454e90b88a4570af6f38f5241a3f22db
https://api.github.com/repos/pokt-network/pocket/pulls/769,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1212298414,dylanlott,7d97aca342185946f3865f445c40076cc2951abc,e3779cdd406028b8d5249f6b4afbe442b5edeadb,"@@ -265,6 +272,17 @@ func (m *p2pModule) setupCurrentHeightProvider() error {
 	return nil
 }
 
+// setupNonceDeduper initializes an empty deduper with a max capacity of
+// the configured `MaxNonces`.
+func (m *p2pModule) setupNonceDeduper() error {
+	if m.cfg.MaxNonces == 0 {",p2p/module.go,2023-05-31 20:52:40+00:00,2023-05-31T21:03:04Z,Great to see global variables getting moved to configuration values 🚀 ,,,,278.0,278,RIGHT,49,49.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/769,pokt-network/pocket,89eea03c454e90b88a4570af6f38f5241a3f22db
https://api.github.com/repos/pokt-network/pocket/pulls/769,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1212301559,dylanlott,7d97aca342185946f3865f445c40076cc2951abc,e3779cdd406028b8d5249f6b4afbe442b5edeadb,"@@ -8,4 +8,5 @@ option go_package = ""github.com/pokt-network/pocket/shared/messaging"";
 
 message PocketEnvelope {
   google.protobuf.Any content = 1;
+  uint64 nonce = 2; // TECHDEBT: should this be the same as the nonce in `Transaction`?",shared/messaging/proto/pocket_envelope.proto,2023-05-31 20:55:00+00:00,2023-05-31T21:03:04Z,Why is this techdebt and not a discussion point? Is it worth mentioning an issue number here?,,,,,11,RIGHT,4,,line,https://api.github.com/repos/pokt-network/pocket/pulls/769,pokt-network/pocket,89eea03c454e90b88a4570af6f38f5241a3f22db
https://api.github.com/repos/pokt-network/pocket/pulls/769,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1212680450,bryanchriswhite,7d97aca342185946f3865f445c40076cc2951abc,e3779cdd406028b8d5249f6b4afbe442b5edeadb,"@@ -8,4 +8,5 @@ option go_package = ""github.com/pokt-network/pocket/shared/messaging"";
 
 message PocketEnvelope {
   google.protobuf.Any content = 1;
+  uint64 nonce = 2; // TECHDEBT: should this be the same as the nonce in `Transaction`?",shared/messaging/proto/pocket_envelope.proto,2023-06-01 06:59:10+00:00,2023-06-01T06:59:58Z,"@dylanlott :+1: I'm not super familiar with the background here, this is a comment that has been transported and transformed across history. AFAIK discussion #278 has the most detail on this:

```suggestion
  uint64 nonce = 2; // DISCUSS(#278): should this be the same as the nonce in `Transaction`?
```",,,,,11,RIGHT,4,,line,https://api.github.com/repos/pokt-network/pocket/pulls/769,pokt-network/pocket,89eea03c454e90b88a4570af6f38f5241a3f22db
https://api.github.com/repos/pokt-network/pocket/pulls/769,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1212683250,bryanchriswhite,d92c2b1a43f414b59ab77269e27be600c0829967,e3779cdd406028b8d5249f6b4afbe442b5edeadb,"@@ -7,7 +7,14 @@ and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0
 
 ## [Unreleased]
 
-## [0.0.0.52] - 2023-05-26
+## [0.0.0.53] - 2023-05-31",p2p/CHANGELOG.md,2023-06-01 07:02:01+00:00,2023-06-01T07:02:01Z,"```suggestion
## [0.0.0.53] - 2023-06-01
```",,,,,10,RIGHT,5,,line,https://api.github.com/repos/pokt-network/pocket/pulls/769,pokt-network/pocket,89eea03c454e90b88a4570af6f38f5241a3f22db
https://api.github.com/repos/pokt-network/pocket/pulls/769,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1212683416,bryanchriswhite,d92c2b1a43f414b59ab77269e27be600c0829967,e3779cdd406028b8d5249f6b4afbe442b5edeadb,"@@ -7,6 +7,10 @@ and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0
 
 ## [Unreleased]
 
+## [0.0.0.58] - 2023-05-31",shared/CHANGELOG.md,2023-06-01 07:02:13+00:00,2023-06-01T07:02:13Z,"```suggestion
## [0.0.0.58] - 2023-06-01
```",,,,,10,RIGHT,4,,line,https://api.github.com/repos/pokt-network/pocket/pulls/769,pokt-network/pocket,89eea03c454e90b88a4570af6f38f5241a3f22db
https://api.github.com/repos/pokt-network/pocket/pulls/766,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1203379958,Olshansk,139b690ae7198d0da0e353aeae0122214a0179a6,87f7613938bcd335fceacc02170cd74007ac8fec,"@@ -0,0 +1,121 @@
+# E2E Features <!-- omit in toc -->
+
+- [Legend](#legend)
+- [A. E2E Relay](#a-e2e-relay)
+  - [1. Trustless Relay 🟡](#1-trustless-relay-)
+  - [2. Delegated Relay 🟡](#2-delegated-relay-)
+  - [3. Rate Limited Application 🟢🔴](#3-rate-limited-application-)",utility/doc/E2E_FEATURE_LIST.md,2023-05-24 03:51:10+00:00,2023-05-24T03:51:10Z,"@adshmh Going to open an inline thread per your comment in  https://github.com/pokt-network/pocket/pull/766#pullrequestreview-1440778055

> Too early for me to propose any potential changes, but I do have a question regarding the TestNet vs MainNet on item 3, i.e. Rate Limited Applications: is there enough distinction between the two E2E tests that having the test ready for MainNet does not cover having it on TestNet?

There's no formal definition (written down anywhere) for what we need to have in TestNet vs MainNet so it's a good question. Even between the [specification](https://github.com/pokt-network/pocket-network-protocol/tree/main/utility), the paper on [Relay Mining](https://arxiv.org/abs/2305.10672), and all the other notes we have, there are still open-ended questions w.r.t the protocol which will be answered by the future economics group.

For TestNet, we need to have all the building blocks (i.e. entrypoints) in place to validate that values are changing, communication/messaging (i.e. web2 style) is reliable and we can build upon it. E2E tests should capture behaviour. For MainNet, we'll need to make sure that everything is completely secure (i.e. no cryptographic vulnerabilities), proven (i.e. the algorithms are sound, scalable and on-chain) and we can build upon the tokenomics. In other words, TestNet -> MainNet will be the bigger hurdle.",,,,7.0,7,RIGHT,7,7.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/766,pokt-network/pocket,d2acbbd16e3b2895c8f45afe348f124aa1597288
https://api.github.com/repos/pokt-network/pocket/pulls/766,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1204201274,fredteumer,139b690ae7198d0da0e353aeae0122214a0179a6,87f7613938bcd335fceacc02170cd74007ac8fec,"@@ -0,0 +1,121 @@
+# E2E Features <!-- omit in toc -->
+
+- [Legend](#legend)
+- [A. E2E Relay](#a-e2e-relay)
+  - [1. Trustless Relay 🟡](#1-trustless-relay-)
+  - [2. Delegated Relay 🟡](#2-delegated-relay-)
+  - [3. Rate Limited Application 🟢🔴](#3-rate-limited-application-)
+- [B. E2E QoS](#b-e2e-qos)",utility/doc/E2E_FEATURE_LIST.md,2023-05-24 13:59:05+00:00,2023-05-24T13:59:06Z,cut all quality of service checks on protocol from v1 scope (imo),,,,8.0,8,RIGHT,8,8.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/766,pokt-network/pocket,d2acbbd16e3b2895c8f45afe348f124aa1597288
https://api.github.com/repos/pokt-network/pocket/pulls/766,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1204202108,fredteumer,139b690ae7198d0da0e353aeae0122214a0179a6,87f7613938bcd335fceacc02170cd74007ac8fec,"@@ -0,0 +1,121 @@
+# E2E Features <!-- omit in toc -->
+
+- [Legend](#legend)
+- [A. E2E Relay](#a-e2e-relay)
+  - [1. Trustless Relay 🟡](#1-trustless-relay-)
+  - [2. Delegated Relay 🟡](#2-delegated-relay-)
+  - [3. Rate Limited Application 🟢🔴](#3-rate-limited-application-)
+- [B. E2E QoS](#b-e2e-qos)
+  - [1. QoS - Single Check 🟡](#1-qos---single-check-)
+  - [2. QoS - Test Score Submission 🟢🔴](#2-qos---test-score-submission-)
+  - [3. QoS - Report Card Aggregation 🟢🔴](#3-qos---report-card-aggregation-)
+- [C. E2E Rewards \& Distributions](#c-e2e-rewards--distributions)
+  - [1. Servicer Relay Rewards - Custodial 🟡](#1-servicer-relay-rewards---custodial-)
+  - [2. Servicer Relay Rewards - Non-Custodial 🟡](#2-servicer-relay-rewards---non-custodial-)
+  - [3. Servicer Relay Rewards - Rev-Share 🔵](#3-servicer-relay-rewards---rev-share-)
+  - [4. Validator - Block Rewards 🟡](#4-validator---block-rewards-)
+  - [5. Fisherman - QoS Submission Rewards 🟡](#5-fisherman---qos-submission-rewards-)",utility/doc/E2E_FEATURE_LIST.md,2023-05-24 13:59:31+00:00,2023-05-24T13:59:31Z,no longer in scope (see previous comment),,,,,17,RIGHT,17,,line,https://api.github.com/repos/pokt-network/pocket/pulls/766,pokt-network/pocket,d2acbbd16e3b2895c8f45afe348f124aa1597288
https://api.github.com/repos/pokt-network/pocket/pulls/766,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1204202636,fredteumer,139b690ae7198d0da0e353aeae0122214a0179a6,87f7613938bcd335fceacc02170cd74007ac8fec,"@@ -0,0 +1,121 @@
+# E2E Features <!-- omit in toc -->
+
+- [Legend](#legend)
+- [A. E2E Relay](#a-e2e-relay)
+  - [1. Trustless Relay 🟡](#1-trustless-relay-)
+  - [2. Delegated Relay 🟡](#2-delegated-relay-)
+  - [3. Rate Limited Application 🟢🔴](#3-rate-limited-application-)
+- [B. E2E QoS](#b-e2e-qos)
+  - [1. QoS - Single Check 🟡](#1-qos---single-check-)
+  - [2. QoS - Test Score Submission 🟢🔴](#2-qos---test-score-submission-)
+  - [3. QoS - Report Card Aggregation 🟢🔴](#3-qos---report-card-aggregation-)
+- [C. E2E Rewards \& Distributions](#c-e2e-rewards--distributions)
+  - [1. Servicer Relay Rewards - Custodial 🟡](#1-servicer-relay-rewards---custodial-)
+  - [2. Servicer Relay Rewards - Non-Custodial 🟡](#2-servicer-relay-rewards---non-custodial-)
+  - [3. Servicer Relay Rewards - Rev-Share 🔵](#3-servicer-relay-rewards---rev-share-)
+  - [4. Validator - Block Rewards 🟡](#4-validator---block-rewards-)
+  - [5. Fisherman - QoS Submission Rewards 🟡](#5-fisherman---qos-submission-rewards-)
+- [D. E2E Burns \& Slashes](#d-e2e-burns--slashes)
+  - [1. Validator - Double-Sign Burn 🔴](#1-validator---double-sign-burn-)
+  - [2. Application - Application Quota Stake Burn 🟢🔴](#2-application---application-quota-stake-burn-)
+  - [3. Servicer - Inaccurate Challenged Response 🔵](#3-servicer---inaccurate-challenged-response-)
+  - [4. Fisherman - Missing Test Score Burn 🔴](#4-fisherman---missing-test-score-burn-)",utility/doc/E2E_FEATURE_LIST.md,2023-05-24 13:59:49+00:00,2023-05-24T13:59:49Z,cut,,,,,22,RIGHT,22,,line,https://api.github.com/repos/pokt-network/pocket/pulls/766,pokt-network/pocket,d2acbbd16e3b2895c8f45afe348f124aa1597288
https://api.github.com/repos/pokt-network/pocket/pulls/766,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1204202808,fredteumer,139b690ae7198d0da0e353aeae0122214a0179a6,87f7613938bcd335fceacc02170cd74007ac8fec,"@@ -0,0 +1,121 @@
+# E2E Features <!-- omit in toc -->
+
+- [Legend](#legend)
+- [A. E2E Relay](#a-e2e-relay)
+  - [1. Trustless Relay 🟡](#1-trustless-relay-)
+  - [2. Delegated Relay 🟡](#2-delegated-relay-)
+  - [3. Rate Limited Application 🟢🔴](#3-rate-limited-application-)
+- [B. E2E QoS](#b-e2e-qos)
+  - [1. QoS - Single Check 🟡](#1-qos---single-check-)
+  - [2. QoS - Test Score Submission 🟢🔴](#2-qos---test-score-submission-)
+  - [3. QoS - Report Card Aggregation 🟢🔴](#3-qos---report-card-aggregation-)
+- [C. E2E Rewards \& Distributions](#c-e2e-rewards--distributions)
+  - [1. Servicer Relay Rewards - Custodial 🟡](#1-servicer-relay-rewards---custodial-)
+  - [2. Servicer Relay Rewards - Non-Custodial 🟡](#2-servicer-relay-rewards---non-custodial-)
+  - [3. Servicer Relay Rewards - Rev-Share 🔵](#3-servicer-relay-rewards---rev-share-)
+  - [4. Validator - Block Rewards 🟡](#4-validator---block-rewards-)
+  - [5. Fisherman - QoS Submission Rewards 🟡](#5-fisherman---qos-submission-rewards-)
+- [D. E2E Burns \& Slashes](#d-e2e-burns--slashes)
+  - [1. Validator - Double-Sign Burn 🔴](#1-validator---double-sign-burn-)
+  - [2. Application - Application Quota Stake Burn 🟢🔴](#2-application---application-quota-stake-burn-)
+  - [3. Servicer - Inaccurate Challenged Response 🔵](#3-servicer---inaccurate-challenged-response-)
+  - [4. Fisherman - Missing Test Score Burn 🔴](#4-fisherman---missing-test-score-burn-)
+  - [5. Fisherman - Incomplete Test Score Burn 🔴](#5-fisherman---incomplete-test-score-burn-)",utility/doc/E2E_FEATURE_LIST.md,2023-05-24 13:59:55+00:00,2023-05-24T13:59:55Z,cut,,,,,23,RIGHT,23,,line,https://api.github.com/repos/pokt-network/pocket/pulls/766,pokt-network/pocket,d2acbbd16e3b2895c8f45afe348f124aa1597288
https://api.github.com/repos/pokt-network/pocket/pulls/766,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1204204100,fredteumer,139b690ae7198d0da0e353aeae0122214a0179a6,87f7613938bcd335fceacc02170cd74007ac8fec,"@@ -0,0 +1,121 @@
+# E2E Features <!-- omit in toc -->
+
+- [Legend](#legend)
+- [A. E2E Relay](#a-e2e-relay)
+  - [1. Trustless Relay 🟡](#1-trustless-relay-)
+  - [2. Delegated Relay 🟡](#2-delegated-relay-)
+  - [3. Rate Limited Application 🟢🔴](#3-rate-limited-application-)
+- [B. E2E QoS](#b-e2e-qos)
+  - [1. QoS - Single Check 🟡](#1-qos---single-check-)
+  - [2. QoS - Test Score Submission 🟢🔴](#2-qos---test-score-submission-)
+  - [3. QoS - Report Card Aggregation 🟢🔴](#3-qos---report-card-aggregation-)
+- [C. E2E Rewards \& Distributions](#c-e2e-rewards--distributions)
+  - [1. Servicer Relay Rewards - Custodial 🟡](#1-servicer-relay-rewards---custodial-)
+  - [2. Servicer Relay Rewards - Non-Custodial 🟡](#2-servicer-relay-rewards---non-custodial-)
+  - [3. Servicer Relay Rewards - Rev-Share 🔵](#3-servicer-relay-rewards---rev-share-)
+  - [4. Validator - Block Rewards 🟡](#4-validator---block-rewards-)
+  - [5. Fisherman - QoS Submission Rewards 🟡](#5-fisherman---qos-submission-rewards-)
+- [D. E2E Burns \& Slashes](#d-e2e-burns--slashes)
+  - [1. Validator - Double-Sign Burn 🔴](#1-validator---double-sign-burn-)
+  - [2. Application - Application Quota Stake Burn 🟢🔴](#2-application---application-quota-stake-burn-)
+  - [3. Servicer - Inaccurate Challenged Response 🔵](#3-servicer---inaccurate-challenged-response-)
+  - [4. Fisherman - Missing Test Score Burn 🔴](#4-fisherman---missing-test-score-burn-)
+  - [5. Fisherman - Incomplete Test Score Burn 🔴](#5-fisherman---incomplete-test-score-burn-)
+- [E. E2E PoS Functionality](#e-e2e-pos-functionality)
+  - [1. Actor Staking 🟡](#1-actor-staking-)
+  - [2. Actor Unstaking 🟡](#2-actor-unstaking-)
+  - [3. Actor Unbonding 🟡](#3-actor-unbonding-)
+  - [4. Actor Jailing 🟡](#4-actor-jailing-)
+  - [5. Actor Unjailing 🟡](#5-actor-unjailing-)
+  - [6. Actor Pausing 🔵](#6-actor-pausing-)
+  - [7. Actor Unpausing 🔵](#7-actor-unpausing-)
+  - [8. Delegated Actor Staking 🔵](#8-delegated-actor-staking-)
+- [F. E2E Feature Flags](#f-e2e-feature-flags)",utility/doc/E2E_FEATURE_LIST.md,2023-05-24 14:00:39+00:00,2023-05-24T14:00:39Z,"cut from scope , can always introduce post launch",,,,,33,RIGHT,33,,line,https://api.github.com/repos/pokt-network/pocket/pulls/766,pokt-network/pocket,d2acbbd16e3b2895c8f45afe348f124aa1597288
https://api.github.com/repos/pokt-network/pocket/pulls/766,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1204204852,fredteumer,139b690ae7198d0da0e353aeae0122214a0179a6,87f7613938bcd335fceacc02170cd74007ac8fec,"@@ -0,0 +1,121 @@
+# E2E Features <!-- omit in toc -->
+
+- [Legend](#legend)
+- [A. E2E Relay](#a-e2e-relay)
+  - [1. Trustless Relay 🟡](#1-trustless-relay-)
+  - [2. Delegated Relay 🟡](#2-delegated-relay-)
+  - [3. Rate Limited Application 🟢🔴](#3-rate-limited-application-)
+- [B. E2E QoS](#b-e2e-qos)
+  - [1. QoS - Single Check 🟡](#1-qos---single-check-)
+  - [2. QoS - Test Score Submission 🟢🔴](#2-qos---test-score-submission-)
+  - [3. QoS - Report Card Aggregation 🟢🔴](#3-qos---report-card-aggregation-)
+- [C. E2E Rewards \& Distributions](#c-e2e-rewards--distributions)
+  - [1. Servicer Relay Rewards - Custodial 🟡](#1-servicer-relay-rewards---custodial-)
+  - [2. Servicer Relay Rewards - Non-Custodial 🟡](#2-servicer-relay-rewards---non-custodial-)
+  - [3. Servicer Relay Rewards - Rev-Share 🔵](#3-servicer-relay-rewards---rev-share-)",utility/doc/E2E_FEATURE_LIST.md,2023-05-24 14:01:06+00:00,2023-05-24T14:01:07Z,"revshare is another cut from scope option, consider it",,,,15.0,15,RIGHT,15,15.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/766,pokt-network/pocket,d2acbbd16e3b2895c8f45afe348f124aa1597288
https://api.github.com/repos/pokt-network/pocket/pulls/780,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1228890250,Olshansk,e61c419746b10e6ef0bee8cf5146ba49fa240050,1a4293cbb757c030326439d66080f3fb09f5ab44,"@@ -40,13 +40,13 @@ The `KeyPair` defined in [crypto package](../../../shared/crypto) is the data st
 
 ### V0<->V1 Interoperability
 
-The `Keybase` interface supports full interoperability of key export & import between Pocket [V0](https://github.com/pokt-network/pocket-core)<->[V1](https://github.com/pokt-network/pocket).
+The `Keybase` interface supports partial interoperability of key export & import between Pocket [V0](https://github.com/pokt-network/pocket-core)<->[V1](https://github.com/pokt-network/pocket).
 
-Any private key created in the V0 protocol can be imported into V1 via one of the following two ways:
+Any private key created in the V0 protocol can be imported into V1 via the following:
 
-1. **JSON keyfile**: This method will take the JSON encoded, encrypted private key, and will import it into the V1 keybase. The `passphrase` supplied must be the same as the one use to encrypt the key in the first place or the key won't be importable.
+ - **Private Key Hex String**: This method will directly import the private key from the hex string provided and encrypt it with the passphrase provided. This enables the passphrase to be different from the original as the provided plaintext is already decrypted.
 
-2. **Private Key Hex String**: This method will directly import the private key from the hex string provided and encrypt it with the passphrase provided. This enables the passphrase to be different from the original as the provided plaintext is already decrypted.
+In order to import a key via a JSON file it must go through a decryption step before being re-encrypted for use in V1. This is because the V0 keys use a different cipher suite to secure the private key compared to V1.",app/client/keybase/README.md,2023-06-14 02:12:00+00:00,2023-06-14T02:21:40Z,"```suggestion
In order to import a key via an armoured JSON file, it must go through a decryption step before being re-encrypted for use in V1. This is because the V0 keys use a different cipher suite to secure the private key than V1.
```",,,,,49,RIGHT,14,,line,https://api.github.com/repos/pokt-network/pocket/pulls/780,pokt-network/pocket,2074a1b0c27ec2c73168b02852cc6145b657c0af
https://api.github.com/repos/pokt-network/pocket/pulls/780,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1228893116,Olshansk,e61c419746b10e6ef0bee8cf5146ba49fa240050,1a4293cbb757c030326439d66080f3fb09f5ab44,"@@ -49,13 +49,11 @@ flowchart LR
     subgraph S[scrypt lib]
         B[""key(salt, pass, ...)""]
     end
-    subgraph AES-GCM
+    subgraph SecretBox",shared/crypto/README.md,2023-06-14 02:18:27+00:00,2023-06-14T02:21:40Z,"Above the flowchart, can you add a sentence saying ""An example of a SecretBox is a cipher suite such as AES-GCM"". It'll provide a concrete example for new readers.",,,,54.0,52,RIGHT,5,23.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/780,pokt-network/pocket,2074a1b0c27ec2c73168b02852cc6145b657c0af
https://api.github.com/repos/pokt-network/pocket/pulls/771,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1198843002,h5law,7aa92313fd756058d605a1740435513846dd2ea5,12104a8f03130b750051681b57aeaec27aacc52d,"@@ -35,3 +35,26 @@ func (u *utilityModule) HandleTransaction(txProtoBytes []byte) error {
 	// Store the tx in the mempool
 	return u.mempool.AddTx(txProtoBytes)
 }
+
+// GetIndexedTransaction implements the exposed functionality of the shared utilityModule interface.
+func (u *utilityModule) GetIndexedTransaction(txProtoBytes []byte) (*coreTypes.IndexedTransaction, error) {",utility/transaction.go,2023-05-19 11:10:15+00:00,2023-05-19T11:10:15Z,🤌  Much nicer than having to pass the index into the hydrate function 👍🏼 ,,,,44.0,40,RIGHT,6,17.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/771,pokt-network/pocket,10a931a06f81902518a919ce33b9642f8388949c
https://api.github.com/repos/pokt-network/pocket/pulls/771,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1198845108,h5law,7aa92313fd756058d605a1740435513846dd2ea5,12104a8f03130b750051681b57aeaec27aacc52d,"@@ -135,9 +135,11 @@ func (uow *baseUtilityUnitOfWork) isProposalBlockSet() bool {
 	return uow.proposalStateHash != """" && uow.proposalProposerAddr != nil
 }
 
-// processTransactionsFromProposalBlock processes the transactions from the proposal block.
-// It also removes the transactions from the mempool if they are also present.
-func (uow *baseUtilityUnitOfWork) processTransactionsFromProposalBlock(txMempool mempool.TXMempool) (err error) {
+// processProposalBlockTransactions processes the transactions from the proposal block stored in the current
+// unit of work. It applies the transactions to the persistence context, indexes them, and removes that from
+// the mempool if they are present.
+func (uow *baseUtilityUnitOfWork) processProposalBlockTransactions(txMempool mempool.TXMempool) (err error) {
+	// CONSIDERATION: should we check that `uow.proposalBlockTxs` is not nil and return an error if so or allow empty blocks?",utility/unit_of_work/module.go,2023-05-19 11:12:59+00:00,2023-05-19T11:12:59Z,"IMO We should not allow an entirely empty block instead just push the block time back until we have some Txs to fill it (even partly in the case the network is really not being used at this time).

The only thought is this may affect auto pacemaker mode in Localnet?",,,,142.0,142,RIGHT,20,20.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/771,pokt-network/pocket,10a931a06f81902518a919ce33b9642f8388949c
https://api.github.com/repos/pokt-network/pocket/pulls/771,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1209934784,h5law,eda74276723ac0b0ff412bed31e9802e09bf6a51,12104a8f03130b750051681b57aeaec27aacc52d,"@@ -361,20 +361,14 @@ func (s *rpcServer) calculateMessageFeeForActor(actorType coreTypes.ActorType, m
 
 // txProtoBytesToRPCIdxTxs converts a slice of serialised Transaction protobufs to a slice of RPC IdxTxs
 func (s *rpcServer) txProtoBytesToRPCIdxTxs(txProtoBytes [][]byte) ([]IndexedTransaction, error) {
-	currentHeight := s.GetBus().GetConsensusModule().CurrentHeight()
-	uow, err := s.GetBus().GetUtilityModule().NewUnitOfWork(int64(currentHeight))
-	if err != nil {
-		return nil, err
-	}
-	defer uow.Release() //nolint:errcheck // We only need to make sure the UOW is released
-
+	utilityModule := s.GetBus().GetUtilityModule()
 	txs := make([]IndexedTransaction, 0)
-	for idx, txBz := range txProtoBytes {
+	for _, txBz := range txProtoBytes {
 		tx := new(coreTypes.Transaction)
 		if err := codec.GetCodec().Unmarshal(txBz, tx); err != nil {
 			return nil, err
 		}
-		idxTx, er := uow.HydrateIdxTx(tx, idx)
+		idxTx, er := utilityModule.GetIndexedTransaction(txBz)",rpc/utils.go,2023-05-30 08:40:57+00:00,2023-05-30T08:40:58Z,"```suggestion
		idxTx, er := s.GetBus().GetUtilityModule().GetIndexedTransaction(txBz)
```
Does this really need to stay in a variable anymore?",,,,,371,RIGHT,20,,line,https://api.github.com/repos/pokt-network/pocket/pulls/771,pokt-network/pocket,10a931a06f81902518a919ce33b9642f8388949c
https://api.github.com/repos/pokt-network/pocket/pulls/771,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1209947205,h5law,eda74276723ac0b0ff412bed31e9802e09bf6a51,12104a8f03130b750051681b57aeaec27aacc52d,"@@ -35,3 +37,30 @@ func (u *utilityModule) HandleTransaction(txProtoBytes []byte) error {
 	// Store the tx in the mempool
 	return u.mempool.AddTx(txProtoBytes)
 }
+
+// GetIndexedTransaction implements the exposed functionality of the shared utilityModule interface.
+func (u *utilityModule) GetIndexedTransaction(txProtoBytes []byte) (*coreTypes.IndexedTransaction, error) {",utility/transaction.go,2023-05-30 08:48:42+00:00,2023-05-30T08:48:43Z,I think it was a by-product of not being able to use the hash of the proto bytes that I originally used the hydrate function - now with the `TxIndexer` working on the same hash for both proto and indexed txs what is stopping us from using the txIndexer alone for this call?,,,,44.0,42,RIGHT,15,17.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/771,pokt-network/pocket,10a931a06f81902518a919ce33b9642f8388949c
https://api.github.com/repos/pokt-network/pocket/pulls/771,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1213540436,adshmh,ace8cd675467aebd83e06ac5320523c2ebf64f95,12104a8f03130b750051681b57aeaec27aacc52d,"@@ -596,10 +602,18 @@ func ErrEmptySignature() Error {
 	return NewError(CodeEmptySignatureError, EmptySignatureError)
 }
 
+func ErrEmptySignatureStructure() Error {
+	return NewError(CodeEmptySignatureStructureError, EmptySignatureStructureError)
+}
+
 func ErrSignatureVerificationFailed() Error {
 	return NewError(CodeSignatureVerificationFailedError, SignatureVerificationFailedError)
 }
 
+func ErrRetrievingSignableBytes(err error) Error {
+	return NewError(CodeRetrievingSignableBytesError, fmt.Sprintf(""%s: %s"", RetrievingSignableBytesError, err.Error()))",shared/core/types/error.go,2023-06-01 18:41:02+00:00,2023-06-01T18:52:06Z,Wrapping errors in general makes more sense IMO (although I understand it would not be very consistent with current codebase),,,,614.0,614,RIGHT,68,68.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/771,pokt-network/pocket,10a931a06f81902518a919ce33b9642f8388949c
https://api.github.com/repos/pokt-network/pocket/pulls/771,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1213542298,adshmh,ace8cd675467aebd83e06ac5320523c2ebf64f95,12104a8f03130b750051681b57aeaec27aacc52d,"@@ -35,3 +38,25 @@ func (u *utilityModule) HandleTransaction(txProtoBytes []byte) error {
 	// Store the tx in the mempool
 	return u.mempool.AddTx(txProtoBytes)
 }
+
+// GetIndexedTransaction implements the exposed functionality of the shared utilityModule interface.
+func (u *utilityModule) GetIndexedTransaction(txProtoBytes []byte) (*coreTypes.IndexedTransaction, error) {
+	txHash := coreTypes.TxHash(txProtoBytes)
+	persistenceModule := u.GetBus().GetPersistenceModule()",utility/transaction.go,2023-06-01 18:43:02+00:00,2023-06-01T18:52:06Z,NIT: moving this closer to the point of usage (or even skipping the declaration altogether) would improve readability.,,,,,45,RIGHT,18,,line,https://api.github.com/repos/pokt-network/pocket/pulls/771,pokt-network/pocket,10a931a06f81902518a919ce33b9642f8388949c
https://api.github.com/repos/pokt-network/pocket/pulls/771,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1213543178,adshmh,ace8cd675467aebd83e06ac5320523c2ebf64f95,12104a8f03130b750051681b57aeaec27aacc52d,"@@ -35,3 +38,25 @@ func (u *utilityModule) HandleTransaction(txProtoBytes []byte) error {
 	// Store the tx in the mempool
 	return u.mempool.AddTx(txProtoBytes)
 }
+
+// GetIndexedTransaction implements the exposed functionality of the shared utilityModule interface.
+func (u *utilityModule) GetIndexedTransaction(txProtoBytes []byte) (*coreTypes.IndexedTransaction, error) {
+	txHash := coreTypes.TxHash(txProtoBytes)
+	persistenceModule := u.GetBus().GetPersistenceModule()
+
+	// TECHDEBT: Note the inconsistency between referencing tx hash as a string vs. byte slice in different places. Need to pick
+	// one and consolidate throughout the codebase
+	hash, err := hex.DecodeString(txHash)
+	if err != nil {
+		return nil, err
+	}
+	idTx, err := persistenceModule.GetTxIndexer().GetByHash(hash)
+	if err != nil {
+		if err.Error() == kvstore.KeyNotFoundError {",utility/transaction.go,2023-06-01 18:44:05+00:00,2023-06-01T18:52:06Z,NIT: using `errors.Is` would be more flexible.,,,,,55,RIGHT,28,,line,https://api.github.com/repos/pokt-network/pocket/pulls/771,pokt-network/pocket,10a931a06f81902518a919ce33b9642f8388949c
https://api.github.com/repos/pokt-network/pocket/pulls/771,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1213706058,adshmh,e19c62d2679623f40f993ec636f4fe9848663cf6,12104a8f03130b750051681b57aeaec27aacc52d,"@@ -42,17 +44,17 @@ func (u *utilityModule) HandleTransaction(txProtoBytes []byte) error {
 // GetIndexedTransaction implements the exposed functionality of the shared utilityModule interface.
 func (u *utilityModule) GetIndexedTransaction(txProtoBytes []byte) (*coreTypes.IndexedTransaction, error) {
 	txHash := coreTypes.TxHash(txProtoBytes)
-	persistenceModule := u.GetBus().GetPersistenceModule()
 
 	// TECHDEBT: Note the inconsistency between referencing tx hash as a string vs. byte slice in different places. Need to pick
 	// one and consolidate throughout the codebase
 	hash, err := hex.DecodeString(txHash)
 	if err != nil {
 		return nil, err
 	}
-	idTx, err := persistenceModule.GetTxIndexer().GetByHash(hash)
+	idTx, err := u.GetBus().GetPersistenceModule().GetTxIndexer().GetByHash(hash)
 	if err != nil {
-		if err.Error() == kvstore.KeyNotFoundError {
+		fmt.Println(""OLSH"", err)",utility/transaction.go,2023-06-01 21:35:54+00:00,2023-06-01T21:36:17Z,Not sure we want to keep this line.,,,,,56,RIGHT,28,,line,https://api.github.com/repos/pokt-network/pocket/pulls/771,pokt-network/pocket,10a931a06f81902518a919ce33b9642f8388949c
https://api.github.com/repos/pokt-network/pocket/pulls/774,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1201183806,h5law,d84ae17982f96b8f8d6d885e3c9162e94f971223,cc752d7f1a723dcb29becec897084c49ed48e9ea,"@@ -6,13 +6,19 @@ import (
 	""fmt""
 
 	""github.com/pokt-network/pocket/persistence/kvstore""
+	""github.com/pokt-network/pocket/shared/codec""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/utils""
 )
 
 // BlockStore is a key-value store that maps block heights to serialized
 // block structures.
 // * It manages the atomic state transitions for applying a Unit of Work.
 type BlockStore interface {
-	kvstore.KVStore
+	kvstore.KVStore // TODO_IN_THIS_COMMIT remove this eventually and expose only the two below
+
+	GetBlock(height uint64) (*coreTypes.Block, error)
+	StoreBlock(height uint64, block *coreTypes.Block) error",persistence/blockstore/block_store.go,2023-05-22 21:40:37+00:00,2023-05-22T21:40:37Z,🔥 So much cleaner this way,,,,21.0,21,RIGHT,17,16.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/774,pokt-network/pocket,f8da548afee08f8416d107fb7aaa474d1ad41ade
https://api.github.com/repos/pokt-network/pocket/pulls/774,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1202653079,h5law,6855c3bec01e349c9d759040cfd51e0b7fd180bc,cc752d7f1a723dcb29becec897084c49ed48e9ea,"@@ -7,6 +7,10 @@ and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0
 
 ## [Unreleased]
 
+## [0.0.0.19] - 2023-05-23
+
+- Updates rpc tests to use updated BlockStore mocks",rpc/doc/CHANGELOG.md,2023-05-23 16:20:38+00:00,2023-05-23T16:20:39Z,NIT: I don't think this is what you did for the RPC module but instead the persistence state tests? In rpc you updated the actual RPC handler logic not tests.,,,,,12,RIGHT,6,,line,https://api.github.com/repos/pokt-network/pocket/pulls/774,pokt-network/pocket,f8da548afee08f8416d107fb7aaa474d1ad41ade
https://api.github.com/repos/pokt-network/pocket/pulls/774,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1203354358,Olshansk,97900b0ddb8c103b553fc27d98340ad431057a0d,cc752d7f1a723dcb29becec897084c49ed48e9ea,"@@ -375,37 +374,73 @@ func basePersistenceMock(t *testing.T, _ modules.EventsChannel, bus modules.Bus)
 
 	blockStoreMock := persistenceMocks.NewMockBlockStore(ctrl)
 
-	blockStoreMock.EXPECT().Get(gomock.Any()).DoAndReturn(func(height []byte) ([]byte, error) {
-		heightInt := utils.HeightFromBytes(height)
-		if bus.GetConsensusModule().CurrentHeight() < heightInt {
-			return nil, fmt.Errorf(""requested height is higher than current height of the node's consensus module"")
-		}
-		blockWithHeight := &coreTypes.Block{
-			BlockHeader: &coreTypes.BlockHeader{
-				Height: utils.HeightFromBytes(height),
-			},
-		}
-		return codec.GetCodec().Marshal(blockWithHeight)
-	}).AnyTimes()
+	blockStoreMock.
+		EXPECT().
+		StoreBlock(gomock.Any(), gomock.Any()).
+		DoAndReturn(func(height []byte, block *coreTypes.Block) error {
+			return nil
+		}).",consensus/e2e_tests/utils_test.go,2023-05-24 03:15:24+00:00,2023-05-24T03:27:25Z,"Optional NIT: if there's nothing you actually want to do, I think you might be able to get away with just `Return(nil)`. Not 100% sure thought so you'd need to double check.",380.0,380.0,RIGHT,382.0,382,RIGHT,29,29.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/774,pokt-network/pocket,f8da548afee08f8416d107fb7aaa474d1ad41ade
https://api.github.com/repos/pokt-network/pocket/pulls/774,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1203354857,Olshansk,97900b0ddb8c103b553fc27d98340ad431057a0d,cc752d7f1a723dcb29becec897084c49ed48e9ea,"@@ -375,37 +374,73 @@ func basePersistenceMock(t *testing.T, _ modules.EventsChannel, bus modules.Bus)
 
 	blockStoreMock := persistenceMocks.NewMockBlockStore(ctrl)
 
-	blockStoreMock.EXPECT().Get(gomock.Any()).DoAndReturn(func(height []byte) ([]byte, error) {
-		heightInt := utils.HeightFromBytes(height)
-		if bus.GetConsensusModule().CurrentHeight() < heightInt {
-			return nil, fmt.Errorf(""requested height is higher than current height of the node's consensus module"")
-		}
-		blockWithHeight := &coreTypes.Block{
-			BlockHeader: &coreTypes.BlockHeader{
-				Height: utils.HeightFromBytes(height),
-			},
-		}
-		return codec.GetCodec().Marshal(blockWithHeight)
-	}).AnyTimes()
+	blockStoreMock.
+		EXPECT().
+		StoreBlock(gomock.Any(), gomock.Any()).
+		DoAndReturn(func(height []byte, block *coreTypes.Block) error {
+			return nil
+		}).
+		AnyTimes()
 
-	persistenceMock.EXPECT().GetBlockStore().Return(blockStoreMock).AnyTimes()
+	blockStoreMock.",consensus/e2e_tests/utils_test.go,2023-05-24 03:16:03+00:00,2023-05-24T03:27:25Z,"```suggestion
	// NB: The business logic in this mock and below is vital for testing state-sync end-to-end
	blockStoreMock.
```",,,,385.0,385,RIGHT,33,33.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/774,pokt-network/pocket,f8da548afee08f8416d107fb7aaa474d1ad41ade
https://api.github.com/repos/pokt-network/pocket/pulls/774,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1203356635,Olshansk,97900b0ddb8c103b553fc27d98340ad431057a0d,cc752d7f1a723dcb29becec897084c49ed48e9ea,"@@ -72,8 +69,10 @@ func (m *stateSync) HandleGetBlockRequest(blockReq *typesCons.GetBlockRequest) e
 	}
 
 	// get block from the persistence module
-	block, err := m.getBlockAtHeight(blockReq.Height)
+	blockStore := m.GetBus().GetPersistenceModule().GetBlockStore()
+	block, err := blockStore.GetBlock(blockReq.Height)
 	if err != nil {
+		m.logger.Error().Err(typesCons.ErrConsensusMempoolFull).Msg(typesCons.DisregardHotstuffMessage)",consensus/state_sync/server.go,2023-05-24 03:18:26+00:00,2023-05-24T03:27:25Z,Why are we logging a `ErrConsensusMempoolFull` error here?,,,,,75,RIGHT,19,,line,https://api.github.com/repos/pokt-network/pocket/pulls/774,pokt-network/pocket,f8da548afee08f8416d107fb7aaa474d1ad41ade
https://api.github.com/repos/pokt-network/pocket/pulls/774,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1203357946,Olshansk,97900b0ddb8c103b553fc27d98340ad431057a0d,cc752d7f1a723dcb29becec897084c49ed48e9ea,"@@ -43,6 +49,31 @@ func NewBlockStore(path string) (BlockStore, error) {
 	}, nil
 }
 
+// StoreBlock takes a coreType Block and stores it.",persistence/blockstore/block_store.go,2023-05-24 03:20:09+00:00,2023-05-24T03:27:25Z,"```suggestion
// StoreBlock accepts a coreType Block and stores it for the given height.
```",,,,,52,RIGHT,24,,line,https://api.github.com/repos/pokt-network/pocket/pulls/774,pokt-network/pocket,f8da548afee08f8416d107fb7aaa474d1ad41ade
https://api.github.com/repos/pokt-network/pocket/pulls/774,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1203358889,Olshansk,97900b0ddb8c103b553fc27d98340ad431057a0d,cc752d7f1a723dcb29becec897084c49ed48e9ea,"@@ -43,6 +49,31 @@ func NewBlockStore(path string) (BlockStore, error) {
 	}, nil
 }
 
+// StoreBlock takes a coreType Block and stores it.
+func (bs *blockStore) StoreBlock(height uint64, block *coreTypes.Block) error {
+	b, err := codec.GetCodec().Marshal(block)
+	if err != nil {
+		return err
+	}
+	// TECHDEBT add a proper logger to blockstore
+	// bs.logger.Info().Uint64(""height"", block.BlockHeader.Height).Msg(""Storing block in block store"")
+	return bs.kv.Set(utils.HeightToBytes(height), b)
+}
+
+// GetBlock returns a coreTypes Block at the given height.
+func (bs *blockStore) GetBlock(height uint64) (*coreTypes.Block, error) {
+	var block coreTypes.Block",persistence/blockstore/block_store.go,2023-05-24 03:21:39+00:00,2023-05-24T03:27:25Z,NIT: Either move this above the line where we first use it or use named return types.,,,,,65,RIGHT,37,,line,https://api.github.com/repos/pokt-network/pocket/pulls/774,pokt-network/pocket,f8da548afee08f8416d107fb7aaa474d1ad41ade
https://api.github.com/repos/pokt-network/pocket/pulls/774,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1203359097,Olshansk,97900b0ddb8c103b553fc27d98340ad431057a0d,cc752d7f1a723dcb29becec897084c49ed48e9ea,"@@ -43,6 +49,31 @@ func NewBlockStore(path string) (BlockStore, error) {
 	}, nil
 }
 
+// StoreBlock takes a coreType Block and stores it.
+func (bs *blockStore) StoreBlock(height uint64, block *coreTypes.Block) error {
+	b, err := codec.GetCodec().Marshal(block)
+	if err != nil {
+		return err
+	}
+	// TECHDEBT add a proper logger to blockstore
+	// bs.logger.Info().Uint64(""height"", block.BlockHeader.Height).Msg(""Storing block in block store"")
+	return bs.kv.Set(utils.HeightToBytes(height), b)
+}
+
+// GetBlock returns a coreTypes Block at the given height.
+func (bs *blockStore) GetBlock(height uint64) (*coreTypes.Block, error) {
+	var block coreTypes.Block
+	blockBytes, err := bs.kv.Get(utils.HeightToBytes(height))
+	if err != nil {
+		return nil, err
+	}
+	err = codec.GetCodec().Unmarshal(blockBytes, &block)
+	if err != nil {",persistence/blockstore/block_store.go,2023-05-24 03:21:53+00:00,2023-05-24T03:27:25Z,NIT: Single line,,70.0,RIGHT,,71,RIGHT,43,,line,https://api.github.com/repos/pokt-network/pocket/pulls/774,pokt-network/pocket,f8da548afee08f8416d107fb7aaa474d1ad41ade
https://api.github.com/repos/pokt-network/pocket/pulls/773,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1199515641,Olshansk,14ec7e08241505da679c5cb1694cf220eda66817,890173b5d1c8027a434cbbb80cc32eddcfe5a8d1,"@@ -0,0 +1,121 @@
+# Table of Contents <!-- omit in toc -->",docs/development/CODE_REVIEW_GUIDELINES.md,2023-05-20 01:11:11+00:00,2023-05-23T22:43:52Z,Let's give the document it's own title,,,,,1,RIGHT,1,,line,https://api.github.com/repos/pokt-network/pocket/pulls/773,pokt-network/pocket,9e66e8a9b7330012979eaed3c8b7a998de198167
https://api.github.com/repos/pokt-network/pocket/pulls/773,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1199517531,Olshansk,14ec7e08241505da679c5cb1694cf220eda66817,890173b5d1c8027a434cbbb80cc32eddcfe5a8d1,"@@ -0,0 +1,121 @@
+# Table of Contents <!-- omit in toc -->
+
+- [Code Quality](#code-quality)
+- [Code Reviews](#code-reviews)
+- [Code Review Guidelines](#code-review-guidelines)
+    - [Expectations](#expectations)
+- [Best Practices](#best-practices)
+    - [Reviewing](#reviewing)
+    - [Starting a Review](#starting-a-review)
+    - [Finishing a Review](#finishing-a-review)
+    - [Merging](#merging)
+
+# Code Quality
+
+""Code Quality"" can be a vague concept, as it usually addresses what is more the ""art"" side (vs. the ""science"" side) of software development.
+There are often several *technically correct* ways to address a problem -- that is, the correct answer or behavior is produced.
+Selecting the ""*best*"" solution is often a matter of style.
+Sometimes the best solution is one that fits the surrounding code in the most cohesive way.
+Terms like ""maintainability"" or ""readability"" are used; these address the ability of other contributors to understand and improve the code.
+
+Unlike correctness or performance concepts, there's no single metric or mathematical solution that can be optimized to achieve better code quality.
+Thus, we rely on human judgement.
+
+In this document, we outline a framework to guide that human judgement towards -- collectively -- ""better code"".
+
+For decades, the IETF (Internet Engineering Task Force) has used the motto ""rough consensus and running code"".",docs/development/CODE_REVIEW_GUIDELINES.md,2023-05-20 01:26:45+00:00,2023-05-23T22:43:52Z,"Cool, TIL some stuff!",,,,,26,RIGHT,26,,line,https://api.github.com/repos/pokt-network/pocket/pulls/773,pokt-network/pocket,9e66e8a9b7330012979eaed3c8b7a998de198167
https://api.github.com/repos/pokt-network/pocket/pulls/773,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1199517538,Olshansk,14ec7e08241505da679c5cb1694cf220eda66817,890173b5d1c8027a434cbbb80cc32eddcfe5a8d1,"@@ -0,0 +1,121 @@
+# Table of Contents <!-- omit in toc -->
+
+- [Code Quality](#code-quality)
+- [Code Reviews](#code-reviews)
+- [Code Review Guidelines](#code-review-guidelines)
+    - [Expectations](#expectations)
+- [Best Practices](#best-practices)
+    - [Reviewing](#reviewing)
+    - [Starting a Review](#starting-a-review)
+    - [Finishing a Review](#finishing-a-review)
+    - [Merging](#merging)
+
+# Code Quality",docs/development/CODE_REVIEW_GUIDELINES.md,2023-05-20 01:26:46+00:00,2023-05-23T22:43:52Z,All the other subsections would need to have an extra `#` after there's a title,,,,,13,RIGHT,13,,line,https://api.github.com/repos/pokt-network/pocket/pulls/773,pokt-network/pocket,9e66e8a9b7330012979eaed3c8b7a998de198167
https://api.github.com/repos/pokt-network/pocket/pulls/773,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1203104336,Olshansk,14ec7e08241505da679c5cb1694cf220eda66817,890173b5d1c8027a434cbbb80cc32eddcfe5a8d1,"@@ -0,0 +1,121 @@
+# Table of Contents <!-- omit in toc -->
+
+- [Code Quality](#code-quality)
+- [Code Reviews](#code-reviews)
+- [Code Review Guidelines](#code-review-guidelines)
+    - [Expectations](#expectations)
+- [Best Practices](#best-practices)
+    - [Reviewing](#reviewing)
+    - [Starting a Review](#starting-a-review)
+    - [Finishing a Review](#finishing-a-review)
+    - [Merging](#merging)
+
+# Code Quality
+
+""Code Quality"" can be a vague concept, as it usually addresses what is more the ""art"" side (vs. the ""science"" side) of software development.
+There are often several *technically correct* ways to address a problem -- that is, the correct answer or behavior is produced.
+Selecting the ""*best*"" solution is often a matter of style.
+Sometimes the best solution is one that fits the surrounding code in the most cohesive way.
+Terms like ""maintainability"" or ""readability"" are used; these address the ability of other contributors to understand and improve the code.
+
+Unlike correctness or performance concepts, there's no single metric or mathematical solution that can be optimized to achieve better code quality.
+Thus, we rely on human judgement.
+
+In this document, we outline a framework to guide that human judgement towards -- collectively -- ""better code"".
+
+For decades, the IETF (Internet Engineering Task Force) has used the motto ""rough consensus and running code"".
+This motto encapsulates (""running code"") that developers' core output is still software: if there is no code that runs and produces correct results, we have nothing.
+It also encapsulates (""rough consensus"") that we may not always precisely agree and that's okay.
+
+## Code Reviews
+
+One tactic often employed to produce ""maintainable"" or ""more-readable"" code is a ""code review"".
+These can take many shapes and forms and often have goals beyond simply ""code quality"".
+
+Broadly speaking, code reviews involve developers looking at some proposed new code (or code changes).
+This is *usually* developers other than the author (although a ""self-review"" can also be employed).
+In many projects, such attention is a scarce commodity: most programmers would rather write code than read someone else's.",docs/development/CODE_REVIEW_GUIDELINES.md,2023-05-23 22:34:08+00:00,2023-05-23T22:43:52Z,"Writing code is the ""easy & fun"" thing to do ;)",,,,,37,RIGHT,37,,line,https://api.github.com/repos/pokt-network/pocket/pulls/773,pokt-network/pocket,9e66e8a9b7330012979eaed3c8b7a998de198167
https://api.github.com/repos/pokt-network/pocket/pulls/773,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1203104782,Olshansk,14ec7e08241505da679c5cb1694cf220eda66817,890173b5d1c8027a434cbbb80cc32eddcfe5a8d1,"@@ -0,0 +1,121 @@
+# Table of Contents <!-- omit in toc -->
+
+- [Code Quality](#code-quality)
+- [Code Reviews](#code-reviews)
+- [Code Review Guidelines](#code-review-guidelines)
+    - [Expectations](#expectations)
+- [Best Practices](#best-practices)
+    - [Reviewing](#reviewing)
+    - [Starting a Review](#starting-a-review)
+    - [Finishing a Review](#finishing-a-review)
+    - [Merging](#merging)
+
+# Code Quality
+
+""Code Quality"" can be a vague concept, as it usually addresses what is more the ""art"" side (vs. the ""science"" side) of software development.
+There are often several *technically correct* ways to address a problem -- that is, the correct answer or behavior is produced.
+Selecting the ""*best*"" solution is often a matter of style.
+Sometimes the best solution is one that fits the surrounding code in the most cohesive way.
+Terms like ""maintainability"" or ""readability"" are used; these address the ability of other contributors to understand and improve the code.
+
+Unlike correctness or performance concepts, there's no single metric or mathematical solution that can be optimized to achieve better code quality.
+Thus, we rely on human judgement.
+
+In this document, we outline a framework to guide that human judgement towards -- collectively -- ""better code"".
+
+For decades, the IETF (Internet Engineering Task Force) has used the motto ""rough consensus and running code"".
+This motto encapsulates (""running code"") that developers' core output is still software: if there is no code that runs and produces correct results, we have nothing.
+It also encapsulates (""rough consensus"") that we may not always precisely agree and that's okay.
+
+## Code Reviews
+
+One tactic often employed to produce ""maintainable"" or ""more-readable"" code is a ""code review"".
+These can take many shapes and forms and often have goals beyond simply ""code quality"".
+
+Broadly speaking, code reviews involve developers looking at some proposed new code (or code changes).
+This is *usually* developers other than the author (although a ""self-review"" can also be employed).
+In many projects, such attention is a scarce commodity: most programmers would rather write code than read someone else's.
+
+## Code Review Guidelines
+
+All participants must adhere to the overall idea that the review is an attempt to achieve ""better"" code.
+This is a vague statement on purpose.
+Participants must be cautious in their criticism and generous with praise.",docs/development/CODE_REVIEW_GUIDELINES.md,2023-05-23 22:34:40+00:00,2023-05-23T22:43:52Z,Thanks Bryan!,,,,49.0,43,RIGHT,43,49.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/773,pokt-network/pocket,9e66e8a9b7330012979eaed3c8b7a998de198167
https://api.github.com/repos/pokt-network/pocket/pulls/773,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1203106699,Olshansk,14ec7e08241505da679c5cb1694cf220eda66817,890173b5d1c8027a434cbbb80cc32eddcfe5a8d1,"@@ -0,0 +1,121 @@
+# Table of Contents <!-- omit in toc -->
+
+- [Code Quality](#code-quality)
+- [Code Reviews](#code-reviews)
+- [Code Review Guidelines](#code-review-guidelines)
+    - [Expectations](#expectations)
+- [Best Practices](#best-practices)
+    - [Reviewing](#reviewing)
+    - [Starting a Review](#starting-a-review)
+    - [Finishing a Review](#finishing-a-review)
+    - [Merging](#merging)
+
+# Code Quality
+
+""Code Quality"" can be a vague concept, as it usually addresses what is more the ""art"" side (vs. the ""science"" side) of software development.
+There are often several *technically correct* ways to address a problem -- that is, the correct answer or behavior is produced.
+Selecting the ""*best*"" solution is often a matter of style.
+Sometimes the best solution is one that fits the surrounding code in the most cohesive way.
+Terms like ""maintainability"" or ""readability"" are used; these address the ability of other contributors to understand and improve the code.
+
+Unlike correctness or performance concepts, there's no single metric or mathematical solution that can be optimized to achieve better code quality.
+Thus, we rely on human judgement.
+
+In this document, we outline a framework to guide that human judgement towards -- collectively -- ""better code"".
+
+For decades, the IETF (Internet Engineering Task Force) has used the motto ""rough consensus and running code"".
+This motto encapsulates (""running code"") that developers' core output is still software: if there is no code that runs and produces correct results, we have nothing.
+It also encapsulates (""rough consensus"") that we may not always precisely agree and that's okay.
+
+## Code Reviews
+
+One tactic often employed to produce ""maintainable"" or ""more-readable"" code is a ""code review"".
+These can take many shapes and forms and often have goals beyond simply ""code quality"".
+
+Broadly speaking, code reviews involve developers looking at some proposed new code (or code changes).
+This is *usually* developers other than the author (although a ""self-review"" can also be employed).
+In many projects, such attention is a scarce commodity: most programmers would rather write code than read someone else's.
+
+## Code Review Guidelines
+
+All participants must adhere to the overall idea that the review is an attempt to achieve ""better"" code.
+This is a vague statement on purpose.
+Participants must be cautious in their criticism and generous with praise.
+Participants must remember the scarcity of another developer's attention.
+
+### Expectations
+
+**Pull Request Authors:**
+The author is responsible for tracking up-to-date next actions for a Pull Request to progress towards being merged.
+
+**Reviewers:**
+Reviewers should prefer engaging in code review over starting new work (i.e. taking planned work items that haven't been started yet).
+
+Reviewers (and prospective reviewers) are encouraged to engage in reviews of codebases outside the projects and technologies they use on a day-to-day basis (but not expected to provide an approving review).
+
+## Best Practices
+
+### Reviewing
+
+### Starting a Review
+
+Consider if it could be broken into smaller Pull Requests. If it is clear that it can be, summarize your thinking on how in your Review.
+
+If the commits be (re)organized (i.e. reordered and/or amended) such that there is a commit at which the tests are passing prior to the conclusion of the main change, that's a signal that there's likely a logic split which can be made at that point in such a (re)arrangement.
+
+Use the following guidelines to evaluate whether a Pull Request should be approved:
+
+- *Every* Pull Request should have tests or justification otherwise; esp. bug fixes.
+- *Every* Pull Request should have at least 1 approval from a team member internal or external to the project. Exceptions made by repository maintainer(s), as necessary, on a case-by-case basis.
+
+During review, submit feedback using line comments (A); prefer ""Add\[ing a\] single comment"" over ""Start[ing] a review"" (B).
+
+*(Once a review has been started, the option to add single comments is removed. Preferring single comments allows feedback to happen even in the event of an interrupted review.)*",docs/development/CODE_REVIEW_GUIDELINES.md,2023-05-23 22:37:06+00:00,2023-05-23T22:43:52Z,"I personally prefer Starting reviews because I often go back and edit/remove comments if my question/comment was addressed elsewhere.

Is this what you found yourself doing recently?",,,,,73,RIGHT,73,,line,https://api.github.com/repos/pokt-network/pocket/pulls/773,pokt-network/pocket,9e66e8a9b7330012979eaed3c8b7a998de198167
https://api.github.com/repos/pokt-network/pocket/pulls/773,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1203108685,Olshansk,14ec7e08241505da679c5cb1694cf220eda66817,890173b5d1c8027a434cbbb80cc32eddcfe5a8d1,"@@ -0,0 +1,121 @@
+# Table of Contents <!-- omit in toc -->
+
+- [Code Quality](#code-quality)
+- [Code Reviews](#code-reviews)
+- [Code Review Guidelines](#code-review-guidelines)
+    - [Expectations](#expectations)
+- [Best Practices](#best-practices)
+    - [Reviewing](#reviewing)
+    - [Starting a Review](#starting-a-review)
+    - [Finishing a Review](#finishing-a-review)
+    - [Merging](#merging)
+
+# Code Quality
+
+""Code Quality"" can be a vague concept, as it usually addresses what is more the ""art"" side (vs. the ""science"" side) of software development.
+There are often several *technically correct* ways to address a problem -- that is, the correct answer or behavior is produced.
+Selecting the ""*best*"" solution is often a matter of style.
+Sometimes the best solution is one that fits the surrounding code in the most cohesive way.
+Terms like ""maintainability"" or ""readability"" are used; these address the ability of other contributors to understand and improve the code.
+
+Unlike correctness or performance concepts, there's no single metric or mathematical solution that can be optimized to achieve better code quality.
+Thus, we rely on human judgement.
+
+In this document, we outline a framework to guide that human judgement towards -- collectively -- ""better code"".
+
+For decades, the IETF (Internet Engineering Task Force) has used the motto ""rough consensus and running code"".
+This motto encapsulates (""running code"") that developers' core output is still software: if there is no code that runs and produces correct results, we have nothing.
+It also encapsulates (""rough consensus"") that we may not always precisely agree and that's okay.
+
+## Code Reviews
+
+One tactic often employed to produce ""maintainable"" or ""more-readable"" code is a ""code review"".
+These can take many shapes and forms and often have goals beyond simply ""code quality"".
+
+Broadly speaking, code reviews involve developers looking at some proposed new code (or code changes).
+This is *usually* developers other than the author (although a ""self-review"" can also be employed).
+In many projects, such attention is a scarce commodity: most programmers would rather write code than read someone else's.
+
+## Code Review Guidelines
+
+All participants must adhere to the overall idea that the review is an attempt to achieve ""better"" code.
+This is a vague statement on purpose.
+Participants must be cautious in their criticism and generous with praise.
+Participants must remember the scarcity of another developer's attention.
+
+### Expectations
+
+**Pull Request Authors:**
+The author is responsible for tracking up-to-date next actions for a Pull Request to progress towards being merged.
+
+**Reviewers:**
+Reviewers should prefer engaging in code review over starting new work (i.e. taking planned work items that haven't been started yet).
+
+Reviewers (and prospective reviewers) are encouraged to engage in reviews of codebases outside the projects and technologies they use on a day-to-day basis (but not expected to provide an approving review).
+
+## Best Practices
+
+### Reviewing
+
+### Starting a Review
+
+Consider if it could be broken into smaller Pull Requests. If it is clear that it can be, summarize your thinking on how in your Review.
+
+If the commits be (re)organized (i.e. reordered and/or amended) such that there is a commit at which the tests are passing prior to the conclusion of the main change, that's a signal that there's likely a logic split which can be made at that point in such a (re)arrangement.
+
+Use the following guidelines to evaluate whether a Pull Request should be approved:
+
+- *Every* Pull Request should have tests or justification otherwise; esp. bug fixes.
+- *Every* Pull Request should have at least 1 approval from a team member internal or external to the project. Exceptions made by repository maintainer(s), as necessary, on a case-by-case basis.
+
+During review, submit feedback using line comments (A); prefer ""Add\[ing a\] single comment"" over ""Start[ing] a review"" (B).
+
+*(Once a review has been started, the option to add single comments is removed. Preferring single comments allows feedback to happen even in the event of an interrupted review.)*
+
+### A",docs/development/CODE_REVIEW_GUIDELINES.md,2023-05-23 22:38:57+00:00,2023-05-23T22:43:52Z,These A-B-C section headers (which are not in the ToC) are a bit confusing. What is the intention here?,,,,,75,RIGHT,75,,line,https://api.github.com/repos/pokt-network/pocket/pulls/773,pokt-network/pocket,9e66e8a9b7330012979eaed3c8b7a998de198167
https://api.github.com/repos/pokt-network/pocket/pulls/773,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1203109443,Olshansk,14ec7e08241505da679c5cb1694cf220eda66817,890173b5d1c8027a434cbbb80cc32eddcfe5a8d1,"@@ -0,0 +1,121 @@
+# Table of Contents <!-- omit in toc -->
+
+- [Code Quality](#code-quality)
+- [Code Reviews](#code-reviews)
+- [Code Review Guidelines](#code-review-guidelines)
+    - [Expectations](#expectations)
+- [Best Practices](#best-practices)
+    - [Reviewing](#reviewing)
+    - [Starting a Review](#starting-a-review)
+    - [Finishing a Review](#finishing-a-review)
+    - [Merging](#merging)
+
+# Code Quality
+
+""Code Quality"" can be a vague concept, as it usually addresses what is more the ""art"" side (vs. the ""science"" side) of software development.
+There are often several *technically correct* ways to address a problem -- that is, the correct answer or behavior is produced.
+Selecting the ""*best*"" solution is often a matter of style.
+Sometimes the best solution is one that fits the surrounding code in the most cohesive way.
+Terms like ""maintainability"" or ""readability"" are used; these address the ability of other contributors to understand and improve the code.
+
+Unlike correctness or performance concepts, there's no single metric or mathematical solution that can be optimized to achieve better code quality.
+Thus, we rely on human judgement.
+
+In this document, we outline a framework to guide that human judgement towards -- collectively -- ""better code"".
+
+For decades, the IETF (Internet Engineering Task Force) has used the motto ""rough consensus and running code"".
+This motto encapsulates (""running code"") that developers' core output is still software: if there is no code that runs and produces correct results, we have nothing.
+It also encapsulates (""rough consensus"") that we may not always precisely agree and that's okay.
+
+## Code Reviews
+
+One tactic often employed to produce ""maintainable"" or ""more-readable"" code is a ""code review"".
+These can take many shapes and forms and often have goals beyond simply ""code quality"".
+
+Broadly speaking, code reviews involve developers looking at some proposed new code (or code changes).
+This is *usually* developers other than the author (although a ""self-review"" can also be employed).
+In many projects, such attention is a scarce commodity: most programmers would rather write code than read someone else's.
+
+## Code Review Guidelines
+
+All participants must adhere to the overall idea that the review is an attempt to achieve ""better"" code.
+This is a vague statement on purpose.
+Participants must be cautious in their criticism and generous with praise.
+Participants must remember the scarcity of another developer's attention.
+
+### Expectations
+
+**Pull Request Authors:**
+The author is responsible for tracking up-to-date next actions for a Pull Request to progress towards being merged.
+
+**Reviewers:**
+Reviewers should prefer engaging in code review over starting new work (i.e. taking planned work items that haven't been started yet).
+
+Reviewers (and prospective reviewers) are encouraged to engage in reviews of codebases outside the projects and technologies they use on a day-to-day basis (but not expected to provide an approving review).
+
+## Best Practices
+
+### Reviewing
+
+### Starting a Review
+
+Consider if it could be broken into smaller Pull Requests. If it is clear that it can be, summarize your thinking on how in your Review.
+
+If the commits be (re)organized (i.e. reordered and/or amended) such that there is a commit at which the tests are passing prior to the conclusion of the main change, that's a signal that there's likely a logic split which can be made at that point in such a (re)arrangement.
+
+Use the following guidelines to evaluate whether a Pull Request should be approved:
+
+- *Every* Pull Request should have tests or justification otherwise; esp. bug fixes.
+- *Every* Pull Request should have at least 1 approval from a team member internal or external to the project. Exceptions made by repository maintainer(s), as necessary, on a case-by-case basis.
+
+During review, submit feedback using line comments (A); prefer ""Add\[ing a\] single comment"" over ""Start[ing] a review"" (B).
+
+*(Once a review has been started, the option to add single comments is removed. Preferring single comments allows feedback to happen even in the event of an interrupted review.)*
+
+### A
+
+![github_line_comment.png](./assets/github_line_comment.png)
+
+### B
+
+![line_comment_dialog_start.png](./assets/line_comment_dialog_start.png)
+
+**Referencing Issues Across Repositories:**",docs/development/CODE_REVIEW_GUIDELINES.md,2023-05-23 22:39:49+00:00,2023-05-23T22:43:52Z,Can you add a section on referencing issues/PRs from the same repository using simply `#issue`?,,,,,83,RIGHT,83,,line,https://api.github.com/repos/pokt-network/pocket/pulls/773,pokt-network/pocket,9e66e8a9b7330012979eaed3c8b7a998de198167
https://api.github.com/repos/pokt-network/pocket/pulls/773,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1203111273,Olshansk,14ec7e08241505da679c5cb1694cf220eda66817,890173b5d1c8027a434cbbb80cc32eddcfe5a8d1,"@@ -0,0 +1,121 @@
+# Table of Contents <!-- omit in toc -->
+
+- [Code Quality](#code-quality)
+- [Code Reviews](#code-reviews)
+- [Code Review Guidelines](#code-review-guidelines)
+    - [Expectations](#expectations)
+- [Best Practices](#best-practices)
+    - [Reviewing](#reviewing)
+    - [Starting a Review](#starting-a-review)
+    - [Finishing a Review](#finishing-a-review)
+    - [Merging](#merging)
+
+# Code Quality
+
+""Code Quality"" can be a vague concept, as it usually addresses what is more the ""art"" side (vs. the ""science"" side) of software development.
+There are often several *technically correct* ways to address a problem -- that is, the correct answer or behavior is produced.
+Selecting the ""*best*"" solution is often a matter of style.
+Sometimes the best solution is one that fits the surrounding code in the most cohesive way.
+Terms like ""maintainability"" or ""readability"" are used; these address the ability of other contributors to understand and improve the code.
+
+Unlike correctness or performance concepts, there's no single metric or mathematical solution that can be optimized to achieve better code quality.
+Thus, we rely on human judgement.
+
+In this document, we outline a framework to guide that human judgement towards -- collectively -- ""better code"".
+
+For decades, the IETF (Internet Engineering Task Force) has used the motto ""rough consensus and running code"".
+This motto encapsulates (""running code"") that developers' core output is still software: if there is no code that runs and produces correct results, we have nothing.
+It also encapsulates (""rough consensus"") that we may not always precisely agree and that's okay.
+
+## Code Reviews
+
+One tactic often employed to produce ""maintainable"" or ""more-readable"" code is a ""code review"".
+These can take many shapes and forms and often have goals beyond simply ""code quality"".
+
+Broadly speaking, code reviews involve developers looking at some proposed new code (or code changes).
+This is *usually* developers other than the author (although a ""self-review"" can also be employed).
+In many projects, such attention is a scarce commodity: most programmers would rather write code than read someone else's.
+
+## Code Review Guidelines
+
+All participants must adhere to the overall idea that the review is an attempt to achieve ""better"" code.
+This is a vague statement on purpose.
+Participants must be cautious in their criticism and generous with praise.
+Participants must remember the scarcity of another developer's attention.
+
+### Expectations
+
+**Pull Request Authors:**
+The author is responsible for tracking up-to-date next actions for a Pull Request to progress towards being merged.
+
+**Reviewers:**
+Reviewers should prefer engaging in code review over starting new work (i.e. taking planned work items that haven't been started yet).
+
+Reviewers (and prospective reviewers) are encouraged to engage in reviews of codebases outside the projects and technologies they use on a day-to-day basis (but not expected to provide an approving review).
+
+## Best Practices
+
+### Reviewing
+
+### Starting a Review
+
+Consider if it could be broken into smaller Pull Requests. If it is clear that it can be, summarize your thinking on how in your Review.
+
+If the commits be (re)organized (i.e. reordered and/or amended) such that there is a commit at which the tests are passing prior to the conclusion of the main change, that's a signal that there's likely a logic split which can be made at that point in such a (re)arrangement.
+
+Use the following guidelines to evaluate whether a Pull Request should be approved:
+
+- *Every* Pull Request should have tests or justification otherwise; esp. bug fixes.
+- *Every* Pull Request should have at least 1 approval from a team member internal or external to the project. Exceptions made by repository maintainer(s), as necessary, on a case-by-case basis.
+
+During review, submit feedback using line comments (A); prefer ""Add\[ing a\] single comment"" over ""Start[ing] a review"" (B).
+
+*(Once a review has been started, the option to add single comments is removed. Preferring single comments allows feedback to happen even in the event of an interrupted review.)*
+
+### A
+
+![github_line_comment.png](./assets/github_line_comment.png)
+
+### B
+
+![line_comment_dialog_start.png](./assets/line_comment_dialog_start.png)
+
+**Referencing Issues Across Repositories:**
+When referencing issues from one repository, in another's Issues and Pull Requests, GitHub supports automatic links in markdown using the following format: `<org name>/<repo name>#<issue or PR number>`.`
+
+### Finishing a Review
+
+Write a summary of your observations and consider including positive remarks in addition to any constructive criticism.
+
+If you observe a deviation from these practices or another reason that this change should not be merged, select ""request changes"" and include a summary of the observation(s), as well as any practice(s) you find them to be in conflict with, in the review body (C).
+
+If you don't feel comfortable giving approval or requesting changes but want to share a summary or observations of larger patterns in the codebase or the company, select ""Comment"" and submit your review (C).
+
+Confirm that all items in the ""required checklist"" are checked or not applicable.
+
+If you believe the Pull Request looks good to merge, select ""Approve"" and submit your review (C).
+
+### C
+
+![submit_review.png](./assets/submit_review.png)
+
+### Merging
+
+1. Utilize the `Squash & Merge` feature (maintain a clean history)
+2. Copy the `Github PR Description` into the commit message (add sufficient detail)
+
+**Authors are core members or regular external contributors**
+
+- Core member needs to approve PR
+- Author should merge in the PR themselves (following instructions above)
+
+**Authors are non-regular external contributors:**
+
+- Core member needs to approve PR
+- Core member can merge PR on behalf of contributor  (following instructions above)
+
+**Pull Request Authors:**
+Specify whether or not the Pull Request can be merged by the last approving reviewer by use of (or lack thereof) the ""Reviewer can merge"" label. If no such label exists for a given project, create it.",docs/development/CODE_REVIEW_GUIDELINES.md,2023-05-23 22:42:00+00:00,2023-05-23T22:43:52Z,Is this `Reviewer can merge` label a new idea? Can you add it if this is the pattern we'll use?,,,,,118,RIGHT,118,,line,https://api.github.com/repos/pokt-network/pocket/pulls/773,pokt-network/pocket,9e66e8a9b7330012979eaed3c8b7a998de198167
https://api.github.com/repos/pokt-network/pocket/pulls/773,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1203112450,Olshansk,14ec7e08241505da679c5cb1694cf220eda66817,890173b5d1c8027a434cbbb80cc32eddcfe5a8d1,"@@ -0,0 +1,121 @@
+# Table of Contents <!-- omit in toc -->
+
+- [Code Quality](#code-quality)
+- [Code Reviews](#code-reviews)
+- [Code Review Guidelines](#code-review-guidelines)
+    - [Expectations](#expectations)
+- [Best Practices](#best-practices)
+    - [Reviewing](#reviewing)
+    - [Starting a Review](#starting-a-review)
+    - [Finishing a Review](#finishing-a-review)
+    - [Merging](#merging)
+
+# Code Quality
+
+""Code Quality"" can be a vague concept, as it usually addresses what is more the ""art"" side (vs. the ""science"" side) of software development.
+There are often several *technically correct* ways to address a problem -- that is, the correct answer or behavior is produced.
+Selecting the ""*best*"" solution is often a matter of style.
+Sometimes the best solution is one that fits the surrounding code in the most cohesive way.
+Terms like ""maintainability"" or ""readability"" are used; these address the ability of other contributors to understand and improve the code.
+
+Unlike correctness or performance concepts, there's no single metric or mathematical solution that can be optimized to achieve better code quality.
+Thus, we rely on human judgement.
+
+In this document, we outline a framework to guide that human judgement towards -- collectively -- ""better code"".
+
+For decades, the IETF (Internet Engineering Task Force) has used the motto ""rough consensus and running code"".
+This motto encapsulates (""running code"") that developers' core output is still software: if there is no code that runs and produces correct results, we have nothing.
+It also encapsulates (""rough consensus"") that we may not always precisely agree and that's okay.
+
+## Code Reviews
+
+One tactic often employed to produce ""maintainable"" or ""more-readable"" code is a ""code review"".
+These can take many shapes and forms and often have goals beyond simply ""code quality"".
+
+Broadly speaking, code reviews involve developers looking at some proposed new code (or code changes).
+This is *usually* developers other than the author (although a ""self-review"" can also be employed).
+In many projects, such attention is a scarce commodity: most programmers would rather write code than read someone else's.
+
+## Code Review Guidelines
+
+All participants must adhere to the overall idea that the review is an attempt to achieve ""better"" code.
+This is a vague statement on purpose.
+Participants must be cautious in their criticism and generous with praise.
+Participants must remember the scarcity of another developer's attention.
+
+### Expectations
+
+**Pull Request Authors:**
+The author is responsible for tracking up-to-date next actions for a Pull Request to progress towards being merged.
+
+**Reviewers:**
+Reviewers should prefer engaging in code review over starting new work (i.e. taking planned work items that haven't been started yet).
+
+Reviewers (and prospective reviewers) are encouraged to engage in reviews of codebases outside the projects and technologies they use on a day-to-day basis (but not expected to provide an approving review).
+
+## Best Practices
+
+### Reviewing
+
+### Starting a Review
+
+Consider if it could be broken into smaller Pull Requests. If it is clear that it can be, summarize your thinking on how in your Review.
+
+If the commits be (re)organized (i.e. reordered and/or amended) such that there is a commit at which the tests are passing prior to the conclusion of the main change, that's a signal that there's likely a logic split which can be made at that point in such a (re)arrangement.
+
+Use the following guidelines to evaluate whether a Pull Request should be approved:
+
+- *Every* Pull Request should have tests or justification otherwise; esp. bug fixes.
+- *Every* Pull Request should have at least 1 approval from a team member internal or external to the project. Exceptions made by repository maintainer(s), as necessary, on a case-by-case basis.
+
+During review, submit feedback using line comments (A); prefer ""Add\[ing a\] single comment"" over ""Start[ing] a review"" (B).
+
+*(Once a review has been started, the option to add single comments is removed. Preferring single comments allows feedback to happen even in the event of an interrupted review.)*
+
+### A
+
+![github_line_comment.png](./assets/github_line_comment.png)
+
+### B
+
+![line_comment_dialog_start.png](./assets/line_comment_dialog_start.png)
+
+**Referencing Issues Across Repositories:**
+When referencing issues from one repository, in another's Issues and Pull Requests, GitHub supports automatic links in markdown using the following format: `<org name>/<repo name>#<issue or PR number>`.`
+
+### Finishing a Review
+
+Write a summary of your observations and consider including positive remarks in addition to any constructive criticism.
+
+If you observe a deviation from these practices or another reason that this change should not be merged, select ""request changes"" and include a summary of the observation(s), as well as any practice(s) you find them to be in conflict with, in the review body (C).
+
+If you don't feel comfortable giving approval or requesting changes but want to share a summary or observations of larger patterns in the codebase or the company, select ""Comment"" and submit your review (C).
+
+Confirm that all items in the ""required checklist"" are checked or not applicable.
+
+If you believe the Pull Request looks good to merge, select ""Approve"" and submit your review (C).
+
+### C
+
+![submit_review.png](./assets/submit_review.png)
+
+### Merging
+
+1. Utilize the `Squash & Merge` feature (maintain a clean history)
+2. Copy the `Github PR Description` into the commit message (add sufficient detail)
+
+**Authors are core members or regular external contributors**
+
+- Core member needs to approve PR
+- Author should merge in the PR themselves (following instructions above)
+
+**Authors are non-regular external contributors:**
+
+- Core member needs to approve PR
+- Core member can merge PR on behalf of contributor  (following instructions above)
+
+**Pull Request Authors:**
+Specify whether or not the Pull Request can be merged by the last approving reviewer by use of (or lack thereof) the ""Reviewer can merge"" label. If no such label exists for a given project, create it.
+
+**Reviewers:**
+If you would give the last approving review **and** the Pull Request has the ""Reviewer can merge"" label, **merge**.",docs/development/CODE_REVIEW_GUIDELINES.md,2023-05-23 22:43:22+00:00,2023-05-23T22:43:52Z,"Can you please add 2 things to this document:

1. What we discussed in last monday's sync around draft PRs that need preliminary feedback but not ready to merge.

3. Asking everyone to fill out the metadata for the RPs per the discussion here: https://discord.com/channels/824324475256438814/1003704237324259418/1110608286664892498

![Screenshot 2023-05-23 at 3 42 20 PM](https://github.com/pokt-network/pocket/assets/1892194/0ba35f11-f298-4225-ba4b-f5b5a682ab23)

",,,,,121,RIGHT,121,,line,https://api.github.com/repos/pokt-network/pocket/pulls/773,pokt-network/pocket,9e66e8a9b7330012979eaed3c8b7a998de198167
https://api.github.com/repos/pokt-network/pocket/pulls/773,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1206139382,adshmh,14ec7e08241505da679c5cb1694cf220eda66817,890173b5d1c8027a434cbbb80cc32eddcfe5a8d1,"@@ -0,0 +1,121 @@
+# Table of Contents <!-- omit in toc -->
+
+- [Code Quality](#code-quality)
+- [Code Reviews](#code-reviews)
+- [Code Review Guidelines](#code-review-guidelines)
+    - [Expectations](#expectations)
+- [Best Practices](#best-practices)
+    - [Reviewing](#reviewing)
+    - [Starting a Review](#starting-a-review)
+    - [Finishing a Review](#finishing-a-review)
+    - [Merging](#merging)
+
+# Code Quality
+
+""Code Quality"" can be a vague concept, as it usually addresses what is more the ""art"" side (vs. the ""science"" side) of software development.
+There are often several *technically correct* ways to address a problem -- that is, the correct answer or behavior is produced.
+Selecting the ""*best*"" solution is often a matter of style.
+Sometimes the best solution is one that fits the surrounding code in the most cohesive way.
+Terms like ""maintainability"" or ""readability"" are used; these address the ability of other contributors to understand and improve the code.
+
+Unlike correctness or performance concepts, there's no single metric or mathematical solution that can be optimized to achieve better code quality.
+Thus, we rely on human judgement.
+
+In this document, we outline a framework to guide that human judgement towards -- collectively -- ""better code"".
+
+For decades, the IETF (Internet Engineering Task Force) has used the motto ""rough consensus and running code"".
+This motto encapsulates (""running code"") that developers' core output is still software: if there is no code that runs and produces correct results, we have nothing.
+It also encapsulates (""rough consensus"") that we may not always precisely agree and that's okay.
+
+## Code Reviews
+
+One tactic often employed to produce ""maintainable"" or ""more-readable"" code is a ""code review"".
+These can take many shapes and forms and often have goals beyond simply ""code quality"".
+
+Broadly speaking, code reviews involve developers looking at some proposed new code (or code changes).
+This is *usually* developers other than the author (although a ""self-review"" can also be employed).
+In many projects, such attention is a scarce commodity: most programmers would rather write code than read someone else's.
+
+## Code Review Guidelines
+
+All participants must adhere to the overall idea that the review is an attempt to achieve ""better"" code.
+This is a vague statement on purpose.
+Participants must be cautious in their criticism and generous with praise.
+Participants must remember the scarcity of another developer's attention.
+
+### Expectations
+
+**Pull Request Authors:**
+The author is responsible for tracking up-to-date next actions for a Pull Request to progress towards being merged.
+
+**Reviewers:**
+Reviewers should prefer engaging in code review over starting new work (i.e. taking planned work items that haven't been started yet).
+
+Reviewers (and prospective reviewers) are encouraged to engage in reviews of codebases outside the projects and technologies they use on a day-to-day basis (but not expected to provide an approving review).
+
+## Best Practices
+
+### Reviewing
+
+### Starting a Review
+
+Consider if it could be broken into smaller Pull Requests. If it is clear that it can be, summarize your thinking on how in your Review.
+
+If the commits be (re)organized (i.e. reordered and/or amended) such that there is a commit at which the tests are passing prior to the conclusion of the main change, that's a signal that there's likely a logic split which can be made at that point in such a (re)arrangement.
+
+Use the following guidelines to evaluate whether a Pull Request should be approved:
+
+- *Every* Pull Request should have tests or justification otherwise; esp. bug fixes.
+- *Every* Pull Request should have at least 1 approval from a team member internal or external to the project. Exceptions made by repository maintainer(s), as necessary, on a case-by-case basis.
+
+During review, submit feedback using line comments (A); prefer ""Add\[ing a\] single comment"" over ""Start[ing] a review"" (B).
+
+*(Once a review has been started, the option to add single comments is removed. Preferring single comments allows feedback to happen even in the event of an interrupted review.)*
+
+### A
+
+![github_line_comment.png](./assets/github_line_comment.png)
+
+### B
+
+![line_comment_dialog_start.png](./assets/line_comment_dialog_start.png)
+
+**Referencing Issues Across Repositories:**
+When referencing issues from one repository, in another's Issues and Pull Requests, GitHub supports automatic links in markdown using the following format: `<org name>/<repo name>#<issue or PR number>`.`
+
+### Finishing a Review
+
+Write a summary of your observations and consider including positive remarks in addition to any constructive criticism.
+
+If you observe a deviation from these practices or another reason that this change should not be merged, select ""request changes"" and include a summary of the observation(s), as well as any practice(s) you find them to be in conflict with, in the review body (C).
+
+If you don't feel comfortable giving approval or requesting changes but want to share a summary or observations of larger patterns in the codebase or the company, select ""Comment"" and submit your review (C).
+
+Confirm that all items in the ""required checklist"" are checked or not applicable.
+
+If you believe the Pull Request looks good to merge, select ""Approve"" and submit your review (C).
+
+### C
+
+![submit_review.png](./assets/submit_review.png)
+
+### Merging",docs/development/CODE_REVIEW_GUIDELINES.md,2023-05-26 01:22:58+00:00,2023-05-26T01:30:11Z,"I suggest we add a section: `Addressing Reviews` to help with a few items, e.g.:

- Do not rebase (and subsequently push -f) the PR branch, as it would make it challenging for the reviewer to identify what has changed between their review and the latest PR update. Instead push more commits to address review comments. The squash merge method will combine all the PR commits into one.",,,,117.0,102,RIGHT,102,117.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/773,pokt-network/pocket,9e66e8a9b7330012979eaed3c8b7a998de198167
https://api.github.com/repos/pokt-network/pocket/pulls/756,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1220406444,Olshansk,3c65f9c895487df8f1b6109168200bba6ac7875f,b83e7add3d4570727d6a171996fe14d5701bf22f,"@@ -33,6 +38,22 @@ type PersistenceModule interface {
 	HandleDebugMessage(*messaging.DebugMessage) error
 }
 
+// TreeStore is fulfilled by the treeStore to create an
+// atomic tree component for use by the peristence context.
+type TreeStore interface {
+	// Update returns the new state hash for a given height.
+	// * Height is passed through to the Update function
+	// and used by the queries against the TxIndexer and the",shared/modules/persistence_module.go,2023-06-06 21:40:09+00:00,2023-06-06T21:59:09Z,Optional NIT: I feel like single lining this whole statement (even if it's > 80 chars) will make it easier to read,,,,,46,RIGHT,28,,line,https://api.github.com/repos/pokt-network/pocket/pulls/756,pokt-network/pocket,70a1a0e2fe2c238fce8c2019e13e9167629a2639
https://api.github.com/repos/pokt-network/pocket/pulls/756,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1220407378,Olshansk,3c65f9c895487df8f1b6109168200bba6ac7875f,b83e7add3d4570727d6a171996fe14d5701bf22f,"@@ -33,6 +38,22 @@ type PersistenceModule interface {
 	HandleDebugMessage(*messaging.DebugMessage) error
 }
 
+// TreeStore is fulfilled by the treeStore to create an",shared/modules/persistence_module.go,2023-06-06 21:40:44+00:00,2023-06-06T21:59:09Z,`by the treeStore` - What is the `treeStore`?,,,,,41,RIGHT,23,,line,https://api.github.com/repos/pokt-network/pocket/pulls/756,pokt-network/pocket,70a1a0e2fe2c238fce8c2019e13e9167629a2639
https://api.github.com/repos/pokt-network/pocket/pulls/756,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1220409158,Olshansk,3c65f9c895487df8f1b6109168200bba6ac7875f,b83e7add3d4570727d6a171996fe14d5701bf22f,"@@ -33,6 +38,22 @@ type PersistenceModule interface {
 	HandleDebugMessage(*messaging.DebugMessage) error
 }
 
+// TreeStore is fulfilled by the treeStore to create an
+// atomic tree component for use by the peristence context.",shared/modules/persistence_module.go,2023-06-06 21:42:17+00:00,2023-06-06T21:59:09Z,"Can you update the comment on the `TreeStore`. I read it and it did not give me much context.

I'm thinking more along the lines of:

`TreeStore provides an interface that guarantees atomic operations (updates and rollbacks) made to the tree supporting the persistence context`",,,,,42,RIGHT,24,,line,https://api.github.com/repos/pokt-network/pocket/pulls/756,pokt-network/pocket,70a1a0e2fe2c238fce8c2019e13e9167629a2639
https://api.github.com/repos/pokt-network/pocket/pulls/756,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1220410502,Olshansk,3c65f9c895487df8f1b6109168200bba6ac7875f,b83e7add3d4570727d6a171996fe14d5701bf22f,"@@ -33,6 +38,22 @@ type PersistenceModule interface {
 	HandleDebugMessage(*messaging.DebugMessage) error
 }
 
+// TreeStore is fulfilled by the treeStore to create an
+// atomic tree component for use by the peristence context.
+type TreeStore interface {
+	// Update returns the new state hash for a given height.
+	// * Height is passed through to the Update function
+	// and used by the queries against the TxIndexer and the
+	// It updates to the future but not to the past.",shared/modules/persistence_module.go,2023-06-06 21:43:35+00:00,2023-06-06T21:59:09Z,Can you elaborate on what this means?,,,,,47,RIGHT,29,,line,https://api.github.com/repos/pokt-network/pocket/pulls/756,pokt-network/pocket,70a1a0e2fe2c238fce8c2019e13e9167629a2639
https://api.github.com/repos/pokt-network/pocket/pulls/756,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1220411608,Olshansk,3c65f9c895487df8f1b6109168200bba6ac7875f,b83e7add3d4570727d6a171996fe14d5701bf22f,"@@ -33,6 +38,22 @@ type PersistenceModule interface {
 	HandleDebugMessage(*messaging.DebugMessage) error
 }
 
+// TreeStore is fulfilled by the treeStore to create an
+// atomic tree component for use by the peristence context.
+type TreeStore interface {
+	// Update returns the new state hash for a given height.
+	// * Height is passed through to the Update function
+	// and used by the queries against the TxIndexer and the
+	// It updates to the future but not to the past.
+	// * Passing a higher height will cause a change
+	// but repeatedly calling the same or a lower height will
+	// not incur a change.
+	Update(pgtx pgx.Tx, txi indexer.TxIndexer, height uint64) (string, error)
+	// ClearAll completely clears the state of the trees.
+	// For debugging purposes only.",shared/modules/persistence_module.go,2023-06-06 21:44:42+00:00,2023-06-06T21:59:09Z,Let's prefact it with `Debug` (e.g. DebugClearAll) and add an `IMPROVE` to move it into a separate file with the appropriate build tag,,,,,53,RIGHT,35,,line,https://api.github.com/repos/pokt-network/pocket/pulls/756,pokt-network/pocket,70a1a0e2fe2c238fce8c2019e13e9167629a2639
https://api.github.com/repos/pokt-network/pocket/pulls/756,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1220415555,Olshansk,3c65f9c895487df8f1b6109168200bba6ac7875f,b83e7add3d4570727d6a171996fe14d5701bf22f,"@@ -36,13 +37,14 @@ type persistenceModule struct {
 	// A key-value store mapping heights to blocks. Needed for block synchronization.
 	blockStore blockstore.BlockStore
 
-	// A tx indexer (i.e. key-value store) mapping transaction hashes to transactions. Needed for
-	// avoiding tx replays attacks, and is also used as the backing database for the transaction
-	// tx merkle tree.
+	// txIndexer is a key-value store mapping transaction hashes to transactions.",persistence/module.go,2023-06-06 21:47:52+00:00,2023-06-06T21:59:09Z,"```suggestion
	// txIndexer is a key-value store mapping transaction hashes to `IndexedTransaction` protos.
```

Is that right?",,,,,40,RIGHT,15,,line,https://api.github.com/repos/pokt-network/pocket/pulls/756,pokt-network/pocket,70a1a0e2fe2c238fce8c2019e13e9167629a2639
https://api.github.com/repos/pokt-network/pocket/pulls/756,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1220416745,Olshansk,3c65f9c895487df8f1b6109168200bba6ac7875f,b83e7add3d4570727d6a171996fe14d5701bf22f,"@@ -36,13 +37,14 @@ type persistenceModule struct {
 	// A key-value store mapping heights to blocks. Needed for block synchronization.
 	blockStore blockstore.BlockStore
 
-	// A tx indexer (i.e. key-value store) mapping transaction hashes to transactions. Needed for
-	// avoiding tx replays attacks, and is also used as the backing database for the transaction
-	// tx merkle tree.
+	// txIndexer is a key-value store mapping transaction hashes to transactions.
+	// It is needed for avoiding tx replays attacks, and is also used as the backing
+	// data store for tree store.",persistence/module.go,2023-06-06 21:49:04+00:00,2023-06-06T21:59:09Z,"```suggestion
	// It is needed for avoiding tx replays attacks, and some business logic around tx validation.
	// IMPORTANT: It doubles as the backing data store for the tx tree in one of the `stateTrees`.
```",,41.0,RIGHT,,42,RIGHT,17,,line,https://api.github.com/repos/pokt-network/pocket/pulls/756,pokt-network/pocket,70a1a0e2fe2c238fce8c2019e13e9167629a2639
https://api.github.com/repos/pokt-network/pocket/pulls/756,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1220418699,Olshansk,3c65f9c895487df8f1b6109168200bba6ac7875f,b83e7add3d4570727d6a171996fe14d5701bf22f,"@@ -102,7 +104,7 @@ func (*persistenceModule) Create(bus modules.Bus, options ...modules.ModuleOptio
 		return nil, err
 	}
 
-	stateTrees, err := newStateTrees(persistenceCfg.TreesStoreDir)
+	stateTrees, err := trees.NewStateTrees(persistenceCfg.TreesStoreDir, txIndexer)",persistence/module.go,2023-06-06 21:51:04+00:00,2023-06-06T21:59:09Z,"Thoughts on having the `TreeStore` be a submodule (using dependency injection, being modular, etc...) that takes in a bus? Then you can access the `txIndexer` via `GetBus().GetPersistenceModule().GetTxIndexer()`",,,,,107,RIGHT,33,,line,https://api.github.com/repos/pokt-network/pocket/pulls/756,pokt-network/pocket,70a1a0e2fe2c238fce8c2019e13e9167629a2639
https://api.github.com/repos/pokt-network/pocket/pulls/756,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1220421661,Olshansk,3c65f9c895487df8f1b6109168200bba6ac7875f,b83e7add3d4570727d6a171996fe14d5701bf22f,"@@ -0,0 +1,66 @@
+",shared/modules/gomock_reflect_1203808572/prog.go,2023-06-06 21:53:52+00:00,2023-06-06T21:59:09Z,Intended to be merged in?,,,,,1,RIGHT,1,,line,https://api.github.com/repos/pokt-network/pocket/pulls/756,pokt-network/pocket,70a1a0e2fe2c238fce8c2019e13e9167629a2639
https://api.github.com/repos/pokt-network/pocket/pulls/756,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1220423232,Olshansk,3c65f9c895487df8f1b6109168200bba6ac7875f,b83e7add3d4570727d6a171996fe14d5701bf22f,"@@ -23,6 +24,10 @@ type PersistenceModule interface {
 
 	// BlockStore operations
 	GetBlockStore() blockstore.BlockStore
+
+	// TreeStore operations",shared/modules/persistence_module.go,2023-06-06 21:54:40+00:00,2023-06-06T21:59:09Z,"I know we didn't do a good job at this earlier on, but can make the comments more explicit on what it does and a couple words on what it's used for. It'll help future readers",,,,,28,RIGHT,13,,line,https://api.github.com/repos/pokt-network/pocket/pulls/756,pokt-network/pocket,70a1a0e2fe2c238fce8c2019e13e9167629a2639
https://api.github.com/repos/pokt-network/pocket/pulls/756,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1220427900,Olshansk,3c65f9c895487df8f1b6109168200bba6ac7875f,b83e7add3d4570727d6a171996fe14d5701bf22f,"@@ -33,6 +38,22 @@ type PersistenceModule interface {
 	HandleDebugMessage(*messaging.DebugMessage) error
 }
 
+// TreeStore is fulfilled by the treeStore to create an
+// atomic tree component for use by the peristence context.
+type TreeStore interface {
+	// Update returns the new state hash for a given height.
+	// * Height is passed through to the Update function
+	// and used by the queries against the TxIndexer and the
+	// It updates to the future but not to the past.
+	// * Passing a higher height will cause a change
+	// but repeatedly calling the same or a lower height will
+	// not incur a change.
+	Update(pgtx pgx.Tx, txi indexer.TxIndexer, height uint64) (string, error)",shared/modules/persistence_module.go,2023-06-06 21:58:24+00:00,2023-06-06T21:59:10Z,"I have a lot of context (more than most) on the work you're doing here and it was hard for my to decipher the interface and implementation. What do you think of this updated interface (note that the txi is part of the state)?

```go
// Update uses the ephemeral state in the postgres transaction pgtx at the given height and automatically
// updates all the trees backing the persistence module. 
// Updates to current or prior heights are idempotent and return the same hash every time.
// Updates to future heights returns an error.
`Update(pgtx pgx.Tx, height uint64) (string, error)`
```",,,,48.0,48,RIGHT,33,33.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/756,pokt-network/pocket,70a1a0e2fe2c238fce8c2019e13e9167629a2639
https://api.github.com/repos/pokt-network/pocket/pulls/756,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1220428397,Olshansk,3c65f9c895487df8f1b6109168200bba6ac7875f,b83e7add3d4570727d6a171996fe14d5701bf22f,"@@ -0,0 +1,573 @@
+// package trees maintains a set of sparse merkle trees",persistence/trees/trees.go,2023-06-06 21:58:58+00:00,2023-06-06T21:59:10Z,"NIT: Please use `mv` in the future. 

Did you make any chances to this logic (do I need to review it) or is it just a mv?",,,,1.0,1,RIGHT,1,1.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/756,pokt-network/pocket,70a1a0e2fe2c238fce8c2019e13e9167629a2639
https://api.github.com/repos/pokt-network/pocket/pulls/756,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1222324856,Olshansk,8912a94396c3e32975d274b784e18d28e7784167,b83e7add3d4570727d6a171996fe14d5701bf22f,"@@ -0,0 +1,573 @@
+// package trees maintains a set of sparse merkle trees
+// each backed by the KVStore interface. It offers an atomic
+// commit and rollback mechanism for interacting with
+// that core resource map of merkle trees.
+package trees
+
+import (
+	""bytes""
+	""context""
+	""crypto/sha256""
+	""encoding/hex""
+	""fmt""
+
+	""github.com/jackc/pgx/v5""
+
+	""github.com/pokt-network/pocket/persistence/indexer""
+	""github.com/pokt-network/pocket/persistence/kvstore""
+	ptypes ""github.com/pokt-network/pocket/persistence/types""
+	""github.com/pokt-network/pocket/shared/codec""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/crypto""
+	""github.com/pokt-network/smt""
+)
+
+var merkleTreeToString = map[merkleTree]string{
+	appMerkleTree:      ""app"",
+	valMerkleTree:      ""val"",
+	fishMerkleTree:     ""fish"",
+	servicerMerkleTree: ""servicer"",
+
+	accountMerkleTree: ""account"",
+	poolMerkleTree:    ""pool"",
+
+	transactionsMerkleTree: ""transactions"",
+	paramsMerkleTree:       ""params"",
+	flagsMerkleTree:        ""flags"",
+}
+
+var actorTypeToMerkleTreeName = map[coreTypes.ActorType]merkleTree{
+	coreTypes.ActorType_ACTOR_TYPE_APP:      appMerkleTree,
+	coreTypes.ActorType_ACTOR_TYPE_VAL:      valMerkleTree,
+	coreTypes.ActorType_ACTOR_TYPE_FISH:     fishMerkleTree,
+	coreTypes.ActorType_ACTOR_TYPE_SERVICER: servicerMerkleTree,
+}
+
+var actorTypeToSchemaName = map[coreTypes.ActorType]ptypes.ProtocolActorSchema{
+	coreTypes.ActorType_ACTOR_TYPE_APP:      ptypes.ApplicationActor,
+	coreTypes.ActorType_ACTOR_TYPE_VAL:      ptypes.ValidatorActor,
+	coreTypes.ActorType_ACTOR_TYPE_FISH:     ptypes.FishermanActor,
+	coreTypes.ActorType_ACTOR_TYPE_SERVICER: ptypes.ServicerActor,
+}
+
+var merkleTreeToActorTypeName = map[merkleTree]coreTypes.ActorType{
+	appMerkleTree:      coreTypes.ActorType_ACTOR_TYPE_APP,
+	valMerkleTree:      coreTypes.ActorType_ACTOR_TYPE_VAL,
+	fishMerkleTree:     coreTypes.ActorType_ACTOR_TYPE_FISH,
+	servicerMerkleTree: coreTypes.ActorType_ACTOR_TYPE_SERVICER,
+}
+
+type merkleTree float64
+
+// A list of Merkle Trees used to maintain the state hash.
+const (
+	// IMPORTANT: The order in which these trees are defined is important and strict. It implicitly
+	// defines the index of the root hash each independent as they are concatenated together
+	// to generate the state hash.
+
+	// Actor Merkle Trees
+	appMerkleTree merkleTree = iota
+	valMerkleTree
+	fishMerkleTree
+	servicerMerkleTree
+
+	// Account Merkle Trees
+	accountMerkleTree
+	poolMerkleTree
+
+	// Data Merkle Trees
+	transactionsMerkleTree
+	paramsMerkleTree
+	flagsMerkleTree
+
+	// Used for iteration purposes only; see https://stackoverflow.com/a/64178235/768439 as a reference
+	numMerkleTrees
+)
+
+// treeStore stores a set of merkle trees that
+// it manages. It fulfills the modules.TreeStore interface.
+// * It is responsible for commit or rollback behavior
+// of the underlying trees by utilizing the lazy loading
+// functionality provided by the underlying smt library.
+type treeStore struct {
+	treeStoreDir string
+	merkleTrees  map[merkleTree]*smt.SMT
+	nodeStores   map[merkleTree]kvstore.KVStore
+}
+
+// NewStateTrees takes a directory location and a TxIndexer  and returns a TreeStore
+// implementation that guarantees
+func NewStateTrees(dir string) (*treeStore, error) {
+	if dir == """" {
+		return newMemStateTrees()
+	}
+
+	stateTrees := &treeStore{
+		treeStoreDir: dir,
+		merkleTrees:  make(map[merkleTree]*smt.SMT, int(numMerkleTrees)),
+		nodeStores:   make(map[merkleTree]kvstore.KVStore, int(numMerkleTrees)),
+	}
+
+	for tree := merkleTree(0); tree < numMerkleTrees; tree++ {
+		nodeStore, err := kvstore.NewKVStore(fmt.Sprintf(""%s/%s_nodes"", dir, merkleTreeToString[tree]))
+		if err != nil {
+			return nil, err
+		}
+		stateTrees.nodeStores[tree] = nodeStore
+		stateTrees.merkleTrees[tree] = smt.NewSparseMerkleTree(nodeStore, sha256.New())
+	}
+	return stateTrees, nil
+}
+
+// Update takes a transaction and a height and updates
+// all of the trees in the treeStore for that height.
+func (t *treeStore) Update(pgtx pgx.Tx, txi indexer.TxIndexer, height uint64) (string, error) {
+	return t.updateMerkleTrees(pgtx, txi, height)
+}
+
+// DebugClearAll is used by the debug cli to completely reset all merkle trees.
+// This should only be called by the debug CLI.
+func (t *treeStore) DebugClearAll() error {
+	for treeType := merkleTree(0); treeType < numMerkleTrees; treeType++ {
+		nodeStore := t.nodeStores[treeType]
+		if err := nodeStore.ClearAll(); err != nil {
+			return fmt.Errorf(""failed to clear %s node store: %w"", merkleTreeToString[treeType], err)
+		}
+		t.merkleTrees[treeType] = smt.NewSparseMerkleTree(nodeStore, sha256.New())
+	}
+
+	return nil
+}
+
+// newMemStateTrees creates a new in-memory state tree
+func newMemStateTrees() (*treeStore, error) {
+	stateTrees := &treeStore{
+		merkleTrees: make(map[merkleTree]*smt.SMT, int(numMerkleTrees)),
+		nodeStores:  make(map[merkleTree]kvstore.KVStore, int(numMerkleTrees)),
+	}
+	for tree := merkleTree(0); tree < numMerkleTrees; tree++ {
+		nodeStore := kvstore.NewMemKVStore() // For testing, `smt.NewSimpleMap()` can be used as well
+		stateTrees.nodeStores[tree] = nodeStore
+		stateTrees.merkleTrees[tree] = smt.NewSparseMerkleTree(nodeStore, sha256.New())
+	}
+	return stateTrees, nil
+}
+
+// updateMerkleTrees updates all of the merkle trees that TreeStore manages.
+// * it returns an hash of the output or an error.
+func (t *treeStore) updateMerkleTrees(pgtx pgx.Tx, txi indexer.TxIndexer, height uint64) (string, error) {
+	for treeType := merkleTree(0); treeType < numMerkleTrees; treeType++ {
+		switch treeType {
+		// Actor Merkle Trees
+		case appMerkleTree, valMerkleTree, fishMerkleTree, servicerMerkleTree:
+			actorType, ok := merkleTreeToActorTypeName[treeType]
+			if !ok {
+				return """", fmt.Errorf(""no actor type found for merkle tree: %v"", treeType)
+			}
+
+			actors, err := t.getActorsUpdated(pgtx, actorType, height)
+			if err != nil {
+				return """", fmt.Errorf(""failed to get actors at height: %w"", err)
+			}
+
+			if err := t.updateActorsTree(actorType, actors); err != nil {
+				return """", fmt.Errorf(""failed to update actors tree for treeType: %v, actorType: %v - %w"", treeType, actorType, err)
+			}
+
+		// Account Merkle Trees
+		case accountMerkleTree:
+			accounts, err := t.getAccounts(pgtx, height)
+			if err != nil {
+				return """", fmt.Errorf(""failed to get accounts: %w"", err)
+			}
+			if err := t.updateAccountTrees(accounts); err != nil {
+				return """", fmt.Errorf(""failed to update account trees: %w"", err)
+			}
+		case poolMerkleTree:
+			pools, err := t.getPools(pgtx, height)
+			if err != nil {
+				return """", fmt.Errorf(""failed to get transactions: %w"", err)
+			}
+			if err := t.updatePoolTrees(pools); err != nil {
+				return """", fmt.Errorf(""failed to update pool trees - %w"", err)
+			}
+
+		// Data Merkle Trees
+		case transactionsMerkleTree:
+			indexedTxs, err := t.getTransactions(txi, height)
+			if err != nil {
+				return """", fmt.Errorf(""failed to get transactions: %w"", err)
+			}
+			if err := t.updateTransactionsTree(indexedTxs); err != nil {
+				return """", fmt.Errorf(""failed to update transactions: %w"", err)
+			}
+		case paramsMerkleTree:
+			params, err := t.getParams(pgtx, height)
+			if err != nil {
+				return """", fmt.Errorf(""failed to get params: %w"", err)
+			}
+			if err := t.updateParamsTree(params); err != nil {
+				return """", fmt.Errorf(""failed to update params tree: %w"", err)
+			}
+		case flagsMerkleTree:
+			flags, err := t.getFlags(pgtx, height)
+			if err != nil {
+				return """", fmt.Errorf(""failed to get flags from transaction: %w"", err)
+			}
+			if err := t.updateFlagsTree(flags); err != nil {
+				return """", fmt.Errorf(""failed to update flags tree - %w"", err)
+			}
+		// Default
+		default:
+			panic(fmt.Sprintf(""not handled in state commitment update. Merkle tree #{%v}"", treeType))
+		}
+	}
+
+	if err := t.commit(); err != nil {
+		return """", fmt.Errorf(""failed to commit: %w"", err)
+	}
+	return t.getStateHash(), nil
+}
+
+func (t *treeStore) commit() error {
+	for tree := merkleTree(0); tree < numMerkleTrees; tree++ {
+		if err := t.merkleTrees[tree].Commit(); err != nil {
+			return fmt.Errorf(""failed to commit %s: %w"", merkleTreeToString[tree], err)
+		}
+	}
+	return nil
+}
+
+func (t *treeStore) getStateHash() string {
+	// create an order-matters list of roots
+	roots := make([][]byte, 0)
+	for tree := merkleTree(0); tree < numMerkleTrees; tree++ {
+		roots = append(roots, t.merkleTrees[tree].Root())
+	}
+
+	// combine them and hash the result
+	rootsConcat := bytes.Join(roots, []byte{})
+	stateHash := sha256.Sum256(rootsConcat)
+
+	// Convert the array to a slice and return it
+	// REF: https://stackoverflow.com/questions/28886616/convert-array-to-slice-in-go
+	return hex.EncodeToString(stateHash[:])
+}
+
+////////////////////////
+// Actor Tree Helpers //
+////////////////////////
+
+// NB: I think this needs to be done manually for all 4 types.
+func (t *treeStore) updateActorsTree(actorType coreTypes.ActorType, actors []*coreTypes.Actor) error {
+	for _, actor := range actors {
+		bzAddr, err := hex.DecodeString(actor.GetAddress())
+		if err != nil {
+			return err
+		}
+
+		actorBz, err := codec.GetCodec().Marshal(actor)
+		if err != nil {
+			return err
+		}
+
+		merkleTreeName, ok := actorTypeToMerkleTreeName[actorType]
+		if !ok {
+			return fmt.Errorf(""no merkle tree found for actor type: %s"", actorType)
+		}
+		if err := t.merkleTrees[merkleTreeName].Update(bzAddr, actorBz); err != nil {
+			return err
+		}
+	}
+
+	return nil
+}
+
+//////////////////////////
+// Account Tree Helpers //
+//////////////////////////
+
+func (t *treeStore) updateAccountTrees(accounts []*coreTypes.Account) error {
+	for _, account := range accounts {
+		bzAddr, err := hex.DecodeString(account.GetAddress())
+		if err != nil {
+			return err
+		}
+
+		accBz, err := codec.GetCodec().Marshal(account)
+		if err != nil {
+			return err
+		}
+
+		if err := t.merkleTrees[accountMerkleTree].Update(bzAddr, accBz); err != nil {
+			return err
+		}
+	}
+
+	return nil
+}
+
+func (t *treeStore) updatePoolTrees(pools []*coreTypes.Account) error {
+	for _, pool := range pools {
+		bzAddr, err := hex.DecodeString(pool.GetAddress())
+		if err != nil {
+			return err
+		}
+
+		accBz, err := codec.GetCodec().Marshal(pool)
+		if err != nil {
+			return err
+		}
+
+		if err := t.merkleTrees[poolMerkleTree].Update(bzAddr, accBz); err != nil {
+			return err
+		}
+	}
+
+	return nil
+}
+
+///////////////////////
+// Data Tree Helpers //
+///////////////////////
+
+func (t *treeStore) updateTransactionsTree(indexedTxs []*coreTypes.IndexedTransaction) error {
+	for _, idxTx := range indexedTxs {
+		txBz := idxTx.GetTx()
+		txHash := crypto.SHA3Hash(txBz)
+		if err := t.merkleTrees[transactionsMerkleTree].Update(txHash, txBz); err != nil {
+			return err
+		}
+	}
+	return nil
+}
+
+func (t *treeStore) updateParamsTree(params []*coreTypes.Param) error {
+	for _, param := range params {
+		paramBz, err := codec.GetCodec().Marshal(param)
+		paramKey := crypto.SHA3Hash([]byte(param.Name))
+		if err != nil {
+			return err
+		}
+		if err := t.merkleTrees[paramsMerkleTree].Update(paramKey, paramBz); err != nil {
+			return err
+		}
+	}
+
+	return nil
+}
+
+func (t *treeStore) updateFlagsTree(flags []*coreTypes.Flag) error {
+	for _, flag := range flags {
+		flagBz, err := codec.GetCodec().Marshal(flag)
+		flagKey := crypto.SHA3Hash([]byte(flag.Name))
+		if err != nil {
+			return err
+		}
+		if err := t.merkleTrees[flagsMerkleTree].Update(flagKey, flagBz); err != nil {
+			return err
+		}
+	}
+
+	return nil
+}
+
+// getActorsUpdated is responsible for fetching the actors that have been updated at a given height.
+func (t *treeStore) getActorsUpdated(
+	pgtx pgx.Tx,
+	actorType coreTypes.ActorType,
+	height uint64,
+) ([]*coreTypes.Actor, error) {
+	actorSchema, ok := actorTypeToSchemaName[actorType]
+	if !ok {
+		return nil, fmt.Errorf(""no schema found for actor type: %s"", actorType)
+	}
+
+	// TECHDEBT #XXX: Avoid this cast to int64
+	query := actorSchema.GetUpdatedAtHeightQuery(int64(height))
+	rows, err := pgtx.Query(context.TODO(), query)
+	if err != nil {
+		return nil, err
+	}
+	defer rows.Close()
+
+	addrs := make([][]byte, 0)
+	for rows.Next() {
+		var addr string
+		if err := rows.Scan(&addr); err != nil {
+			return nil, err
+		}
+		addrBz, err := hex.DecodeString(addr)
+		if err != nil {
+			return nil, err
+		}
+		addrs = append(addrs, addrBz)
+	}
+
+	actors := make([]*coreTypes.Actor, len(addrs))
+	for i, addr := range addrs {
+		// TECHDEBT #XXX: Avoid this cast to int64
+		actor, err := t.getActor(pgtx, actorSchema, addr, int64(height))
+		if err != nil {
+			return nil, err
+		}
+		actors[i] = actor
+	}
+	rows.Close()
+
+	return actors, nil
+}
+
+func (t *treeStore) getAccountsUpdated(
+	pgtx pgx.Tx,
+	acctType ptypes.ProtocolAccountSchema,
+	height uint64,
+) ([]*coreTypes.Account, error) {
+	accounts := []*coreTypes.Account{}
+
+	// TECHDEBT #XXX: Avoid this cast to int64
+	query := acctType.GetAccountsUpdatedAtHeightQuery(int64(height))
+	rows, err := pgtx.Query(context.TODO(), query)
+	if err != nil {
+		return nil, err
+	}
+	defer rows.Close()
+
+	for rows.Next() {
+		acc := new(coreTypes.Account)
+		if err := rows.Scan(&acc.Address, &acc.Amount); err != nil {
+			return nil, err
+		}
+		accounts = append(accounts, acc)
+	}
+
+	return accounts, nil
+}
+
+func (t *treeStore) getTransactions(txi indexer.TxIndexer, height uint64) ([]*coreTypes.IndexedTransaction, error) {
+	// TECHDEBT(#XXX): TxIndexer should use uint64s so we avoid this cast.
+	indexedTxs, err := txi.GetByHeight(int64(height), false)
+	if err != nil {
+		return nil, fmt.Errorf(""failed to get transactions by height: %w"", err)
+	}
+	return indexedTxs, nil
+}
+
+// getPools returns the pools updated at the given height
+func (t *treeStore) getPools(pgtx pgx.Tx, height uint64) ([]*coreTypes.Account, error) {
+	pools, err := t.getAccountsUpdated(pgtx, ptypes.Pool, height)
+	if err != nil {
+		return nil, fmt.Errorf(""failed to get pools: %w"", err)
+	}
+	return pools, nil
+}
+
+// getAccounts returns the list of accounts updated at the provided height
+func (t *treeStore) getAccounts(pgtx pgx.Tx, height uint64) ([]*coreTypes.Account, error) {
+	accounts, err := t.getAccountsUpdated(pgtx, ptypes.Account, height)
+	if err != nil {
+		return nil, fmt.Errorf(""failed to get accounts: %w"", err)
+	}
+	return accounts, nil
+}
+
+func (t *treeStore) getFlags(pgtx pgx.Tx, height uint64) ([]*coreTypes.Flag, error) {
+	fields := ""name,value,enabled""
+	query := fmt.Sprintf(""SELECT %s FROM %s WHERE height=%d ORDER BY name ASC"", fields, ptypes.FlagsTableName, height)
+	rows, err := pgtx.Query(context.TODO(), query)
+	if err != nil {
+		return nil, fmt.Errorf(""failed to get flags: %w"", err)
+	}
+	defer rows.Close()
+
+	flagSlice := []*coreTypes.Flag{}
+	for rows.Next() {
+		flag := new(coreTypes.Flag)
+		if err := rows.Scan(&flag.Name, &flag.Value, &flag.Enabled); err != nil {
+			return nil, err
+		}
+		flag.Height = int64(height)
+		flagSlice = append(flagSlice, flag)
+	}
+
+	return flagSlice, nil
+}
+
+func (t *treeStore) getParams(pgtx pgx.Tx, height uint64) ([]*coreTypes.Param, error) {
+	fields := ""name,value""
+	query := fmt.Sprintf(""SELECT %s FROM %s WHERE height=%d ORDER BY name ASC"", fields, ptypes.ParamsTableName, height)
+	rows, err := pgtx.Query(context.TODO(), query)
+	if err != nil {
+		return nil, err
+	}
+	defer rows.Close()
+
+	var paramSlice []*coreTypes.Param
+	for rows.Next() {
+		param := new(coreTypes.Param)
+		if err := rows.Scan(&param.Name, &param.Value); err != nil {
+			return nil, err
+		}
+		param.Height = int64(height)
+		paramSlice = append(paramSlice, param)
+	}
+
+	return paramSlice, nil
+}
+
+func (t *treeStore) getActor(tx pgx.Tx, actorSchema ptypes.ProtocolActorSchema, address []byte, height int64) (actor *coreTypes.Actor, err error) {
+	ctx := context.TODO()
+	actor, height, err = t.getActorFromRow(actorSchema.GetActorType(), tx.QueryRow(ctx, actorSchema.GetQuery(hex.EncodeToString(address), height)))
+	if err != nil {
+		return
+	}
+	return t.getChainsForActor(ctx, tx, actorSchema, actor, height)
+}
+
+func (t *treeStore) getActorFromRow(actorType coreTypes.ActorType, row pgx.Row) (actor *coreTypes.Actor, height int64, err error) {
+	actor = &coreTypes.Actor{
+		ActorType: actorType,
+	}
+	err = row.Scan(
+		&actor.Address,
+		&actor.PublicKey,
+		&actor.StakedAmount,
+		&actor.ServiceUrl,
+		&actor.Output,
+		&actor.PausedHeight,
+		&actor.UnstakingHeight,
+		&height)
+	return
+}
+
+func (t *treeStore) getChainsForActor(
+	ctx context.Context,
+	tx pgx.Tx,
+	actorSchema ptypes.ProtocolActorSchema,
+	actor *coreTypes.Actor,
+	height int64,
+) (a *coreTypes.Actor, err error) {
+	if actorSchema.GetChainsTableName() == """" {
+		return actor, nil
+	}
+	rows, err := tx.Query(ctx, actorSchema.GetChainsQuery(actor.Address, height))
+	if err != nil {
+		return actor, err
+	}
+	defer rows.Close()
+
+	var chainAddr string
+	var chainID string
+	var chainEndHeight int64 // DISCUSS: why is this commented as ""unused""?
+	for rows.Next() {
+		err = rows.Scan(&chainAddr, &chainID, &chainEndHeight)
+		if err != nil {
+			return
+		}
+		if chainAddr != actor.Address {
+			return actor, fmt.Errorf(""unexpected address %s, expected %s when reading chains"", chainAddr, actor.Address)
+		}
+		actor.Chains = append(actor.Chains, chainID)
+	}
+	return actor, nil
+}",persistence/trees/trees.go,2023-06-08 00:51:19+00:00,2023-06-08T00:54:10Z,"Related to

> Yes, was planning on future PRs with more test coverage. This PR was meant to bring the refactor online and achieve test parity.

Can you add the Test function headers (w/ a TODO to implement) even if you don't plan on implementing them in this PR? That way we're not just forgetting about it.

I think that doing a git diff on this PR and getting suggestions from ChatGPT could help out.",,,,,575,RIGHT,573,,line,https://api.github.com/repos/pokt-network/pocket/pulls/756,pokt-network/pocket,70a1a0e2fe2c238fce8c2019e13e9167629a2639
https://api.github.com/repos/pokt-network/pocket/pulls/756,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1222325688,Olshansk,8912a94396c3e32975d274b784e18d28e7784167,b83e7add3d4570727d6a171996fe14d5701bf22f,"@@ -0,0 +1,573 @@
+// package trees maintains a set of sparse merkle trees
+// each backed by the KVStore interface. It offers an atomic
+// commit and rollback mechanism for interacting with
+// that core resource map of merkle trees.
+package trees
+
+import (
+	""bytes""
+	""context""
+	""crypto/sha256""
+	""encoding/hex""
+	""fmt""
+
+	""github.com/jackc/pgx/v5""
+
+	""github.com/pokt-network/pocket/persistence/indexer""
+	""github.com/pokt-network/pocket/persistence/kvstore""
+	ptypes ""github.com/pokt-network/pocket/persistence/types""
+	""github.com/pokt-network/pocket/shared/codec""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/crypto""
+	""github.com/pokt-network/smt""
+)
+
+var merkleTreeToString = map[merkleTree]string{
+	appMerkleTree:      ""app"",
+	valMerkleTree:      ""val"",
+	fishMerkleTree:     ""fish"",
+	servicerMerkleTree: ""servicer"",
+
+	accountMerkleTree: ""account"",
+	poolMerkleTree:    ""pool"",
+
+	transactionsMerkleTree: ""transactions"",
+	paramsMerkleTree:       ""params"",
+	flagsMerkleTree:        ""flags"",
+}
+
+var actorTypeToMerkleTreeName = map[coreTypes.ActorType]merkleTree{
+	coreTypes.ActorType_ACTOR_TYPE_APP:      appMerkleTree,
+	coreTypes.ActorType_ACTOR_TYPE_VAL:      valMerkleTree,
+	coreTypes.ActorType_ACTOR_TYPE_FISH:     fishMerkleTree,
+	coreTypes.ActorType_ACTOR_TYPE_SERVICER: servicerMerkleTree,
+}
+
+var actorTypeToSchemaName = map[coreTypes.ActorType]ptypes.ProtocolActorSchema{
+	coreTypes.ActorType_ACTOR_TYPE_APP:      ptypes.ApplicationActor,
+	coreTypes.ActorType_ACTOR_TYPE_VAL:      ptypes.ValidatorActor,
+	coreTypes.ActorType_ACTOR_TYPE_FISH:     ptypes.FishermanActor,
+	coreTypes.ActorType_ACTOR_TYPE_SERVICER: ptypes.ServicerActor,
+}
+
+var merkleTreeToActorTypeName = map[merkleTree]coreTypes.ActorType{
+	appMerkleTree:      coreTypes.ActorType_ACTOR_TYPE_APP,
+	valMerkleTree:      coreTypes.ActorType_ACTOR_TYPE_VAL,
+	fishMerkleTree:     coreTypes.ActorType_ACTOR_TYPE_FISH,
+	servicerMerkleTree: coreTypes.ActorType_ACTOR_TYPE_SERVICER,
+}
+
+type merkleTree float64
+
+// A list of Merkle Trees used to maintain the state hash.
+const (
+	// IMPORTANT: The order in which these trees are defined is important and strict. It implicitly
+	// defines the index of the root hash each independent as they are concatenated together
+	// to generate the state hash.
+
+	// Actor Merkle Trees
+	appMerkleTree merkleTree = iota
+	valMerkleTree
+	fishMerkleTree
+	servicerMerkleTree
+
+	// Account Merkle Trees
+	accountMerkleTree
+	poolMerkleTree
+
+	// Data Merkle Trees
+	transactionsMerkleTree
+	paramsMerkleTree
+	flagsMerkleTree
+
+	// Used for iteration purposes only; see https://stackoverflow.com/a/64178235/768439 as a reference
+	numMerkleTrees
+)
+
+// treeStore stores a set of merkle trees that
+// it manages. It fulfills the modules.TreeStore interface.
+// * It is responsible for commit or rollback behavior
+// of the underlying trees by utilizing the lazy loading
+// functionality provided by the underlying smt library.
+type treeStore struct {
+	treeStoreDir string
+	merkleTrees  map[merkleTree]*smt.SMT
+	nodeStores   map[merkleTree]kvstore.KVStore
+}
+
+// NewStateTrees takes a directory location and a TxIndexer  and returns a TreeStore
+// implementation that guarantees
+func NewStateTrees(dir string) (*treeStore, error) {
+	if dir == """" {
+		return newMemStateTrees()
+	}
+
+	stateTrees := &treeStore{
+		treeStoreDir: dir,
+		merkleTrees:  make(map[merkleTree]*smt.SMT, int(numMerkleTrees)),
+		nodeStores:   make(map[merkleTree]kvstore.KVStore, int(numMerkleTrees)),
+	}
+
+	for tree := merkleTree(0); tree < numMerkleTrees; tree++ {
+		nodeStore, err := kvstore.NewKVStore(fmt.Sprintf(""%s/%s_nodes"", dir, merkleTreeToString[tree]))
+		if err != nil {
+			return nil, err
+		}
+		stateTrees.nodeStores[tree] = nodeStore
+		stateTrees.merkleTrees[tree] = smt.NewSparseMerkleTree(nodeStore, sha256.New())
+	}
+	return stateTrees, nil
+}
+
+// Update takes a transaction and a height and updates
+// all of the trees in the treeStore for that height.
+func (t *treeStore) Update(pgtx pgx.Tx, txi indexer.TxIndexer, height uint64) (string, error) {
+	return t.updateMerkleTrees(pgtx, txi, height)
+}
+
+// DebugClearAll is used by the debug cli to completely reset all merkle trees.
+// This should only be called by the debug CLI.
+func (t *treeStore) DebugClearAll() error {
+	for treeType := merkleTree(0); treeType < numMerkleTrees; treeType++ {
+		nodeStore := t.nodeStores[treeType]
+		if err := nodeStore.ClearAll(); err != nil {
+			return fmt.Errorf(""failed to clear %s node store: %w"", merkleTreeToString[treeType], err)
+		}
+		t.merkleTrees[treeType] = smt.NewSparseMerkleTree(nodeStore, sha256.New())
+	}
+
+	return nil
+}
+
+// newMemStateTrees creates a new in-memory state tree
+func newMemStateTrees() (*treeStore, error) {
+	stateTrees := &treeStore{
+		merkleTrees: make(map[merkleTree]*smt.SMT, int(numMerkleTrees)),
+		nodeStores:  make(map[merkleTree]kvstore.KVStore, int(numMerkleTrees)),
+	}
+	for tree := merkleTree(0); tree < numMerkleTrees; tree++ {
+		nodeStore := kvstore.NewMemKVStore() // For testing, `smt.NewSimpleMap()` can be used as well
+		stateTrees.nodeStores[tree] = nodeStore
+		stateTrees.merkleTrees[tree] = smt.NewSparseMerkleTree(nodeStore, sha256.New())
+	}
+	return stateTrees, nil
+}
+
+// updateMerkleTrees updates all of the merkle trees that TreeStore manages.
+// * it returns an hash of the output or an error.
+func (t *treeStore) updateMerkleTrees(pgtx pgx.Tx, txi indexer.TxIndexer, height uint64) (string, error) {
+	for treeType := merkleTree(0); treeType < numMerkleTrees; treeType++ {
+		switch treeType {
+		// Actor Merkle Trees
+		case appMerkleTree, valMerkleTree, fishMerkleTree, servicerMerkleTree:
+			actorType, ok := merkleTreeToActorTypeName[treeType]
+			if !ok {
+				return """", fmt.Errorf(""no actor type found for merkle tree: %v"", treeType)
+			}
+
+			actors, err := t.getActorsUpdated(pgtx, actorType, height)
+			if err != nil {
+				return """", fmt.Errorf(""failed to get actors at height: %w"", err)
+			}
+
+			if err := t.updateActorsTree(actorType, actors); err != nil {
+				return """", fmt.Errorf(""failed to update actors tree for treeType: %v, actorType: %v - %w"", treeType, actorType, err)
+			}
+
+		// Account Merkle Trees
+		case accountMerkleTree:
+			accounts, err := t.getAccounts(pgtx, height)
+			if err != nil {
+				return """", fmt.Errorf(""failed to get accounts: %w"", err)
+			}
+			if err := t.updateAccountTrees(accounts); err != nil {
+				return """", fmt.Errorf(""failed to update account trees: %w"", err)
+			}
+		case poolMerkleTree:
+			pools, err := t.getPools(pgtx, height)
+			if err != nil {
+				return """", fmt.Errorf(""failed to get transactions: %w"", err)
+			}
+			if err := t.updatePoolTrees(pools); err != nil {
+				return """", fmt.Errorf(""failed to update pool trees - %w"", err)
+			}
+
+		// Data Merkle Trees
+		case transactionsMerkleTree:
+			indexedTxs, err := t.getTransactions(txi, height)
+			if err != nil {
+				return """", fmt.Errorf(""failed to get transactions: %w"", err)
+			}
+			if err := t.updateTransactionsTree(indexedTxs); err != nil {
+				return """", fmt.Errorf(""failed to update transactions: %w"", err)
+			}
+		case paramsMerkleTree:
+			params, err := t.getParams(pgtx, height)
+			if err != nil {
+				return """", fmt.Errorf(""failed to get params: %w"", err)
+			}
+			if err := t.updateParamsTree(params); err != nil {
+				return """", fmt.Errorf(""failed to update params tree: %w"", err)
+			}
+		case flagsMerkleTree:
+			flags, err := t.getFlags(pgtx, height)
+			if err != nil {
+				return """", fmt.Errorf(""failed to get flags from transaction: %w"", err)
+			}
+			if err := t.updateFlagsTree(flags); err != nil {
+				return """", fmt.Errorf(""failed to update flags tree - %w"", err)
+			}
+		// Default
+		default:
+			panic(fmt.Sprintf(""not handled in state commitment update. Merkle tree #{%v}"", treeType))
+		}
+	}
+
+	if err := t.commit(); err != nil {
+		return """", fmt.Errorf(""failed to commit: %w"", err)
+	}
+	return t.getStateHash(), nil
+}
+
+func (t *treeStore) commit() error {
+	for tree := merkleTree(0); tree < numMerkleTrees; tree++ {
+		if err := t.merkleTrees[tree].Commit(); err != nil {
+			return fmt.Errorf(""failed to commit %s: %w"", merkleTreeToString[tree], err)
+		}
+	}
+	return nil
+}
+
+func (t *treeStore) getStateHash() string {
+	// create an order-matters list of roots
+	roots := make([][]byte, 0)
+	for tree := merkleTree(0); tree < numMerkleTrees; tree++ {
+		roots = append(roots, t.merkleTrees[tree].Root())
+	}
+
+	// combine them and hash the result
+	rootsConcat := bytes.Join(roots, []byte{})
+	stateHash := sha256.Sum256(rootsConcat)
+
+	// Convert the array to a slice and return it
+	// REF: https://stackoverflow.com/questions/28886616/convert-array-to-slice-in-go
+	return hex.EncodeToString(stateHash[:])
+}
+
+////////////////////////
+// Actor Tree Helpers //
+////////////////////////
+
+// NB: I think this needs to be done manually for all 4 types.
+func (t *treeStore) updateActorsTree(actorType coreTypes.ActorType, actors []*coreTypes.Actor) error {
+	for _, actor := range actors {
+		bzAddr, err := hex.DecodeString(actor.GetAddress())
+		if err != nil {
+			return err
+		}
+
+		actorBz, err := codec.GetCodec().Marshal(actor)
+		if err != nil {
+			return err
+		}
+
+		merkleTreeName, ok := actorTypeToMerkleTreeName[actorType]
+		if !ok {
+			return fmt.Errorf(""no merkle tree found for actor type: %s"", actorType)
+		}
+		if err := t.merkleTrees[merkleTreeName].Update(bzAddr, actorBz); err != nil {
+			return err
+		}
+	}
+
+	return nil
+}
+
+//////////////////////////
+// Account Tree Helpers //
+//////////////////////////
+
+func (t *treeStore) updateAccountTrees(accounts []*coreTypes.Account) error {
+	for _, account := range accounts {
+		bzAddr, err := hex.DecodeString(account.GetAddress())
+		if err != nil {
+			return err
+		}
+
+		accBz, err := codec.GetCodec().Marshal(account)
+		if err != nil {
+			return err
+		}
+
+		if err := t.merkleTrees[accountMerkleTree].Update(bzAddr, accBz); err != nil {
+			return err
+		}
+	}
+
+	return nil
+}
+
+func (t *treeStore) updatePoolTrees(pools []*coreTypes.Account) error {
+	for _, pool := range pools {
+		bzAddr, err := hex.DecodeString(pool.GetAddress())
+		if err != nil {
+			return err
+		}
+
+		accBz, err := codec.GetCodec().Marshal(pool)
+		if err != nil {
+			return err
+		}
+
+		if err := t.merkleTrees[poolMerkleTree].Update(bzAddr, accBz); err != nil {
+			return err
+		}
+	}
+
+	return nil
+}
+
+///////////////////////
+// Data Tree Helpers //
+///////////////////////
+
+func (t *treeStore) updateTransactionsTree(indexedTxs []*coreTypes.IndexedTransaction) error {
+	for _, idxTx := range indexedTxs {
+		txBz := idxTx.GetTx()
+		txHash := crypto.SHA3Hash(txBz)
+		if err := t.merkleTrees[transactionsMerkleTree].Update(txHash, txBz); err != nil {
+			return err
+		}
+	}
+	return nil
+}
+
+func (t *treeStore) updateParamsTree(params []*coreTypes.Param) error {
+	for _, param := range params {
+		paramBz, err := codec.GetCodec().Marshal(param)
+		paramKey := crypto.SHA3Hash([]byte(param.Name))
+		if err != nil {
+			return err
+		}
+		if err := t.merkleTrees[paramsMerkleTree].Update(paramKey, paramBz); err != nil {
+			return err
+		}
+	}
+
+	return nil
+}
+
+func (t *treeStore) updateFlagsTree(flags []*coreTypes.Flag) error {
+	for _, flag := range flags {
+		flagBz, err := codec.GetCodec().Marshal(flag)
+		flagKey := crypto.SHA3Hash([]byte(flag.Name))
+		if err != nil {
+			return err
+		}
+		if err := t.merkleTrees[flagsMerkleTree].Update(flagKey, flagBz); err != nil {
+			return err
+		}
+	}
+
+	return nil
+}
+
+// getActorsUpdated is responsible for fetching the actors that have been updated at a given height.
+func (t *treeStore) getActorsUpdated(
+	pgtx pgx.Tx,
+	actorType coreTypes.ActorType,
+	height uint64,
+) ([]*coreTypes.Actor, error) {
+	actorSchema, ok := actorTypeToSchemaName[actorType]
+	if !ok {
+		return nil, fmt.Errorf(""no schema found for actor type: %s"", actorType)
+	}
+
+	// TECHDEBT #XXX: Avoid this cast to int64
+	query := actorSchema.GetUpdatedAtHeightQuery(int64(height))
+	rows, err := pgtx.Query(context.TODO(), query)
+	if err != nil {
+		return nil, err
+	}
+	defer rows.Close()
+
+	addrs := make([][]byte, 0)
+	for rows.Next() {
+		var addr string
+		if err := rows.Scan(&addr); err != nil {
+			return nil, err
+		}
+		addrBz, err := hex.DecodeString(addr)
+		if err != nil {
+			return nil, err
+		}
+		addrs = append(addrs, addrBz)
+	}
+
+	actors := make([]*coreTypes.Actor, len(addrs))
+	for i, addr := range addrs {
+		// TECHDEBT #XXX: Avoid this cast to int64",persistence/trees/trees.go,2023-06-08 00:52:27+00:00,2023-06-08T00:54:10Z,We should create a ticket for it if we're referencing the same techdebt item each time,,,,,408,RIGHT,409,,line,https://api.github.com/repos/pokt-network/pocket/pulls/756,pokt-network/pocket,70a1a0e2fe2c238fce8c2019e13e9167629a2639
https://api.github.com/repos/pokt-network/pocket/pulls/756,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1222326678,Olshansk,8912a94396c3e32975d274b784e18d28e7784167,b83e7add3d4570727d6a171996fe14d5701bf22f,"@@ -102,7 +104,7 @@ func (*persistenceModule) Create(bus modules.Bus, options ...modules.ModuleOptio
 		return nil, err
 	}
 
-	stateTrees, err := newStateTrees(persistenceCfg.TreesStoreDir)
+	stateTrees, err := trees.NewStateTrees(persistenceCfg.TreesStoreDir)",persistence/module.go,2023-06-08 00:54:07+00:00,2023-06-08T00:54:10Z,Can you add a TODO (linking to your other PR) to make this a submodule?,,,,108.0,108,RIGHT,33,34.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/756,pokt-network/pocket,70a1a0e2fe2c238fce8c2019e13e9167629a2639
https://api.github.com/repos/pokt-network/pocket/pulls/756,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1230091145,Olshansk,64586305e2aaeb40b5380dde8c922368e4ec8464,b83e7add3d4570727d6a171996fe14d5701bf22f,"@@ -102,7 +104,8 @@ func (*persistenceModule) Create(bus modules.Bus, options ...modules.ModuleOptio
 		return nil, err
 	}
 
-	stateTrees, err := newStateTrees(persistenceCfg.TreesStoreDir)
+	// TECHDEBT (PR #808): Make TreeStore into a full Module",persistence/module.go,2023-06-14 19:48:43+00:00,2023-06-14T20:26:14Z,"```suggestion
	// TECHDEBT(#808): Make TreeStore into a full Module
```",,,,,107,RIGHT,33,,line,https://api.github.com/repos/pokt-network/pocket/pulls/756,pokt-network/pocket,70a1a0e2fe2c238fce8c2019e13e9167629a2639
https://api.github.com/repos/pokt-network/pocket/pulls/756,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1230102472,Olshansk,64586305e2aaeb40b5380dde8c922368e4ec8464,b83e7add3d4570727d6a171996fe14d5701bf22f,"@@ -0,0 +1,574 @@
+// package trees maintains a set of sparse merkle trees
+// each backed by the KVStore interface. It offers an atomic
+// commit and rollback mechanism for interacting with
+// that core resource map of merkle trees.
+package trees
+
+import (
+	""bytes""
+	""context""
+	""crypto/sha256""
+	""encoding/hex""
+	""fmt""
+
+	""github.com/jackc/pgx/v5""
+
+	""github.com/pokt-network/pocket/persistence/indexer""
+	""github.com/pokt-network/pocket/persistence/kvstore""
+	ptypes ""github.com/pokt-network/pocket/persistence/types""
+	""github.com/pokt-network/pocket/shared/codec""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/crypto""
+	""github.com/pokt-network/smt""
+)
+
+var merkleTreeToString = map[merkleTree]string{
+	appMerkleTree:      ""app"",
+	valMerkleTree:      ""val"",
+	fishMerkleTree:     ""fish"",
+	servicerMerkleTree: ""servicer"",
+
+	accountMerkleTree: ""account"",
+	poolMerkleTree:    ""pool"",
+
+	transactionsMerkleTree: ""transactions"",
+	paramsMerkleTree:       ""params"",
+	flagsMerkleTree:        ""flags"",
+}
+
+var actorTypeToMerkleTreeName = map[coreTypes.ActorType]merkleTree{
+	coreTypes.ActorType_ACTOR_TYPE_APP:      appMerkleTree,
+	coreTypes.ActorType_ACTOR_TYPE_VAL:      valMerkleTree,
+	coreTypes.ActorType_ACTOR_TYPE_FISH:     fishMerkleTree,
+	coreTypes.ActorType_ACTOR_TYPE_SERVICER: servicerMerkleTree,
+}
+
+var actorTypeToSchemaName = map[coreTypes.ActorType]ptypes.ProtocolActorSchema{
+	coreTypes.ActorType_ACTOR_TYPE_APP:      ptypes.ApplicationActor,
+	coreTypes.ActorType_ACTOR_TYPE_VAL:      ptypes.ValidatorActor,
+	coreTypes.ActorType_ACTOR_TYPE_FISH:     ptypes.FishermanActor,
+	coreTypes.ActorType_ACTOR_TYPE_SERVICER: ptypes.ServicerActor,
+}
+
+var merkleTreeToActorTypeName = map[merkleTree]coreTypes.ActorType{
+	appMerkleTree:      coreTypes.ActorType_ACTOR_TYPE_APP,
+	valMerkleTree:      coreTypes.ActorType_ACTOR_TYPE_VAL,
+	fishMerkleTree:     coreTypes.ActorType_ACTOR_TYPE_FISH,
+	servicerMerkleTree: coreTypes.ActorType_ACTOR_TYPE_SERVICER,
+}
+
+type merkleTree float64
+
+// A list of Merkle Trees used to maintain the state hash.
+const (
+	// IMPORTANT: The order in which these trees are defined is important and strict. It implicitly
+	// defines the index of the root hash each independent as they are concatenated together
+	// to generate the state hash.
+
+	// Actor Merkle Trees",persistence/trees/trees.go,2023-06-14 20:01:00+00:00,2023-06-14T20:26:14Z,"```suggestion
	// to generate the state hash.
        // TECHDEBT: Enforce this ordering in protobufs using enums

	// Actor Merkle Trees
```",,66.0,RIGHT,,65,RIGHT,68,,line,https://api.github.com/repos/pokt-network/pocket/pulls/756,pokt-network/pocket,70a1a0e2fe2c238fce8c2019e13e9167629a2639
https://api.github.com/repos/pokt-network/pocket/pulls/756,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1230103568,Olshansk,64586305e2aaeb40b5380dde8c922368e4ec8464,b83e7add3d4570727d6a171996fe14d5701bf22f,"@@ -0,0 +1,574 @@
+// package trees maintains a set of sparse merkle trees
+// each backed by the KVStore interface. It offers an atomic
+// commit and rollback mechanism for interacting with
+// that core resource map of merkle trees.
+package trees
+
+import (
+	""bytes""
+	""context""
+	""crypto/sha256""
+	""encoding/hex""
+	""fmt""
+
+	""github.com/jackc/pgx/v5""
+
+	""github.com/pokt-network/pocket/persistence/indexer""
+	""github.com/pokt-network/pocket/persistence/kvstore""
+	ptypes ""github.com/pokt-network/pocket/persistence/types""
+	""github.com/pokt-network/pocket/shared/codec""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/crypto""
+	""github.com/pokt-network/smt""
+)
+
+var merkleTreeToString = map[merkleTree]string{
+	appMerkleTree:      ""app"",
+	valMerkleTree:      ""val"",
+	fishMerkleTree:     ""fish"",
+	servicerMerkleTree: ""servicer"",
+
+	accountMerkleTree: ""account"",
+	poolMerkleTree:    ""pool"",
+
+	transactionsMerkleTree: ""transactions"",
+	paramsMerkleTree:       ""params"",
+	flagsMerkleTree:        ""flags"",
+}
+
+var actorTypeToMerkleTreeName = map[coreTypes.ActorType]merkleTree{
+	coreTypes.ActorType_ACTOR_TYPE_APP:      appMerkleTree,
+	coreTypes.ActorType_ACTOR_TYPE_VAL:      valMerkleTree,
+	coreTypes.ActorType_ACTOR_TYPE_FISH:     fishMerkleTree,
+	coreTypes.ActorType_ACTOR_TYPE_SERVICER: servicerMerkleTree,
+}
+
+var actorTypeToSchemaName = map[coreTypes.ActorType]ptypes.ProtocolActorSchema{
+	coreTypes.ActorType_ACTOR_TYPE_APP:      ptypes.ApplicationActor,
+	coreTypes.ActorType_ACTOR_TYPE_VAL:      ptypes.ValidatorActor,
+	coreTypes.ActorType_ACTOR_TYPE_FISH:     ptypes.FishermanActor,
+	coreTypes.ActorType_ACTOR_TYPE_SERVICER: ptypes.ServicerActor,
+}
+
+var merkleTreeToActorTypeName = map[merkleTree]coreTypes.ActorType{
+	appMerkleTree:      coreTypes.ActorType_ACTOR_TYPE_APP,
+	valMerkleTree:      coreTypes.ActorType_ACTOR_TYPE_VAL,
+	fishMerkleTree:     coreTypes.ActorType_ACTOR_TYPE_FISH,
+	servicerMerkleTree: coreTypes.ActorType_ACTOR_TYPE_SERVICER,
+}
+
+type merkleTree float64
+
+// A list of Merkle Trees used to maintain the state hash.
+const (
+	// IMPORTANT: The order in which these trees are defined is important and strict. It implicitly
+	// defines the index of the root hash each independent as they are concatenated together
+	// to generate the state hash.
+
+	// Actor Merkle Trees
+	appMerkleTree merkleTree = iota
+	valMerkleTree
+	fishMerkleTree
+	servicerMerkleTree
+
+	// Account Merkle Trees
+	accountMerkleTree
+	poolMerkleTree
+
+	// Data Merkle Trees
+	transactionsMerkleTree
+	paramsMerkleTree
+	flagsMerkleTree
+
+	// Used for iteration purposes only; see https://stackoverflow.com/a/64178235/768439 as a reference
+	numMerkleTrees
+)
+
+// treeStore stores a set of merkle trees that
+// it manages. It fulfills the modules.TreeStore interface.
+// * It is responsible for commit or rollback behavior",persistence/trees/trees.go,2023-06-14 20:02:12+00:00,2023-06-14T20:26:14Z,"```suggestion
// * It is responsible for atomic commit or rollback behavior
```",,,,,89,RIGHT,89,,line,https://api.github.com/repos/pokt-network/pocket/pulls/756,pokt-network/pocket,70a1a0e2fe2c238fce8c2019e13e9167629a2639
https://api.github.com/repos/pokt-network/pocket/pulls/756,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1230106214,Olshansk,64586305e2aaeb40b5380dde8c922368e4ec8464,b83e7add3d4570727d6a171996fe14d5701bf22f,"@@ -0,0 +1,574 @@
+// package trees maintains a set of sparse merkle trees
+// each backed by the KVStore interface. It offers an atomic
+// commit and rollback mechanism for interacting with
+// that core resource map of merkle trees.
+package trees
+
+import (
+	""bytes""
+	""context""
+	""crypto/sha256""
+	""encoding/hex""
+	""fmt""
+
+	""github.com/jackc/pgx/v5""
+
+	""github.com/pokt-network/pocket/persistence/indexer""
+	""github.com/pokt-network/pocket/persistence/kvstore""
+	ptypes ""github.com/pokt-network/pocket/persistence/types""
+	""github.com/pokt-network/pocket/shared/codec""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/crypto""
+	""github.com/pokt-network/smt""
+)
+
+var merkleTreeToString = map[merkleTree]string{
+	appMerkleTree:      ""app"",
+	valMerkleTree:      ""val"",
+	fishMerkleTree:     ""fish"",
+	servicerMerkleTree: ""servicer"",
+
+	accountMerkleTree: ""account"",
+	poolMerkleTree:    ""pool"",
+
+	transactionsMerkleTree: ""transactions"",
+	paramsMerkleTree:       ""params"",
+	flagsMerkleTree:        ""flags"",
+}
+
+var actorTypeToMerkleTreeName = map[coreTypes.ActorType]merkleTree{
+	coreTypes.ActorType_ACTOR_TYPE_APP:      appMerkleTree,
+	coreTypes.ActorType_ACTOR_TYPE_VAL:      valMerkleTree,
+	coreTypes.ActorType_ACTOR_TYPE_FISH:     fishMerkleTree,
+	coreTypes.ActorType_ACTOR_TYPE_SERVICER: servicerMerkleTree,
+}
+
+var actorTypeToSchemaName = map[coreTypes.ActorType]ptypes.ProtocolActorSchema{
+	coreTypes.ActorType_ACTOR_TYPE_APP:      ptypes.ApplicationActor,
+	coreTypes.ActorType_ACTOR_TYPE_VAL:      ptypes.ValidatorActor,
+	coreTypes.ActorType_ACTOR_TYPE_FISH:     ptypes.FishermanActor,
+	coreTypes.ActorType_ACTOR_TYPE_SERVICER: ptypes.ServicerActor,
+}
+
+var merkleTreeToActorTypeName = map[merkleTree]coreTypes.ActorType{
+	appMerkleTree:      coreTypes.ActorType_ACTOR_TYPE_APP,
+	valMerkleTree:      coreTypes.ActorType_ACTOR_TYPE_VAL,
+	fishMerkleTree:     coreTypes.ActorType_ACTOR_TYPE_FISH,
+	servicerMerkleTree: coreTypes.ActorType_ACTOR_TYPE_SERVICER,
+}
+
+type merkleTree float64
+
+// A list of Merkle Trees used to maintain the state hash.
+const (
+	// IMPORTANT: The order in which these trees are defined is important and strict. It implicitly
+	// defines the index of the root hash each independent as they are concatenated together
+	// to generate the state hash.
+
+	// Actor Merkle Trees
+	appMerkleTree merkleTree = iota
+	valMerkleTree
+	fishMerkleTree
+	servicerMerkleTree
+
+	// Account Merkle Trees
+	accountMerkleTree
+	poolMerkleTree
+
+	// Data Merkle Trees
+	transactionsMerkleTree
+	paramsMerkleTree
+	flagsMerkleTree
+
+	// Used for iteration purposes only; see https://stackoverflow.com/a/64178235/768439 as a reference
+	numMerkleTrees
+)
+
+// treeStore stores a set of merkle trees that
+// it manages. It fulfills the modules.TreeStore interface.
+// * It is responsible for commit or rollback behavior
+// of the underlying trees by utilizing the lazy loading",persistence/trees/trees.go,2023-06-14 20:05:17+00:00,2023-06-14T20:26:14Z,"I can't believe I just realized that ""lazy loading"" is what enables this 🤯 

",,,,87.0,87,RIGHT,90,87.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/756,pokt-network/pocket,70a1a0e2fe2c238fce8c2019e13e9167629a2639
https://api.github.com/repos/pokt-network/pocket/pulls/756,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1230108124,Olshansk,64586305e2aaeb40b5380dde8c922368e4ec8464,b83e7add3d4570727d6a171996fe14d5701bf22f,"@@ -0,0 +1,574 @@
+// package trees maintains a set of sparse merkle trees
+// each backed by the KVStore interface. It offers an atomic
+// commit and rollback mechanism for interacting with
+// that core resource map of merkle trees.
+package trees
+
+import (
+	""bytes""
+	""context""
+	""crypto/sha256""
+	""encoding/hex""
+	""fmt""
+
+	""github.com/jackc/pgx/v5""
+
+	""github.com/pokt-network/pocket/persistence/indexer""
+	""github.com/pokt-network/pocket/persistence/kvstore""
+	ptypes ""github.com/pokt-network/pocket/persistence/types""
+	""github.com/pokt-network/pocket/shared/codec""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/crypto""
+	""github.com/pokt-network/smt""
+)
+
+var merkleTreeToString = map[merkleTree]string{
+	appMerkleTree:      ""app"",
+	valMerkleTree:      ""val"",
+	fishMerkleTree:     ""fish"",
+	servicerMerkleTree: ""servicer"",
+
+	accountMerkleTree: ""account"",
+	poolMerkleTree:    ""pool"",
+
+	transactionsMerkleTree: ""transactions"",
+	paramsMerkleTree:       ""params"",
+	flagsMerkleTree:        ""flags"",
+}
+
+var actorTypeToMerkleTreeName = map[coreTypes.ActorType]merkleTree{
+	coreTypes.ActorType_ACTOR_TYPE_APP:      appMerkleTree,
+	coreTypes.ActorType_ACTOR_TYPE_VAL:      valMerkleTree,
+	coreTypes.ActorType_ACTOR_TYPE_FISH:     fishMerkleTree,
+	coreTypes.ActorType_ACTOR_TYPE_SERVICER: servicerMerkleTree,
+}
+
+var actorTypeToSchemaName = map[coreTypes.ActorType]ptypes.ProtocolActorSchema{
+	coreTypes.ActorType_ACTOR_TYPE_APP:      ptypes.ApplicationActor,
+	coreTypes.ActorType_ACTOR_TYPE_VAL:      ptypes.ValidatorActor,
+	coreTypes.ActorType_ACTOR_TYPE_FISH:     ptypes.FishermanActor,
+	coreTypes.ActorType_ACTOR_TYPE_SERVICER: ptypes.ServicerActor,
+}
+
+var merkleTreeToActorTypeName = map[merkleTree]coreTypes.ActorType{
+	appMerkleTree:      coreTypes.ActorType_ACTOR_TYPE_APP,
+	valMerkleTree:      coreTypes.ActorType_ACTOR_TYPE_VAL,
+	fishMerkleTree:     coreTypes.ActorType_ACTOR_TYPE_FISH,
+	servicerMerkleTree: coreTypes.ActorType_ACTOR_TYPE_SERVICER,
+}
+
+type merkleTree float64
+
+// A list of Merkle Trees used to maintain the state hash.
+const (
+	// IMPORTANT: The order in which these trees are defined is important and strict. It implicitly
+	// defines the index of the root hash each independent as they are concatenated together
+	// to generate the state hash.
+
+	// Actor Merkle Trees
+	appMerkleTree merkleTree = iota
+	valMerkleTree
+	fishMerkleTree
+	servicerMerkleTree
+
+	// Account Merkle Trees
+	accountMerkleTree
+	poolMerkleTree
+
+	// Data Merkle Trees
+	transactionsMerkleTree
+	paramsMerkleTree
+	flagsMerkleTree
+
+	// Used for iteration purposes only; see https://stackoverflow.com/a/64178235/768439 as a reference
+	numMerkleTrees
+)
+
+// treeStore stores a set of merkle trees that
+// it manages. It fulfills the modules.TreeStore interface.
+// * It is responsible for commit or rollback behavior
+// of the underlying trees by utilizing the lazy loading
+// functionality provided by the underlying smt library.
+type treeStore struct {
+	treeStoreDir string
+	merkleTrees  map[merkleTree]*smt.SMT
+	nodeStores   map[merkleTree]kvstore.KVStore
+}
+
+// Update takes a transaction and a height and updates",persistence/trees/trees.go,2023-06-14 20:07:35+00:00,2023-06-14T20:26:14Z,"```suggestion
// Update takes an indexed transaction and a height and updates
```",,,,,100,RIGHT,98,,line,https://api.github.com/repos/pokt-network/pocket/pulls/756,pokt-network/pocket,70a1a0e2fe2c238fce8c2019e13e9167629a2639
https://api.github.com/repos/pokt-network/pocket/pulls/756,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1230108371,Olshansk,64586305e2aaeb40b5380dde8c922368e4ec8464,b83e7add3d4570727d6a171996fe14d5701bf22f,"@@ -0,0 +1,574 @@
+// package trees maintains a set of sparse merkle trees
+// each backed by the KVStore interface. It offers an atomic
+// commit and rollback mechanism for interacting with
+// that core resource map of merkle trees.
+package trees
+
+import (
+	""bytes""
+	""context""
+	""crypto/sha256""
+	""encoding/hex""
+	""fmt""
+
+	""github.com/jackc/pgx/v5""
+
+	""github.com/pokt-network/pocket/persistence/indexer""
+	""github.com/pokt-network/pocket/persistence/kvstore""
+	ptypes ""github.com/pokt-network/pocket/persistence/types""
+	""github.com/pokt-network/pocket/shared/codec""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/crypto""
+	""github.com/pokt-network/smt""
+)
+
+var merkleTreeToString = map[merkleTree]string{
+	appMerkleTree:      ""app"",
+	valMerkleTree:      ""val"",
+	fishMerkleTree:     ""fish"",
+	servicerMerkleTree: ""servicer"",
+
+	accountMerkleTree: ""account"",
+	poolMerkleTree:    ""pool"",
+
+	transactionsMerkleTree: ""transactions"",
+	paramsMerkleTree:       ""params"",
+	flagsMerkleTree:        ""flags"",
+}
+
+var actorTypeToMerkleTreeName = map[coreTypes.ActorType]merkleTree{
+	coreTypes.ActorType_ACTOR_TYPE_APP:      appMerkleTree,
+	coreTypes.ActorType_ACTOR_TYPE_VAL:      valMerkleTree,
+	coreTypes.ActorType_ACTOR_TYPE_FISH:     fishMerkleTree,
+	coreTypes.ActorType_ACTOR_TYPE_SERVICER: servicerMerkleTree,
+}
+
+var actorTypeToSchemaName = map[coreTypes.ActorType]ptypes.ProtocolActorSchema{
+	coreTypes.ActorType_ACTOR_TYPE_APP:      ptypes.ApplicationActor,
+	coreTypes.ActorType_ACTOR_TYPE_VAL:      ptypes.ValidatorActor,
+	coreTypes.ActorType_ACTOR_TYPE_FISH:     ptypes.FishermanActor,
+	coreTypes.ActorType_ACTOR_TYPE_SERVICER: ptypes.ServicerActor,
+}
+
+var merkleTreeToActorTypeName = map[merkleTree]coreTypes.ActorType{
+	appMerkleTree:      coreTypes.ActorType_ACTOR_TYPE_APP,
+	valMerkleTree:      coreTypes.ActorType_ACTOR_TYPE_VAL,
+	fishMerkleTree:     coreTypes.ActorType_ACTOR_TYPE_FISH,
+	servicerMerkleTree: coreTypes.ActorType_ACTOR_TYPE_SERVICER,
+}
+
+type merkleTree float64
+
+// A list of Merkle Trees used to maintain the state hash.
+const (
+	// IMPORTANT: The order in which these trees are defined is important and strict. It implicitly
+	// defines the index of the root hash each independent as they are concatenated together
+	// to generate the state hash.
+
+	// Actor Merkle Trees
+	appMerkleTree merkleTree = iota
+	valMerkleTree
+	fishMerkleTree
+	servicerMerkleTree
+
+	// Account Merkle Trees
+	accountMerkleTree
+	poolMerkleTree
+
+	// Data Merkle Trees
+	transactionsMerkleTree
+	paramsMerkleTree
+	flagsMerkleTree
+
+	// Used for iteration purposes only; see https://stackoverflow.com/a/64178235/768439 as a reference
+	numMerkleTrees
+)
+
+// treeStore stores a set of merkle trees that
+// it manages. It fulfills the modules.TreeStore interface.
+// * It is responsible for commit or rollback behavior
+// of the underlying trees by utilizing the lazy loading
+// functionality provided by the underlying smt library.
+type treeStore struct {
+	treeStoreDir string
+	merkleTrees  map[merkleTree]*smt.SMT
+	nodeStores   map[merkleTree]kvstore.KVStore
+}
+
+// Update takes a transaction and a height and updates
+// all of the trees in the treeStore for that height.",persistence/trees/trees.go,2023-06-14 20:07:53+00:00,2023-06-14T20:26:14Z,"```suggestion
// all of the trees in the treeStore affected by that transaction for that height.
```",,,,,101,RIGHT,99,,line,https://api.github.com/repos/pokt-network/pocket/pulls/756,pokt-network/pocket,70a1a0e2fe2c238fce8c2019e13e9167629a2639
https://api.github.com/repos/pokt-network/pocket/pulls/756,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1230110454,Olshansk,64586305e2aaeb40b5380dde8c922368e4ec8464,b83e7add3d4570727d6a171996fe14d5701bf22f,"@@ -0,0 +1,574 @@
+// package trees maintains a set of sparse merkle trees
+// each backed by the KVStore interface. It offers an atomic
+// commit and rollback mechanism for interacting with
+// that core resource map of merkle trees.
+package trees
+
+import (
+	""bytes""
+	""context""
+	""crypto/sha256""
+	""encoding/hex""
+	""fmt""
+
+	""github.com/jackc/pgx/v5""
+
+	""github.com/pokt-network/pocket/persistence/indexer""
+	""github.com/pokt-network/pocket/persistence/kvstore""
+	ptypes ""github.com/pokt-network/pocket/persistence/types""
+	""github.com/pokt-network/pocket/shared/codec""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/crypto""
+	""github.com/pokt-network/smt""
+)
+
+var merkleTreeToString = map[merkleTree]string{
+	appMerkleTree:      ""app"",
+	valMerkleTree:      ""val"",
+	fishMerkleTree:     ""fish"",
+	servicerMerkleTree: ""servicer"",
+
+	accountMerkleTree: ""account"",
+	poolMerkleTree:    ""pool"",
+
+	transactionsMerkleTree: ""transactions"",
+	paramsMerkleTree:       ""params"",
+	flagsMerkleTree:        ""flags"",
+}
+
+var actorTypeToMerkleTreeName = map[coreTypes.ActorType]merkleTree{
+	coreTypes.ActorType_ACTOR_TYPE_APP:      appMerkleTree,
+	coreTypes.ActorType_ACTOR_TYPE_VAL:      valMerkleTree,
+	coreTypes.ActorType_ACTOR_TYPE_FISH:     fishMerkleTree,
+	coreTypes.ActorType_ACTOR_TYPE_SERVICER: servicerMerkleTree,
+}
+
+var actorTypeToSchemaName = map[coreTypes.ActorType]ptypes.ProtocolActorSchema{
+	coreTypes.ActorType_ACTOR_TYPE_APP:      ptypes.ApplicationActor,
+	coreTypes.ActorType_ACTOR_TYPE_VAL:      ptypes.ValidatorActor,
+	coreTypes.ActorType_ACTOR_TYPE_FISH:     ptypes.FishermanActor,
+	coreTypes.ActorType_ACTOR_TYPE_SERVICER: ptypes.ServicerActor,
+}
+
+var merkleTreeToActorTypeName = map[merkleTree]coreTypes.ActorType{
+	appMerkleTree:      coreTypes.ActorType_ACTOR_TYPE_APP,
+	valMerkleTree:      coreTypes.ActorType_ACTOR_TYPE_VAL,
+	fishMerkleTree:     coreTypes.ActorType_ACTOR_TYPE_FISH,
+	servicerMerkleTree: coreTypes.ActorType_ACTOR_TYPE_SERVICER,
+}
+
+type merkleTree float64
+
+// A list of Merkle Trees used to maintain the state hash.
+const (
+	// IMPORTANT: The order in which these trees are defined is important and strict. It implicitly
+	// defines the index of the root hash each independent as they are concatenated together
+	// to generate the state hash.
+
+	// Actor Merkle Trees
+	appMerkleTree merkleTree = iota
+	valMerkleTree
+	fishMerkleTree
+	servicerMerkleTree
+
+	// Account Merkle Trees
+	accountMerkleTree
+	poolMerkleTree
+
+	// Data Merkle Trees
+	transactionsMerkleTree
+	paramsMerkleTree
+	flagsMerkleTree
+
+	// Used for iteration purposes only; see https://stackoverflow.com/a/64178235/768439 as a reference
+	numMerkleTrees
+)
+
+// treeStore stores a set of merkle trees that
+// it manages. It fulfills the modules.TreeStore interface.
+// * It is responsible for commit or rollback behavior
+// of the underlying trees by utilizing the lazy loading
+// functionality provided by the underlying smt library.
+type treeStore struct {
+	treeStoreDir string
+	merkleTrees  map[merkleTree]*smt.SMT
+	nodeStores   map[merkleTree]kvstore.KVStore
+}
+
+// Update takes a transaction and a height and updates
+// all of the trees in the treeStore for that height.
+func (t *treeStore) Update(pgtx pgx.Tx, txi indexer.TxIndexer, height uint64) (string, error) {
+	return t.updateMerkleTrees(pgtx, txi, height)
+}
+
+func NewStateTrees(treesStoreDir string) (*treeStore, error) {
+	if treesStoreDir == "":memory:"" {
+		return newMemStateTrees()
+	}
+
+	stateTrees := &treeStore{
+		treeStoreDir: treesStoreDir,
+		merkleTrees:  make(map[merkleTree]*smt.SMT, int(numMerkleTrees)),
+		nodeStores:   make(map[merkleTree]kvstore.KVStore, int(numMerkleTrees)),
+	}
+
+	for tree := merkleTree(0); tree < numMerkleTrees; tree++ {
+		nodeStore, err := kvstore.NewKVStore(fmt.Sprintf(""%s/%s_nodes"", treesStoreDir, merkleTreeToString[tree]))
+		if err != nil {
+			return nil, err
+		}
+		stateTrees.nodeStores[tree] = nodeStore
+		stateTrees.merkleTrees[tree] = smt.NewSparseMerkleTree(nodeStore, sha256.New())",persistence/trees/trees.go,2023-06-14 20:10:03+00:00,2023-06-14T20:26:14Z,"Can you move `sha256.New` into a local constant called `smtPathHasher` so it's not ""hidden"" in the code",,,,,123,RIGHT,121,,line,https://api.github.com/repos/pokt-network/pocket/pulls/756,pokt-network/pocket,70a1a0e2fe2c238fce8c2019e13e9167629a2639
https://api.github.com/repos/pokt-network/pocket/pulls/756,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1230110953,Olshansk,64586305e2aaeb40b5380dde8c922368e4ec8464,b83e7add3d4570727d6a171996fe14d5701bf22f,"@@ -0,0 +1,574 @@
+// package trees maintains a set of sparse merkle trees
+// each backed by the KVStore interface. It offers an atomic
+// commit and rollback mechanism for interacting with
+// that core resource map of merkle trees.
+package trees
+
+import (
+	""bytes""
+	""context""
+	""crypto/sha256""
+	""encoding/hex""
+	""fmt""
+
+	""github.com/jackc/pgx/v5""
+
+	""github.com/pokt-network/pocket/persistence/indexer""
+	""github.com/pokt-network/pocket/persistence/kvstore""
+	ptypes ""github.com/pokt-network/pocket/persistence/types""
+	""github.com/pokt-network/pocket/shared/codec""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/crypto""
+	""github.com/pokt-network/smt""
+)
+
+var merkleTreeToString = map[merkleTree]string{
+	appMerkleTree:      ""app"",
+	valMerkleTree:      ""val"",
+	fishMerkleTree:     ""fish"",
+	servicerMerkleTree: ""servicer"",
+
+	accountMerkleTree: ""account"",
+	poolMerkleTree:    ""pool"",
+
+	transactionsMerkleTree: ""transactions"",
+	paramsMerkleTree:       ""params"",
+	flagsMerkleTree:        ""flags"",
+}
+
+var actorTypeToMerkleTreeName = map[coreTypes.ActorType]merkleTree{
+	coreTypes.ActorType_ACTOR_TYPE_APP:      appMerkleTree,
+	coreTypes.ActorType_ACTOR_TYPE_VAL:      valMerkleTree,
+	coreTypes.ActorType_ACTOR_TYPE_FISH:     fishMerkleTree,
+	coreTypes.ActorType_ACTOR_TYPE_SERVICER: servicerMerkleTree,
+}
+
+var actorTypeToSchemaName = map[coreTypes.ActorType]ptypes.ProtocolActorSchema{
+	coreTypes.ActorType_ACTOR_TYPE_APP:      ptypes.ApplicationActor,
+	coreTypes.ActorType_ACTOR_TYPE_VAL:      ptypes.ValidatorActor,
+	coreTypes.ActorType_ACTOR_TYPE_FISH:     ptypes.FishermanActor,
+	coreTypes.ActorType_ACTOR_TYPE_SERVICER: ptypes.ServicerActor,
+}
+
+var merkleTreeToActorTypeName = map[merkleTree]coreTypes.ActorType{
+	appMerkleTree:      coreTypes.ActorType_ACTOR_TYPE_APP,
+	valMerkleTree:      coreTypes.ActorType_ACTOR_TYPE_VAL,
+	fishMerkleTree:     coreTypes.ActorType_ACTOR_TYPE_FISH,
+	servicerMerkleTree: coreTypes.ActorType_ACTOR_TYPE_SERVICER,
+}
+
+type merkleTree float64
+
+// A list of Merkle Trees used to maintain the state hash.
+const (
+	// IMPORTANT: The order in which these trees are defined is important and strict. It implicitly
+	// defines the index of the root hash each independent as they are concatenated together
+	// to generate the state hash.
+
+	// Actor Merkle Trees
+	appMerkleTree merkleTree = iota
+	valMerkleTree
+	fishMerkleTree
+	servicerMerkleTree
+
+	// Account Merkle Trees
+	accountMerkleTree
+	poolMerkleTree
+
+	// Data Merkle Trees
+	transactionsMerkleTree
+	paramsMerkleTree
+	flagsMerkleTree
+
+	// Used for iteration purposes only; see https://stackoverflow.com/a/64178235/768439 as a reference
+	numMerkleTrees
+)
+
+// treeStore stores a set of merkle trees that
+// it manages. It fulfills the modules.TreeStore interface.
+// * It is responsible for commit or rollback behavior
+// of the underlying trees by utilizing the lazy loading
+// functionality provided by the underlying smt library.
+type treeStore struct {
+	treeStoreDir string
+	merkleTrees  map[merkleTree]*smt.SMT
+	nodeStores   map[merkleTree]kvstore.KVStore
+}
+
+// Update takes a transaction and a height and updates
+// all of the trees in the treeStore for that height.
+func (t *treeStore) Update(pgtx pgx.Tx, txi indexer.TxIndexer, height uint64) (string, error) {
+	return t.updateMerkleTrees(pgtx, txi, height)
+}
+
+func NewStateTrees(treesStoreDir string) (*treeStore, error) {
+	if treesStoreDir == "":memory:"" {
+		return newMemStateTrees()
+	}
+
+	stateTrees := &treeStore{
+		treeStoreDir: treesStoreDir,
+		merkleTrees:  make(map[merkleTree]*smt.SMT, int(numMerkleTrees)),
+		nodeStores:   make(map[merkleTree]kvstore.KVStore, int(numMerkleTrees)),
+	}
+
+	for tree := merkleTree(0); tree < numMerkleTrees; tree++ {
+		nodeStore, err := kvstore.NewKVStore(fmt.Sprintf(""%s/%s_nodes"", treesStoreDir, merkleTreeToString[tree]))",persistence/trees/trees.go,2023-06-14 20:10:35+00:00,2023-06-14T20:26:14Z,Optional NIT: Move the formatted string into a local var at the top of the file so it's easier to see where/how we store the data.,,,,113.0,113,RIGHT,116,113.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/756,pokt-network/pocket,70a1a0e2fe2c238fce8c2019e13e9167629a2639
https://api.github.com/repos/pokt-network/pocket/pulls/756,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1230111375,Olshansk,64586305e2aaeb40b5380dde8c922368e4ec8464,b83e7add3d4570727d6a171996fe14d5701bf22f,"@@ -0,0 +1,574 @@
+// package trees maintains a set of sparse merkle trees
+// each backed by the KVStore interface. It offers an atomic
+// commit and rollback mechanism for interacting with
+// that core resource map of merkle trees.
+package trees
+
+import (
+	""bytes""
+	""context""
+	""crypto/sha256""
+	""encoding/hex""
+	""fmt""
+
+	""github.com/jackc/pgx/v5""
+
+	""github.com/pokt-network/pocket/persistence/indexer""
+	""github.com/pokt-network/pocket/persistence/kvstore""
+	ptypes ""github.com/pokt-network/pocket/persistence/types""
+	""github.com/pokt-network/pocket/shared/codec""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/crypto""
+	""github.com/pokt-network/smt""
+)
+
+var merkleTreeToString = map[merkleTree]string{
+	appMerkleTree:      ""app"",
+	valMerkleTree:      ""val"",
+	fishMerkleTree:     ""fish"",
+	servicerMerkleTree: ""servicer"",
+
+	accountMerkleTree: ""account"",
+	poolMerkleTree:    ""pool"",
+
+	transactionsMerkleTree: ""transactions"",
+	paramsMerkleTree:       ""params"",
+	flagsMerkleTree:        ""flags"",
+}
+
+var actorTypeToMerkleTreeName = map[coreTypes.ActorType]merkleTree{
+	coreTypes.ActorType_ACTOR_TYPE_APP:      appMerkleTree,
+	coreTypes.ActorType_ACTOR_TYPE_VAL:      valMerkleTree,
+	coreTypes.ActorType_ACTOR_TYPE_FISH:     fishMerkleTree,
+	coreTypes.ActorType_ACTOR_TYPE_SERVICER: servicerMerkleTree,
+}
+
+var actorTypeToSchemaName = map[coreTypes.ActorType]ptypes.ProtocolActorSchema{
+	coreTypes.ActorType_ACTOR_TYPE_APP:      ptypes.ApplicationActor,
+	coreTypes.ActorType_ACTOR_TYPE_VAL:      ptypes.ValidatorActor,
+	coreTypes.ActorType_ACTOR_TYPE_FISH:     ptypes.FishermanActor,
+	coreTypes.ActorType_ACTOR_TYPE_SERVICER: ptypes.ServicerActor,
+}
+
+var merkleTreeToActorTypeName = map[merkleTree]coreTypes.ActorType{
+	appMerkleTree:      coreTypes.ActorType_ACTOR_TYPE_APP,
+	valMerkleTree:      coreTypes.ActorType_ACTOR_TYPE_VAL,
+	fishMerkleTree:     coreTypes.ActorType_ACTOR_TYPE_FISH,
+	servicerMerkleTree: coreTypes.ActorType_ACTOR_TYPE_SERVICER,
+}
+
+type merkleTree float64
+
+// A list of Merkle Trees used to maintain the state hash.
+const (
+	// IMPORTANT: The order in which these trees are defined is important and strict. It implicitly
+	// defines the index of the root hash each independent as they are concatenated together
+	// to generate the state hash.
+
+	// Actor Merkle Trees
+	appMerkleTree merkleTree = iota
+	valMerkleTree
+	fishMerkleTree
+	servicerMerkleTree
+
+	// Account Merkle Trees
+	accountMerkleTree
+	poolMerkleTree
+
+	// Data Merkle Trees
+	transactionsMerkleTree
+	paramsMerkleTree
+	flagsMerkleTree
+
+	// Used for iteration purposes only; see https://stackoverflow.com/a/64178235/768439 as a reference
+	numMerkleTrees
+)
+
+// treeStore stores a set of merkle trees that
+// it manages. It fulfills the modules.TreeStore interface.
+// * It is responsible for commit or rollback behavior
+// of the underlying trees by utilizing the lazy loading
+// functionality provided by the underlying smt library.
+type treeStore struct {
+	treeStoreDir string
+	merkleTrees  map[merkleTree]*smt.SMT
+	nodeStores   map[merkleTree]kvstore.KVStore
+}
+
+// Update takes a transaction and a height and updates
+// all of the trees in the treeStore for that height.
+func (t *treeStore) Update(pgtx pgx.Tx, txi indexer.TxIndexer, height uint64) (string, error) {
+	return t.updateMerkleTrees(pgtx, txi, height)
+}
+
+func NewStateTrees(treesStoreDir string) (*treeStore, error) {
+	if treesStoreDir == "":memory:"" {
+		return newMemStateTrees()
+	}
+
+	stateTrees := &treeStore{
+		treeStoreDir: treesStoreDir,
+		merkleTrees:  make(map[merkleTree]*smt.SMT, int(numMerkleTrees)),
+		nodeStores:   make(map[merkleTree]kvstore.KVStore, int(numMerkleTrees)),
+	}
+
+	for tree := merkleTree(0); tree < numMerkleTrees; tree++ {
+		nodeStore, err := kvstore.NewKVStore(fmt.Sprintf(""%s/%s_nodes"", treesStoreDir, merkleTreeToString[tree]))
+		if err != nil {
+			return nil, err
+		}
+		stateTrees.nodeStores[tree] = nodeStore
+		stateTrees.merkleTrees[tree] = smt.NewSparseMerkleTree(nodeStore, sha256.New())
+	}
+	return stateTrees, nil
+}
+
+// DebugClearAll is used by the debug cli to completely reset all merkle trees.
+// This should only be called by the debug CLI.
+func (t *treeStore) DebugClearAll() error {",persistence/trees/trees.go,2023-06-14 20:11:04+00:00,2023-06-14T20:26:14Z,"```suggestion
// TECHDEBT: Move this into a separate file with a debug build flag to avoid accidental usage in prod
func (t *treeStore) DebugClearAll() error {
```",,,,126.0,126,RIGHT,128,126.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/756,pokt-network/pocket,70a1a0e2fe2c238fce8c2019e13e9167629a2639
https://api.github.com/repos/pokt-network/pocket/pulls/756,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1230112435,Olshansk,64586305e2aaeb40b5380dde8c922368e4ec8464,b83e7add3d4570727d6a171996fe14d5701bf22f,"@@ -0,0 +1,574 @@
+// package trees maintains a set of sparse merkle trees
+// each backed by the KVStore interface. It offers an atomic
+// commit and rollback mechanism for interacting with
+// that core resource map of merkle trees.
+package trees
+
+import (
+	""bytes""
+	""context""
+	""crypto/sha256""
+	""encoding/hex""
+	""fmt""
+
+	""github.com/jackc/pgx/v5""
+
+	""github.com/pokt-network/pocket/persistence/indexer""
+	""github.com/pokt-network/pocket/persistence/kvstore""
+	ptypes ""github.com/pokt-network/pocket/persistence/types""
+	""github.com/pokt-network/pocket/shared/codec""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/crypto""
+	""github.com/pokt-network/smt""
+)
+
+var merkleTreeToString = map[merkleTree]string{
+	appMerkleTree:      ""app"",
+	valMerkleTree:      ""val"",
+	fishMerkleTree:     ""fish"",
+	servicerMerkleTree: ""servicer"",
+
+	accountMerkleTree: ""account"",
+	poolMerkleTree:    ""pool"",
+
+	transactionsMerkleTree: ""transactions"",
+	paramsMerkleTree:       ""params"",
+	flagsMerkleTree:        ""flags"",
+}
+
+var actorTypeToMerkleTreeName = map[coreTypes.ActorType]merkleTree{
+	coreTypes.ActorType_ACTOR_TYPE_APP:      appMerkleTree,
+	coreTypes.ActorType_ACTOR_TYPE_VAL:      valMerkleTree,
+	coreTypes.ActorType_ACTOR_TYPE_FISH:     fishMerkleTree,
+	coreTypes.ActorType_ACTOR_TYPE_SERVICER: servicerMerkleTree,
+}
+
+var actorTypeToSchemaName = map[coreTypes.ActorType]ptypes.ProtocolActorSchema{
+	coreTypes.ActorType_ACTOR_TYPE_APP:      ptypes.ApplicationActor,
+	coreTypes.ActorType_ACTOR_TYPE_VAL:      ptypes.ValidatorActor,
+	coreTypes.ActorType_ACTOR_TYPE_FISH:     ptypes.FishermanActor,
+	coreTypes.ActorType_ACTOR_TYPE_SERVICER: ptypes.ServicerActor,
+}
+
+var merkleTreeToActorTypeName = map[merkleTree]coreTypes.ActorType{
+	appMerkleTree:      coreTypes.ActorType_ACTOR_TYPE_APP,
+	valMerkleTree:      coreTypes.ActorType_ACTOR_TYPE_VAL,
+	fishMerkleTree:     coreTypes.ActorType_ACTOR_TYPE_FISH,
+	servicerMerkleTree: coreTypes.ActorType_ACTOR_TYPE_SERVICER,
+}
+
+type merkleTree float64
+
+// A list of Merkle Trees used to maintain the state hash.
+const (
+	// IMPORTANT: The order in which these trees are defined is important and strict. It implicitly
+	// defines the index of the root hash each independent as they are concatenated together
+	// to generate the state hash.
+
+	// Actor Merkle Trees
+	appMerkleTree merkleTree = iota
+	valMerkleTree
+	fishMerkleTree
+	servicerMerkleTree
+
+	// Account Merkle Trees
+	accountMerkleTree
+	poolMerkleTree
+
+	// Data Merkle Trees
+	transactionsMerkleTree
+	paramsMerkleTree
+	flagsMerkleTree
+
+	// Used for iteration purposes only; see https://stackoverflow.com/a/64178235/768439 as a reference
+	numMerkleTrees
+)
+
+// treeStore stores a set of merkle trees that
+// it manages. It fulfills the modules.TreeStore interface.
+// * It is responsible for commit or rollback behavior
+// of the underlying trees by utilizing the lazy loading
+// functionality provided by the underlying smt library.
+type treeStore struct {
+	treeStoreDir string
+	merkleTrees  map[merkleTree]*smt.SMT
+	nodeStores   map[merkleTree]kvstore.KVStore
+}
+
+// Update takes a transaction and a height and updates
+// all of the trees in the treeStore for that height.
+func (t *treeStore) Update(pgtx pgx.Tx, txi indexer.TxIndexer, height uint64) (string, error) {
+	return t.updateMerkleTrees(pgtx, txi, height)
+}
+
+func NewStateTrees(treesStoreDir string) (*treeStore, error) {",persistence/trees/trees.go,2023-06-14 20:12:14+00:00,2023-06-14T20:26:14Z,Can you add a comment? `NewStateTrees ...`,,,,101.0,101,RIGHT,104,101.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/756,pokt-network/pocket,70a1a0e2fe2c238fce8c2019e13e9167629a2639
https://api.github.com/repos/pokt-network/pocket/pulls/756,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1230113522,Olshansk,64586305e2aaeb40b5380dde8c922368e4ec8464,b83e7add3d4570727d6a171996fe14d5701bf22f,"@@ -0,0 +1,574 @@
+// package trees maintains a set of sparse merkle trees
+// each backed by the KVStore interface. It offers an atomic
+// commit and rollback mechanism for interacting with
+// that core resource map of merkle trees.
+package trees
+
+import (
+	""bytes""
+	""context""
+	""crypto/sha256""
+	""encoding/hex""
+	""fmt""
+
+	""github.com/jackc/pgx/v5""
+
+	""github.com/pokt-network/pocket/persistence/indexer""
+	""github.com/pokt-network/pocket/persistence/kvstore""
+	ptypes ""github.com/pokt-network/pocket/persistence/types""
+	""github.com/pokt-network/pocket/shared/codec""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/crypto""
+	""github.com/pokt-network/smt""
+)
+
+var merkleTreeToString = map[merkleTree]string{
+	appMerkleTree:      ""app"",
+	valMerkleTree:      ""val"",
+	fishMerkleTree:     ""fish"",
+	servicerMerkleTree: ""servicer"",
+
+	accountMerkleTree: ""account"",
+	poolMerkleTree:    ""pool"",
+
+	transactionsMerkleTree: ""transactions"",
+	paramsMerkleTree:       ""params"",
+	flagsMerkleTree:        ""flags"",
+}
+
+var actorTypeToMerkleTreeName = map[coreTypes.ActorType]merkleTree{
+	coreTypes.ActorType_ACTOR_TYPE_APP:      appMerkleTree,
+	coreTypes.ActorType_ACTOR_TYPE_VAL:      valMerkleTree,
+	coreTypes.ActorType_ACTOR_TYPE_FISH:     fishMerkleTree,
+	coreTypes.ActorType_ACTOR_TYPE_SERVICER: servicerMerkleTree,
+}
+
+var actorTypeToSchemaName = map[coreTypes.ActorType]ptypes.ProtocolActorSchema{
+	coreTypes.ActorType_ACTOR_TYPE_APP:      ptypes.ApplicationActor,
+	coreTypes.ActorType_ACTOR_TYPE_VAL:      ptypes.ValidatorActor,
+	coreTypes.ActorType_ACTOR_TYPE_FISH:     ptypes.FishermanActor,
+	coreTypes.ActorType_ACTOR_TYPE_SERVICER: ptypes.ServicerActor,
+}
+
+var merkleTreeToActorTypeName = map[merkleTree]coreTypes.ActorType{
+	appMerkleTree:      coreTypes.ActorType_ACTOR_TYPE_APP,
+	valMerkleTree:      coreTypes.ActorType_ACTOR_TYPE_VAL,
+	fishMerkleTree:     coreTypes.ActorType_ACTOR_TYPE_FISH,
+	servicerMerkleTree: coreTypes.ActorType_ACTOR_TYPE_SERVICER,
+}
+
+type merkleTree float64
+
+// A list of Merkle Trees used to maintain the state hash.
+const (
+	// IMPORTANT: The order in which these trees are defined is important and strict. It implicitly
+	// defines the index of the root hash each independent as they are concatenated together
+	// to generate the state hash.
+
+	// Actor Merkle Trees
+	appMerkleTree merkleTree = iota
+	valMerkleTree
+	fishMerkleTree
+	servicerMerkleTree
+
+	// Account Merkle Trees
+	accountMerkleTree
+	poolMerkleTree
+
+	// Data Merkle Trees
+	transactionsMerkleTree
+	paramsMerkleTree
+	flagsMerkleTree
+
+	// Used for iteration purposes only; see https://stackoverflow.com/a/64178235/768439 as a reference
+	numMerkleTrees
+)
+
+// treeStore stores a set of merkle trees that
+// it manages. It fulfills the modules.TreeStore interface.
+// * It is responsible for commit or rollback behavior
+// of the underlying trees by utilizing the lazy loading
+// functionality provided by the underlying smt library.
+type treeStore struct {
+	treeStoreDir string
+	merkleTrees  map[merkleTree]*smt.SMT
+	nodeStores   map[merkleTree]kvstore.KVStore
+}
+
+// Update takes a transaction and a height and updates
+// all of the trees in the treeStore for that height.
+func (t *treeStore) Update(pgtx pgx.Tx, txi indexer.TxIndexer, height uint64) (string, error) {
+	return t.updateMerkleTrees(pgtx, txi, height)
+}
+
+func NewStateTrees(treesStoreDir string) (*treeStore, error) {
+	if treesStoreDir == "":memory:"" {
+		return newMemStateTrees()
+	}
+
+	stateTrees := &treeStore{
+		treeStoreDir: treesStoreDir,
+		merkleTrees:  make(map[merkleTree]*smt.SMT, int(numMerkleTrees)),
+		nodeStores:   make(map[merkleTree]kvstore.KVStore, int(numMerkleTrees)),
+	}
+
+	for tree := merkleTree(0); tree < numMerkleTrees; tree++ {
+		nodeStore, err := kvstore.NewKVStore(fmt.Sprintf(""%s/%s_nodes"", treesStoreDir, merkleTreeToString[tree]))
+		if err != nil {
+			return nil, err
+		}
+		stateTrees.nodeStores[tree] = nodeStore
+		stateTrees.merkleTrees[tree] = smt.NewSparseMerkleTree(nodeStore, sha256.New())
+	}
+	return stateTrees, nil
+}
+
+// DebugClearAll is used by the debug cli to completely reset all merkle trees.
+// This should only be called by the debug CLI.
+func (t *treeStore) DebugClearAll() error {
+	for treeType := merkleTree(0); treeType < numMerkleTrees; treeType++ {
+		nodeStore := t.nodeStores[treeType]
+		if err := nodeStore.ClearAll(); err != nil {
+			return fmt.Errorf(""failed to clear %s node store: %w"", merkleTreeToString[treeType], err)
+		}
+		t.merkleTrees[treeType] = smt.NewSparseMerkleTree(nodeStore, sha256.New())
+	}
+
+	return nil
+}
+
+// newMemStateTrees creates a new in-memory state tree
+func newMemStateTrees() (*treeStore, error) {
+	stateTrees := &treeStore{
+		merkleTrees: make(map[merkleTree]*smt.SMT, int(numMerkleTrees)),
+		nodeStores:  make(map[merkleTree]kvstore.KVStore, int(numMerkleTrees)),
+	}
+	for tree := merkleTree(0); tree < numMerkleTrees; tree++ {
+		nodeStore := kvstore.NewMemKVStore() // For testing, `smt.NewSimpleMap()` can be used as well
+		stateTrees.nodeStores[tree] = nodeStore
+		stateTrees.merkleTrees[tree] = smt.NewSparseMerkleTree(nodeStore, sha256.New())",persistence/trees/trees.go,2023-06-14 20:13:17+00:00,2023-06-14T20:26:15Z,Make sure to update this to the package scoped var as well,,,,,151,RIGHT,149,,line,https://api.github.com/repos/pokt-network/pocket/pulls/756,pokt-network/pocket,70a1a0e2fe2c238fce8c2019e13e9167629a2639
https://api.github.com/repos/pokt-network/pocket/pulls/756,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1230114315,Olshansk,64586305e2aaeb40b5380dde8c922368e4ec8464,b83e7add3d4570727d6a171996fe14d5701bf22f,"@@ -0,0 +1,574 @@
+// package trees maintains a set of sparse merkle trees
+// each backed by the KVStore interface. It offers an atomic
+// commit and rollback mechanism for interacting with
+// that core resource map of merkle trees.
+package trees
+
+import (
+	""bytes""
+	""context""
+	""crypto/sha256""
+	""encoding/hex""
+	""fmt""
+
+	""github.com/jackc/pgx/v5""
+
+	""github.com/pokt-network/pocket/persistence/indexer""
+	""github.com/pokt-network/pocket/persistence/kvstore""
+	ptypes ""github.com/pokt-network/pocket/persistence/types""
+	""github.com/pokt-network/pocket/shared/codec""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/crypto""
+	""github.com/pokt-network/smt""
+)
+
+var merkleTreeToString = map[merkleTree]string{
+	appMerkleTree:      ""app"",
+	valMerkleTree:      ""val"",
+	fishMerkleTree:     ""fish"",
+	servicerMerkleTree: ""servicer"",
+
+	accountMerkleTree: ""account"",
+	poolMerkleTree:    ""pool"",
+
+	transactionsMerkleTree: ""transactions"",
+	paramsMerkleTree:       ""params"",
+	flagsMerkleTree:        ""flags"",
+}
+
+var actorTypeToMerkleTreeName = map[coreTypes.ActorType]merkleTree{
+	coreTypes.ActorType_ACTOR_TYPE_APP:      appMerkleTree,
+	coreTypes.ActorType_ACTOR_TYPE_VAL:      valMerkleTree,
+	coreTypes.ActorType_ACTOR_TYPE_FISH:     fishMerkleTree,
+	coreTypes.ActorType_ACTOR_TYPE_SERVICER: servicerMerkleTree,
+}
+
+var actorTypeToSchemaName = map[coreTypes.ActorType]ptypes.ProtocolActorSchema{
+	coreTypes.ActorType_ACTOR_TYPE_APP:      ptypes.ApplicationActor,
+	coreTypes.ActorType_ACTOR_TYPE_VAL:      ptypes.ValidatorActor,
+	coreTypes.ActorType_ACTOR_TYPE_FISH:     ptypes.FishermanActor,
+	coreTypes.ActorType_ACTOR_TYPE_SERVICER: ptypes.ServicerActor,
+}
+
+var merkleTreeToActorTypeName = map[merkleTree]coreTypes.ActorType{
+	appMerkleTree:      coreTypes.ActorType_ACTOR_TYPE_APP,
+	valMerkleTree:      coreTypes.ActorType_ACTOR_TYPE_VAL,
+	fishMerkleTree:     coreTypes.ActorType_ACTOR_TYPE_FISH,
+	servicerMerkleTree: coreTypes.ActorType_ACTOR_TYPE_SERVICER,
+}
+
+type merkleTree float64
+
+// A list of Merkle Trees used to maintain the state hash.
+const (
+	// IMPORTANT: The order in which these trees are defined is important and strict. It implicitly
+	// defines the index of the root hash each independent as they are concatenated together
+	// to generate the state hash.
+
+	// Actor Merkle Trees
+	appMerkleTree merkleTree = iota
+	valMerkleTree
+	fishMerkleTree
+	servicerMerkleTree
+
+	// Account Merkle Trees
+	accountMerkleTree
+	poolMerkleTree
+
+	// Data Merkle Trees
+	transactionsMerkleTree
+	paramsMerkleTree
+	flagsMerkleTree
+
+	// Used for iteration purposes only; see https://stackoverflow.com/a/64178235/768439 as a reference
+	numMerkleTrees
+)
+
+// treeStore stores a set of merkle trees that
+// it manages. It fulfills the modules.TreeStore interface.
+// * It is responsible for commit or rollback behavior
+// of the underlying trees by utilizing the lazy loading
+// functionality provided by the underlying smt library.
+type treeStore struct {
+	treeStoreDir string
+	merkleTrees  map[merkleTree]*smt.SMT
+	nodeStores   map[merkleTree]kvstore.KVStore
+}
+
+// Update takes a transaction and a height and updates
+// all of the trees in the treeStore for that height.
+func (t *treeStore) Update(pgtx pgx.Tx, txi indexer.TxIndexer, height uint64) (string, error) {
+	return t.updateMerkleTrees(pgtx, txi, height)
+}
+
+func NewStateTrees(treesStoreDir string) (*treeStore, error) {
+	if treesStoreDir == "":memory:"" {
+		return newMemStateTrees()
+	}
+
+	stateTrees := &treeStore{
+		treeStoreDir: treesStoreDir,
+		merkleTrees:  make(map[merkleTree]*smt.SMT, int(numMerkleTrees)),
+		nodeStores:   make(map[merkleTree]kvstore.KVStore, int(numMerkleTrees)),
+	}
+
+	for tree := merkleTree(0); tree < numMerkleTrees; tree++ {
+		nodeStore, err := kvstore.NewKVStore(fmt.Sprintf(""%s/%s_nodes"", treesStoreDir, merkleTreeToString[tree]))
+		if err != nil {
+			return nil, err
+		}
+		stateTrees.nodeStores[tree] = nodeStore
+		stateTrees.merkleTrees[tree] = smt.NewSparseMerkleTree(nodeStore, sha256.New())
+	}
+	return stateTrees, nil
+}
+
+// DebugClearAll is used by the debug cli to completely reset all merkle trees.
+// This should only be called by the debug CLI.
+func (t *treeStore) DebugClearAll() error {
+	for treeType := merkleTree(0); treeType < numMerkleTrees; treeType++ {
+		nodeStore := t.nodeStores[treeType]
+		if err := nodeStore.ClearAll(); err != nil {
+			return fmt.Errorf(""failed to clear %s node store: %w"", merkleTreeToString[treeType], err)
+		}
+		t.merkleTrees[treeType] = smt.NewSparseMerkleTree(nodeStore, sha256.New())
+	}
+
+	return nil
+}
+
+// newMemStateTrees creates a new in-memory state tree
+func newMemStateTrees() (*treeStore, error) {
+	stateTrees := &treeStore{
+		merkleTrees: make(map[merkleTree]*smt.SMT, int(numMerkleTrees)),
+		nodeStores:  make(map[merkleTree]kvstore.KVStore, int(numMerkleTrees)),
+	}
+	for tree := merkleTree(0); tree < numMerkleTrees; tree++ {
+		nodeStore := kvstore.NewMemKVStore() // For testing, `smt.NewSimpleMap()` can be used as well
+		stateTrees.nodeStores[tree] = nodeStore
+		stateTrees.merkleTrees[tree] = smt.NewSparseMerkleTree(nodeStore, sha256.New())
+	}
+	return stateTrees, nil
+}
+
+// updateMerkleTrees updates all of the merkle trees that TreeStore manages.
+// * it returns an hash of the output or an error.",persistence/trees/trees.go,2023-06-14 20:14:01+00:00,2023-06-14T20:26:15Z,"```suggestion
// * it returns the new state hash capturing the state of all the trees or an error if one occured
```",,,,,157,RIGHT,155,,line,https://api.github.com/repos/pokt-network/pocket/pulls/756,pokt-network/pocket,70a1a0e2fe2c238fce8c2019e13e9167629a2639
https://api.github.com/repos/pokt-network/pocket/pulls/756,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1230116084,Olshansk,64586305e2aaeb40b5380dde8c922368e4ec8464,b83e7add3d4570727d6a171996fe14d5701bf22f,"@@ -0,0 +1,18 @@
+package trees
+
+import ""testing""
+
+func TestTreeStore_Update(t *testing.T) {
+	// TODO: Write test case for the Update method
+	t.Skip(""TODO: Write test case for Update method"")
+}
+
+func TestNewStateTrees(t *testing.T) {",persistence/trees/trees_test.go,2023-06-14 20:15:29+00:00,2023-06-14T20:26:15Z,"```suggestion
func TestTreeStore_New(t *testing.T) {
```",,,,,10,RIGHT,10,,line,https://api.github.com/repos/pokt-network/pocket/pulls/756,pokt-network/pocket,70a1a0e2fe2c238fce8c2019e13e9167629a2639
https://api.github.com/repos/pokt-network/pocket/pulls/756,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1230118824,Olshansk,64586305e2aaeb40b5380dde8c922368e4ec8464,b83e7add3d4570727d6a171996fe14d5701bf22f,"@@ -0,0 +1,18 @@
+package trees",persistence/trees/trees_test.go,2023-06-14 20:17:40+00:00,2023-06-14T20:26:15Z,"The list of headers doesn't seem to be exhaustive and I think it's a non-trivial task to figure out what to test. While you're working on this, you probably have the most context of what we need, which will be lost later.

Can you please do one of:
1. Add more test function headers on what we think we need
2. Create a new github issue (or see if one exists) and link to it here. Potentially add a deliverable to leverage ChatGPT to see what else we should test for

The lack of testing in this is one of the few things that keep me up at night so appreciate you understanding :)",,,,1.0,1,RIGHT,1,1.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/756,pokt-network/pocket,70a1a0e2fe2c238fce8c2019e13e9167629a2639
https://api.github.com/repos/pokt-network/pocket/pulls/756,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1230120072,Olshansk,64586305e2aaeb40b5380dde8c922368e4ec8464,b83e7add3d4570727d6a171996fe14d5701bf22f,"@@ -0,0 +1,574 @@
+// package trees maintains a set of sparse merkle trees
+// each backed by the KVStore interface. It offers an atomic
+// commit and rollback mechanism for interacting with
+// that core resource map of merkle trees.
+package trees
+
+import (
+	""bytes""
+	""context""
+	""crypto/sha256""
+	""encoding/hex""
+	""fmt""
+
+	""github.com/jackc/pgx/v5""
+
+	""github.com/pokt-network/pocket/persistence/indexer""
+	""github.com/pokt-network/pocket/persistence/kvstore""
+	ptypes ""github.com/pokt-network/pocket/persistence/types""
+	""github.com/pokt-network/pocket/shared/codec""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/crypto""
+	""github.com/pokt-network/smt""
+)
+
+var merkleTreeToString = map[merkleTree]string{
+	appMerkleTree:      ""app"",
+	valMerkleTree:      ""val"",
+	fishMerkleTree:     ""fish"",
+	servicerMerkleTree: ""servicer"",
+
+	accountMerkleTree: ""account"",
+	poolMerkleTree:    ""pool"",
+
+	transactionsMerkleTree: ""transactions"",
+	paramsMerkleTree:       ""params"",
+	flagsMerkleTree:        ""flags"",
+}
+
+var actorTypeToMerkleTreeName = map[coreTypes.ActorType]merkleTree{
+	coreTypes.ActorType_ACTOR_TYPE_APP:      appMerkleTree,
+	coreTypes.ActorType_ACTOR_TYPE_VAL:      valMerkleTree,
+	coreTypes.ActorType_ACTOR_TYPE_FISH:     fishMerkleTree,
+	coreTypes.ActorType_ACTOR_TYPE_SERVICER: servicerMerkleTree,
+}
+
+var actorTypeToSchemaName = map[coreTypes.ActorType]ptypes.ProtocolActorSchema{
+	coreTypes.ActorType_ACTOR_TYPE_APP:      ptypes.ApplicationActor,
+	coreTypes.ActorType_ACTOR_TYPE_VAL:      ptypes.ValidatorActor,
+	coreTypes.ActorType_ACTOR_TYPE_FISH:     ptypes.FishermanActor,
+	coreTypes.ActorType_ACTOR_TYPE_SERVICER: ptypes.ServicerActor,
+}
+
+var merkleTreeToActorTypeName = map[merkleTree]coreTypes.ActorType{
+	appMerkleTree:      coreTypes.ActorType_ACTOR_TYPE_APP,
+	valMerkleTree:      coreTypes.ActorType_ACTOR_TYPE_VAL,
+	fishMerkleTree:     coreTypes.ActorType_ACTOR_TYPE_FISH,
+	servicerMerkleTree: coreTypes.ActorType_ACTOR_TYPE_SERVICER,
+}
+
+type merkleTree float64
+
+// A list of Merkle Trees used to maintain the state hash.
+const (
+	// IMPORTANT: The order in which these trees are defined is important and strict. It implicitly
+	// defines the index of the root hash each independent as they are concatenated together
+	// to generate the state hash.
+
+	// Actor Merkle Trees
+	appMerkleTree merkleTree = iota
+	valMerkleTree
+	fishMerkleTree
+	servicerMerkleTree
+
+	// Account Merkle Trees
+	accountMerkleTree
+	poolMerkleTree
+
+	// Data Merkle Trees
+	transactionsMerkleTree
+	paramsMerkleTree
+	flagsMerkleTree
+
+	// Used for iteration purposes only; see https://stackoverflow.com/a/64178235/768439 as a reference
+	numMerkleTrees
+)
+
+// treeStore stores a set of merkle trees that
+// it manages. It fulfills the modules.TreeStore interface.
+// * It is responsible for commit or rollback behavior
+// of the underlying trees by utilizing the lazy loading
+// functionality provided by the underlying smt library.
+type treeStore struct {
+	treeStoreDir string
+	merkleTrees  map[merkleTree]*smt.SMT
+	nodeStores   map[merkleTree]kvstore.KVStore
+}
+
+// Update takes a transaction and a height and updates
+// all of the trees in the treeStore for that height.
+func (t *treeStore) Update(pgtx pgx.Tx, txi indexer.TxIndexer, height uint64) (string, error) {
+	return t.updateMerkleTrees(pgtx, txi, height)
+}
+
+func NewStateTrees(treesStoreDir string) (*treeStore, error) {
+	if treesStoreDir == "":memory:"" {
+		return newMemStateTrees()
+	}
+
+	stateTrees := &treeStore{
+		treeStoreDir: treesStoreDir,
+		merkleTrees:  make(map[merkleTree]*smt.SMT, int(numMerkleTrees)),
+		nodeStores:   make(map[merkleTree]kvstore.KVStore, int(numMerkleTrees)),
+	}
+
+	for tree := merkleTree(0); tree < numMerkleTrees; tree++ {
+		nodeStore, err := kvstore.NewKVStore(fmt.Sprintf(""%s/%s_nodes"", treesStoreDir, merkleTreeToString[tree]))
+		if err != nil {
+			return nil, err
+		}
+		stateTrees.nodeStores[tree] = nodeStore
+		stateTrees.merkleTrees[tree] = smt.NewSparseMerkleTree(nodeStore, sha256.New())
+	}
+	return stateTrees, nil
+}
+
+// DebugClearAll is used by the debug cli to completely reset all merkle trees.
+// This should only be called by the debug CLI.
+func (t *treeStore) DebugClearAll() error {
+	for treeType := merkleTree(0); treeType < numMerkleTrees; treeType++ {
+		nodeStore := t.nodeStores[treeType]
+		if err := nodeStore.ClearAll(); err != nil {
+			return fmt.Errorf(""failed to clear %s node store: %w"", merkleTreeToString[treeType], err)
+		}
+		t.merkleTrees[treeType] = smt.NewSparseMerkleTree(nodeStore, sha256.New())
+	}
+
+	return nil
+}
+
+// newMemStateTrees creates a new in-memory state tree
+func newMemStateTrees() (*treeStore, error) {
+	stateTrees := &treeStore{
+		merkleTrees: make(map[merkleTree]*smt.SMT, int(numMerkleTrees)),
+		nodeStores:  make(map[merkleTree]kvstore.KVStore, int(numMerkleTrees)),
+	}
+	for tree := merkleTree(0); tree < numMerkleTrees; tree++ {
+		nodeStore := kvstore.NewMemKVStore() // For testing, `smt.NewSimpleMap()` can be used as well
+		stateTrees.nodeStores[tree] = nodeStore
+		stateTrees.merkleTrees[tree] = smt.NewSparseMerkleTree(nodeStore, sha256.New())
+	}
+	return stateTrees, nil
+}
+
+// updateMerkleTrees updates all of the merkle trees that TreeStore manages.
+// * it returns an hash of the output or an error.
+func (t *treeStore) updateMerkleTrees(pgtx pgx.Tx, txi indexer.TxIndexer, height uint64) (string, error) {
+	for treeType := merkleTree(0); treeType < numMerkleTrees; treeType++ {
+		switch treeType {
+		// Actor Merkle Trees
+		case appMerkleTree, valMerkleTree, fishMerkleTree, servicerMerkleTree:
+			actorType, ok := merkleTreeToActorTypeName[treeType]
+			if !ok {
+				return """", fmt.Errorf(""no actor type found for merkle tree: %v"", treeType)
+			}
+
+			actors, err := t.getActorsUpdated(pgtx, actorType, height)
+			if err != nil {
+				return """", fmt.Errorf(""failed to get actors at height: %w"", err)
+			}
+
+			if err := t.updateActorsTree(actorType, actors); err != nil {
+				return """", fmt.Errorf(""failed to update actors tree for treeType: %v, actorType: %v - %w"", treeType, actorType, err)
+			}
+
+		// Account Merkle Trees
+		case accountMerkleTree:
+			accounts, err := t.getAccounts(pgtx, height)
+			if err != nil {
+				return """", fmt.Errorf(""failed to get accounts: %w"", err)
+			}
+			if err := t.updateAccountTrees(accounts); err != nil {
+				return """", fmt.Errorf(""failed to update account trees: %w"", err)
+			}
+		case poolMerkleTree:
+			pools, err := t.getPools(pgtx, height)
+			if err != nil {
+				return """", fmt.Errorf(""failed to get transactions: %w"", err)
+			}
+			if err := t.updatePoolTrees(pools); err != nil {
+				return """", fmt.Errorf(""failed to update pool trees - %w"", err)
+			}
+
+		// Data Merkle Trees
+		case transactionsMerkleTree:
+			indexedTxs, err := t.getTransactions(txi, height)
+			if err != nil {
+				return """", fmt.Errorf(""failed to get transactions: %w"", err)
+			}
+			if err := t.updateTransactionsTree(indexedTxs); err != nil {
+				return """", fmt.Errorf(""failed to update transactions: %w"", err)
+			}
+		case paramsMerkleTree:
+			params, err := t.getParams(pgtx, height)
+			if err != nil {
+				return """", fmt.Errorf(""failed to get params: %w"", err)
+			}
+			if err := t.updateParamsTree(params); err != nil {
+				return """", fmt.Errorf(""failed to update params tree: %w"", err)
+			}
+		case flagsMerkleTree:
+			flags, err := t.getFlags(pgtx, height)
+			if err != nil {
+				return """", fmt.Errorf(""failed to get flags from transaction: %w"", err)
+			}
+			if err := t.updateFlagsTree(flags); err != nil {
+				return """", fmt.Errorf(""failed to update flags tree - %w"", err)
+			}
+		// Default
+		default:
+			panic(fmt.Sprintf(""not handled in state commitment update. Merkle tree #{%v}"", treeType))
+		}
+	}
+
+	if err := t.commit(); err != nil {
+		return """", fmt.Errorf(""failed to commit: %w"", err)
+	}
+	return t.getStateHash(), nil
+}
+
+func (t *treeStore) commit() error {
+	for tree := merkleTree(0); tree < numMerkleTrees; tree++ {
+		if err := t.merkleTrees[tree].Commit(); err != nil {
+			return fmt.Errorf(""failed to commit %s: %w"", merkleTreeToString[tree], err)
+		}
+	}
+	return nil
+}
+
+func (t *treeStore) getStateHash() string {
+	// create an order-matters list of roots
+	roots := make([][]byte, 0)
+	for tree := merkleTree(0); tree < numMerkleTrees; tree++ {
+		roots = append(roots, t.merkleTrees[tree].Root())
+	}
+
+	// combine them and hash the result
+	rootsConcat := bytes.Join(roots, []byte{})
+	stateHash := sha256.Sum256(rootsConcat)
+
+	// Convert the array to a slice and return it
+	// REF: https://stackoverflow.com/questions/28886616/convert-array-to-slice-in-go
+	return hex.EncodeToString(stateHash[:])
+}
+
+////////////////////////
+// Actor Tree Helpers //
+////////////////////////
+
+// NB: I think this needs to be done manually for all 4 types.
+func (t *treeStore) updateActorsTree(actorType coreTypes.ActorType, actors []*coreTypes.Actor) error {
+	for _, actor := range actors {
+		bzAddr, err := hex.DecodeString(actor.GetAddress())
+		if err != nil {
+			return err
+		}
+
+		actorBz, err := codec.GetCodec().Marshal(actor)
+		if err != nil {
+			return err
+		}
+
+		merkleTreeName, ok := actorTypeToMerkleTreeName[actorType]
+		if !ok {
+			return fmt.Errorf(""no merkle tree found for actor type: %s"", actorType)
+		}
+		if err := t.merkleTrees[merkleTreeName].Update(bzAddr, actorBz); err != nil {
+			return err
+		}
+	}
+
+	return nil
+}
+
+//////////////////////////
+// Account Tree Helpers //
+//////////////////////////
+
+func (t *treeStore) updateAccountTrees(accounts []*coreTypes.Account) error {
+	for _, account := range accounts {
+		bzAddr, err := hex.DecodeString(account.GetAddress())
+		if err != nil {
+			return err
+		}
+
+		accBz, err := codec.GetCodec().Marshal(account)
+		if err != nil {
+			return err
+		}
+
+		if err := t.merkleTrees[accountMerkleTree].Update(bzAddr, accBz); err != nil {
+			return err
+		}
+	}
+
+	return nil
+}
+
+func (t *treeStore) updatePoolTrees(pools []*coreTypes.Account) error {
+	for _, pool := range pools {
+		bzAddr, err := hex.DecodeString(pool.GetAddress())
+		if err != nil {
+			return err
+		}
+
+		accBz, err := codec.GetCodec().Marshal(pool)
+		if err != nil {
+			return err
+		}
+
+		if err := t.merkleTrees[poolMerkleTree].Update(bzAddr, accBz); err != nil {
+			return err
+		}
+	}
+
+	return nil
+}
+
+///////////////////////
+// Data Tree Helpers //
+///////////////////////
+
+func (t *treeStore) updateTransactionsTree(indexedTxs []*coreTypes.IndexedTransaction) error {
+	for _, idxTx := range indexedTxs {
+		txBz := idxTx.GetTx()
+		txHash := crypto.SHA3Hash(txBz)
+		if err := t.merkleTrees[transactionsMerkleTree].Update(txHash, txBz); err != nil {
+			return err
+		}
+	}
+	return nil
+}
+
+func (t *treeStore) updateParamsTree(params []*coreTypes.Param) error {
+	for _, param := range params {
+		paramBz, err := codec.GetCodec().Marshal(param)
+		paramKey := crypto.SHA3Hash([]byte(param.Name))
+		if err != nil {
+			return err
+		}
+		if err := t.merkleTrees[paramsMerkleTree].Update(paramKey, paramBz); err != nil {
+			return err
+		}
+	}
+
+	return nil
+}
+
+func (t *treeStore) updateFlagsTree(flags []*coreTypes.Flag) error {
+	for _, flag := range flags {
+		flagBz, err := codec.GetCodec().Marshal(flag)
+		flagKey := crypto.SHA3Hash([]byte(flag.Name))
+		if err != nil {
+			return err
+		}
+		if err := t.merkleTrees[flagsMerkleTree].Update(flagKey, flagBz); err != nil {
+			return err
+		}
+	}
+
+	return nil
+}
+
+// getActorsUpdated is responsible for fetching the actors that have been updated at a given height.
+func (t *treeStore) getActorsUpdated(
+	pgtx pgx.Tx,
+	actorType coreTypes.ActorType,
+	height uint64,
+) ([]*coreTypes.Actor, error) {
+	actorSchema, ok := actorTypeToSchemaName[actorType]
+	if !ok {
+		return nil, fmt.Errorf(""no schema found for actor type: %s"", actorType)
+	}
+
+	// TECHDEBT (ISSUE #813): Avoid this cast to int64
+	// https://github.com/pokt-network/pocket/issues/813
+	query := actorSchema.GetUpdatedAtHeightQuery(int64(height))
+	rows, err := pgtx.Query(context.TODO(), query)
+	if err != nil {
+		return nil, err
+	}
+	defer rows.Close()
+
+	addrs := make([][]byte, 0)
+	for rows.Next() {
+		var addr string
+		if err := rows.Scan(&addr); err != nil {
+			return nil, err
+		}
+		addrBz, err := hex.DecodeString(addr)
+		if err != nil {
+			return nil, err
+		}
+		addrs = append(addrs, addrBz)
+	}
+
+	actors := make([]*coreTypes.Actor, len(addrs))
+	for i, addr := range addrs {
+		// TECHDEBT #XXX: Avoid this cast to int64
+		actor, err := t.getActor(pgtx, actorSchema, addr, int64(height))
+		if err != nil {
+			return nil, err
+		}
+		actors[i] = actor
+	}
+	rows.Close()
+
+	return actors, nil
+}
+
+func (t *treeStore) getAccountsUpdated(
+	pgtx pgx.Tx,
+	acctType ptypes.ProtocolAccountSchema,
+	height uint64,
+) ([]*coreTypes.Account, error) {
+	accounts := []*coreTypes.Account{}
+
+	// TECHDEBT (ISSUE #813): Avoid this cast to int64
+	// https://github.com/pokt-network/pocket/issues/813
+	query := acctType.GetAccountsUpdatedAtHeightQuery(int64(height))
+	rows, err := pgtx.Query(context.TODO(), query)
+	if err != nil {
+		return nil, err
+	}
+	defer rows.Close()
+
+	for rows.Next() {
+		acc := new(coreTypes.Account)
+		if err := rows.Scan(&acc.Address, &acc.Amount); err != nil {
+			return nil, err
+		}
+		accounts = append(accounts, acc)
+	}
+
+	return accounts, nil
+}
+
+func (t *treeStore) getTransactions(txi indexer.TxIndexer, height uint64) ([]*coreTypes.IndexedTransaction, error) {
+	// TECHDEBT (ISSUE #813): Avoid this cast to int64
+	// https://github.com/pokt-network/pocket/issues/813
+	indexedTxs, err := txi.GetByHeight(int64(height), false)
+	if err != nil {
+		return nil, fmt.Errorf(""failed to get transactions by height: %w"", err)
+	}
+	return indexedTxs, nil
+}
+
+// getPools returns the pools updated at the given height
+func (t *treeStore) getPools(pgtx pgx.Tx, height uint64) ([]*coreTypes.Account, error) {
+	pools, err := t.getAccountsUpdated(pgtx, ptypes.Pool, height)
+	if err != nil {
+		return nil, fmt.Errorf(""failed to get pools: %w"", err)
+	}
+	return pools, nil
+}
+
+// getAccounts returns the list of accounts updated at the provided height
+func (t *treeStore) getAccounts(pgtx pgx.Tx, height uint64) ([]*coreTypes.Account, error) {
+	accounts, err := t.getAccountsUpdated(pgtx, ptypes.Account, height)
+	if err != nil {
+		return nil, fmt.Errorf(""failed to get accounts: %w"", err)
+	}
+	return accounts, nil
+}
+
+func (t *treeStore) getFlags(pgtx pgx.Tx, height uint64) ([]*coreTypes.Flag, error) {
+	fields := ""name,value,enabled""
+	query := fmt.Sprintf(""SELECT %s FROM %s WHERE height=%d ORDER BY name ASC"", fields, ptypes.FlagsTableName, height)
+	rows, err := pgtx.Query(context.TODO(), query)
+	if err != nil {
+		return nil, fmt.Errorf(""failed to get flags: %w"", err)
+	}
+	defer rows.Close()
+
+	flagSlice := []*coreTypes.Flag{}
+	for rows.Next() {
+		flag := new(coreTypes.Flag)
+		if err := rows.Scan(&flag.Name, &flag.Value, &flag.Enabled); err != nil {
+			return nil, err
+		}
+		flag.Height = int64(height)
+		flagSlice = append(flagSlice, flag)
+	}
+
+	return flagSlice, nil
+}
+
+func (t *treeStore) getParams(pgtx pgx.Tx, height uint64) ([]*coreTypes.Param, error) {
+	fields := ""name,value""
+	query := fmt.Sprintf(""SELECT %s FROM %s WHERE height=%d ORDER BY name ASC"", fields, ptypes.ParamsTableName, height)
+	rows, err := pgtx.Query(context.TODO(), query)
+	if err != nil {
+		return nil, err
+	}
+	defer rows.Close()
+
+	var paramSlice []*coreTypes.Param
+	for rows.Next() {
+		param := new(coreTypes.Param)
+		if err := rows.Scan(&param.Name, &param.Value); err != nil {
+			return nil, err
+		}
+		param.Height = int64(height)
+		paramSlice = append(paramSlice, param)
+	}
+
+	return paramSlice, nil
+}
+
+func (t *treeStore) getActor(tx pgx.Tx, actorSchema ptypes.ProtocolActorSchema, address []byte, height int64) (actor *coreTypes.Actor, err error) {
+	ctx := context.TODO()
+	actor, height, err = t.getActorFromRow(actorSchema.GetActorType(), tx.QueryRow(ctx, actorSchema.GetQuery(hex.EncodeToString(address), height)))
+	if err != nil {
+		return
+	}
+	return t.getChainsForActor(ctx, tx, actorSchema, actor, height)
+}
+
+func (t *treeStore) getActorFromRow(actorType coreTypes.ActorType, row pgx.Row) (actor *coreTypes.Actor, height int64, err error) {
+	actor = &coreTypes.Actor{
+		ActorType: actorType,
+	}
+	err = row.Scan(
+		&actor.Address,
+		&actor.PublicKey,
+		&actor.StakedAmount,
+		&actor.ServiceUrl,
+		&actor.Output,
+		&actor.PausedHeight,
+		&actor.UnstakingHeight,
+		&height)
+	return
+}
+
+func (t *treeStore) getChainsForActor(
+	ctx context.Context,
+	tx pgx.Tx,
+	actorSchema ptypes.ProtocolActorSchema,
+	actor *coreTypes.Actor,
+	height int64,
+) (a *coreTypes.Actor, err error) {
+	if actorSchema.GetChainsTableName() == """" {
+		return actor, nil
+	}
+	rows, err := tx.Query(ctx, actorSchema.GetChainsQuery(actor.Address, height))
+	if err != nil {
+		return actor, err
+	}
+	defer rows.Close()
+
+	var chainAddr string
+	var chainID string
+	var chainEndHeight int64 // DISCUSS: why is this commented as ""unused""?",persistence/trees/trees.go,2023-06-14 20:18:34+00:00,2023-06-14T20:26:15Z,I do not remember about the `unused` thing... Good reminder of the importance of adding details techdebt comments along the way.,,,,,562,RIGHT,562,,line,https://api.github.com/repos/pokt-network/pocket/pulls/756,pokt-network/pocket,70a1a0e2fe2c238fce8c2019e13e9167629a2639
https://api.github.com/repos/pokt-network/pocket/pulls/756,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1230124237,Olshansk,64586305e2aaeb40b5380dde8c922368e4ec8464,b83e7add3d4570727d6a171996fe14d5701bf22f,"@@ -0,0 +1,574 @@
+// package trees maintains a set of sparse merkle trees
+// each backed by the KVStore interface. It offers an atomic
+// commit and rollback mechanism for interacting with
+// that core resource map of merkle trees.
+package trees
+
+import (
+	""bytes""
+	""context""
+	""crypto/sha256""
+	""encoding/hex""
+	""fmt""
+
+	""github.com/jackc/pgx/v5""
+
+	""github.com/pokt-network/pocket/persistence/indexer""
+	""github.com/pokt-network/pocket/persistence/kvstore""
+	ptypes ""github.com/pokt-network/pocket/persistence/types""
+	""github.com/pokt-network/pocket/shared/codec""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/crypto""
+	""github.com/pokt-network/smt""
+)
+
+var merkleTreeToString = map[merkleTree]string{
+	appMerkleTree:      ""app"",
+	valMerkleTree:      ""val"",
+	fishMerkleTree:     ""fish"",
+	servicerMerkleTree: ""servicer"",
+
+	accountMerkleTree: ""account"",
+	poolMerkleTree:    ""pool"",
+
+	transactionsMerkleTree: ""transactions"",
+	paramsMerkleTree:       ""params"",
+	flagsMerkleTree:        ""flags"",
+}
+
+var actorTypeToMerkleTreeName = map[coreTypes.ActorType]merkleTree{
+	coreTypes.ActorType_ACTOR_TYPE_APP:      appMerkleTree,
+	coreTypes.ActorType_ACTOR_TYPE_VAL:      valMerkleTree,
+	coreTypes.ActorType_ACTOR_TYPE_FISH:     fishMerkleTree,
+	coreTypes.ActorType_ACTOR_TYPE_SERVICER: servicerMerkleTree,
+}
+
+var actorTypeToSchemaName = map[coreTypes.ActorType]ptypes.ProtocolActorSchema{
+	coreTypes.ActorType_ACTOR_TYPE_APP:      ptypes.ApplicationActor,
+	coreTypes.ActorType_ACTOR_TYPE_VAL:      ptypes.ValidatorActor,
+	coreTypes.ActorType_ACTOR_TYPE_FISH:     ptypes.FishermanActor,
+	coreTypes.ActorType_ACTOR_TYPE_SERVICER: ptypes.ServicerActor,
+}
+
+var merkleTreeToActorTypeName = map[merkleTree]coreTypes.ActorType{
+	appMerkleTree:      coreTypes.ActorType_ACTOR_TYPE_APP,
+	valMerkleTree:      coreTypes.ActorType_ACTOR_TYPE_VAL,
+	fishMerkleTree:     coreTypes.ActorType_ACTOR_TYPE_FISH,
+	servicerMerkleTree: coreTypes.ActorType_ACTOR_TYPE_SERVICER,
+}
+
+type merkleTree float64
+
+// A list of Merkle Trees used to maintain the state hash.
+const (
+	// IMPORTANT: The order in which these trees are defined is important and strict. It implicitly
+	// defines the index of the root hash each independent as they are concatenated together
+	// to generate the state hash.
+
+	// Actor Merkle Trees
+	appMerkleTree merkleTree = iota
+	valMerkleTree
+	fishMerkleTree
+	servicerMerkleTree
+
+	// Account Merkle Trees
+	accountMerkleTree
+	poolMerkleTree
+
+	// Data Merkle Trees
+	transactionsMerkleTree
+	paramsMerkleTree
+	flagsMerkleTree
+
+	// Used for iteration purposes only; see https://stackoverflow.com/a/64178235/768439 as a reference
+	numMerkleTrees
+)
+
+// treeStore stores a set of merkle trees that
+// it manages. It fulfills the modules.TreeStore interface.
+// * It is responsible for commit or rollback behavior
+// of the underlying trees by utilizing the lazy loading
+// functionality provided by the underlying smt library.
+type treeStore struct {
+	treeStoreDir string
+	merkleTrees  map[merkleTree]*smt.SMT
+	nodeStores   map[merkleTree]kvstore.KVStore
+}
+
+// Update takes a transaction and a height and updates
+// all of the trees in the treeStore for that height.
+func (t *treeStore) Update(pgtx pgx.Tx, txi indexer.TxIndexer, height uint64) (string, error) {
+	return t.updateMerkleTrees(pgtx, txi, height)
+}
+
+func NewStateTrees(treesStoreDir string) (*treeStore, error) {
+	if treesStoreDir == "":memory:"" {
+		return newMemStateTrees()
+	}
+
+	stateTrees := &treeStore{
+		treeStoreDir: treesStoreDir,
+		merkleTrees:  make(map[merkleTree]*smt.SMT, int(numMerkleTrees)),
+		nodeStores:   make(map[merkleTree]kvstore.KVStore, int(numMerkleTrees)),
+	}
+
+	for tree := merkleTree(0); tree < numMerkleTrees; tree++ {
+		nodeStore, err := kvstore.NewKVStore(fmt.Sprintf(""%s/%s_nodes"", treesStoreDir, merkleTreeToString[tree]))
+		if err != nil {
+			return nil, err
+		}
+		stateTrees.nodeStores[tree] = nodeStore
+		stateTrees.merkleTrees[tree] = smt.NewSparseMerkleTree(nodeStore, sha256.New())
+	}
+	return stateTrees, nil
+}
+
+// DebugClearAll is used by the debug cli to completely reset all merkle trees.
+// This should only be called by the debug CLI.
+func (t *treeStore) DebugClearAll() error {
+	for treeType := merkleTree(0); treeType < numMerkleTrees; treeType++ {
+		nodeStore := t.nodeStores[treeType]
+		if err := nodeStore.ClearAll(); err != nil {
+			return fmt.Errorf(""failed to clear %s node store: %w"", merkleTreeToString[treeType], err)
+		}
+		t.merkleTrees[treeType] = smt.NewSparseMerkleTree(nodeStore, sha256.New())
+	}
+
+	return nil
+}
+
+// newMemStateTrees creates a new in-memory state tree
+func newMemStateTrees() (*treeStore, error) {
+	stateTrees := &treeStore{
+		merkleTrees: make(map[merkleTree]*smt.SMT, int(numMerkleTrees)),
+		nodeStores:  make(map[merkleTree]kvstore.KVStore, int(numMerkleTrees)),
+	}
+	for tree := merkleTree(0); tree < numMerkleTrees; tree++ {
+		nodeStore := kvstore.NewMemKVStore() // For testing, `smt.NewSimpleMap()` can be used as well
+		stateTrees.nodeStores[tree] = nodeStore
+		stateTrees.merkleTrees[tree] = smt.NewSparseMerkleTree(nodeStore, sha256.New())
+	}
+	return stateTrees, nil
+}
+
+// updateMerkleTrees updates all of the merkle trees that TreeStore manages.
+// * it returns an hash of the output or an error.
+func (t *treeStore) updateMerkleTrees(pgtx pgx.Tx, txi indexer.TxIndexer, height uint64) (string, error) {
+	for treeType := merkleTree(0); treeType < numMerkleTrees; treeType++ {
+		switch treeType {
+		// Actor Merkle Trees
+		case appMerkleTree, valMerkleTree, fishMerkleTree, servicerMerkleTree:
+			actorType, ok := merkleTreeToActorTypeName[treeType]
+			if !ok {
+				return """", fmt.Errorf(""no actor type found for merkle tree: %v"", treeType)
+			}
+
+			actors, err := t.getActorsUpdated(pgtx, actorType, height)
+			if err != nil {
+				return """", fmt.Errorf(""failed to get actors at height: %w"", err)
+			}
+
+			if err := t.updateActorsTree(actorType, actors); err != nil {
+				return """", fmt.Errorf(""failed to update actors tree for treeType: %v, actorType: %v - %w"", treeType, actorType, err)
+			}
+
+		// Account Merkle Trees
+		case accountMerkleTree:
+			accounts, err := t.getAccounts(pgtx, height)
+			if err != nil {
+				return """", fmt.Errorf(""failed to get accounts: %w"", err)
+			}
+			if err := t.updateAccountTrees(accounts); err != nil {
+				return """", fmt.Errorf(""failed to update account trees: %w"", err)
+			}
+		case poolMerkleTree:
+			pools, err := t.getPools(pgtx, height)
+			if err != nil {
+				return """", fmt.Errorf(""failed to get transactions: %w"", err)
+			}
+			if err := t.updatePoolTrees(pools); err != nil {
+				return """", fmt.Errorf(""failed to update pool trees - %w"", err)
+			}
+
+		// Data Merkle Trees
+		case transactionsMerkleTree:
+			indexedTxs, err := t.getTransactions(txi, height)
+			if err != nil {
+				return """", fmt.Errorf(""failed to get transactions: %w"", err)
+			}
+			if err := t.updateTransactionsTree(indexedTxs); err != nil {
+				return """", fmt.Errorf(""failed to update transactions: %w"", err)
+			}
+		case paramsMerkleTree:
+			params, err := t.getParams(pgtx, height)
+			if err != nil {
+				return """", fmt.Errorf(""failed to get params: %w"", err)
+			}
+			if err := t.updateParamsTree(params); err != nil {
+				return """", fmt.Errorf(""failed to update params tree: %w"", err)
+			}
+		case flagsMerkleTree:
+			flags, err := t.getFlags(pgtx, height)
+			if err != nil {
+				return """", fmt.Errorf(""failed to get flags from transaction: %w"", err)
+			}
+			if err := t.updateFlagsTree(flags); err != nil {
+				return """", fmt.Errorf(""failed to update flags tree - %w"", err)
+			}
+		// Default
+		default:
+			panic(fmt.Sprintf(""not handled in state commitment update. Merkle tree #{%v}"", treeType))
+		}
+	}
+
+	if err := t.commit(); err != nil {
+		return """", fmt.Errorf(""failed to commit: %w"", err)
+	}
+	return t.getStateHash(), nil
+}
+
+func (t *treeStore) commit() error {
+	for tree := merkleTree(0); tree < numMerkleTrees; tree++ {
+		if err := t.merkleTrees[tree].Commit(); err != nil {
+			return fmt.Errorf(""failed to commit %s: %w"", merkleTreeToString[tree], err)
+		}
+	}
+	return nil
+}
+
+func (t *treeStore) getStateHash() string {
+	// create an order-matters list of roots
+	roots := make([][]byte, 0)
+	for tree := merkleTree(0); tree < numMerkleTrees; tree++ {
+		roots = append(roots, t.merkleTrees[tree].Root())
+	}
+
+	// combine them and hash the result
+	rootsConcat := bytes.Join(roots, []byte{})
+	stateHash := sha256.Sum256(rootsConcat)
+
+	// Convert the array to a slice and return it
+	// REF: https://stackoverflow.com/questions/28886616/convert-array-to-slice-in-go
+	return hex.EncodeToString(stateHash[:])
+}
+
+////////////////////////
+// Actor Tree Helpers //
+////////////////////////
+
+// NB: I think this needs to be done manually for all 4 types.
+func (t *treeStore) updateActorsTree(actorType coreTypes.ActorType, actors []*coreTypes.Actor) error {
+	for _, actor := range actors {
+		bzAddr, err := hex.DecodeString(actor.GetAddress())
+		if err != nil {
+			return err
+		}
+
+		actorBz, err := codec.GetCodec().Marshal(actor)
+		if err != nil {
+			return err
+		}
+
+		merkleTreeName, ok := actorTypeToMerkleTreeName[actorType]
+		if !ok {
+			return fmt.Errorf(""no merkle tree found for actor type: %s"", actorType)
+		}
+		if err := t.merkleTrees[merkleTreeName].Update(bzAddr, actorBz); err != nil {
+			return err
+		}
+	}
+
+	return nil
+}
+
+//////////////////////////
+// Account Tree Helpers //
+//////////////////////////
+
+func (t *treeStore) updateAccountTrees(accounts []*coreTypes.Account) error {
+	for _, account := range accounts {
+		bzAddr, err := hex.DecodeString(account.GetAddress())
+		if err != nil {
+			return err
+		}
+
+		accBz, err := codec.GetCodec().Marshal(account)
+		if err != nil {
+			return err
+		}
+
+		if err := t.merkleTrees[accountMerkleTree].Update(bzAddr, accBz); err != nil {
+			return err
+		}
+	}
+
+	return nil
+}
+
+func (t *treeStore) updatePoolTrees(pools []*coreTypes.Account) error {
+	for _, pool := range pools {
+		bzAddr, err := hex.DecodeString(pool.GetAddress())
+		if err != nil {
+			return err
+		}
+
+		accBz, err := codec.GetCodec().Marshal(pool)
+		if err != nil {
+			return err
+		}
+
+		if err := t.merkleTrees[poolMerkleTree].Update(bzAddr, accBz); err != nil {
+			return err
+		}
+	}
+
+	return nil
+}
+
+///////////////////////
+// Data Tree Helpers //
+///////////////////////
+
+func (t *treeStore) updateTransactionsTree(indexedTxs []*coreTypes.IndexedTransaction) error {
+	for _, idxTx := range indexedTxs {
+		txBz := idxTx.GetTx()
+		txHash := crypto.SHA3Hash(txBz)
+		if err := t.merkleTrees[transactionsMerkleTree].Update(txHash, txBz); err != nil {
+			return err
+		}
+	}
+	return nil
+}
+
+func (t *treeStore) updateParamsTree(params []*coreTypes.Param) error {
+	for _, param := range params {
+		paramBz, err := codec.GetCodec().Marshal(param)
+		paramKey := crypto.SHA3Hash([]byte(param.Name))
+		if err != nil {
+			return err
+		}
+		if err := t.merkleTrees[paramsMerkleTree].Update(paramKey, paramBz); err != nil {
+			return err
+		}
+	}
+
+	return nil
+}
+
+func (t *treeStore) updateFlagsTree(flags []*coreTypes.Flag) error {
+	for _, flag := range flags {
+		flagBz, err := codec.GetCodec().Marshal(flag)
+		flagKey := crypto.SHA3Hash([]byte(flag.Name))
+		if err != nil {
+			return err
+		}
+		if err := t.merkleTrees[flagsMerkleTree].Update(flagKey, flagBz); err != nil {
+			return err
+		}
+	}
+
+	return nil
+}
+
+// getActorsUpdated is responsible for fetching the actors that have been updated at a given height.
+func (t *treeStore) getActorsUpdated(
+	pgtx pgx.Tx,
+	actorType coreTypes.ActorType,
+	height uint64,
+) ([]*coreTypes.Actor, error) {
+	actorSchema, ok := actorTypeToSchemaName[actorType]
+	if !ok {
+		return nil, fmt.Errorf(""no schema found for actor type: %s"", actorType)
+	}
+
+	// TECHDEBT (ISSUE #813): Avoid this cast to int64
+	// https://github.com/pokt-network/pocket/issues/813",persistence/trees/trees.go,2023-06-14 20:22:09+00:00,2023-06-14T20:26:15Z,"Leaving one comment but ditto elsewhere 

```suggestion
	// TECHDET(#813): Avoid this cast to int64
```",,384.0,RIGHT,,387,RIGHT,385,,line,https://api.github.com/repos/pokt-network/pocket/pulls/756,pokt-network/pocket,70a1a0e2fe2c238fce8c2019e13e9167629a2639
https://api.github.com/repos/pokt-network/pocket/pulls/756,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1230124767,Olshansk,64586305e2aaeb40b5380dde8c922368e4ec8464,b83e7add3d4570727d6a171996fe14d5701bf22f,"@@ -0,0 +1,574 @@
+// package trees maintains a set of sparse merkle trees
+// each backed by the KVStore interface. It offers an atomic
+// commit and rollback mechanism for interacting with
+// that core resource map of merkle trees.
+package trees
+
+import (
+	""bytes""
+	""context""
+	""crypto/sha256""
+	""encoding/hex""
+	""fmt""
+
+	""github.com/jackc/pgx/v5""
+
+	""github.com/pokt-network/pocket/persistence/indexer""
+	""github.com/pokt-network/pocket/persistence/kvstore""
+	ptypes ""github.com/pokt-network/pocket/persistence/types""
+	""github.com/pokt-network/pocket/shared/codec""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/crypto""
+	""github.com/pokt-network/smt""
+)
+
+var merkleTreeToString = map[merkleTree]string{
+	appMerkleTree:      ""app"",
+	valMerkleTree:      ""val"",
+	fishMerkleTree:     ""fish"",
+	servicerMerkleTree: ""servicer"",
+
+	accountMerkleTree: ""account"",
+	poolMerkleTree:    ""pool"",
+
+	transactionsMerkleTree: ""transactions"",
+	paramsMerkleTree:       ""params"",
+	flagsMerkleTree:        ""flags"",
+}
+
+var actorTypeToMerkleTreeName = map[coreTypes.ActorType]merkleTree{
+	coreTypes.ActorType_ACTOR_TYPE_APP:      appMerkleTree,
+	coreTypes.ActorType_ACTOR_TYPE_VAL:      valMerkleTree,
+	coreTypes.ActorType_ACTOR_TYPE_FISH:     fishMerkleTree,
+	coreTypes.ActorType_ACTOR_TYPE_SERVICER: servicerMerkleTree,
+}
+
+var actorTypeToSchemaName = map[coreTypes.ActorType]ptypes.ProtocolActorSchema{
+	coreTypes.ActorType_ACTOR_TYPE_APP:      ptypes.ApplicationActor,
+	coreTypes.ActorType_ACTOR_TYPE_VAL:      ptypes.ValidatorActor,
+	coreTypes.ActorType_ACTOR_TYPE_FISH:     ptypes.FishermanActor,
+	coreTypes.ActorType_ACTOR_TYPE_SERVICER: ptypes.ServicerActor,
+}
+
+var merkleTreeToActorTypeName = map[merkleTree]coreTypes.ActorType{
+	appMerkleTree:      coreTypes.ActorType_ACTOR_TYPE_APP,
+	valMerkleTree:      coreTypes.ActorType_ACTOR_TYPE_VAL,
+	fishMerkleTree:     coreTypes.ActorType_ACTOR_TYPE_FISH,
+	servicerMerkleTree: coreTypes.ActorType_ACTOR_TYPE_SERVICER,
+}
+
+type merkleTree float64
+
+// A list of Merkle Trees used to maintain the state hash.
+const (
+	// IMPORTANT: The order in which these trees are defined is important and strict. It implicitly
+	// defines the index of the root hash each independent as they are concatenated together
+	// to generate the state hash.
+
+	// Actor Merkle Trees
+	appMerkleTree merkleTree = iota
+	valMerkleTree
+	fishMerkleTree
+	servicerMerkleTree
+
+	// Account Merkle Trees
+	accountMerkleTree
+	poolMerkleTree
+
+	// Data Merkle Trees
+	transactionsMerkleTree
+	paramsMerkleTree
+	flagsMerkleTree
+
+	// Used for iteration purposes only; see https://stackoverflow.com/a/64178235/768439 as a reference
+	numMerkleTrees
+)
+
+// treeStore stores a set of merkle trees that
+// it manages. It fulfills the modules.TreeStore interface.
+// * It is responsible for commit or rollback behavior
+// of the underlying trees by utilizing the lazy loading
+// functionality provided by the underlying smt library.
+type treeStore struct {
+	treeStoreDir string
+	merkleTrees  map[merkleTree]*smt.SMT
+	nodeStores   map[merkleTree]kvstore.KVStore
+}
+
+// Update takes a transaction and a height and updates
+// all of the trees in the treeStore for that height.
+func (t *treeStore) Update(pgtx pgx.Tx, txi indexer.TxIndexer, height uint64) (string, error) {
+	return t.updateMerkleTrees(pgtx, txi, height)
+}
+
+func NewStateTrees(treesStoreDir string) (*treeStore, error) {
+	if treesStoreDir == "":memory:"" {
+		return newMemStateTrees()
+	}
+
+	stateTrees := &treeStore{
+		treeStoreDir: treesStoreDir,
+		merkleTrees:  make(map[merkleTree]*smt.SMT, int(numMerkleTrees)),
+		nodeStores:   make(map[merkleTree]kvstore.KVStore, int(numMerkleTrees)),
+	}
+
+	for tree := merkleTree(0); tree < numMerkleTrees; tree++ {
+		nodeStore, err := kvstore.NewKVStore(fmt.Sprintf(""%s/%s_nodes"", treesStoreDir, merkleTreeToString[tree]))
+		if err != nil {
+			return nil, err
+		}
+		stateTrees.nodeStores[tree] = nodeStore
+		stateTrees.merkleTrees[tree] = smt.NewSparseMerkleTree(nodeStore, sha256.New())
+	}
+	return stateTrees, nil
+}
+
+// DebugClearAll is used by the debug cli to completely reset all merkle trees.
+// This should only be called by the debug CLI.
+func (t *treeStore) DebugClearAll() error {
+	for treeType := merkleTree(0); treeType < numMerkleTrees; treeType++ {
+		nodeStore := t.nodeStores[treeType]
+		if err := nodeStore.ClearAll(); err != nil {
+			return fmt.Errorf(""failed to clear %s node store: %w"", merkleTreeToString[treeType], err)
+		}
+		t.merkleTrees[treeType] = smt.NewSparseMerkleTree(nodeStore, sha256.New())
+	}
+
+	return nil
+}
+
+// newMemStateTrees creates a new in-memory state tree
+func newMemStateTrees() (*treeStore, error) {
+	stateTrees := &treeStore{
+		merkleTrees: make(map[merkleTree]*smt.SMT, int(numMerkleTrees)),
+		nodeStores:  make(map[merkleTree]kvstore.KVStore, int(numMerkleTrees)),
+	}
+	for tree := merkleTree(0); tree < numMerkleTrees; tree++ {
+		nodeStore := kvstore.NewMemKVStore() // For testing, `smt.NewSimpleMap()` can be used as well
+		stateTrees.nodeStores[tree] = nodeStore
+		stateTrees.merkleTrees[tree] = smt.NewSparseMerkleTree(nodeStore, sha256.New())
+	}
+	return stateTrees, nil
+}
+
+// updateMerkleTrees updates all of the merkle trees that TreeStore manages.
+// * it returns an hash of the output or an error.
+func (t *treeStore) updateMerkleTrees(pgtx pgx.Tx, txi indexer.TxIndexer, height uint64) (string, error) {
+	for treeType := merkleTree(0); treeType < numMerkleTrees; treeType++ {
+		switch treeType {
+		// Actor Merkle Trees
+		case appMerkleTree, valMerkleTree, fishMerkleTree, servicerMerkleTree:
+			actorType, ok := merkleTreeToActorTypeName[treeType]
+			if !ok {
+				return """", fmt.Errorf(""no actor type found for merkle tree: %v"", treeType)
+			}
+
+			actors, err := t.getActorsUpdated(pgtx, actorType, height)
+			if err != nil {
+				return """", fmt.Errorf(""failed to get actors at height: %w"", err)
+			}
+
+			if err := t.updateActorsTree(actorType, actors); err != nil {
+				return """", fmt.Errorf(""failed to update actors tree for treeType: %v, actorType: %v - %w"", treeType, actorType, err)
+			}
+
+		// Account Merkle Trees
+		case accountMerkleTree:
+			accounts, err := t.getAccounts(pgtx, height)
+			if err != nil {
+				return """", fmt.Errorf(""failed to get accounts: %w"", err)
+			}
+			if err := t.updateAccountTrees(accounts); err != nil {
+				return """", fmt.Errorf(""failed to update account trees: %w"", err)
+			}
+		case poolMerkleTree:
+			pools, err := t.getPools(pgtx, height)
+			if err != nil {
+				return """", fmt.Errorf(""failed to get transactions: %w"", err)
+			}
+			if err := t.updatePoolTrees(pools); err != nil {
+				return """", fmt.Errorf(""failed to update pool trees - %w"", err)
+			}
+
+		// Data Merkle Trees
+		case transactionsMerkleTree:
+			indexedTxs, err := t.getTransactions(txi, height)
+			if err != nil {
+				return """", fmt.Errorf(""failed to get transactions: %w"", err)
+			}
+			if err := t.updateTransactionsTree(indexedTxs); err != nil {
+				return """", fmt.Errorf(""failed to update transactions: %w"", err)
+			}
+		case paramsMerkleTree:
+			params, err := t.getParams(pgtx, height)
+			if err != nil {
+				return """", fmt.Errorf(""failed to get params: %w"", err)
+			}
+			if err := t.updateParamsTree(params); err != nil {
+				return """", fmt.Errorf(""failed to update params tree: %w"", err)
+			}
+		case flagsMerkleTree:
+			flags, err := t.getFlags(pgtx, height)
+			if err != nil {
+				return """", fmt.Errorf(""failed to get flags from transaction: %w"", err)
+			}
+			if err := t.updateFlagsTree(flags); err != nil {
+				return """", fmt.Errorf(""failed to update flags tree - %w"", err)
+			}
+		// Default
+		default:
+			panic(fmt.Sprintf(""not handled in state commitment update. Merkle tree #{%v}"", treeType))
+		}
+	}
+
+	if err := t.commit(); err != nil {
+		return """", fmt.Errorf(""failed to commit: %w"", err)
+	}
+	return t.getStateHash(), nil
+}
+
+func (t *treeStore) commit() error {
+	for tree := merkleTree(0); tree < numMerkleTrees; tree++ {
+		if err := t.merkleTrees[tree].Commit(); err != nil {
+			return fmt.Errorf(""failed to commit %s: %w"", merkleTreeToString[tree], err)
+		}
+	}
+	return nil
+}
+
+func (t *treeStore) getStateHash() string {
+	// create an order-matters list of roots
+	roots := make([][]byte, 0)
+	for tree := merkleTree(0); tree < numMerkleTrees; tree++ {
+		roots = append(roots, t.merkleTrees[tree].Root())
+	}
+
+	// combine them and hash the result
+	rootsConcat := bytes.Join(roots, []byte{})
+	stateHash := sha256.Sum256(rootsConcat)
+
+	// Convert the array to a slice and return it
+	// REF: https://stackoverflow.com/questions/28886616/convert-array-to-slice-in-go
+	return hex.EncodeToString(stateHash[:])
+}
+
+////////////////////////
+// Actor Tree Helpers //
+////////////////////////
+
+// NB: I think this needs to be done manually for all 4 types.
+func (t *treeStore) updateActorsTree(actorType coreTypes.ActorType, actors []*coreTypes.Actor) error {
+	for _, actor := range actors {
+		bzAddr, err := hex.DecodeString(actor.GetAddress())
+		if err != nil {
+			return err
+		}
+
+		actorBz, err := codec.GetCodec().Marshal(actor)
+		if err != nil {
+			return err
+		}
+
+		merkleTreeName, ok := actorTypeToMerkleTreeName[actorType]
+		if !ok {
+			return fmt.Errorf(""no merkle tree found for actor type: %s"", actorType)
+		}
+		if err := t.merkleTrees[merkleTreeName].Update(bzAddr, actorBz); err != nil {
+			return err
+		}
+	}
+
+	return nil
+}
+
+//////////////////////////
+// Account Tree Helpers //
+//////////////////////////
+
+func (t *treeStore) updateAccountTrees(accounts []*coreTypes.Account) error {
+	for _, account := range accounts {
+		bzAddr, err := hex.DecodeString(account.GetAddress())
+		if err != nil {
+			return err
+		}
+
+		accBz, err := codec.GetCodec().Marshal(account)
+		if err != nil {
+			return err
+		}
+
+		if err := t.merkleTrees[accountMerkleTree].Update(bzAddr, accBz); err != nil {
+			return err
+		}
+	}
+
+	return nil
+}
+
+func (t *treeStore) updatePoolTrees(pools []*coreTypes.Account) error {
+	for _, pool := range pools {
+		bzAddr, err := hex.DecodeString(pool.GetAddress())
+		if err != nil {
+			return err
+		}
+
+		accBz, err := codec.GetCodec().Marshal(pool)
+		if err != nil {
+			return err
+		}
+
+		if err := t.merkleTrees[poolMerkleTree].Update(bzAddr, accBz); err != nil {
+			return err
+		}
+	}
+
+	return nil
+}
+
+///////////////////////
+// Data Tree Helpers //
+///////////////////////
+
+func (t *treeStore) updateTransactionsTree(indexedTxs []*coreTypes.IndexedTransaction) error {
+	for _, idxTx := range indexedTxs {
+		txBz := idxTx.GetTx()
+		txHash := crypto.SHA3Hash(txBz)
+		if err := t.merkleTrees[transactionsMerkleTree].Update(txHash, txBz); err != nil {
+			return err
+		}
+	}
+	return nil
+}
+
+func (t *treeStore) updateParamsTree(params []*coreTypes.Param) error {
+	for _, param := range params {
+		paramBz, err := codec.GetCodec().Marshal(param)
+		paramKey := crypto.SHA3Hash([]byte(param.Name))
+		if err != nil {
+			return err
+		}
+		if err := t.merkleTrees[paramsMerkleTree].Update(paramKey, paramBz); err != nil {
+			return err
+		}
+	}
+
+	return nil
+}
+
+func (t *treeStore) updateFlagsTree(flags []*coreTypes.Flag) error {
+	for _, flag := range flags {
+		flagBz, err := codec.GetCodec().Marshal(flag)
+		flagKey := crypto.SHA3Hash([]byte(flag.Name))
+		if err != nil {
+			return err
+		}
+		if err := t.merkleTrees[flagsMerkleTree].Update(flagKey, flagBz); err != nil {
+			return err
+		}
+	}
+
+	return nil
+}
+
+// getActorsUpdated is responsible for fetching the actors that have been updated at a given height.
+func (t *treeStore) getActorsUpdated(
+	pgtx pgx.Tx,
+	actorType coreTypes.ActorType,
+	height uint64,
+) ([]*coreTypes.Actor, error) {
+	actorSchema, ok := actorTypeToSchemaName[actorType]
+	if !ok {
+		return nil, fmt.Errorf(""no schema found for actor type: %s"", actorType)
+	}
+
+	// TECHDEBT (ISSUE #813): Avoid this cast to int64
+	// https://github.com/pokt-network/pocket/issues/813
+	query := actorSchema.GetUpdatedAtHeightQuery(int64(height))
+	rows, err := pgtx.Query(context.TODO(), query)
+	if err != nil {
+		return nil, err
+	}
+	defer rows.Close()
+
+	addrs := make([][]byte, 0)
+	for rows.Next() {
+		var addr string
+		if err := rows.Scan(&addr); err != nil {
+			return nil, err
+		}
+		addrBz, err := hex.DecodeString(addr)
+		if err != nil {
+			return nil, err
+		}
+		addrs = append(addrs, addrBz)
+	}
+
+	actors := make([]*coreTypes.Actor, len(addrs))
+	for i, addr := range addrs {
+		// TECHDEBT #XXX: Avoid this cast to int64",persistence/trees/trees.go,2023-06-14 20:22:38+00:00,2023-06-14T20:26:15Z,"NIT: Missing #813.

PLease check other places as well",,,,,408,RIGHT,408,,line,https://api.github.com/repos/pokt-network/pocket/pulls/756,pokt-network/pocket,70a1a0e2fe2c238fce8c2019e13e9167629a2639
https://api.github.com/repos/pokt-network/pocket/pulls/756,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1230125610,Olshansk,64586305e2aaeb40b5380dde8c922368e4ec8464,b83e7add3d4570727d6a171996fe14d5701bf22f,"@@ -0,0 +1,574 @@
+// package trees maintains a set of sparse merkle trees
+// each backed by the KVStore interface. It offers an atomic
+// commit and rollback mechanism for interacting with
+// that core resource map of merkle trees.
+package trees
+
+import (
+	""bytes""
+	""context""
+	""crypto/sha256""
+	""encoding/hex""
+	""fmt""
+
+	""github.com/jackc/pgx/v5""
+
+	""github.com/pokt-network/pocket/persistence/indexer""
+	""github.com/pokt-network/pocket/persistence/kvstore""
+	ptypes ""github.com/pokt-network/pocket/persistence/types""
+	""github.com/pokt-network/pocket/shared/codec""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/crypto""
+	""github.com/pokt-network/smt""
+)
+
+var merkleTreeToString = map[merkleTree]string{
+	appMerkleTree:      ""app"",
+	valMerkleTree:      ""val"",
+	fishMerkleTree:     ""fish"",
+	servicerMerkleTree: ""servicer"",
+
+	accountMerkleTree: ""account"",
+	poolMerkleTree:    ""pool"",
+
+	transactionsMerkleTree: ""transactions"",
+	paramsMerkleTree:       ""params"",
+	flagsMerkleTree:        ""flags"",
+}
+
+var actorTypeToMerkleTreeName = map[coreTypes.ActorType]merkleTree{
+	coreTypes.ActorType_ACTOR_TYPE_APP:      appMerkleTree,
+	coreTypes.ActorType_ACTOR_TYPE_VAL:      valMerkleTree,
+	coreTypes.ActorType_ACTOR_TYPE_FISH:     fishMerkleTree,
+	coreTypes.ActorType_ACTOR_TYPE_SERVICER: servicerMerkleTree,
+}
+
+var actorTypeToSchemaName = map[coreTypes.ActorType]ptypes.ProtocolActorSchema{
+	coreTypes.ActorType_ACTOR_TYPE_APP:      ptypes.ApplicationActor,
+	coreTypes.ActorType_ACTOR_TYPE_VAL:      ptypes.ValidatorActor,
+	coreTypes.ActorType_ACTOR_TYPE_FISH:     ptypes.FishermanActor,
+	coreTypes.ActorType_ACTOR_TYPE_SERVICER: ptypes.ServicerActor,
+}
+
+var merkleTreeToActorTypeName = map[merkleTree]coreTypes.ActorType{
+	appMerkleTree:      coreTypes.ActorType_ACTOR_TYPE_APP,
+	valMerkleTree:      coreTypes.ActorType_ACTOR_TYPE_VAL,
+	fishMerkleTree:     coreTypes.ActorType_ACTOR_TYPE_FISH,
+	servicerMerkleTree: coreTypes.ActorType_ACTOR_TYPE_SERVICER,
+}
+
+type merkleTree float64
+
+// A list of Merkle Trees used to maintain the state hash.
+const (
+	// IMPORTANT: The order in which these trees are defined is important and strict. It implicitly
+	// defines the index of the root hash each independent as they are concatenated together
+	// to generate the state hash.
+
+	// Actor Merkle Trees
+	appMerkleTree merkleTree = iota
+	valMerkleTree
+	fishMerkleTree
+	servicerMerkleTree
+
+	// Account Merkle Trees
+	accountMerkleTree
+	poolMerkleTree
+
+	// Data Merkle Trees
+	transactionsMerkleTree
+	paramsMerkleTree
+	flagsMerkleTree
+
+	// Used for iteration purposes only; see https://stackoverflow.com/a/64178235/768439 as a reference
+	numMerkleTrees
+)
+
+// treeStore stores a set of merkle trees that
+// it manages. It fulfills the modules.TreeStore interface.
+// * It is responsible for commit or rollback behavior
+// of the underlying trees by utilizing the lazy loading
+// functionality provided by the underlying smt library.
+type treeStore struct {
+	treeStoreDir string
+	merkleTrees  map[merkleTree]*smt.SMT
+	nodeStores   map[merkleTree]kvstore.KVStore
+}
+
+// Update takes a transaction and a height and updates
+// all of the trees in the treeStore for that height.
+func (t *treeStore) Update(pgtx pgx.Tx, txi indexer.TxIndexer, height uint64) (string, error) {
+	return t.updateMerkleTrees(pgtx, txi, height)
+}
+
+func NewStateTrees(treesStoreDir string) (*treeStore, error) {
+	if treesStoreDir == "":memory:"" {
+		return newMemStateTrees()
+	}
+
+	stateTrees := &treeStore{
+		treeStoreDir: treesStoreDir,
+		merkleTrees:  make(map[merkleTree]*smt.SMT, int(numMerkleTrees)),
+		nodeStores:   make(map[merkleTree]kvstore.KVStore, int(numMerkleTrees)),
+	}
+
+	for tree := merkleTree(0); tree < numMerkleTrees; tree++ {
+		nodeStore, err := kvstore.NewKVStore(fmt.Sprintf(""%s/%s_nodes"", treesStoreDir, merkleTreeToString[tree]))
+		if err != nil {
+			return nil, err
+		}
+		stateTrees.nodeStores[tree] = nodeStore
+		stateTrees.merkleTrees[tree] = smt.NewSparseMerkleTree(nodeStore, sha256.New())
+	}
+	return stateTrees, nil
+}
+
+// DebugClearAll is used by the debug cli to completely reset all merkle trees.
+// This should only be called by the debug CLI.
+func (t *treeStore) DebugClearAll() error {
+	for treeType := merkleTree(0); treeType < numMerkleTrees; treeType++ {
+		nodeStore := t.nodeStores[treeType]
+		if err := nodeStore.ClearAll(); err != nil {
+			return fmt.Errorf(""failed to clear %s node store: %w"", merkleTreeToString[treeType], err)
+		}
+		t.merkleTrees[treeType] = smt.NewSparseMerkleTree(nodeStore, sha256.New())
+	}
+
+	return nil
+}
+
+// newMemStateTrees creates a new in-memory state tree
+func newMemStateTrees() (*treeStore, error) {
+	stateTrees := &treeStore{
+		merkleTrees: make(map[merkleTree]*smt.SMT, int(numMerkleTrees)),
+		nodeStores:  make(map[merkleTree]kvstore.KVStore, int(numMerkleTrees)),
+	}
+	for tree := merkleTree(0); tree < numMerkleTrees; tree++ {
+		nodeStore := kvstore.NewMemKVStore() // For testing, `smt.NewSimpleMap()` can be used as well
+		stateTrees.nodeStores[tree] = nodeStore
+		stateTrees.merkleTrees[tree] = smt.NewSparseMerkleTree(nodeStore, sha256.New())
+	}
+	return stateTrees, nil
+}
+
+// updateMerkleTrees updates all of the merkle trees that TreeStore manages.
+// * it returns an hash of the output or an error.
+func (t *treeStore) updateMerkleTrees(pgtx pgx.Tx, txi indexer.TxIndexer, height uint64) (string, error) {
+	for treeType := merkleTree(0); treeType < numMerkleTrees; treeType++ {
+		switch treeType {
+		// Actor Merkle Trees
+		case appMerkleTree, valMerkleTree, fishMerkleTree, servicerMerkleTree:
+			actorType, ok := merkleTreeToActorTypeName[treeType]
+			if !ok {
+				return """", fmt.Errorf(""no actor type found for merkle tree: %v"", treeType)
+			}
+
+			actors, err := t.getActorsUpdated(pgtx, actorType, height)
+			if err != nil {
+				return """", fmt.Errorf(""failed to get actors at height: %w"", err)
+			}
+
+			if err := t.updateActorsTree(actorType, actors); err != nil {
+				return """", fmt.Errorf(""failed to update actors tree for treeType: %v, actorType: %v - %w"", treeType, actorType, err)
+			}
+
+		// Account Merkle Trees
+		case accountMerkleTree:
+			accounts, err := t.getAccounts(pgtx, height)
+			if err != nil {
+				return """", fmt.Errorf(""failed to get accounts: %w"", err)
+			}
+			if err := t.updateAccountTrees(accounts); err != nil {
+				return """", fmt.Errorf(""failed to update account trees: %w"", err)
+			}
+		case poolMerkleTree:
+			pools, err := t.getPools(pgtx, height)
+			if err != nil {
+				return """", fmt.Errorf(""failed to get transactions: %w"", err)
+			}
+			if err := t.updatePoolTrees(pools); err != nil {
+				return """", fmt.Errorf(""failed to update pool trees - %w"", err)
+			}
+
+		// Data Merkle Trees
+		case transactionsMerkleTree:
+			indexedTxs, err := t.getTransactions(txi, height)
+			if err != nil {
+				return """", fmt.Errorf(""failed to get transactions: %w"", err)
+			}
+			if err := t.updateTransactionsTree(indexedTxs); err != nil {
+				return """", fmt.Errorf(""failed to update transactions: %w"", err)
+			}
+		case paramsMerkleTree:
+			params, err := t.getParams(pgtx, height)
+			if err != nil {
+				return """", fmt.Errorf(""failed to get params: %w"", err)
+			}
+			if err := t.updateParamsTree(params); err != nil {
+				return """", fmt.Errorf(""failed to update params tree: %w"", err)
+			}
+		case flagsMerkleTree:
+			flags, err := t.getFlags(pgtx, height)
+			if err != nil {
+				return """", fmt.Errorf(""failed to get flags from transaction: %w"", err)
+			}
+			if err := t.updateFlagsTree(flags); err != nil {
+				return """", fmt.Errorf(""failed to update flags tree - %w"", err)
+			}
+		// Default
+		default:
+			panic(fmt.Sprintf(""not handled in state commitment update. Merkle tree #{%v}"", treeType))
+		}
+	}
+
+	if err := t.commit(); err != nil {
+		return """", fmt.Errorf(""failed to commit: %w"", err)
+	}
+	return t.getStateHash(), nil
+}
+
+func (t *treeStore) commit() error {
+	for tree := merkleTree(0); tree < numMerkleTrees; tree++ {
+		if err := t.merkleTrees[tree].Commit(); err != nil {
+			return fmt.Errorf(""failed to commit %s: %w"", merkleTreeToString[tree], err)
+		}
+	}
+	return nil
+}
+
+func (t *treeStore) getStateHash() string {
+	// create an order-matters list of roots
+	roots := make([][]byte, 0)
+	for tree := merkleTree(0); tree < numMerkleTrees; tree++ {
+		roots = append(roots, t.merkleTrees[tree].Root())
+	}
+
+	// combine them and hash the result
+	rootsConcat := bytes.Join(roots, []byte{})
+	stateHash := sha256.Sum256(rootsConcat)
+
+	// Convert the array to a slice and return it
+	// REF: https://stackoverflow.com/questions/28886616/convert-array-to-slice-in-go
+	return hex.EncodeToString(stateHash[:])
+}
+
+////////////////////////
+// Actor Tree Helpers //
+////////////////////////
+
+// NB: I think this needs to be done manually for all 4 types.
+func (t *treeStore) updateActorsTree(actorType coreTypes.ActorType, actors []*coreTypes.Actor) error {
+	for _, actor := range actors {
+		bzAddr, err := hex.DecodeString(actor.GetAddress())
+		if err != nil {
+			return err
+		}
+
+		actorBz, err := codec.GetCodec().Marshal(actor)
+		if err != nil {
+			return err
+		}
+
+		merkleTreeName, ok := actorTypeToMerkleTreeName[actorType]
+		if !ok {
+			return fmt.Errorf(""no merkle tree found for actor type: %s"", actorType)
+		}
+		if err := t.merkleTrees[merkleTreeName].Update(bzAddr, actorBz); err != nil {
+			return err
+		}
+	}
+
+	return nil
+}
+
+//////////////////////////
+// Account Tree Helpers //
+//////////////////////////
+
+func (t *treeStore) updateAccountTrees(accounts []*coreTypes.Account) error {
+	for _, account := range accounts {
+		bzAddr, err := hex.DecodeString(account.GetAddress())
+		if err != nil {
+			return err
+		}
+
+		accBz, err := codec.GetCodec().Marshal(account)
+		if err != nil {
+			return err
+		}
+
+		if err := t.merkleTrees[accountMerkleTree].Update(bzAddr, accBz); err != nil {
+			return err
+		}
+	}
+
+	return nil
+}
+
+func (t *treeStore) updatePoolTrees(pools []*coreTypes.Account) error {
+	for _, pool := range pools {
+		bzAddr, err := hex.DecodeString(pool.GetAddress())
+		if err != nil {
+			return err
+		}
+
+		accBz, err := codec.GetCodec().Marshal(pool)
+		if err != nil {
+			return err
+		}
+
+		if err := t.merkleTrees[poolMerkleTree].Update(bzAddr, accBz); err != nil {
+			return err
+		}
+	}
+
+	return nil
+}
+
+///////////////////////
+// Data Tree Helpers //
+///////////////////////
+
+func (t *treeStore) updateTransactionsTree(indexedTxs []*coreTypes.IndexedTransaction) error {
+	for _, idxTx := range indexedTxs {
+		txBz := idxTx.GetTx()
+		txHash := crypto.SHA3Hash(txBz)
+		if err := t.merkleTrees[transactionsMerkleTree].Update(txHash, txBz); err != nil {
+			return err
+		}
+	}
+	return nil
+}
+
+func (t *treeStore) updateParamsTree(params []*coreTypes.Param) error {
+	for _, param := range params {
+		paramBz, err := codec.GetCodec().Marshal(param)
+		paramKey := crypto.SHA3Hash([]byte(param.Name))
+		if err != nil {
+			return err
+		}
+		if err := t.merkleTrees[paramsMerkleTree].Update(paramKey, paramBz); err != nil {
+			return err
+		}
+	}
+
+	return nil
+}
+
+func (t *treeStore) updateFlagsTree(flags []*coreTypes.Flag) error {
+	for _, flag := range flags {
+		flagBz, err := codec.GetCodec().Marshal(flag)
+		flagKey := crypto.SHA3Hash([]byte(flag.Name))
+		if err != nil {
+			return err
+		}
+		if err := t.merkleTrees[flagsMerkleTree].Update(flagKey, flagBz); err != nil {
+			return err
+		}
+	}
+
+	return nil
+}
+
+// getActorsUpdated is responsible for fetching the actors that have been updated at a given height.
+func (t *treeStore) getActorsUpdated(
+	pgtx pgx.Tx,
+	actorType coreTypes.ActorType,
+	height uint64,
+) ([]*coreTypes.Actor, error) {
+	actorSchema, ok := actorTypeToSchemaName[actorType]
+	if !ok {
+		return nil, fmt.Errorf(""no schema found for actor type: %s"", actorType)
+	}
+
+	// TECHDEBT (ISSUE #813): Avoid this cast to int64
+	// https://github.com/pokt-network/pocket/issues/813
+	query := actorSchema.GetUpdatedAtHeightQuery(int64(height))
+	rows, err := pgtx.Query(context.TODO(), query)
+	if err != nil {
+		return nil, err
+	}
+	defer rows.Close()
+
+	addrs := make([][]byte, 0)
+	for rows.Next() {
+		var addr string
+		if err := rows.Scan(&addr); err != nil {
+			return nil, err
+		}
+		addrBz, err := hex.DecodeString(addr)
+		if err != nil {
+			return nil, err
+		}
+		addrs = append(addrs, addrBz)
+	}
+
+	actors := make([]*coreTypes.Actor, len(addrs))
+	for i, addr := range addrs {
+		// TECHDEBT #XXX: Avoid this cast to int64
+		actor, err := t.getActor(pgtx, actorSchema, addr, int64(height))
+		if err != nil {
+			return nil, err
+		}
+		actors[i] = actor
+	}
+	rows.Close()",persistence/trees/trees.go,2023-06-14 20:23:38+00:00,2023-06-14T20:26:15Z,"Given line 391, I don't think we need this",,,,,415,RIGHT,415,,line,https://api.github.com/repos/pokt-network/pocket/pulls/756,pokt-network/pocket,70a1a0e2fe2c238fce8c2019e13e9167629a2639
https://api.github.com/repos/pokt-network/pocket/pulls/756,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1230127975,Olshansk,64586305e2aaeb40b5380dde8c922368e4ec8464,b83e7add3d4570727d6a171996fe14d5701bf22f,"@@ -0,0 +1,574 @@
+// package trees maintains a set of sparse merkle trees
+// each backed by the KVStore interface. It offers an atomic
+// commit and rollback mechanism for interacting with
+// that core resource map of merkle trees.
+package trees
+
+import (
+	""bytes""
+	""context""
+	""crypto/sha256""
+	""encoding/hex""
+	""fmt""
+
+	""github.com/jackc/pgx/v5""
+
+	""github.com/pokt-network/pocket/persistence/indexer""
+	""github.com/pokt-network/pocket/persistence/kvstore""
+	ptypes ""github.com/pokt-network/pocket/persistence/types""
+	""github.com/pokt-network/pocket/shared/codec""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/crypto""
+	""github.com/pokt-network/smt""
+)
+
+var merkleTreeToString = map[merkleTree]string{
+	appMerkleTree:      ""app"",
+	valMerkleTree:      ""val"",
+	fishMerkleTree:     ""fish"",
+	servicerMerkleTree: ""servicer"",
+
+	accountMerkleTree: ""account"",
+	poolMerkleTree:    ""pool"",
+
+	transactionsMerkleTree: ""transactions"",
+	paramsMerkleTree:       ""params"",
+	flagsMerkleTree:        ""flags"",
+}
+
+var actorTypeToMerkleTreeName = map[coreTypes.ActorType]merkleTree{
+	coreTypes.ActorType_ACTOR_TYPE_APP:      appMerkleTree,
+	coreTypes.ActorType_ACTOR_TYPE_VAL:      valMerkleTree,
+	coreTypes.ActorType_ACTOR_TYPE_FISH:     fishMerkleTree,
+	coreTypes.ActorType_ACTOR_TYPE_SERVICER: servicerMerkleTree,
+}
+
+var actorTypeToSchemaName = map[coreTypes.ActorType]ptypes.ProtocolActorSchema{
+	coreTypes.ActorType_ACTOR_TYPE_APP:      ptypes.ApplicationActor,
+	coreTypes.ActorType_ACTOR_TYPE_VAL:      ptypes.ValidatorActor,
+	coreTypes.ActorType_ACTOR_TYPE_FISH:     ptypes.FishermanActor,
+	coreTypes.ActorType_ACTOR_TYPE_SERVICER: ptypes.ServicerActor,
+}
+
+var merkleTreeToActorTypeName = map[merkleTree]coreTypes.ActorType{
+	appMerkleTree:      coreTypes.ActorType_ACTOR_TYPE_APP,
+	valMerkleTree:      coreTypes.ActorType_ACTOR_TYPE_VAL,
+	fishMerkleTree:     coreTypes.ActorType_ACTOR_TYPE_FISH,
+	servicerMerkleTree: coreTypes.ActorType_ACTOR_TYPE_SERVICER,
+}
+
+type merkleTree float64
+
+// A list of Merkle Trees used to maintain the state hash.
+const (
+	// IMPORTANT: The order in which these trees are defined is important and strict. It implicitly
+	// defines the index of the root hash each independent as they are concatenated together
+	// to generate the state hash.
+
+	// Actor Merkle Trees
+	appMerkleTree merkleTree = iota
+	valMerkleTree
+	fishMerkleTree
+	servicerMerkleTree
+
+	// Account Merkle Trees
+	accountMerkleTree
+	poolMerkleTree
+
+	// Data Merkle Trees
+	transactionsMerkleTree
+	paramsMerkleTree
+	flagsMerkleTree
+
+	// Used for iteration purposes only; see https://stackoverflow.com/a/64178235/768439 as a reference
+	numMerkleTrees
+)
+
+// treeStore stores a set of merkle trees that
+// it manages. It fulfills the modules.TreeStore interface.
+// * It is responsible for commit or rollback behavior
+// of the underlying trees by utilizing the lazy loading
+// functionality provided by the underlying smt library.
+type treeStore struct {
+	treeStoreDir string
+	merkleTrees  map[merkleTree]*smt.SMT
+	nodeStores   map[merkleTree]kvstore.KVStore
+}
+
+// Update takes a transaction and a height and updates
+// all of the trees in the treeStore for that height.
+func (t *treeStore) Update(pgtx pgx.Tx, txi indexer.TxIndexer, height uint64) (string, error) {
+	return t.updateMerkleTrees(pgtx, txi, height)
+}
+
+func NewStateTrees(treesStoreDir string) (*treeStore, error) {
+	if treesStoreDir == "":memory:"" {
+		return newMemStateTrees()
+	}
+
+	stateTrees := &treeStore{
+		treeStoreDir: treesStoreDir,
+		merkleTrees:  make(map[merkleTree]*smt.SMT, int(numMerkleTrees)),
+		nodeStores:   make(map[merkleTree]kvstore.KVStore, int(numMerkleTrees)),
+	}
+
+	for tree := merkleTree(0); tree < numMerkleTrees; tree++ {
+		nodeStore, err := kvstore.NewKVStore(fmt.Sprintf(""%s/%s_nodes"", treesStoreDir, merkleTreeToString[tree]))
+		if err != nil {
+			return nil, err
+		}
+		stateTrees.nodeStores[tree] = nodeStore
+		stateTrees.merkleTrees[tree] = smt.NewSparseMerkleTree(nodeStore, sha256.New())
+	}
+	return stateTrees, nil
+}
+
+// DebugClearAll is used by the debug cli to completely reset all merkle trees.
+// This should only be called by the debug CLI.
+func (t *treeStore) DebugClearAll() error {
+	for treeType := merkleTree(0); treeType < numMerkleTrees; treeType++ {
+		nodeStore := t.nodeStores[treeType]
+		if err := nodeStore.ClearAll(); err != nil {
+			return fmt.Errorf(""failed to clear %s node store: %w"", merkleTreeToString[treeType], err)
+		}
+		t.merkleTrees[treeType] = smt.NewSparseMerkleTree(nodeStore, sha256.New())
+	}
+
+	return nil
+}
+
+// newMemStateTrees creates a new in-memory state tree
+func newMemStateTrees() (*treeStore, error) {
+	stateTrees := &treeStore{
+		merkleTrees: make(map[merkleTree]*smt.SMT, int(numMerkleTrees)),
+		nodeStores:  make(map[merkleTree]kvstore.KVStore, int(numMerkleTrees)),
+	}
+	for tree := merkleTree(0); tree < numMerkleTrees; tree++ {
+		nodeStore := kvstore.NewMemKVStore() // For testing, `smt.NewSimpleMap()` can be used as well
+		stateTrees.nodeStores[tree] = nodeStore
+		stateTrees.merkleTrees[tree] = smt.NewSparseMerkleTree(nodeStore, sha256.New())
+	}
+	return stateTrees, nil
+}
+
+// updateMerkleTrees updates all of the merkle trees that TreeStore manages.
+// * it returns an hash of the output or an error.
+func (t *treeStore) updateMerkleTrees(pgtx pgx.Tx, txi indexer.TxIndexer, height uint64) (string, error) {
+	for treeType := merkleTree(0); treeType < numMerkleTrees; treeType++ {
+		switch treeType {
+		// Actor Merkle Trees
+		case appMerkleTree, valMerkleTree, fishMerkleTree, servicerMerkleTree:
+			actorType, ok := merkleTreeToActorTypeName[treeType]
+			if !ok {
+				return """", fmt.Errorf(""no actor type found for merkle tree: %v"", treeType)
+			}
+
+			actors, err := t.getActorsUpdated(pgtx, actorType, height)
+			if err != nil {
+				return """", fmt.Errorf(""failed to get actors at height: %w"", err)
+			}
+
+			if err := t.updateActorsTree(actorType, actors); err != nil {
+				return """", fmt.Errorf(""failed to update actors tree for treeType: %v, actorType: %v - %w"", treeType, actorType, err)
+			}
+
+		// Account Merkle Trees
+		case accountMerkleTree:
+			accounts, err := t.getAccounts(pgtx, height)
+			if err != nil {
+				return """", fmt.Errorf(""failed to get accounts: %w"", err)
+			}
+			if err := t.updateAccountTrees(accounts); err != nil {
+				return """", fmt.Errorf(""failed to update account trees: %w"", err)
+			}
+		case poolMerkleTree:
+			pools, err := t.getPools(pgtx, height)
+			if err != nil {
+				return """", fmt.Errorf(""failed to get transactions: %w"", err)
+			}
+			if err := t.updatePoolTrees(pools); err != nil {
+				return """", fmt.Errorf(""failed to update pool trees - %w"", err)
+			}
+
+		// Data Merkle Trees
+		case transactionsMerkleTree:
+			indexedTxs, err := t.getTransactions(txi, height)
+			if err != nil {
+				return """", fmt.Errorf(""failed to get transactions: %w"", err)
+			}
+			if err := t.updateTransactionsTree(indexedTxs); err != nil {
+				return """", fmt.Errorf(""failed to update transactions: %w"", err)
+			}
+		case paramsMerkleTree:
+			params, err := t.getParams(pgtx, height)
+			if err != nil {
+				return """", fmt.Errorf(""failed to get params: %w"", err)
+			}
+			if err := t.updateParamsTree(params); err != nil {
+				return """", fmt.Errorf(""failed to update params tree: %w"", err)
+			}
+		case flagsMerkleTree:
+			flags, err := t.getFlags(pgtx, height)
+			if err != nil {
+				return """", fmt.Errorf(""failed to get flags from transaction: %w"", err)
+			}
+			if err := t.updateFlagsTree(flags); err != nil {
+				return """", fmt.Errorf(""failed to update flags tree - %w"", err)
+			}
+		// Default
+		default:
+			panic(fmt.Sprintf(""not handled in state commitment update. Merkle tree #{%v}"", treeType))
+		}
+	}
+
+	if err := t.commit(); err != nil {
+		return """", fmt.Errorf(""failed to commit: %w"", err)
+	}
+	return t.getStateHash(), nil
+}
+
+func (t *treeStore) commit() error {
+	for tree := merkleTree(0); tree < numMerkleTrees; tree++ {
+		if err := t.merkleTrees[tree].Commit(); err != nil {
+			return fmt.Errorf(""failed to commit %s: %w"", merkleTreeToString[tree], err)
+		}
+	}
+	return nil
+}
+
+func (t *treeStore) getStateHash() string {
+	// create an order-matters list of roots
+	roots := make([][]byte, 0)
+	for tree := merkleTree(0); tree < numMerkleTrees; tree++ {
+		roots = append(roots, t.merkleTrees[tree].Root())
+	}
+
+	// combine them and hash the result
+	rootsConcat := bytes.Join(roots, []byte{})
+	stateHash := sha256.Sum256(rootsConcat)
+
+	// Convert the array to a slice and return it
+	// REF: https://stackoverflow.com/questions/28886616/convert-array-to-slice-in-go
+	return hex.EncodeToString(stateHash[:])
+}
+
+////////////////////////
+// Actor Tree Helpers //
+////////////////////////
+
+// NB: I think this needs to be done manually for all 4 types.
+func (t *treeStore) updateActorsTree(actorType coreTypes.ActorType, actors []*coreTypes.Actor) error {
+	for _, actor := range actors {
+		bzAddr, err := hex.DecodeString(actor.GetAddress())
+		if err != nil {
+			return err
+		}
+
+		actorBz, err := codec.GetCodec().Marshal(actor)
+		if err != nil {
+			return err
+		}
+
+		merkleTreeName, ok := actorTypeToMerkleTreeName[actorType]
+		if !ok {
+			return fmt.Errorf(""no merkle tree found for actor type: %s"", actorType)
+		}
+		if err := t.merkleTrees[merkleTreeName].Update(bzAddr, actorBz); err != nil {
+			return err
+		}
+	}
+
+	return nil
+}
+
+//////////////////////////
+// Account Tree Helpers //
+//////////////////////////
+
+func (t *treeStore) updateAccountTrees(accounts []*coreTypes.Account) error {
+	for _, account := range accounts {
+		bzAddr, err := hex.DecodeString(account.GetAddress())
+		if err != nil {
+			return err
+		}
+
+		accBz, err := codec.GetCodec().Marshal(account)
+		if err != nil {
+			return err
+		}
+
+		if err := t.merkleTrees[accountMerkleTree].Update(bzAddr, accBz); err != nil {
+			return err
+		}
+	}
+
+	return nil
+}
+
+func (t *treeStore) updatePoolTrees(pools []*coreTypes.Account) error {
+	for _, pool := range pools {
+		bzAddr, err := hex.DecodeString(pool.GetAddress())
+		if err != nil {
+			return err
+		}
+
+		accBz, err := codec.GetCodec().Marshal(pool)
+		if err != nil {
+			return err
+		}
+
+		if err := t.merkleTrees[poolMerkleTree].Update(bzAddr, accBz); err != nil {
+			return err
+		}
+	}
+
+	return nil
+}
+
+///////////////////////
+// Data Tree Helpers //
+///////////////////////
+
+func (t *treeStore) updateTransactionsTree(indexedTxs []*coreTypes.IndexedTransaction) error {
+	for _, idxTx := range indexedTxs {
+		txBz := idxTx.GetTx()
+		txHash := crypto.SHA3Hash(txBz)
+		if err := t.merkleTrees[transactionsMerkleTree].Update(txHash, txBz); err != nil {
+			return err
+		}
+	}
+	return nil
+}
+
+func (t *treeStore) updateParamsTree(params []*coreTypes.Param) error {
+	for _, param := range params {
+		paramBz, err := codec.GetCodec().Marshal(param)
+		paramKey := crypto.SHA3Hash([]byte(param.Name))
+		if err != nil {
+			return err
+		}
+		if err := t.merkleTrees[paramsMerkleTree].Update(paramKey, paramBz); err != nil {
+			return err
+		}
+	}
+
+	return nil
+}
+
+func (t *treeStore) updateFlagsTree(flags []*coreTypes.Flag) error {
+	for _, flag := range flags {
+		flagBz, err := codec.GetCodec().Marshal(flag)
+		flagKey := crypto.SHA3Hash([]byte(flag.Name))
+		if err != nil {
+			return err
+		}
+		if err := t.merkleTrees[flagsMerkleTree].Update(flagKey, flagBz); err != nil {
+			return err
+		}
+	}
+
+	return nil
+}
+
+// getActorsUpdated is responsible for fetching the actors that have been updated at a given height.
+func (t *treeStore) getActorsUpdated(
+	pgtx pgx.Tx,
+	actorType coreTypes.ActorType,
+	height uint64,
+) ([]*coreTypes.Actor, error) {
+	actorSchema, ok := actorTypeToSchemaName[actorType]
+	if !ok {
+		return nil, fmt.Errorf(""no schema found for actor type: %s"", actorType)
+	}
+
+	// TECHDEBT (ISSUE #813): Avoid this cast to int64
+	// https://github.com/pokt-network/pocket/issues/813
+	query := actorSchema.GetUpdatedAtHeightQuery(int64(height))
+	rows, err := pgtx.Query(context.TODO(), query)
+	if err != nil {
+		return nil, err
+	}
+	defer rows.Close()
+
+	addrs := make([][]byte, 0)
+	for rows.Next() {
+		var addr string
+		if err := rows.Scan(&addr); err != nil {
+			return nil, err
+		}
+		addrBz, err := hex.DecodeString(addr)
+		if err != nil {
+			return nil, err
+		}
+		addrs = append(addrs, addrBz)
+	}
+
+	actors := make([]*coreTypes.Actor, len(addrs))
+	for i, addr := range addrs {
+		// TECHDEBT #XXX: Avoid this cast to int64
+		actor, err := t.getActor(pgtx, actorSchema, addr, int64(height))
+		if err != nil {
+			return nil, err
+		}
+		actors[i] = actor
+	}
+	rows.Close()
+
+	return actors, nil
+}
+
+func (t *treeStore) getAccountsUpdated(
+	pgtx pgx.Tx,
+	acctType ptypes.ProtocolAccountSchema,
+	height uint64,
+) ([]*coreTypes.Account, error) {
+	accounts := []*coreTypes.Account{}
+
+	// TECHDEBT (ISSUE #813): Avoid this cast to int64
+	// https://github.com/pokt-network/pocket/issues/813
+	query := acctType.GetAccountsUpdatedAtHeightQuery(int64(height))
+	rows, err := pgtx.Query(context.TODO(), query)
+	if err != nil {
+		return nil, err
+	}
+	defer rows.Close()
+
+	for rows.Next() {
+		acc := new(coreTypes.Account)
+		if err := rows.Scan(&acc.Address, &acc.Amount); err != nil {
+			return nil, err
+		}
+		accounts = append(accounts, acc)
+	}
+
+	return accounts, nil
+}
+
+func (t *treeStore) getTransactions(txi indexer.TxIndexer, height uint64) ([]*coreTypes.IndexedTransaction, error) {
+	// TECHDEBT (ISSUE #813): Avoid this cast to int64
+	// https://github.com/pokt-network/pocket/issues/813
+	indexedTxs, err := txi.GetByHeight(int64(height), false)
+	if err != nil {
+		return nil, fmt.Errorf(""failed to get transactions by height: %w"", err)
+	}
+	return indexedTxs, nil
+}
+
+// getPools returns the pools updated at the given height
+func (t *treeStore) getPools(pgtx pgx.Tx, height uint64) ([]*coreTypes.Account, error) {
+	pools, err := t.getAccountsUpdated(pgtx, ptypes.Pool, height)
+	if err != nil {
+		return nil, fmt.Errorf(""failed to get pools: %w"", err)
+	}
+	return pools, nil
+}
+
+// getAccounts returns the list of accounts updated at the provided height
+func (t *treeStore) getAccounts(pgtx pgx.Tx, height uint64) ([]*coreTypes.Account, error) {
+	accounts, err := t.getAccountsUpdated(pgtx, ptypes.Account, height)
+	if err != nil {
+		return nil, fmt.Errorf(""failed to get accounts: %w"", err)
+	}
+	return accounts, nil
+}
+
+func (t *treeStore) getFlags(pgtx pgx.Tx, height uint64) ([]*coreTypes.Flag, error) {",persistence/trees/trees.go,2023-06-14 20:26:06+00:00,2023-06-14T20:26:15Z,"Prior to this change, we were using a helper:

![Screenshot 2023-06-14 at 1 24 27 PM](https://github.com/pokt-network/pocket/assets/1892194/e69fd525-4f82-429c-a9e8-443b210337e3)

I'm not a fan of as it lets SQL spill over into new pats of the code that were otherwise blind to it

![Screenshot 2023-06-14 at 1 24 44 PM](https://github.com/pokt-network/pocket/assets/1892194/ddd56718-5fda-4d58-80c5-30351c08c9f4)

I feel strongly that we either revert or encapsulate the logic elsewhere, or please explain the logic/reasoning here.
",,,,,476,RIGHT,475,,line,https://api.github.com/repos/pokt-network/pocket/pulls/756,pokt-network/pocket,70a1a0e2fe2c238fce8c2019e13e9167629a2639
https://api.github.com/repos/pokt-network/pocket/pulls/756,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1232247008,h5law,f35bc5b63358eb061b8080ee37db0bacc8511d21,b83e7add3d4570727d6a171996fe14d5701bf22f,"@@ -0,0 +1,365 @@
+// package trees maintains a set of sparse merkle trees
+// each backed by the KVStore interface. It offers an atomic
+// commit and rollback mechanism for interacting with
+// that core resource map of merkle trees.
+package trees
+
+import (
+	""bytes""
+	""crypto/sha256""
+	""encoding/hex""
+	""fmt""
+
+	""github.com/jackc/pgx/v5""
+
+	""github.com/pokt-network/pocket/persistence/indexer""
+	""github.com/pokt-network/pocket/persistence/kvstore""
+	""github.com/pokt-network/pocket/persistence/sql""
+	""github.com/pokt-network/pocket/shared/codec""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/crypto""
+	""github.com/pokt-network/smt""
+)
+
+var merkleTreeToString = map[merkleTree]string{
+	appMerkleTree:      ""app"",
+	valMerkleTree:      ""val"",
+	fishMerkleTree:     ""fish"",
+	servicerMerkleTree: ""servicer"",
+
+	accountMerkleTree: ""account"",
+	poolMerkleTree:    ""pool"",
+
+	transactionsMerkleTree: ""transactions"",
+	paramsMerkleTree:       ""params"",
+	flagsMerkleTree:        ""flags"",
+}
+
+var actorTypeToMerkleTreeName = map[coreTypes.ActorType]merkleTree{
+	coreTypes.ActorType_ACTOR_TYPE_APP:      appMerkleTree,
+	coreTypes.ActorType_ACTOR_TYPE_VAL:      valMerkleTree,
+	coreTypes.ActorType_ACTOR_TYPE_FISH:     fishMerkleTree,
+	coreTypes.ActorType_ACTOR_TYPE_SERVICER: servicerMerkleTree,
+}
+
+var merkleTreeToActorTypeName = map[merkleTree]coreTypes.ActorType{
+	appMerkleTree:      coreTypes.ActorType_ACTOR_TYPE_APP,
+	valMerkleTree:      coreTypes.ActorType_ACTOR_TYPE_VAL,
+	fishMerkleTree:     coreTypes.ActorType_ACTOR_TYPE_FISH,
+	servicerMerkleTree: coreTypes.ActorType_ACTOR_TYPE_SERVICER,
+}
+
+type merkleTree float64
+
+// A list of Merkle Trees used to maintain the state hash.
+const (
+	// IMPORTANT: The order in which these trees are defined is important and strict. It implicitly",persistence/trees/trees.go,2023-06-16 13:22:46+00:00,2023-06-16T13:22:46Z,"Wdyt of changing the root hash calculation to be the root of an SMT with key value pairings as follows:
`stateRootTree.Update([]byte(""app""), treeStore.merkleTrees[""app""].Root())`

Then our state root would be `stateRootTree.Root()`",,,,59.0,59,RIGHT,56,59.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/756,pokt-network/pocket,70a1a0e2fe2c238fce8c2019e13e9167629a2639
https://api.github.com/repos/pokt-network/pocket/pulls/756,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1232473942,dylanlott,f35bc5b63358eb061b8080ee37db0bacc8511d21,b83e7add3d4570727d6a171996fe14d5701bf22f,"@@ -0,0 +1,35 @@
+# SQL Package
+
+The SQL package is a library of functions that all take a `pgx.Tx` as an argument and execute SQL queries on it.
+
+- GetAccountsUpdated
+- GetActors
+- GetTransactions
+- GetPools
+- GetAccounts
+- GetFlags
+- GetParams
+
+These functions are meant to abstract away the SQL row and error handling for components of the persistence package.
+
+GetActors is used to get each of the actor types in the system: Applications, Validators, Watchers, and Servicers.
+
+## Why a whole package?
+
+If the SQL handling lives in the persistence package, the package submodules will run into import cycle errors when attempting to use the SQL handlers. Putting the SQL helpers into a package inside persistence avoids the import cycle.
+
+```mermaid
+flowchart TD
+    subgraph pers[persistence]
+        subgraph p[ without sql package - import cycle error ]
+            persistenceContext1[PersistenceContext]
+            treeStore1[TreeStore]
+            treeStore1 -- Tx --> persistenceContext1
+            persistenceContext1 -- Tx --> treeStore1
+        end 
+        subgraph p2[ with sql package - refactored ]
+            persistenceContext -- Tx --> sql
+            treeStore2 -- Tx --> sql
+        end 
+    end
+```",persistence/sql/README.md,2023-06-16 16:25:14+00:00,2023-06-16T16:25:15Z,@Olshansk the import cycle issue is described here.,21.0,21.0,RIGHT,35.0,35,RIGHT,35,35.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/756,pokt-network/pocket,70a1a0e2fe2c238fce8c2019e13e9167629a2639
https://api.github.com/repos/pokt-network/pocket/pulls/756,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1233962823,h5law,e64af30a6d730881f04c5cbe5c44c3fe3d992d05,b83e7add3d4570727d6a171996fe14d5701bf22f,"@@ -0,0 +1,365 @@
+// package trees maintains a set of sparse merkle trees
+// each backed by the KVStore interface. It offers an atomic
+// commit and rollback mechanism for interacting with
+// that core resource map of merkle trees.
+package trees
+
+import (
+	""bytes""
+	""crypto/sha256""
+	""encoding/hex""
+	""fmt""
+
+	""github.com/jackc/pgx/v5""
+
+	""github.com/pokt-network/pocket/persistence/indexer""
+	""github.com/pokt-network/pocket/persistence/kvstore""
+	""github.com/pokt-network/pocket/persistence/sql""
+	""github.com/pokt-network/pocket/shared/codec""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/crypto""
+	""github.com/pokt-network/smt""
+)
+
+var merkleTreeToString = map[merkleTree]string{
+	appMerkleTree:      ""app"",
+	valMerkleTree:      ""val"",
+	fishMerkleTree:     ""fish"",
+	servicerMerkleTree: ""servicer"",
+
+	accountMerkleTree: ""account"",
+	poolMerkleTree:    ""pool"",
+
+	transactionsMerkleTree: ""transactions"",
+	paramsMerkleTree:       ""params"",
+	flagsMerkleTree:        ""flags"",
+}
+
+var actorTypeToMerkleTreeName = map[coreTypes.ActorType]merkleTree{
+	coreTypes.ActorType_ACTOR_TYPE_APP:      appMerkleTree,
+	coreTypes.ActorType_ACTOR_TYPE_VAL:      valMerkleTree,
+	coreTypes.ActorType_ACTOR_TYPE_FISH:     fishMerkleTree,
+	coreTypes.ActorType_ACTOR_TYPE_SERVICER: servicerMerkleTree,
+}
+
+var merkleTreeToActorTypeName = map[merkleTree]coreTypes.ActorType{
+	appMerkleTree:      coreTypes.ActorType_ACTOR_TYPE_APP,
+	valMerkleTree:      coreTypes.ActorType_ACTOR_TYPE_VAL,
+	fishMerkleTree:     coreTypes.ActorType_ACTOR_TYPE_FISH,
+	servicerMerkleTree: coreTypes.ActorType_ACTOR_TYPE_SERVICER,
+}
+
+type merkleTree float64
+
+// A list of Merkle Trees used to maintain the state hash.
+const (
+	// IMPORTANT: The order in which these trees are defined is important and strict. It implicitly
+	// defines the index of the root hash each independent as they are concatenated together
+	// to generate the state hash.
+
+	// TECHDEBT(#834): Remove the need for enforced ordering
+
+	// Actor Merkle Trees
+	appMerkleTree merkleTree = iota
+	valMerkleTree
+	fishMerkleTree
+	servicerMerkleTree
+
+	// Account Merkle Trees
+	accountMerkleTree
+	poolMerkleTree
+
+	// Data Merkle Trees
+	transactionsMerkleTree
+	paramsMerkleTree
+	flagsMerkleTree
+
+	// Used for iteration purposes only; see https://stackoverflow.com/a/64178235/768439 as a reference
+	numMerkleTrees
+)
+
+// treeStore stores a set of merkle trees that
+// it manages. It fulfills the modules.TreeStore interface.
+// * It is responsible for atomic commit or rollback behavior
+// of the underlying trees by utilizing the lazy loading
+// functionality provided by the underlying smt library.
+type treeStore struct {
+	treeStoreDir string
+	merkleTrees  map[merkleTree]*smt.SMT
+	nodeStores   map[merkleTree]kvstore.KVStore
+}
+
+// Update takes a transaction and a height and updates
+// all of the trees in the treeStore for that height.
+func (t *treeStore) Update(pgtx pgx.Tx, txi indexer.TxIndexer, height uint64) (string, error) {
+	return t.updateMerkleTrees(pgtx, txi, height)
+}
+
+func NewStateTrees(treesStoreDir string) (*treeStore, error) {
+	if treesStoreDir == "":memory:"" {
+		return newMemStateTrees()
+	}
+
+	stateTrees := &treeStore{
+		treeStoreDir: treesStoreDir,
+		merkleTrees:  make(map[merkleTree]*smt.SMT, int(numMerkleTrees)),
+		nodeStores:   make(map[merkleTree]kvstore.KVStore, int(numMerkleTrees)),
+	}
+
+	for tree := merkleTree(0); tree < numMerkleTrees; tree++ {
+		nodeStore, err := kvstore.NewKVStore(fmt.Sprintf(""%s/%s_nodes"", treesStoreDir, merkleTreeToString[tree]))
+		if err != nil {
+			return nil, err
+		}
+		stateTrees.nodeStores[tree] = nodeStore
+		stateTrees.merkleTrees[tree] = smt.NewSparseMerkleTree(nodeStore, sha256.New())
+	}
+	return stateTrees, nil
+}
+
+// DebugClearAll is used by the debug cli to completely reset all merkle trees.
+// This should only be called by the debug CLI.
+func (t *treeStore) DebugClearAll() error {
+	for treeType := merkleTree(0); treeType < numMerkleTrees; treeType++ {
+		nodeStore := t.nodeStores[treeType]
+		if err := nodeStore.ClearAll(); err != nil {
+			return fmt.Errorf(""failed to clear %s node store: %w"", merkleTreeToString[treeType], err)
+		}
+		t.merkleTrees[treeType] = smt.NewSparseMerkleTree(nodeStore, sha256.New())
+	}
+
+	return nil
+}
+
+// newMemStateTrees creates a new in-memory state tree
+func newMemStateTrees() (*treeStore, error) {
+	stateTrees := &treeStore{
+		merkleTrees: make(map[merkleTree]*smt.SMT, int(numMerkleTrees)),
+		nodeStores:  make(map[merkleTree]kvstore.KVStore, int(numMerkleTrees)),
+	}
+	for tree := merkleTree(0); tree < numMerkleTrees; tree++ {
+		nodeStore := kvstore.NewMemKVStore() // For testing, `smt.NewSimpleMap()` can be used as well
+		stateTrees.nodeStores[tree] = nodeStore
+		stateTrees.merkleTrees[tree] = smt.NewSparseMerkleTree(nodeStore, sha256.New())
+	}
+	return stateTrees, nil
+}
+
+// updateMerkleTrees updates all of the merkle trees that TreeStore manages.
+// * it returns an hash of the output or an error.
+func (t *treeStore) updateMerkleTrees(pgtx pgx.Tx, txi indexer.TxIndexer, height uint64) (string, error) {
+	for treeType := merkleTree(0); treeType < numMerkleTrees; treeType++ {
+		switch treeType {
+		// Actor Merkle Trees
+		case appMerkleTree, valMerkleTree, fishMerkleTree, servicerMerkleTree:
+			actorType, ok := merkleTreeToActorTypeName[treeType]
+			if !ok {
+				return """", fmt.Errorf(""no actor type found for merkle tree: %v"", treeType)
+			}
+
+			actors, err := sql.GetActors(pgtx, actorType, height)
+			if err != nil {
+				return """", fmt.Errorf(""failed to get actors at height: %w"", err)
+			}
+
+			if err := t.updateActorsTree(actorType, actors); err != nil {
+				return """", fmt.Errorf(""failed to update actors tree for treeType: %v, actorType: %v - %w"", treeType, actorType, err)
+			}
+
+		// Account Merkle Trees
+		case accountMerkleTree:
+			accounts, err := sql.GetAccounts(pgtx, height)
+			if err != nil {
+				return """", fmt.Errorf(""failed to get accounts: %w"", err)
+			}
+			if err := t.updateAccountTrees(accounts); err != nil {
+				return """", fmt.Errorf(""failed to update account trees: %w"", err)
+			}
+		case poolMerkleTree:
+			pools, err := sql.GetPools(pgtx, height)
+			if err != nil {
+				return """", fmt.Errorf(""failed to get transactions: %w"", err)
+			}
+			if err := t.updatePoolTrees(pools); err != nil {
+				return """", fmt.Errorf(""failed to update pool trees - %w"", err)
+			}
+
+		// Data Merkle Trees
+		case transactionsMerkleTree:
+			indexedTxs, err := sql.GetTransactions(txi, height)
+			if err != nil {
+				return """", fmt.Errorf(""failed to get transactions: %w"", err)
+			}
+			if err := t.updateTransactionsTree(indexedTxs); err != nil {
+				return """", fmt.Errorf(""failed to update transactions: %w"", err)
+			}
+		case paramsMerkleTree:
+			params, err := sql.GetParams(pgtx, height)
+			if err != nil {
+				return """", fmt.Errorf(""failed to get params: %w"", err)
+			}
+			if err := t.updateParamsTree(params); err != nil {
+				return """", fmt.Errorf(""failed to update params tree: %w"", err)
+			}
+		case flagsMerkleTree:
+			flags, err := sql.GetFlags(pgtx, height)
+			if err != nil {
+				return """", fmt.Errorf(""failed to get flags from transaction: %w"", err)
+			}
+			if err := t.updateFlagsTree(flags); err != nil {
+				return """", fmt.Errorf(""failed to update flags tree - %w"", err)
+			}
+		// Default
+		default:
+			panic(fmt.Sprintf(""not handled in state commitment update. Merkle tree #{%v}"", treeType))
+		}
+	}
+
+	if err := t.commit(); err != nil {
+		return """", fmt.Errorf(""failed to commit: %w"", err)
+	}
+	return t.getStateHash(), nil
+}
+
+func (t *treeStore) commit() error {
+	for tree := merkleTree(0); tree < numMerkleTrees; tree++ {
+		if err := t.merkleTrees[tree].Commit(); err != nil {
+			return fmt.Errorf(""failed to commit %s: %w"", merkleTreeToString[tree], err)
+		}
+	}
+	return nil
+}
+
+func (t *treeStore) getStateHash() string {
+	// create an order-matters list of roots
+	roots := make([][]byte, 0)
+	for tree := merkleTree(0); tree < numMerkleTrees; tree++ {
+		roots = append(roots, t.merkleTrees[tree].Root())
+	}
+
+	// combine them and hash the result
+	rootsConcat := bytes.Join(roots, []byte{})
+	stateHash := sha256.Sum256(rootsConcat)
+
+	// Convert the array to a slice and return it
+	// REF: https://stackoverflow.com/questions/28886616/convert-array-to-slice-in-go
+	return hex.EncodeToString(stateHash[:])
+}
+
+////////////////////////
+// Actor Tree Helpers //
+////////////////////////
+
+// NB: I think this needs to be done manually for all 4 types.
+func (t *treeStore) updateActorsTree(actorType coreTypes.ActorType, actors []*coreTypes.Actor) error {
+	for _, actor := range actors {
+		bzAddr, err := hex.DecodeString(actor.GetAddress())
+		if err != nil {
+			return err
+		}
+
+		actorBz, err := codec.GetCodec().Marshal(actor)
+		if err != nil {
+			return err
+		}
+
+		merkleTreeName, ok := actorTypeToMerkleTreeName[actorType]
+		if !ok {
+			return fmt.Errorf(""no merkle tree found for actor type: %s"", actorType)
+		}
+		if err := t.merkleTrees[merkleTreeName].Update(bzAddr, actorBz); err != nil {
+			return err
+		}
+	}
+
+	return nil
+}
+
+//////////////////////////
+// Account Tree Helpers //
+//////////////////////////
+
+func (t *treeStore) updateAccountTrees(accounts []*coreTypes.Account) error {
+	for _, account := range accounts {
+		bzAddr, err := hex.DecodeString(account.GetAddress())
+		if err != nil {
+			return err
+		}
+
+		accBz, err := codec.GetCodec().Marshal(account)
+		if err != nil {
+			return err
+		}
+
+		if err := t.merkleTrees[accountMerkleTree].Update(bzAddr, accBz); err != nil {
+			return err
+		}
+	}
+
+	return nil
+}
+
+func (t *treeStore) updatePoolTrees(pools []*coreTypes.Account) error {
+	for _, pool := range pools {
+		bzAddr, err := hex.DecodeString(pool.GetAddress())
+		if err != nil {
+			return err
+		}
+
+		accBz, err := codec.GetCodec().Marshal(pool)
+		if err != nil {
+			return err
+		}
+
+		if err := t.merkleTrees[poolMerkleTree].Update(bzAddr, accBz); err != nil {
+			return err
+		}
+	}
+
+	return nil
+}
+
+///////////////////////
+// Data Tree Helpers //
+///////////////////////
+
+func (t *treeStore) updateTransactionsTree(indexedTxs []*coreTypes.IndexedTransaction) error {
+	for _, idxTx := range indexedTxs {
+		txBz := idxTx.GetTx()
+		txHash := crypto.SHA3Hash(txBz)
+		if err := t.merkleTrees[transactionsMerkleTree].Update(txHash, txBz); err != nil {
+			return err
+		}
+	}
+	return nil
+}
+
+func (t *treeStore) updateParamsTree(params []*coreTypes.Param) error {",persistence/trees/trees.go,2023-06-19 12:06:32+00:00,2023-06-19T12:06:33Z,"<img width=""866"" alt=""Screenshot 2023-06-19 at 13 06 04"" src=""https://github.com/pokt-network/pocket/assets/53987565/7c5c7c99-78ee-4507-b256-3754e10d6cd6"">

Can you address these linter errors? Either bring the helper functions into the SQL package or remove them",,,,340.0,340,RIGHT,337,340.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/756,pokt-network/pocket,70a1a0e2fe2c238fce8c2019e13e9167629a2639
https://api.github.com/repos/pokt-network/pocket/pulls/756,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1237685551,Olshansk,70537cacb898c08d8a3225b3b5d5e124aca26bb9,b83e7add3d4570727d6a171996fe14d5701bf22f,"@@ -0,0 +1,19 @@
+package trees
+
+import ""testing""
+
+// TECHDEBT #836: Tests added in https://github.com/pokt-network/pocket/pull/836",persistence/trees/trees_test.go,2023-06-21 20:54:50+00:00,2023-06-21T20:57:01Z,"```suggestion
// TECHDEBT(#836): Tests added in https://github.com/pokt-network/pocket/pull/836
```

I'm just thinking about automation and regex parsing",,,,,5,RIGHT,5,,line,https://api.github.com/repos/pokt-network/pocket/pulls/756,pokt-network/pocket,70a1a0e2fe2c238fce8c2019e13e9167629a2639
https://api.github.com/repos/pokt-network/pocket/pulls/786,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1212394250,h5law,2be66719100cac8cf41fc4e2e010c43ca58fb698,1be22052a01cfc063c59b953651b7123bdcb9f76,"@@ -0,0 +1,14 @@
+
+Feature: Query Namespace
+
+  Scenario: User Wants Help Using The Query Command 
+    Given the user has a validator
+    When the user runs the command ""Query help""
+    Then the user should be able to see standard output containing ""Available Commands""",e2e/tests/query.feature,2023-05-31 22:52:17+00:00,2023-05-31T22:52:18Z,So cool we can test with language like this 😎 ,,,,7.0,7,RIGHT,7,7.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/786,pokt-network/pocket,29bb66fa8520d8ccb7dcf97fa1f43d75a925d7b0
https://api.github.com/repos/pokt-network/pocket/pulls/786,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1212399146,Olshansk,2be66719100cac8cf41fc4e2e010c43ca58fb698,1be22052a01cfc063c59b953651b7123bdcb9f76,"@@ -0,0 +1,14 @@
+
+Feature: Query Namespace
+
+  Scenario: User Wants Help Using The Query Command 
+    Given the user has a validator
+    When the user runs the command ""Query help""
+    Then the user should be able to see standard output containing ""Available Commands""
+    And the validator should have exited without error
+
+    Scenario: User Wants To See The Block At Current Height
+    Given the user has a validator",e2e/tests/query.feature,2023-05-31 23:01:00+00:00,2023-05-31T23:01:07Z,"Can you leave a TODO somewhere that this should probably be renamed/rewroded to ""full node"" / ""node"" in the future?",,,,11.0,11,RIGHT,11,11.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/786,pokt-network/pocket,29bb66fa8520d8ccb7dcf97fa1f43d75a925d7b0
https://api.github.com/repos/pokt-network/pocket/pulls/790,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1210510108,dylanlott,b9b2976065982ce254f896d872bb23248b60c422,52a025c7ab854a5015f19287106f369e49a6bb0d,"@@ -17,12 +17,11 @@ import (
 type merkleTree float64
 
 type stateTrees struct {
-	merkleTrees map[merkleTree]*smt.SparseMerkleTree
+	merkleTrees map[merkleTree]*smt.SMT
 
-	// nodeStores & valueStore are part of the SMT, but references are kept below for convenience
+	// nodeStores are part of the SMT, but references are kept below for convenience
 	// and debugging purposes
-	nodeStores  map[merkleTree]kvstore.KVStore
-	valueStores map[merkleTree]kvstore.KVStore",persistence/state.go,2023-05-30 16:09:42+00:00,2023-05-30T16:17:47Z,Were the value stores even used for anything? I considered a similar removal for my refactor but hadn't done it yet just because I was more worried about the rest of the functionality. ,,,,25.0,25,LEFT,11,11.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/790,pokt-network/pocket,2dddb4591615aa8b73b72b8a122ed9d2825a5e62
https://api.github.com/repos/pokt-network/pocket/pulls/790,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1210730003,Olshansk,b9b2976065982ce254f896d872bb23248b60c422,52a025c7ab854a5015f19287106f369e49a6bb0d,"@@ -37,7 +37,7 @@ require (
 	github.com/manifoldco/promptui v0.9.0
 	github.com/mitchellh/mapstructure v1.5.0
 	github.com/multiformats/go-multiaddr v0.8.0
-	github.com/pokt-network/smt v0.4.0
+	github.com/pokt-network/smt v0.5.0-beta",go.mod,2023-05-30 19:26:27+00:00,2023-05-30T19:27:20Z,"On the offchance you don't know about it, Golang has a native way to ""replace"" dependencies.

Might be useful for your local development if you don't already use it.

https://go.dev/ref/mod#go-mod-file

![Screenshot 2023-05-30 at 12 25 36 PM](https://github.com/pokt-network/pocket/assets/1892194/7cd8c688-738b-4a88-b35e-bc9503041d5f)
",,,,,40,RIGHT,5,,line,https://api.github.com/repos/pokt-network/pocket/pulls/790,pokt-network/pocket,2dddb4591615aa8b73b72b8a122ed9d2825a5e62
https://api.github.com/repos/pokt-network/pocket/pulls/777,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1201365575,Olshansk,0635baa56aa032bc28083c392d2f982fdb6c10d5,8701934088cf0d477a9996844b3e6b57bee81a5e,"@@ -0,0 +1,205 @@
+# Consensus Module <!-- omit in toc -->
+
+This README serves as a guide to the implementation of the [1.0 Pocket's Consensus Module Specification](https://github.com/pokt-network/pocket-network-protocol/tree/main/consensus). It is designed to provide insights into the structure and design of the codebase.
+
+## Table of Contents <!-- omit in toc -->
+
+- [Interface](#interface)
+- [Consensus Processes](#consensus-processes)
+  - [Leader Election](#leader-election)
+  - [Consensus Phases](#consensus-phases)
+  - [Block Generation](#block-generation)
+  - [Block Validation](#block-validation)
+  - [Consensus Lifecycle](#consensus-lifecycle)
+  - [State Sync](#state-sync)
+- [Implementation](#implementation)
+  - [Code Organization](#code-organization)
+- [Testing](#testing)
+  - [Running Unit Tests](#running-unit-tests)
+
+## Interface
+
+This module adheres to the interface outlined in `pocket/shared/modules/consensus_module.go`, which is derived from the above specification.
+
+## Consensus Processes
+
+This repository features an implementation of the HotStuff consensus algorithm. It facilitates the consensus process through a series of rounds. Staked validator nodes participate in the consensus process, with one node serving as the leader and the rest as replicas.
+
+### Leader Election
+
+A dedicated submodule handles the leader election process. The current configuration employs a deterministic round-robin leader election mechanism.
+
+### Consensus Phases
+
+The HotStuff consensus algorithm consists of three phases: `Prepare`, `Pre-Commit`, and `Commit`. In each phase, the leader creates a proposal and broadcasts it to all replica nodes.
+
+Upon receiving the proposal, each replica node performs a block validation check. If the proposal is valid, the replica node responds to the leader with its signature as a vote.
+
+When the leader collects votes from more than two-thirds of the replicas, it progresses to the next consensus phase. This two-thirds rule is essential to achieve Byzantine Fault Tolerance (BFT), ensuring network resilience against faulty or malicious nodes.
+
+### Block Generation
+
+Block generation in the HotStuff consensus algorithm involves a series of interactive steps between the Leader and the Replica nodes. The steps are as follows:
+
+```mermaid
+sequenceDiagram
+    participant Leader
+    participant Replicas
+    Note over Leader,Replicas: Leader Election
+    Leader->>Replicas: Propose(block)
+    Note over Replicas: Validate proposed block
+    Replicas-->>Leader: Prepare(block)
+    Note over Leader: Receives Prepare messages from a quorum of Replicas
+    Leader->>Replicas: Pre-Commit(block, Prepare messages)
+    Note over Replicas: Validate Pre-Commit message
+    Replicas-->>Leader: Commit(block)
+    Note over Leader: Receives Commit messages from a quorum of Replicas
+    Leader->>Replicas: Notify(block, Commit messages)
+    Note over Replicas: Add block to local blockchain copy
+    Note over Leader,Replicas: New Leader Election
+```
+
+### Block Validation
+
+Every proposal made by the leader goes through a series of validation steps performed by the replicas.
+
+```mermaid
+graph TD
+    A[Receive Block proposal from leader]
+    B[Perform basic validation]
+    C[Check Block structure]
+    D[Validate quorum certificate]",consensus/README.md,2023-05-23 00:55:03+00:00,2023-05-23T01:00:06Z,"What's the difference between step D and E? To me they're the same thing, but I believe you can add a ""note"" in mermaid to make it even more explicit with a clarification.",,,,73.0,71,RIGHT,71,73.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/777,pokt-network/pocket,f72e1f0c6dc2bd6c2634a6dc1387f7808453fe18
https://api.github.com/repos/pokt-network/pocket/pulls/777,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1201365720,Olshansk,0635baa56aa032bc28083c392d2f982fdb6c10d5,8701934088cf0d477a9996844b3e6b57bee81a5e,"@@ -0,0 +1,205 @@
+# Consensus Module <!-- omit in toc -->
+
+This README serves as a guide to the implementation of the [1.0 Pocket's Consensus Module Specification](https://github.com/pokt-network/pocket-network-protocol/tree/main/consensus). It is designed to provide insights into the structure and design of the codebase.
+
+## Table of Contents <!-- omit in toc -->
+
+- [Interface](#interface)
+- [Consensus Processes](#consensus-processes)
+  - [Leader Election](#leader-election)
+  - [Consensus Phases](#consensus-phases)
+  - [Block Generation](#block-generation)
+  - [Block Validation](#block-validation)
+  - [Consensus Lifecycle](#consensus-lifecycle)
+  - [State Sync](#state-sync)
+- [Implementation](#implementation)
+  - [Code Organization](#code-organization)
+- [Testing](#testing)
+  - [Running Unit Tests](#running-unit-tests)
+
+## Interface
+
+This module adheres to the interface outlined in `pocket/shared/modules/consensus_module.go`, which is derived from the above specification.
+
+## Consensus Processes
+
+This repository features an implementation of the HotStuff consensus algorithm. It facilitates the consensus process through a series of rounds. Staked validator nodes participate in the consensus process, with one node serving as the leader and the rest as replicas.
+
+### Leader Election
+
+A dedicated submodule handles the leader election process. The current configuration employs a deterministic round-robin leader election mechanism.
+
+### Consensus Phases
+
+The HotStuff consensus algorithm consists of three phases: `Prepare`, `Pre-Commit`, and `Commit`. In each phase, the leader creates a proposal and broadcasts it to all replica nodes.",consensus/README.md,2023-05-23 00:55:31+00:00,2023-05-23T01:00:06Z,"Can you link to hotstuff 2 and mention how ""recent research has shown this can be improved""",,,,,34,RIGHT,34,,line,https://api.github.com/repos/pokt-network/pocket/pulls/777,pokt-network/pocket,f72e1f0c6dc2bd6c2634a6dc1387f7808453fe18
https://api.github.com/repos/pokt-network/pocket/pulls/777,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1201365873,Olshansk,0635baa56aa032bc28083c392d2f982fdb6c10d5,8701934088cf0d477a9996844b3e6b57bee81a5e,"@@ -0,0 +1,205 @@
+# Consensus Module <!-- omit in toc -->
+
+This README serves as a guide to the implementation of the [1.0 Pocket's Consensus Module Specification](https://github.com/pokt-network/pocket-network-protocol/tree/main/consensus). It is designed to provide insights into the structure and design of the codebase.
+
+## Table of Contents <!-- omit in toc -->
+
+- [Interface](#interface)
+- [Consensus Processes](#consensus-processes)
+  - [Leader Election](#leader-election)
+  - [Consensus Phases](#consensus-phases)
+  - [Block Generation](#block-generation)
+  - [Block Validation](#block-validation)
+  - [Consensus Lifecycle](#consensus-lifecycle)
+  - [State Sync](#state-sync)
+- [Implementation](#implementation)
+  - [Code Organization](#code-organization)
+- [Testing](#testing)
+  - [Running Unit Tests](#running-unit-tests)
+
+## Interface
+
+This module adheres to the interface outlined in `pocket/shared/modules/consensus_module.go`, which is derived from the above specification.
+
+## Consensus Processes
+
+This repository features an implementation of the HotStuff consensus algorithm. It facilitates the consensus process through a series of rounds. Staked validator nodes participate in the consensus process, with one node serving as the leader and the rest as replicas.
+
+### Leader Election
+
+A dedicated submodule handles the leader election process. The current configuration employs a deterministic round-robin leader election mechanism.",consensus/README.md,2023-05-23 00:55:59+00:00,2023-05-23T01:00:06Z,"Should we mention Algoran'd leader election (and potentially link to it too), explaining that it's the next step?",,,,,30,RIGHT,30,,line,https://api.github.com/repos/pokt-network/pocket/pulls/777,pokt-network/pocket,f72e1f0c6dc2bd6c2634a6dc1387f7808453fe18
https://api.github.com/repos/pokt-network/pocket/pulls/777,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1201366353,Olshansk,0635baa56aa032bc28083c392d2f982fdb6c10d5,8701934088cf0d477a9996844b3e6b57bee81a5e,"@@ -0,0 +1,205 @@
+# Consensus Module <!-- omit in toc -->
+
+This README serves as a guide to the implementation of the [1.0 Pocket's Consensus Module Specification](https://github.com/pokt-network/pocket-network-protocol/tree/main/consensus). It is designed to provide insights into the structure and design of the codebase.
+
+## Table of Contents <!-- omit in toc -->
+
+- [Interface](#interface)
+- [Consensus Processes](#consensus-processes)
+  - [Leader Election](#leader-election)
+  - [Consensus Phases](#consensus-phases)
+  - [Block Generation](#block-generation)
+  - [Block Validation](#block-validation)
+  - [Consensus Lifecycle](#consensus-lifecycle)
+  - [State Sync](#state-sync)
+- [Implementation](#implementation)
+  - [Code Organization](#code-organization)
+- [Testing](#testing)
+  - [Running Unit Tests](#running-unit-tests)
+
+## Interface
+
+This module adheres to the interface outlined in `pocket/shared/modules/consensus_module.go`, which is derived from the above specification.
+
+## Consensus Processes
+
+This repository features an implementation of the HotStuff consensus algorithm. It facilitates the consensus process through a series of rounds. Staked validator nodes participate in the consensus process, with one node serving as the leader and the rest as replicas.
+
+### Leader Election
+
+A dedicated submodule handles the leader election process. The current configuration employs a deterministic round-robin leader election mechanism.
+
+### Consensus Phases
+
+The HotStuff consensus algorithm consists of three phases: `Prepare`, `Pre-Commit`, and `Commit`. In each phase, the leader creates a proposal and broadcasts it to all replica nodes.
+
+Upon receiving the proposal, each replica node performs a block validation check. If the proposal is valid, the replica node responds to the leader with its signature as a vote.
+
+When the leader collects votes from more than two-thirds of the replicas, it progresses to the next consensus phase. This two-thirds rule is essential to achieve Byzantine Fault Tolerance (BFT), ensuring network resilience against faulty or malicious nodes.
+
+### Block Generation
+
+Block generation in the HotStuff consensus algorithm involves a series of interactive steps between the Leader and the Replica nodes. The steps are as follows:
+
+```mermaid
+sequenceDiagram
+    participant Leader
+    participant Replicas
+    Note over Leader,Replicas: Leader Election
+    Leader->>Replicas: Propose(block)
+    Note over Replicas: Validate proposed block
+    Replicas-->>Leader: Prepare(block)
+    Note over Leader: Receives Prepare messages from a quorum of Replicas
+    Leader->>Replicas: Pre-Commit(block, Prepare messages)
+    Note over Replicas: Validate Pre-Commit message
+    Replicas-->>Leader: Commit(block)
+    Note over Leader: Receives Commit messages from a quorum of Replicas
+    Leader->>Replicas: Notify(block, Commit messages)
+    Note over Replicas: Add block to local blockchain copy
+    Note over Leader,Replicas: New Leader Election
+```
+
+### Block Validation
+
+Every proposal made by the leader goes through a series of validation steps performed by the replicas.",consensus/README.md,2023-05-23 00:56:50+00:00,2023-05-23T01:00:06Z,"We should  mentional this only happens in the `Propose` step, and the other steps are just about signature validation. I think you imply it but we should try to make it really explicit.",,,,,64,RIGHT,64,,line,https://api.github.com/repos/pokt-network/pocket/pulls/777,pokt-network/pocket,f72e1f0c6dc2bd6c2634a6dc1387f7808453fe18
https://api.github.com/repos/pokt-network/pocket/pulls/777,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1201366790,Olshansk,0635baa56aa032bc28083c392d2f982fdb6c10d5,8701934088cf0d477a9996844b3e6b57bee81a5e,"@@ -0,0 +1,205 @@
+# Consensus Module <!-- omit in toc -->
+
+This README serves as a guide to the implementation of the [1.0 Pocket's Consensus Module Specification](https://github.com/pokt-network/pocket-network-protocol/tree/main/consensus). It is designed to provide insights into the structure and design of the codebase.
+
+## Table of Contents <!-- omit in toc -->
+
+- [Interface](#interface)
+- [Consensus Processes](#consensus-processes)
+  - [Leader Election](#leader-election)
+  - [Consensus Phases](#consensus-phases)
+  - [Block Generation](#block-generation)
+  - [Block Validation](#block-validation)
+  - [Consensus Lifecycle](#consensus-lifecycle)
+  - [State Sync](#state-sync)
+- [Implementation](#implementation)
+  - [Code Organization](#code-organization)
+- [Testing](#testing)
+  - [Running Unit Tests](#running-unit-tests)
+
+## Interface
+
+This module adheres to the interface outlined in `pocket/shared/modules/consensus_module.go`, which is derived from the above specification.
+
+## Consensus Processes
+
+This repository features an implementation of the HotStuff consensus algorithm. It facilitates the consensus process through a series of rounds. Staked validator nodes participate in the consensus process, with one node serving as the leader and the rest as replicas.
+
+### Leader Election
+
+A dedicated submodule handles the leader election process. The current configuration employs a deterministic round-robin leader election mechanism.
+
+### Consensus Phases
+
+The HotStuff consensus algorithm consists of three phases: `Prepare`, `Pre-Commit`, and `Commit`. In each phase, the leader creates a proposal and broadcasts it to all replica nodes.
+
+Upon receiving the proposal, each replica node performs a block validation check. If the proposal is valid, the replica node responds to the leader with its signature as a vote.
+
+When the leader collects votes from more than two-thirds of the replicas, it progresses to the next consensus phase. This two-thirds rule is essential to achieve Byzantine Fault Tolerance (BFT), ensuring network resilience against faulty or malicious nodes.
+
+### Block Generation
+
+Block generation in the HotStuff consensus algorithm involves a series of interactive steps between the Leader and the Replica nodes. The steps are as follows:
+
+```mermaid
+sequenceDiagram
+    participant Leader
+    participant Replicas
+    Note over Leader,Replicas: Leader Election
+    Leader->>Replicas: Propose(block)
+    Note over Replicas: Validate proposed block
+    Replicas-->>Leader: Prepare(block)
+    Note over Leader: Receives Prepare messages from a quorum of Replicas
+    Leader->>Replicas: Pre-Commit(block, Prepare messages)
+    Note over Replicas: Validate Pre-Commit message
+    Replicas-->>Leader: Commit(block)
+    Note over Leader: Receives Commit messages from a quorum of Replicas
+    Leader->>Replicas: Notify(block, Commit messages)
+    Note over Replicas: Add block to local blockchain copy
+    Note over Leader,Replicas: New Leader Election
+```
+
+### Block Validation
+
+Every proposal made by the leader goes through a series of validation steps performed by the replicas.
+
+```mermaid
+graph TD
+    A[Receive Block proposal from leader]
+    B[Perform basic validation]
+    C[Check Block structure]
+    D[Validate quorum certificate]
+    E[Validate message signatures]
+    F[Validate optimistic threshold]
+    G[Block is Valid - apply block]
+    H[Block is Invalid - Reject the proposal]
+    J[Create and send vote message to the leader]
+    A-->B
+    B-->C
+    C-->D
+    D-->E
+    E-->F
+    F-->G
+    G-->J
+    B-.->H
+    C-.->H
+    D-.->H
+    E-.->H
+    F-.->H
+```
+
+### Consensus Lifecycle
+
+The consensus lifecycle begins with a new round that includes leader election, proposal creation, proposal validation, vote aggregation, and block commitment. The steps are as follows:
+
+```mermaid
+flowchart TD
+  A[Start New Round] --> |Elect Leader| L[Leader Election Module]
+  L --> D1[Leader]
+  L --> D2[Replica]
+  D1 --> E1[Create Proposals]
+  D2 --> E2[Validate Proposals]
+  E1 --> F1[Aggregate Votes]
+  E2 --> F2[Vote on Proposals]
+  F1 --> G1[Quorum and Commit Block]
+  F2 --> G2[Commit Block]
+  G1 --> J1[End Round]
+  G2 --> J1
+  J1 --> A
+```
+
+### State Sync
+
+State synchronization is crucial to ensure all participating nodes maintain a consistent and up-to-date view of the network state. It is especially important in a dynamic and decentralized network where nodes can join, leave, or experience intermittent connectivity. For an in-depth understanding of the state sync process and its current status, please refer to our [State Sync Protocol Design Specification](https://github.com/pokt-network/pocket/blob/main/consensus/doc/PROTOCOL_STATE_SYNC.md).
+
+```mermaid
+graph TD
+    A(Start testing) --> Z(Add new validators)
+    Z --> B[Trigger Next View]
+    B --> C{BFT threshold satisfied?}
+    C -->|Yes| D(New block, height increases)
+    C -->|No| E(No new block, height is same)
+    E --> B
+    D --> F{Are there new validators staked?}
+    F -->|Yes| G(Wait for validators' metadata responses)
+    F -->|No| J{Are syncing nodes caught up?}
+    J --> |Yes| Z
+    J -->|No| B
+    G --> B
+
+    subgraph Notes
+       note1>NOTE: BFT requires > 2/3 validators<br>in the same round & height, voting for the proposal.]
+       note2>NOTE: Syncing validators request blocks from the network.]
+    end
+
+    C --> note1
+    J --> note2
+```
+
+## Implementation
+
+### Code Organization
+
+The codebase is organized as follows:
+
+```bash
+consensus
+├── doc
+│   ├── CHANGELOG.md
+│   ├── PROTOCOL_STATE_SYNC.md              # State sync protocol definition
+├── e2e_tests
+│   ├── hotstuff_test.go                    # Hotstuff consensus tests
+│   ├── pacemaker_test.go                   # Pacemaker module tests
+│   ├── state_sync_test.go                  # State sync tests
+│   ├── utils_test.go                       # test utils
+├── leader_election
+│   ├── sortition
+│       └── sortition_test.go               # Sortition tests
+│       └── sortition.go                    # Cryptographic sortition implementation
+│   ├── vrf
+│       └── errors.go
+│       └── vrf_test.go                     # VRF tests
+│       └── vrf.go                          # VRF implementation
+│   ├── module.go                           # Leader election module implementation
+├── pacemaker
+│   ├── debug.go
+│   ├── module.go                           # Pacemaker module implementation
+├── state_sync
+│   ├── helpers.go
+│   ├── interfaces.go
+│   ├── module.go                           # State sync module implementation
+│   ├── server.go                           # State sync server functions
+├── telemetry
+│   ├── metrics.go
+├── types
+│   ├── proto                               # Proto3 messages for generated types
+│   ├── actor_mapper_test.go
+│   ├── actor_mapper.go
+│   ├── messages.go                         # Consensus message definitions
+│   ├── types.go                            # Consensus type definitions
+├── block.go
+├── debugging.go                            # Debug function implementation
+├── events.go
+├── fsm_handler.go                          # FSM events handler implementation
+├── helpers.go
+├── hotstuff_handler.go
+├── hotstuff_leader.go                      # Hotstuff message handlers for Leader
+├── hotstuff_mempool_test.go                # Mempool tests
+├── hotstuff_mempool.go                     # Hotstuff transaction mempool implementation
+├── hotstuff_replica.go                     # Hotstuff message handlers for Replica
+├── messages.go                             # Hotstuff message helpers
+├── module_consensus_debugging.go
+├── module_consensus_pacemaker.go           # Pacemaker module helpers
+├── module_consensus_state_sync.go          # State sync module helpers
+├── module.go                               # The implementation of the Consensus Interface
+├── README.md                               # Self link to this README
+├── state_sync_handler.go                   # State sync message handler
+```
+
+## Testing",consensus/README.md,2023-05-23 00:58:03+00:00,2023-05-23T01:00:06Z,Can you add a TODO to document the testing framework as well please?,,,,204.0,199,RIGHT,199,204.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/777,pokt-network/pocket,f72e1f0c6dc2bd6c2634a6dc1387f7808453fe18
https://api.github.com/repos/pokt-network/pocket/pulls/777,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1201367609,Olshansk,0635baa56aa032bc28083c392d2f982fdb6c10d5,8701934088cf0d477a9996844b3e6b57bee81a5e,"@@ -0,0 +1,205 @@
+# Consensus Module <!-- omit in toc -->
+
+This README serves as a guide to the implementation of the [1.0 Pocket's Consensus Module Specification](https://github.com/pokt-network/pocket-network-protocol/tree/main/consensus). It is designed to provide insights into the structure and design of the codebase.
+
+## Table of Contents <!-- omit in toc -->
+
+- [Interface](#interface)
+- [Consensus Processes](#consensus-processes)
+  - [Leader Election](#leader-election)
+  - [Consensus Phases](#consensus-phases)
+  - [Block Generation](#block-generation)
+  - [Block Validation](#block-validation)
+  - [Consensus Lifecycle](#consensus-lifecycle)
+  - [State Sync](#state-sync)
+- [Implementation](#implementation)
+  - [Code Organization](#code-organization)
+- [Testing](#testing)
+  - [Running Unit Tests](#running-unit-tests)
+
+## Interface
+
+This module adheres to the interface outlined in `pocket/shared/modules/consensus_module.go`, which is derived from the above specification.
+
+## Consensus Processes
+
+This repository features an implementation of the HotStuff consensus algorithm. It facilitates the consensus process through a series of rounds. Staked validator nodes participate in the consensus process, with one node serving as the leader and the rest as replicas.
+
+### Leader Election
+
+A dedicated submodule handles the leader election process. The current configuration employs a deterministic round-robin leader election mechanism.
+
+### Consensus Phases
+
+The HotStuff consensus algorithm consists of three phases: `Prepare`, `Pre-Commit`, and `Commit`. In each phase, the leader creates a proposal and broadcasts it to all replica nodes.
+
+Upon receiving the proposal, each replica node performs a block validation check. If the proposal is valid, the replica node responds to the leader with its signature as a vote.
+
+When the leader collects votes from more than two-thirds of the replicas, it progresses to the next consensus phase. This two-thirds rule is essential to achieve Byzantine Fault Tolerance (BFT), ensuring network resilience against faulty or malicious nodes.
+
+### Block Generation
+
+Block generation in the HotStuff consensus algorithm involves a series of interactive steps between the Leader and the Replica nodes. The steps are as follows:
+
+```mermaid
+sequenceDiagram
+    participant Leader
+    participant Replicas
+    Note over Leader,Replicas: Leader Election
+    Leader->>Replicas: Propose(block)
+    Note over Replicas: Validate proposed block
+    Replicas-->>Leader: Prepare(block)
+    Note over Leader: Receives Prepare messages from a quorum of Replicas
+    Leader->>Replicas: Pre-Commit(block, Prepare messages)
+    Note over Replicas: Validate Pre-Commit message
+    Replicas-->>Leader: Commit(block)
+    Note over Leader: Receives Commit messages from a quorum of Replicas
+    Leader->>Replicas: Notify(block, Commit messages)
+    Note over Replicas: Add block to local blockchain copy
+    Note over Leader,Replicas: New Leader Election
+```
+
+### Block Validation
+
+Every proposal made by the leader goes through a series of validation steps performed by the replicas.
+
+```mermaid
+graph TD
+    A[Receive Block proposal from leader]
+    B[Perform basic validation]
+    C[Check Block structure]
+    D[Validate quorum certificate]
+    E[Validate message signatures]
+    F[Validate optimistic threshold]
+    G[Block is Valid - apply block]
+    H[Block is Invalid - Reject the proposal]
+    J[Create and send vote message to the leader]
+    A-->B
+    B-->C
+    C-->D
+    D-->E
+    E-->F
+    F-->G
+    G-->J
+    B-.->H
+    C-.->H
+    D-.->H
+    E-.->H
+    F-.->H
+```
+
+### Consensus Lifecycle
+
+The consensus lifecycle begins with a new round that includes leader election, proposal creation, proposal validation, vote aggregation, and block commitment. The steps are as follows:
+
+```mermaid
+flowchart TD
+  A[Start New Round] --> |Elect Leader| L[Leader Election Module]
+  L --> D1[Leader]
+  L --> D2[Replica]
+  D1 --> E1[Create Proposals]
+  D2 --> E2[Validate Proposals]
+  E1 --> F1[Aggregate Votes]
+  E2 --> F2[Vote on Proposals]
+  F1 --> G1[Quorum and Commit Block]
+  F2 --> G2[Commit Block]
+  G1 --> J1[End Round]
+  G2 --> J1
+  J1 --> A
+```
+
+### State Sync
+
+State synchronization is crucial to ensure all participating nodes maintain a consistent and up-to-date view of the network state. It is especially important in a dynamic and decentralized network where nodes can join, leave, or experience intermittent connectivity. For an in-depth understanding of the state sync process and its current status, please refer to our [State Sync Protocol Design Specification](https://github.com/pokt-network/pocket/blob/main/consensus/doc/PROTOCOL_STATE_SYNC.md).",consensus/README.md,2023-05-23 00:59:32+00:00,2023-05-23T01:00:06Z,"NIT: Any chance you could follow the ""best practices"" I learnt about recently and see if we can reformat this (by moving this around) so it's easier to read: https://twitter.com/olshansky/status/1660499323317284864

If this is too hard, then no worries!",,,,113.0,113,RIGHT,113,113.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/777,pokt-network/pocket,f72e1f0c6dc2bd6c2634a6dc1387f7808453fe18
https://api.github.com/repos/pokt-network/pocket/pulls/781,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1203038406,Olshansk,5c9ee34a679732ea070e76890699f5058fe4ee1f,3a2c7c60158540a6c6eaa534ab9504d5c664d5fe,"@@ -148,6 +148,21 @@ For example:
 - `0010297b55fc9278e4be4f1bcfe52bf9bd0443f8` is a servicer #001.
 - `314019dbb7faf8390c1f0cf4976ef1215c90b7e4` is an application #314.
 
+
+#### Applications staked on LocalNet
+Applications with the following addresses are staked on LocalNet, through [applications field of the genesis.json in the configuration](https://github.com/pokt-network/pocket/blob/main/build/localnet/manifests/configs.yaml#L4088)",build/localnet/README.md,2023-05-23 21:30:49+00:00,2023-05-23T21:32:15Z,"```suggestion
Applications with the following addresses are staked on LocalNet, through the [applications field of the genesis.json in the LocalNet configuration](https://github.com/pokt-network/pocket/blob/main/build/localnet/manifests/configs.yaml#L4088)
```",,,,,153,RIGHT,6,,line,https://api.github.com/repos/pokt-network/pocket/pulls/781,pokt-network/pocket,763207675ef5838e1a04d30b43f155a1664d606c
https://api.github.com/repos/pokt-network/pocket/pulls/781,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1203038685,Olshansk,5c9ee34a679732ea070e76890699f5058fe4ee1f,3a2c7c60158540a6c6eaa534ab9504d5c664d5fe,"@@ -148,6 +148,21 @@ For example:
 - `0010297b55fc9278e4be4f1bcfe52bf9bd0443f8` is a servicer #001.
 - `314019dbb7faf8390c1f0cf4976ef1215c90b7e4` is an application #314.
 
+
+#### Applications staked on LocalNet
+Applications with the following addresses are staked on LocalNet, through [applications field of the genesis.json in the configuration](https://github.com/pokt-network/pocket/blob/main/build/localnet/manifests/configs.yaml#L4088)
+
+- `00001fff518b1cdddd74c197d76ba5b5dedc0301`
+- `00101f2ff54811e84df2d767c661f57a06349b7e`
+
+These addresses can be used for e.g. testing the CLI.
+
+#### Servicers staked on LocalNet
+Servicers with the following addresses are staked on LocalNet, through [servicers field of the genesis.json in the configuration](https://github.com/pokt-network/pocket/blob/main/build/localnet/manifests/configs.yaml#L4120)",build/localnet/README.md,2023-05-23 21:31:05+00:00,2023-05-23T21:32:15Z,"```suggestion
Servicers with the following addresses are staked on LocalNet, through the [servicers field of the genesis.json in the LocalNet configuration](https://github.com/pokt-network/pocket/blob/main/build/localnet/manifests/configs.yaml#L4120)
```",,,,,161,RIGHT,14,,line,https://api.github.com/repos/pokt-network/pocket/pulls/781,pokt-network/pocket,763207675ef5838e1a04d30b43f155a1664d606c
https://api.github.com/repos/pokt-network/pocket/pulls/789,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1206025624,Olshansk,81e6c24ebc25c21c24f5997eaa8570347f0f5d47,01da7a84832f2d78c03275edbb8bdf57c79b6edd,"@@ -18,12 +18,15 @@ message RelayPayload {
 }
 
 message RelayMeta {
+    reserved 5;",shared/core/types/proto/relay.proto,2023-05-25 21:33:03+00:00,2023-05-25T21:56:37Z,"No need to do this yet. We're not in production yet and this will undergo a lot of changes before we get there.

I use https://marketplace.visualstudio.com/items?itemName=ripwu.protobuf-helper to reset the numbers. When it starts mattering, we'll follow best practices.",,,,,21,RIGHT,4,,line,https://api.github.com/repos/pokt-network/pocket/pulls/789,pokt-network/pocket,682912b958986467465e21b1ae2710cac98aff55
https://api.github.com/repos/pokt-network/pocket/pulls/789,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1206025831,Olshansk,81e6c24ebc25c21c24f5997eaa8570347f0f5d47,01da7a84832f2d78c03275edbb8bdf57c79b6edd,"@@ -18,12 +18,15 @@ message RelayPayload {
 }
 
 message RelayMeta {
+    reserved 5;
+    reserved ""token"";
     int64 block_height = 1;
     string servicer_public_key = 2;
     Identifiable relay_chain = 3;
     Identifiable geo_zone = 4;
-    AAT token = 5;
     string signature = 6;
+    // TODO: should we use public key instead?
+    string application_address = 7;",shared/core/types/proto/relay.proto,2023-05-25 21:33:13+00:00,2023-05-25T21:56:37Z,Yes,,,,,29,RIGHT,13,,line,https://api.github.com/repos/pokt-network/pocket/pulls/789,pokt-network/pocket,682912b958986467465e21b1ae2710cac98aff55
https://api.github.com/repos/pokt-network/pocket/pulls/789,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1206026649,Olshansk,81e6c24ebc25c21c24f5997eaa8570347f0f5d47,01da7a84832f2d78c03275edbb8bdf57c79b6edd,"@@ -22,6 +23,9 @@ type utilityModule struct {
 
 	logger  *modules.Logger
 	mempool mempool.TXMempool
+
+	// TODO: initialize",utility/module.go,2023-05-25 21:33:59+00:00,2023-05-25T21:56:37Z,"See #710 by @0xBigBoss  who is working on this.

@0xBigBoss do you think we could merge in your configs work (even though it's not fully done) to unblock soon to come work?",,,,26.0,27,RIGHT,13,5.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/789,pokt-network/pocket,682912b958986467465e21b1ae2710cac98aff55
https://api.github.com/repos/pokt-network/pocket/pulls/789,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1206027848,Olshansk,81e6c24ebc25c21c24f5997eaa8570347f0f5d47,01da7a84832f2d78c03275edbb8bdf57c79b6edd,"@@ -120,6 +120,7 @@ func NewDefaultConfig(options ...func(*Config)) *Config {
 			},
 		},
 		Utility: &UtilityConfig{
+			// TODO: add a servicer default config",runtime/configs/config.go,2023-05-25 21:35:43+00:00,2023-05-25T21:56:37Z,Should we have an empty struct here for now? You can add an `enabled` flag in the config and set it to `false`,,,,,123,RIGHT,4,,line,https://api.github.com/repos/pokt-network/pocket/pulls/789,pokt-network/pocket,682912b958986467465e21b1ae2710cac98aff55
https://api.github.com/repos/pokt-network/pocket/pulls/789,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1206028232,Olshansk,81e6c24ebc25c21c24f5997eaa8570347f0f5d47,01da7a84832f2d78c03275edbb8bdf57c79b6edd,"@@ -0,0 +1,137 @@
+package service
+
+import (
+	""fmt""
+	""testing""
+
+	""github.com/pokt-network/pocket/runtime/configs""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+)
+
+func TestAdmitRelay(t *testing.T) {
+	testCases := []struct {
+		name          string
+		config        configs.ServicerConfig
+		relay         coreTypes.Relay
+		currentHeight int64
+		session       *coreTypes.Session
+		errSession    error
+		expected      error
+	}{
+		{
+			name:     ""Relay with empty Meta is rejected"",
+			expected: fmt.Errorf(""Error admitting relay: relay metadata failed validation: empty relay metadata""),
+		},
+		{
+			name:     ""Relay with unspecified chain is rejected"",
+			relay:    coreTypes.Relay{Meta: &coreTypes.RelayMeta{}},
+			expected: fmt.Errorf(""Error admitting relay: relay metadata failed validation: relay chain unspecified""),
+		},
+		{
+			name:     ""Relay for unsupported chain is rejected"",
+			relay:    testRelay(""0021"", 0),
+			expected: fmt.Errorf(""Error admitting relay: relay metadata failed validation: relay chain not supported: %s"", ""0021""),
+		},
+		{
+			name:     ""Relay with height set in a past session is rejected"",
+			relay:    testRelay(""0021"", 5),
+			config:   testServicerConfig(""0021""),
+			session:  testSession(sessionNumber(2), sessionBlocks(4), sessionHeight(2)),
+			expected: fmt.Errorf(""Error admitting relay: relay failed block height validation: relay block height 5 not within session ID session-1 starting block 8 and last block 10""),
+		},
+		{
+			name:     ""Relay with height set in a future session is rejected"",
+			relay:    testRelay(""0021"", 9999),
+			config:   testServicerConfig(""0021""),
+			session:  testSession(sessionNumber(2), sessionBlocks(4), sessionHeight(2)),
+			expected: fmt.Errorf(""Error admitting relay: relay failed block height validation: relay block height 9999 not within session ID session-1 starting block 8 and last block 10""),
+		},
+	}
+
+	for _, tc := range testCases {
+		t.Run(tc.name, func(t *testing.T) {
+			servicer := servicer{
+				provider: mockProvider{
+					Height:     tc.currentHeight,
+					Session:    tc.session,
+					ErrSession: tc.errSession,
+				},
+				config: tc.config,
+			}
+
+			err := servicer.admitRelay(tc.relay)",utility/service/service_test.go,2023-05-25 21:36:24+00:00,2023-05-25T21:56:37Z,"Lots of linter errors, PTAL",,,,,62,RIGHT,62,,line,https://api.github.com/repos/pokt-network/pocket/pulls/789,pokt-network/pocket,682912b958986467465e21b1ae2710cac98aff55
https://api.github.com/repos/pokt-network/pocket/pulls/789,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1206028430,Olshansk,81e6c24ebc25c21c24f5997eaa8570347f0f5d47,01da7a84832f2d78c03275edbb8bdf57c79b6edd,"@@ -0,0 +1,137 @@
+package service
+
+import (
+	""fmt""
+	""testing""
+
+	""github.com/pokt-network/pocket/runtime/configs""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+)
+
+func TestAdmitRelay(t *testing.T) {
+	testCases := []struct {
+		name          string
+		config        configs.ServicerConfig
+		relay         coreTypes.Relay
+		currentHeight int64
+		session       *coreTypes.Session
+		errSession    error
+		expected      error
+	}{
+		{
+			name:     ""Relay with empty Meta is rejected"",
+			expected: fmt.Errorf(""Error admitting relay: relay metadata failed validation: empty relay metadata""),
+		},
+		{
+			name:     ""Relay with unspecified chain is rejected"",
+			relay:    coreTypes.Relay{Meta: &coreTypes.RelayMeta{}},
+			expected: fmt.Errorf(""Error admitting relay: relay metadata failed validation: relay chain unspecified""),
+		},
+		{
+			name:     ""Relay for unsupported chain is rejected"",
+			relay:    testRelay(""0021"", 0),
+			expected: fmt.Errorf(""Error admitting relay: relay metadata failed validation: relay chain not supported: %s"", ""0021""),
+		},
+		{
+			name:     ""Relay with height set in a past session is rejected"",
+			relay:    testRelay(""0021"", 5),
+			config:   testServicerConfig(""0021""),
+			session:  testSession(sessionNumber(2), sessionBlocks(4), sessionHeight(2)),
+			expected: fmt.Errorf(""Error admitting relay: relay failed block height validation: relay block height 5 not within session ID session-1 starting block 8 and last block 10""),
+		},
+		{
+			name:     ""Relay with height set in a future session is rejected"",
+			relay:    testRelay(""0021"", 9999),
+			config:   testServicerConfig(""0021""),
+			session:  testSession(sessionNumber(2), sessionBlocks(4), sessionHeight(2)),
+			expected: fmt.Errorf(""Error admitting relay: relay failed block height validation: relay block height 9999 not within session ID session-1 starting block 8 and last block 10""),
+		},
+	}
+
+	for _, tc := range testCases {
+		t.Run(tc.name, func(t *testing.T) {
+			servicer := servicer{
+				provider: mockProvider{
+					Height:     tc.currentHeight,
+					Session:    tc.session,
+					ErrSession: tc.errSession,
+				},
+				config: tc.config,
+			}
+
+			err := servicer.admitRelay(tc.relay)
+			switch {
+			case err == nil && tc.expected != nil:
+				t.Fatalf(""Expected error %v, got: nil"", tc.expected)
+			case err != nil && tc.expected == nil:
+				t.Fatalf(""Unexpected error %v"", err)
+			case err != nil && err.Error() != tc.expected.Error():
+				t.Fatalf(""Expected error %v, got: %v"", tc.expected, err)
+			}
+		})
+	}
+}
+
+type mockProvider struct {",utility/service/service_test.go,2023-05-25 21:36:43+00:00,2023-05-25T21:56:37Z,"We use [mockgen](https://github.com/golang/mock) throughout the entire codebase. If you search for `EXPECT()`, you should find a few examples as a starting point and I belive it's important to keep using that pattern throughout.

Lmk if you need more direct pointers or examples.",,,,,75,RIGHT,75,,line,https://api.github.com/repos/pokt-network/pocket/pulls/789,pokt-network/pocket,682912b958986467465e21b1ae2710cac98aff55
https://api.github.com/repos/pokt-network/pocket/pulls/789,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1206035589,Olshansk,81e6c24ebc25c21c24f5997eaa8570347f0f5d47,01da7a84832f2d78c03275edbb8bdf57c79b6edd,"@@ -147,3 +151,151 @@ func (r *relay) GetRelayChain() RelayChain              { return nil }
 func (r *relay) GetGeoZone() GeoZone                    { return nil }
 func (r *relay) GetToken() AAT                          { return nil }
 func (r *relay) GetSignature() string                   { return """" }
+
+type Provider interface {",utility/service/service.go,2023-05-25 21:47:56+00:00,2023-05-25T21:56:37Z,"Rather than using a provider, use our `application-specific bus` which is what we use for dependency injection throughout the entire repository in every module/submodule.

You can then do `bus.GetConsensusModule().CurrentHeight()` or `bus.GetUtilityModule().GetSession(...)`.

For example, here is a mock of the utility module in `consensus/e2e_tests`:

![Screenshot 2023-05-25 at 2 47 27 PM](https://github.com/pokt-network/pocket/assets/1892194/26bcf1b5-4f0e-41da-876f-35c7eb596dca)

See this link for more details and please (please please) update the documentation where you see gaps: https://github.com/pokt-network/pocket/wiki/Modules-Readme",,,,,155,RIGHT,21,,line,https://api.github.com/repos/pokt-network/pocket/pulls/789,pokt-network/pocket,682912b958986467465e21b1ae2710cac98aff55
https://api.github.com/repos/pokt-network/pocket/pulls/789,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1206036117,Olshansk,81e6c24ebc25c21c24f5997eaa8570347f0f5d47,01da7a84832f2d78c03275edbb8bdf57c79b6edd,"@@ -147,3 +151,151 @@ func (r *relay) GetRelayChain() RelayChain              { return nil }
 func (r *relay) GetGeoZone() GeoZone                    { return nil }
 func (r *relay) GetToken() AAT                          { return nil }
 func (r *relay) GetSignature() string                   { return """" }
+
+type Provider interface {
+	CurrentHeight() int64
+	GetSession(appAddr string, height int64, relayChain, geoZone string) (*coreTypes.Session, error)
+}
+
+type Servicer interface {
+	HandleRelay(*coreTypes.Relay) (*coreTypes.RelayResponse, error)
+}
+
+func NewServicer(provider Provider, config configs.ServicerConfig) (Servicer, error) {",utility/service/service.go,2023-05-25 21:48:52+00:00,2023-05-25T21:56:37Z,We have a pattern for factory functions. See `shared/modules/factory.go` as an example. This will also give you access to the `bus` I mentioned above.,,,,,164,RIGHT,30,,line,https://api.github.com/repos/pokt-network/pocket/pulls/789,pokt-network/pocket,682912b958986467465e21b1ae2710cac98aff55
https://api.github.com/repos/pokt-network/pocket/pulls/789,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1212482027,Olshansk,5f511658026e16c7b4025662c7e7016ed440674c,01da7a84832f2d78c03275edbb8bdf57c79b6edd,"@@ -7,4 +7,11 @@ option go_package = ""github.com/pokt-network/pocket/runtime/configs"";
 message UtilityConfig {
   uint64 max_mempool_transaction_bytes = 1;
   uint32 max_mempool_transactions = 2;
+  ServicerConfig servicer_config = 3;
+}
+
+message ServicerConfig {",runtime/configs/proto/utility_config.proto,2023-06-01 01:57:02+00:00,2023-06-01T02:40:28Z,@0xBigBoss Just a heads up on the merge conflicts we'll need to resolve related to this.,,,,14.0,13,RIGHT,7,8.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/789,pokt-network/pocket,682912b958986467465e21b1ae2710cac98aff55
https://api.github.com/repos/pokt-network/pocket/pulls/789,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1212482607,Olshansk,5f511658026e16c7b4025662c7e7016ed440674c,01da7a84832f2d78c03275edbb8bdf57c79b6edd,"@@ -22,8 +22,8 @@ message RelayMeta {
     string servicer_public_key = 2;
     Identifiable relay_chain = 3;
     Identifiable geo_zone = 4;
-    AAT token = 5;
-    string signature = 6;
+    string signature = 5;",shared/core/types/proto/relay.proto,2023-06-01 01:58:30+00:00,2023-06-01T02:40:28Z,"```suggestion
    string signature = 5; // TODO: Add support for delegated signature validation
```",,,,25.0,25,RIGHT,6,6.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/789,pokt-network/pocket,682912b958986467465e21b1ae2710cac98aff55
https://api.github.com/repos/pokt-network/pocket/pulls/789,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1212483016,Olshansk,5f511658026e16c7b4025662c7e7016ed440674c,01da7a84832f2d78c03275edbb8bdf57c79b6edd,"@@ -7,4 +7,11 @@ option go_package = ""github.com/pokt-network/pocket/runtime/configs"";
 message UtilityConfig {
   uint64 max_mempool_transaction_bytes = 1;
   uint32 max_mempool_transactions = 2;
+  ServicerConfig servicer_config = 3;
+}
+
+message ServicerConfig {",runtime/configs/proto/utility_config.proto,2023-06-01 01:59:29+00:00,2023-06-01T02:40:28Z,"```suggestion
// TODO: Reevalute whether each utility actor should contain address/pubKey configs or if it should be shared
message ServicerConfig {
```

Cc @bryanchriswhite for context regarding node identity",,,,14.0,13,RIGHT,7,8.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/789,pokt-network/pocket,682912b958986467465e21b1ae2710cac98aff55
https://api.github.com/repos/pokt-network/pocket/pulls/789,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1212490554,Olshansk,5f511658026e16c7b4025662c7e7016ed440674c,01da7a84832f2d78c03275edbb8bdf57c79b6edd,"@@ -1,11 +1,217 @@
 package service
 
 import (
+	""errors""
+	""fmt""
+
+	""github.com/pokt-network/pocket/logger""
+	""github.com/pokt-network/pocket/runtime/configs""
 	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
 	""github.com/pokt-network/pocket/shared/crypto""
+	""github.com/pokt-network/pocket/shared/modules""
+	""github.com/pokt-network/pocket/shared/modules/base_modules""
+)
+
+var (
+	errValidateBlockHeight = errors.New(""relay failed block height validation"")
+	errValidateRelayMeta   = errors.New(""relay failed metadata validation"")
+
+	_ Servicer = &servicer{}
 )
 
+type Servicer interface {",utility/service/service.go,2023-06-01 02:13:42+00:00,2023-06-01T02:40:28Z,"NIT: What are your thoughts on moving this into `utility_module.go` so when someone comes to the codebase, they can immediately see what kind of interfaces each actor exposes?",,,,,22,RIGHT,22,,line,https://api.github.com/repos/pokt-network/pocket/pulls/789,pokt-network/pocket,682912b958986467465e21b1ae2710cac98aff55
https://api.github.com/repos/pokt-network/pocket/pulls/789,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1212490720,Olshansk,5f511658026e16c7b4025662c7e7016ed440674c,01da7a84832f2d78c03275edbb8bdf57c79b6edd,"@@ -1,11 +1,217 @@
 package service
 
 import (
+	""errors""
+	""fmt""
+
+	""github.com/pokt-network/pocket/logger""
+	""github.com/pokt-network/pocket/runtime/configs""
 	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
 	""github.com/pokt-network/pocket/shared/crypto""
+	""github.com/pokt-network/pocket/shared/modules""
+	""github.com/pokt-network/pocket/shared/modules/base_modules""
+)
+
+var (
+	errValidateBlockHeight = errors.New(""relay failed block height validation"")
+	errValidateRelayMeta   = errors.New(""relay failed metadata validation"")
+
+	_ Servicer = &servicer{}
 )
 
+type Servicer interface {
+	modules.Module
+
+	HandleRelay(*coreTypes.Relay) (*coreTypes.RelayResponse, error)
+}
+
+type servicer struct {
+	base_modules.IntegratableModule
+	base_modules.InterruptableModule
+
+	logger *modules.Logger
+	config *configs.ServicerConfig
+}
+
+func CreateServicer(bus modules.Bus, options ...modules.ModuleOption) (modules.Module, error) {
+	return new(servicer).Create(bus, options...)
+}
+
+func (*servicer) Create(bus modules.Bus, options ...modules.ModuleOption) (modules.Module, error) {
+	s := &servicer{
+		logger: logger.Global.CreateLoggerForModule(servicerModuleName),
+	}
+
+	for _, option := range options {
+		option(s)
+	}
+
+	bus.RegisterModule(s)
+
+	cfg := bus.GetRuntimeMgr().GetConfig()
+	s.config = cfg.Utility.ServicerConfig
+
+	return s, nil
+}
+
+func (s *servicer) Start() error {
+	s.logger = logger.Global.CreateLoggerForModule(s.GetModuleName())
+	return nil
+}
+
+func (*servicer) GetModuleName() string {
+	return servicerModuleName
+}
+
+// HandleRelay processes a relay after performing validation.
+// It also updates the servicer's internal state to keep track of served relays.
+func (s *servicer) HandleRelay(relay *coreTypes.Relay) (*coreTypes.RelayResponse, error) {
+	if relay == nil {
+		return nil, fmt.Errorf(""cannot serve nil relay"")
+	}
+
+	if err := s.admitRelay(relay); err != nil {
+		return nil, fmt.Errorf(""Error admitting relay: %w"", err)
+	}
+
+	// TODO: implement Persist Relay
+	// TODO: implement execution
+	// TODO: implement state maintenance
+	// TODO: validate the response from the node?
+	// TODO: (QUESTION) Should we persist SignedRPC?
+	return nil, nil
+}
+
+// validateRelayMeta ensures the relay metadata is valid for being handled by the servicer
+// TODO: (REFACTOR) move the meta-specific validation to a Validator method on RelayMeta struct",utility/service/service.go,2023-06-01 02:14:07+00:00,2023-06-01T02:40:28Z,"```suggestion
// REFACTOR: move the meta-specific validation to a Validator method on RelayMeta struct
```",,,,,86,RIGHT,86,,line,https://api.github.com/repos/pokt-network/pocket/pulls/789,pokt-network/pocket,682912b958986467465e21b1ae2710cac98aff55
https://api.github.com/repos/pokt-network/pocket/pulls/789,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1212491217,Olshansk,5f511658026e16c7b4025662c7e7016ed440674c,01da7a84832f2d78c03275edbb8bdf57c79b6edd,"@@ -1,11 +1,217 @@
 package service
 
 import (
+	""errors""
+	""fmt""
+
+	""github.com/pokt-network/pocket/logger""
+	""github.com/pokt-network/pocket/runtime/configs""
 	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
 	""github.com/pokt-network/pocket/shared/crypto""
+	""github.com/pokt-network/pocket/shared/modules""
+	""github.com/pokt-network/pocket/shared/modules/base_modules""
+)
+
+var (
+	errValidateBlockHeight = errors.New(""relay failed block height validation"")
+	errValidateRelayMeta   = errors.New(""relay failed metadata validation"")
+
+	_ Servicer = &servicer{}
 )
 
+type Servicer interface {
+	modules.Module
+
+	HandleRelay(*coreTypes.Relay) (*coreTypes.RelayResponse, error)
+}
+
+type servicer struct {
+	base_modules.IntegratableModule
+	base_modules.InterruptableModule
+
+	logger *modules.Logger
+	config *configs.ServicerConfig
+}
+
+func CreateServicer(bus modules.Bus, options ...modules.ModuleOption) (modules.Module, error) {
+	return new(servicer).Create(bus, options...)
+}
+
+func (*servicer) Create(bus modules.Bus, options ...modules.ModuleOption) (modules.Module, error) {
+	s := &servicer{
+		logger: logger.Global.CreateLoggerForModule(servicerModuleName),
+	}
+
+	for _, option := range options {
+		option(s)
+	}
+
+	bus.RegisterModule(s)
+
+	cfg := bus.GetRuntimeMgr().GetConfig()
+	s.config = cfg.Utility.ServicerConfig
+
+	return s, nil
+}
+
+func (s *servicer) Start() error {
+	s.logger = logger.Global.CreateLoggerForModule(s.GetModuleName())
+	return nil
+}
+
+func (*servicer) GetModuleName() string {
+	return servicerModuleName
+}
+
+// HandleRelay processes a relay after performing validation.
+// It also updates the servicer's internal state to keep track of served relays.
+func (s *servicer) HandleRelay(relay *coreTypes.Relay) (*coreTypes.RelayResponse, error) {
+	if relay == nil {
+		return nil, fmt.Errorf(""cannot serve nil relay"")
+	}
+
+	if err := s.admitRelay(relay); err != nil {
+		return nil, fmt.Errorf(""Error admitting relay: %w"", err)
+	}
+
+	// TODO: implement Persist Relay
+	// TODO: implement execution
+	// TODO: implement state maintenance
+	// TODO: validate the response from the node?
+	// TODO: (QUESTION) Should we persist SignedRPC?
+	return nil, nil
+}
+
+// validateRelayMeta ensures the relay metadata is valid for being handled by the servicer
+// TODO: (REFACTOR) move the meta-specific validation to a Validator method on RelayMeta struct
+func (s servicer) validateRelayMeta(meta *coreTypes.RelayMeta, currentHeight int64) error {
+	if meta == nil {
+		return fmt.Errorf(""empty relay metadata"")
+	}
+
+	if meta.RelayChain == nil {
+		return fmt.Errorf(""relay chain unspecified"")
+	}
+
+	// TODO: supported chains: needs to be crossed-checked with the world state from the persistence layer
+	if err := s.validateRelayChainSupport(meta.RelayChain, currentHeight); err != nil {
+		return fmt.Errorf(""validation of support for relay chain %s failed: %w"", meta.RelayChain.Id, err)
+	}
+
+	return nil
+}
+
+func (s servicer) validateRelayChainSupport(relayChain *coreTypes.Identifiable, currentHeight int64) error {
+	if !isChainSupported(relayChain.Id, s.config.Chains) {
+		return fmt.Errorf(""chain %s not supported by servicer %s configuration"", relayChain.Id, s.config.Address)
+	}
+
+	// DISCUSS: either update NewReadContext to take a uint64, or the GetCurrentHeight to return an int64.",utility/service/service.go,2023-06-01 02:15:18+00:00,2023-06-01T02:40:28Z,"Yup, this is on @dylanlott's 📡",,,,105.0,109,RIGHT,109,105.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/789,pokt-network/pocket,682912b958986467465e21b1ae2710cac98aff55
https://api.github.com/repos/pokt-network/pocket/pulls/789,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1212491674,Olshansk,5f511658026e16c7b4025662c7e7016ed440674c,01da7a84832f2d78c03275edbb8bdf57c79b6edd,"@@ -1,11 +1,217 @@
 package service
 
 import (
+	""errors""
+	""fmt""
+
+	""github.com/pokt-network/pocket/logger""
+	""github.com/pokt-network/pocket/runtime/configs""
 	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
 	""github.com/pokt-network/pocket/shared/crypto""
+	""github.com/pokt-network/pocket/shared/modules""
+	""github.com/pokt-network/pocket/shared/modules/base_modules""
+)
+
+var (
+	errValidateBlockHeight = errors.New(""relay failed block height validation"")
+	errValidateRelayMeta   = errors.New(""relay failed metadata validation"")
+
+	_ Servicer = &servicer{}
 )
 
+type Servicer interface {
+	modules.Module
+
+	HandleRelay(*coreTypes.Relay) (*coreTypes.RelayResponse, error)
+}
+
+type servicer struct {
+	base_modules.IntegratableModule
+	base_modules.InterruptableModule
+
+	logger *modules.Logger
+	config *configs.ServicerConfig
+}
+
+func CreateServicer(bus modules.Bus, options ...modules.ModuleOption) (modules.Module, error) {
+	return new(servicer).Create(bus, options...)
+}
+
+func (*servicer) Create(bus modules.Bus, options ...modules.ModuleOption) (modules.Module, error) {
+	s := &servicer{
+		logger: logger.Global.CreateLoggerForModule(servicerModuleName),
+	}
+
+	for _, option := range options {
+		option(s)
+	}
+
+	bus.RegisterModule(s)
+
+	cfg := bus.GetRuntimeMgr().GetConfig()
+	s.config = cfg.Utility.ServicerConfig
+
+	return s, nil
+}
+
+func (s *servicer) Start() error {
+	s.logger = logger.Global.CreateLoggerForModule(s.GetModuleName())
+	return nil
+}
+
+func (*servicer) GetModuleName() string {
+	return servicerModuleName
+}
+
+// HandleRelay processes a relay after performing validation.
+// It also updates the servicer's internal state to keep track of served relays.
+func (s *servicer) HandleRelay(relay *coreTypes.Relay) (*coreTypes.RelayResponse, error) {
+	if relay == nil {
+		return nil, fmt.Errorf(""cannot serve nil relay"")
+	}
+
+	if err := s.admitRelay(relay); err != nil {
+		return nil, fmt.Errorf(""Error admitting relay: %w"", err)
+	}
+
+	// TODO: implement Persist Relay
+	// TODO: implement execution
+	// TODO: implement state maintenance
+	// TODO: validate the response from the node?
+	// TODO: (QUESTION) Should we persist SignedRPC?
+	return nil, nil
+}
+
+// validateRelayMeta ensures the relay metadata is valid for being handled by the servicer
+// TODO: (REFACTOR) move the meta-specific validation to a Validator method on RelayMeta struct
+func (s servicer) validateRelayMeta(meta *coreTypes.RelayMeta, currentHeight int64) error {
+	if meta == nil {
+		return fmt.Errorf(""empty relay metadata"")
+	}
+
+	if meta.RelayChain == nil {
+		return fmt.Errorf(""relay chain unspecified"")
+	}
+
+	// TODO: supported chains: needs to be crossed-checked with the world state from the persistence layer
+	if err := s.validateRelayChainSupport(meta.RelayChain, currentHeight); err != nil {
+		return fmt.Errorf(""validation of support for relay chain %s failed: %w"", meta.RelayChain.Id, err)
+	}
+
+	return nil
+}
+
+func (s servicer) validateRelayChainSupport(relayChain *coreTypes.Identifiable, currentHeight int64) error {
+	if !isChainSupported(relayChain.Id, s.config.Chains) {
+		return fmt.Errorf(""chain %s not supported by servicer %s configuration"", relayChain.Id, s.config.Address)
+	}
+
+	// DISCUSS: either update NewReadContext to take a uint64, or the GetCurrentHeight to return an int64.
+	readCtx, err := s.GetBus().GetPersistenceModule().NewReadContext(currentHeight)
+	if err != nil {
+		return fmt.Errorf(""error getting persistence context at height %d: %w"", currentHeight, err)
+	}
+	defer readCtx.Release() //nolint:errcheck // We only need to make sure the readCtx is released
+
+	// DISCUSS: should we update the GetServicer signature to take a string instead?",utility/service/service.go,2023-06-01 02:16:23+00:00,2023-06-01T02:40:28Z,"Yes

![Screenshot 2023-05-31 at 7 16 11 PM](https://github.com/pokt-network/pocket/assets/1892194/47b47354-85ad-426b-95e1-83073bae38d5)
",,,,112.0,116,RIGHT,116,112.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/789,pokt-network/pocket,682912b958986467465e21b1ae2710cac98aff55
https://api.github.com/repos/pokt-network/pocket/pulls/789,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1212498825,Olshansk,5f511658026e16c7b4025662c7e7016ed440674c,01da7a84832f2d78c03275edbb8bdf57c79b6edd,"@@ -147,3 +353,12 @@ func (r *relay) GetRelayChain() RelayChain              { return nil }
 func (r *relay) GetGeoZone() GeoZone                    { return nil }
 func (r *relay) GetToken() AAT                          { return nil }
 func (r *relay) GetSignature() string                   { return """" }
+
+func isChainSupported(chainId string, allChains []string) bool {
+	for _, ch := range allChains {",utility/service/service.go,2023-06-01 02:33:53+00:00,2023-06-01T02:40:28Z,Optional NIT: We can use `slices.Index` nowadays :),,,,,358,RIGHT,224,,line,https://api.github.com/repos/pokt-network/pocket/pulls/789,pokt-network/pocket,682912b958986467465e21b1ae2710cac98aff55
https://api.github.com/repos/pokt-network/pocket/pulls/789,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1212499104,Olshansk,5f511658026e16c7b4025662c7e7016ed440674c,01da7a84832f2d78c03275edbb8bdf57c79b6edd,"@@ -1,11 +1,217 @@
 package service
 
 import (
+	""errors""
+	""fmt""
+
+	""github.com/pokt-network/pocket/logger""
+	""github.com/pokt-network/pocket/runtime/configs""
 	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
 	""github.com/pokt-network/pocket/shared/crypto""
+	""github.com/pokt-network/pocket/shared/modules""
+	""github.com/pokt-network/pocket/shared/modules/base_modules""
+)
+
+var (
+	errValidateBlockHeight = errors.New(""relay failed block height validation"")
+	errValidateRelayMeta   = errors.New(""relay failed metadata validation"")
+
+	_ Servicer = &servicer{}
 )
 
+type Servicer interface {
+	modules.Module
+
+	HandleRelay(*coreTypes.Relay) (*coreTypes.RelayResponse, error)
+}
+
+type servicer struct {
+	base_modules.IntegratableModule
+	base_modules.InterruptableModule
+
+	logger *modules.Logger
+	config *configs.ServicerConfig
+}
+
+func CreateServicer(bus modules.Bus, options ...modules.ModuleOption) (modules.Module, error) {
+	return new(servicer).Create(bus, options...)
+}
+
+func (*servicer) Create(bus modules.Bus, options ...modules.ModuleOption) (modules.Module, error) {
+	s := &servicer{
+		logger: logger.Global.CreateLoggerForModule(servicerModuleName),
+	}
+
+	for _, option := range options {
+		option(s)
+	}
+
+	bus.RegisterModule(s)
+
+	cfg := bus.GetRuntimeMgr().GetConfig()
+	s.config = cfg.Utility.ServicerConfig
+
+	return s, nil
+}
+
+func (s *servicer) Start() error {
+	s.logger = logger.Global.CreateLoggerForModule(s.GetModuleName())
+	return nil
+}
+
+func (*servicer) GetModuleName() string {
+	return servicerModuleName
+}
+
+// HandleRelay processes a relay after performing validation.
+// It also updates the servicer's internal state to keep track of served relays.
+func (s *servicer) HandleRelay(relay *coreTypes.Relay) (*coreTypes.RelayResponse, error) {
+	if relay == nil {
+		return nil, fmt.Errorf(""cannot serve nil relay"")
+	}
+
+	if err := s.admitRelay(relay); err != nil {
+		return nil, fmt.Errorf(""Error admitting relay: %w"", err)
+	}
+
+	// TODO: implement Persist Relay
+	// TODO: implement execution
+	// TODO: implement state maintenance
+	// TODO: validate the response from the node?
+	// TODO: (QUESTION) Should we persist SignedRPC?
+	return nil, nil
+}
+
+// validateRelayMeta ensures the relay metadata is valid for being handled by the servicer
+// TODO: (REFACTOR) move the meta-specific validation to a Validator method on RelayMeta struct
+func (s servicer) validateRelayMeta(meta *coreTypes.RelayMeta, currentHeight int64) error {
+	if meta == nil {
+		return fmt.Errorf(""empty relay metadata"")
+	}
+
+	if meta.RelayChain == nil {
+		return fmt.Errorf(""relay chain unspecified"")
+	}
+
+	// TODO: supported chains: needs to be crossed-checked with the world state from the persistence layer
+	if err := s.validateRelayChainSupport(meta.RelayChain, currentHeight); err != nil {
+		return fmt.Errorf(""validation of support for relay chain %s failed: %w"", meta.RelayChain.Id, err)
+	}
+
+	return nil
+}
+
+func (s servicer) validateRelayChainSupport(relayChain *coreTypes.Identifiable, currentHeight int64) error {
+	if !isChainSupported(relayChain.Id, s.config.Chains) {
+		return fmt.Errorf(""chain %s not supported by servicer %s configuration"", relayChain.Id, s.config.Address)
+	}
+
+	// DISCUSS: either update NewReadContext to take a uint64, or the GetCurrentHeight to return an int64.
+	readCtx, err := s.GetBus().GetPersistenceModule().NewReadContext(currentHeight)
+	if err != nil {
+		return fmt.Errorf(""error getting persistence context at height %d: %w"", currentHeight, err)
+	}
+	defer readCtx.Release() //nolint:errcheck // We only need to make sure the readCtx is released
+
+	// DISCUSS: should we update the GetServicer signature to take a string instead?
+	servicer, err := readCtx.GetServicer([]byte(s.config.Address), currentHeight)
+	if err != nil {
+		return fmt.Errorf(""error reading servicer from persistence: %w"", err)
+	}
+
+	if !isChainSupported(relayChain.Id, servicer.Chains) {
+		return fmt.Errorf(""chain %s not supported by servicer %s configuration fetched from persistence"", relayChain.Id, s.config.Address)
+	}
+
+	return nil
+}
+
+// TODO: implement
+// validateApplication makes sure the application has not received more relays than allocated in the current session.
+func (s servicer) validateApplication(meta *coreTypes.RelayMeta, session *coreTypes.Session) error {
+	/*
+		// if maxRelaysPerSession, overServiced := calculateAppSessionTokens(); overServiced {
+			return fmt.Errorf(""application %s has exceeded its allocated relays %d for the session %d"", meta.ApplicationPublicKey, maxRelaysPerSession)
+		}
+	*/
+	return nil
+}
+
+// validateServicer makes sure the servicer is A) active in the current session, and B) has not served more than its allocated relays for the session
+func (s servicer) validateServicer(meta *coreTypes.RelayMeta, session *coreTypes.Session) error {
+	if meta.ServicerPublicKey != s.config.PublicKey {
+		return fmt.Errorf(""relay servicer key %s does not match this servicer instance %s"", meta.ServicerPublicKey, s.config.PublicKey)
+	}
+
+	var found bool
+	for _, servicer := range session.Servicers {
+		if servicer != nil && servicer.PublicKey == meta.ServicerPublicKey {
+			found = true
+			break
+		}
+	}
+
+	if !found {
+		return fmt.Errorf(""relay servicer key %s not found in session %d with %d servicers"", meta.ServicerPublicKey, session.SessionNumber, len(session.Servicers))
+	}
+
+	// TODO: implement isServicerMaxedOut
+	return nil
+}
+
+// admitRelay decides whether the relay should be served
+func (s servicer) admitRelay(relay *coreTypes.Relay) error {
+	// TODO: utility module should initialize the servicer (if this module instance is a servicer)
+	const errPrefix = ""Error admitting relay""
+
+	if relay == nil {
+		return fmt.Errorf(""%s: relay is nil"", errPrefix)
+	}
+
+	height := s.GetBus().GetConsensusModule().CurrentHeight()
+	if err := s.validateRelayMeta(relay.Meta, int64(height)); err != nil {
+		return fmt.Errorf(""%w: %w"", errValidateRelayMeta, err)
+	}
+
+	// TODO: update the CLI to include ApplicationAddress(or Application Public Key) in the RelayMeta
+	session, err := s.GetBus().GetUtilityModule().GetSession(relay.Meta.ApplicationAddress, int64(height), relay.Meta.RelayChain.Id, relay.Meta.GeoZone.Id)
+	if err != nil {
+		return fmt.Errorf(""%s: failed to get a session for height %d for relay meta %s: %w"", errPrefix, height, relay.Meta, err)
+	}
+
+	// TODO: (REFACTOR) use a loop to run all validators: would also remove the need for passing the session around
+	if err := validateRelayBlockHeight(relay.Meta, session); err != nil {
+		return fmt.Errorf(""%w: %w"", errValidateBlockHeight, err)
+	}
+
+	if err := s.validateApplication(relay.Meta, session); err != nil {
+		return fmt.Errorf(""%s: relay failed application validation: %w"", errPrefix, err)
+	}
+
+	if err := s.validateServicer(relay.Meta, session); err != nil {
+		return fmt.Errorf(""%s: relay failed servicer instance validation: %w"", errPrefix, err)
+	}
+
+	return nil
+}
+
+func validateRelayBlockHeight(relayMeta *coreTypes.RelayMeta, session *coreTypes.Session) error {",utility/service/service.go,2023-06-01 02:34:39+00:00,2023-06-01T02:40:28Z,"```suggestion
// IMPROVE: Add session height tolerance to account for session rollovers 
func validateRelayBlockHeight(relayMeta *coreTypes.RelayMeta, session *coreTypes.Session) error {
```",,,,195.0,198,RIGHT,198,195.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/789,pokt-network/pocket,682912b958986467465e21b1ae2710cac98aff55
https://api.github.com/repos/pokt-network/pocket/pulls/806,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1219906817,dylanlott,df5eb7eecd9f14d3c38f5a4193d24f691f276cd2,413589f72ee094c873540734f373261243ee0ee1,"@@ -0,0 +1,13 @@
+package flags",app/client/cli/flags/flags.go,2023-06-06 15:54:22+00:00,2023-06-06T16:17:30Z,"This makes it much clearer when flags are being used vs local variables, nice 👍 ",,,,1.0,1,RIGHT,1,1.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/806,pokt-network/pocket,12f9f498c8b05a91f4c08c6b27227d94013d9232
https://api.github.com/repos/pokt-network/pocket/pulls/806,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1219916121,dylanlott,df5eb7eecd9f14d3c38f5a4193d24f691f276cd2,413589f72ee094c873540734f373261243ee0ee1,"@@ -0,0 +1,76 @@
+package helpers
+
+import (
+	""fmt""
+
+	""github.com/pokt-network/pocket/app/client/cli/flags""
+	""github.com/spf13/cobra""
+
+	""github.com/pokt-network/pocket/logger""
+	""github.com/pokt-network/pocket/p2p""
+	rpc2 ""github.com/pokt-network/pocket/p2p/providers/current_height_provider/rpc""
+	""github.com/pokt-network/pocket/p2p/providers/peerstore_provider/rpc""
+	""github.com/pokt-network/pocket/runtime""
+	""github.com/pokt-network/pocket/runtime/defaults""
+	""github.com/pokt-network/pocket/shared/modules""
+)
+
+// P2PDependenciesPreRunE initializes peerstore & current height providers, and a
+// p2p module with consumes them. Everything is registered to the bus.",app/client/cli/helpers/setup.go,2023-06-06 15:59:29+00:00,2023-06-06T16:17:30Z,"Is this supposed to be ""which"" consumes them? ",,,,,19,RIGHT,19,,line,https://api.github.com/repos/pokt-network/pocket/pulls/806,pokt-network/pocket,12f9f498c8b05a91f4c08c6b27227d94013d9232
https://api.github.com/repos/pokt-network/pocket/pulls/806,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1219918451,dylanlott,df5eb7eecd9f14d3c38f5a4193d24f691f276cd2,413589f72ee094c873540734f373261243ee0ee1,"@@ -0,0 +1,76 @@
+package helpers
+
+import (
+	""fmt""
+
+	""github.com/pokt-network/pocket/app/client/cli/flags""
+	""github.com/spf13/cobra""
+
+	""github.com/pokt-network/pocket/logger""
+	""github.com/pokt-network/pocket/p2p""
+	rpc2 ""github.com/pokt-network/pocket/p2p/providers/current_height_provider/rpc""
+	""github.com/pokt-network/pocket/p2p/providers/peerstore_provider/rpc""
+	""github.com/pokt-network/pocket/runtime""
+	""github.com/pokt-network/pocket/runtime/defaults""
+	""github.com/pokt-network/pocket/shared/modules""
+)
+
+// P2PDependenciesPreRunE initializes peerstore & current height providers, and a
+// p2p module with consumes them. Everything is registered to the bus.
+func P2PDependenciesPreRunE(cmd *cobra.Command, _ []string) error {
+	// TECHDEBT: this is to keep backwards compatibility with localnet
+	flags.ConfigPath = runtime.GetEnv(""CONFIG_PATH"", ""build/config/config1.json"")",app/client/cli/helpers/setup.go,2023-06-06 16:01:01+00:00,2023-06-06T16:17:30Z,Let's make sure this doesn't cause issues in DevNet respectively,,,,,22,RIGHT,22,,line,https://api.github.com/repos/pokt-network/pocket/pulls/806,pokt-network/pocket,12f9f498c8b05a91f4c08c6b27227d94013d9232
https://api.github.com/repos/pokt-network/pocket/pulls/806,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1220511547,Olshansk,df5eb7eecd9f14d3c38f5a4193d24f691f276cd2,413589f72ee094c873540734f373261243ee0ee1,"@@ -0,0 +1,13 @@
+package flags
+
+var (
+	RemoteCLIURL string",app/client/cli/flags/flags.go,2023-06-06 23:03:28+00:00,2023-06-06T23:54:51Z,Do these need to be exposed outside of the `flags` package?,,,,7.0,4,RIGHT,4,7.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/806,pokt-network/pocket,12f9f498c8b05a91f4c08c6b27227d94013d9232
https://api.github.com/repos/pokt-network/pocket/pulls/806,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1220512526,Olshansk,df5eb7eecd9f14d3c38f5a4193d24f691f276cd2,413589f72ee094c873540734f373261243ee0ee1,"@@ -0,0 +1,13 @@
+package flags
+
+var (
+	RemoteCLIURL string
+
+	DataDir string
+
+	ConfigPath string
+
+	NonInteractive bool
+
+	Verbose bool",app/client/cli/flags/flags.go,2023-06-06 23:04:39+00:00,2023-06-06T23:54:51Z,Can you add a very short comment for each of them?,,,,23.0,12,RIGHT,12,23.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/806,pokt-network/pocket,12f9f498c8b05a91f4c08c6b27227d94013d9232
https://api.github.com/repos/pokt-network/pocket/pulls/806,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1220512755,Olshansk,df5eb7eecd9f14d3c38f5a4193d24f691f276cd2,413589f72ee094c873540734f373261243ee0ee1,"@@ -0,0 +1,14 @@
+package helpers
+
+import (
+	""github.com/pokt-network/pocket/runtime""
+	""github.com/pokt-network/pocket/shared/modules""
+)
+
+var (
+	GenesisPath = runtime.GetEnv(""GENESIS_PATH"", ""build/config/genesis.json"")",app/client/cli/helpers/common.go,2023-06-06 23:04:58+00:00,2023-06-06T23:54:51Z,Reevaluate the visibility of the vars (from a package scope perspective) ,,,,,9,RIGHT,9,,line,https://api.github.com/repos/pokt-network/pocket/pulls/806,pokt-network/pocket,12f9f498c8b05a91f4c08c6b27227d94013d9232
https://api.github.com/repos/pokt-network/pocket/pulls/806,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1220513336,Olshansk,df5eb7eecd9f14d3c38f5a4193d24f691f276cd2,413589f72ee094c873540734f373261243ee0ee1,"@@ -0,0 +1,14 @@
+package helpers
+
+import (
+	""github.com/pokt-network/pocket/runtime""
+	""github.com/pokt-network/pocket/shared/modules""
+)
+
+var (
+	GenesisPath = runtime.GetEnv(""GENESIS_PATH"", ""build/config/genesis.json"")
+	RpcHost     string",app/client/cli/helpers/common.go,2023-06-06 23:05:32+00:00,2023-06-06T23:54:51Z,"Can this be overriden by `RemoteCLIURL`? 

Asking to:
1. Understand
2. Modify / consolidate as needed",,,,,10,RIGHT,10,,line,https://api.github.com/repos/pokt-network/pocket/pulls/806,pokt-network/pocket,12f9f498c8b05a91f4c08c6b27227d94013d9232
https://api.github.com/repos/pokt-network/pocket/pulls/806,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1220513672,Olshansk,df5eb7eecd9f14d3c38f5a4193d24f691f276cd2,413589f72ee094c873540734f373261243ee0ee1,"@@ -0,0 +1,14 @@
+package helpers
+
+import (
+	""github.com/pokt-network/pocket/runtime""
+	""github.com/pokt-network/pocket/shared/modules""
+)
+
+var (
+	GenesisPath = runtime.GetEnv(""GENESIS_PATH"", ""build/config/genesis.json"")",app/client/cli/helpers/common.go,2023-06-06 23:06:00+00:00,2023-06-06T23:54:51Z,"Add a TODO to:
1. Also accept reading this from datadir
2. Accept this is a flag",,,,,9,RIGHT,9,,line,https://api.github.com/repos/pokt-network/pocket/pulls/806,pokt-network/pocket,12f9f498c8b05a91f4c08c6b27227d94013d9232
https://api.github.com/repos/pokt-network/pocket/pulls/806,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1220545483,Olshansk,df5eb7eecd9f14d3c38f5a4193d24f691f276cd2,413589f72ee094c873540734f373261243ee0ee1,"@@ -0,0 +1,21 @@
+package helpers
+
+import (
+	""context""
+
+	""github.com/spf13/cobra""
+)
+
+const BusCLICtxKey cliContextKey = ""bus""
+
+// NOTE: this is required by the linter, otherwise a simple string constant would have been enough
+type cliContextKey string
+
+func SetValueInCLIContext(cmd *cobra.Command, key cliContextKey, value any) {
+	cmd.SetContext(context.WithValue(cmd.Context(), key, value))
+}
+
+func GetValueFromCLIContext[T any](cmd *cobra.Command, key cliContextKey) (T, bool) {
+	value, ok := cmd.Context().Value(key).(T)
+	return value, ok",app/client/cli/helpers/context.go,2023-06-06 23:42:09+00:00,2023-06-06T23:54:51Z,"```suggestion
	return cmd.Context().Value(key).(T)
```",19.0,19.0,RIGHT,20.0,20,RIGHT,20,20.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/806,pokt-network/pocket,12f9f498c8b05a91f4c08c6b27227d94013d9232
https://api.github.com/repos/pokt-network/pocket/pulls/806,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1224528019,okdas,8c2b9f4adb15b535663604b51347fc92b417e9fb,413589f72ee094c873540734f373261243ee0ee1,"@@ -2,40 +2,43 @@ package cli
 
 import (
 	""context""
+	""log""
 
-	""github.com/pokt-network/pocket/runtime/configs""
-	""github.com/pokt-network/pocket/runtime/defaults""
 	""github.com/spf13/cobra""
 	""github.com/spf13/viper""
+
+	""github.com/pokt-network/pocket/app/client/cli/flags""
+	""github.com/pokt-network/pocket/runtime/configs""
+	""github.com/pokt-network/pocket/runtime/defaults""
 )
 
 const (
 	cliExecutableName = ""p1""
 )
 
 var (
-	remoteCLIURL   string
-	dataDir        string
-	configPath     string
-	nonInteractive bool
-	verbose        bool
-	cfg            *configs.Config
+	cfg *configs.Config
 )
 
 func init() {
-	rootCmd.PersistentFlags().StringVar(&remoteCLIURL, ""remote_cli_url"", defaults.DefaultRemoteCLIURL, ""takes a remote endpoint in the form of <protocol>://<host> (uses RPC Port)"")
-	rootCmd.PersistentFlags().BoolVar(&nonInteractive, ""non_interactive"", false, ""if true skips the interactive prompts wherever possible (useful for scripting & automation)"")
+	rootCmd.PersistentFlags().StringVar(&flags.RemoteCLIURL, ""remote_cli_url"", defaults.DefaultRemoteCLIURL, ""takes a remote endpoint in the form of <protocol>://<host>:<port> (uses RPC Port)"")
+	// ensure that this flag can be overidden by the respective viper-conventional environment variable (i.e. `POCKET_REMOTE_CLI_URL`)",app/client/cli/cmd.go,2023-06-09 16:42:49+00:00,2023-06-09T16:42:49Z,Have you checked if it environment variable works? I love that you bind a viper configuration instead of looking up the environment variable! ,,,,,25,RIGHT,34,,line,https://api.github.com/repos/pokt-network/pocket/pulls/806,pokt-network/pocket,12f9f498c8b05a91f4c08c6b27227d94013d9232
https://api.github.com/repos/pokt-network/pocket/pulls/806,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1227216682,Olshansk,c0577a3e5318866ec4e454112dbd438aebf45d5d,413589f72ee094c873540734f373261243ee0ee1,"@@ -43,6 +48,9 @@ var rootCmd = &cobra.Command{
 	PersistentPreRunE: func(cmd *cobra.Command, args []string) error {
 		// by this time, the config path should be set
 		cfg = configs.ParseConfig(flags.ConfigPath)
+
+		// set final `remote_cli_url` value; order of precedence: flag > env var > config > default",app/client/cli/cmd.go,2023-06-12 20:38:05+00:00,2023-06-12T21:26:27Z,Should this be something we do for every flag?,,,,52.0,52,RIGHT,50,67.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/806,pokt-network/pocket,12f9f498c8b05a91f4c08c6b27227d94013d9232
https://api.github.com/repos/pokt-network/pocket/pulls/806,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1227217911,Olshansk,c0577a3e5318866ec4e454112dbd438aebf45d5d,413589f72ee094c873540734f373261243ee0ee1,"@@ -1,13 +1,24 @@
 package flags
 
 var (
+	// RemoveCLIURL is the URL of the remote RPC node which the CLI will interact with.
+	// Formatted as <protocol>://<host>:<port> (uses RPC Port).
+	// (see: --help the root command for more info).",app/client/cli/flags/flags.go,2023-06-12 20:39:28+00:00,2023-06-12T21:26:27Z,NIT: I think adding `(see: --help the root command for more info).` once above `var (` would be sufficient.,,,,6.0,6,RIGHT,6,6.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/806,pokt-network/pocket,12f9f498c8b05a91f4c08c6b27227d94013d9232
https://api.github.com/repos/pokt-network/pocket/pulls/806,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1227257833,Olshansk,c0577a3e5318866ec4e454112dbd438aebf45d5d,413589f72ee094c873540734f373261243ee0ee1,"@@ -18,7 +18,19 @@ var (
 )
 
 func init() {
-	rpcURL = fmt.Sprintf(""http://%s:%s"", runtime.GetEnv(""RPC_HOST"", ""pocket-validators""), defaults.DefaultRPCPort)
+	// set the rpcURL based on the environment while still supporting overriding of the RPC_HOST.
+	var rpcHost string
+	// TECHDEBT: if we intend to support running the e2e tests in both tilt/k8s and",e2e/tests/validator.go,2023-06-12 21:22:32+00:00,2023-06-12T21:26:27Z,I think E2E tests are only intended for tilt/k8s - not docker compose,,,,,23,RIGHT,7,,line,https://api.github.com/repos/pokt-network/pocket/pulls/806,pokt-network/pocket,12f9f498c8b05a91f4c08c6b27227d94013d9232
https://api.github.com/repos/pokt-network/pocket/pulls/806,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1227258195,Olshansk,c0577a3e5318866ec4e454112dbd438aebf45d5d,413589f72ee094c873540734f373261243ee0ee1,"@@ -18,7 +18,19 @@ var (
 )
 
 func init() {
-	rpcURL = fmt.Sprintf(""http://%s:%s"", runtime.GetEnv(""RPC_HOST"", ""pocket-validators""), defaults.DefaultRPCPort)
+	// set the rpcURL based on the environment while still supporting overriding of the RPC_HOST.
+	var rpcHost string
+	// TECHDEBT: if we intend to support running the e2e tests in both tilt/k8s and
+	// docker compose, then we need to understand why the `KUBERNETES_SERVICE_HOST`
+	// isn't set even when running in k8s. See: `test_go('e2e-tests', ...` in the
+	// Tiltfile.
+	// if runtime.IsProcessRunningInsideKubernetes() {",e2e/tests/validator.go,2023-06-12 21:22:51+00:00,2023-06-12T21:26:27Z,Is this a WIP to be checked with @okdas in this PR?,,,,,27,RIGHT,11,,line,https://api.github.com/repos/pokt-network/pocket/pulls/806,pokt-network/pocket,12f9f498c8b05a91f4c08c6b27227d94013d9232
https://api.github.com/repos/pokt-network/pocket/pulls/806,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1227260381,Olshansk,c0577a3e5318866ec4e454112dbd438aebf45d5d,413589f72ee094c873540734f373261243ee0ee1,"@@ -31,13 +35,45 @@ var (
 	// autoStakeSkipStakeForValidatorIds is a list of validator ids that should not be auto-staked
 	// it is used to avoid auto-staking the validators that are already staked as part of genesis.
 	autoStakeSkipStakeForValidatorIds = []string{""001"", ""002"", ""003"", ""004""}
+
+	clusterManagerCmd = &cobra.Command{
+		Use:   ""cluster-manager"",
+		Short: ""Start the Pocket Network Cluster Manager service"",
+		Long: `Start the Pocket Network Cluster Manager service which listens for and reacts to events coming over the k8s.io API's watch.Interface#ResultChan().
+
+See the following k8s.io documentation for more information:
+- https://pkg.go.dev/k8s.io/client-go/kubernetes/typed/core/v1@v0.26.1#ServiceInterface
+- https://pkg.go.dev/k8s.io/apimachinery/pkg/watch#Interface,
+- https://pkg.go.dev/k8s.io/apimachinery/pkg/watch#Event`,
+		Run:  runClusterManagerCmd,
+		Args: cobra.ExactArgs(0),
+	}
 )
 
 func init() {
-	rpcURL = fmt.Sprintf(""http://%s:%s"", runtime.GetEnv(""RPC_HOST"", defaults.Validator1EndpointK8S), defaults.DefaultRPCPort)
+	// setup the `remote_cli_url` flag to be consistent with the CLI except for
+	// the default, which is set to the URL of the first k8s validator's RPC
+	// endpoint.
+	clusterManagerCmd.PersistentFlags().StringVar(
+		&flags.RemoteCLIURL,
+		""remote_cli_url"",
+		defaults.Validator1EndpointK8SHostname,
+		""takes a remote endpoint in the form of <protocol>://<host>:<port> (uses RPC Port)"",
+	)
+
+	// ensure that the env var can override the flag",build/localnet/cluster-manager/main.go,2023-06-12 21:25:19+00:00,2023-06-12T21:26:27Z,"I know we've had a lot of issues with viper and flag binding in the past.

I don't have much feedback on this as I'd have to dive in really deep, but have to be honest that I have lost context on where/how this variable binding is working.

Anything I should focus on or provide feedback in particular? If not, LGTM",,,,64.0,64,RIGHT,49,49.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/806,pokt-network/pocket,12f9f498c8b05a91f4c08c6b27227d94013d9232
https://api.github.com/repos/pokt-network/pocket/pulls/806,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1227609360,bryanchriswhite,c0577a3e5318866ec4e454112dbd438aebf45d5d,413589f72ee094c873540734f373261243ee0ee1,"@@ -0,0 +1,72 @@
+package helpers
+
+import (
+	""github.com/spf13/cobra""
+
+	""github.com/pokt-network/pocket/app/client/cli/flags""
+	""github.com/pokt-network/pocket/logger""
+	""github.com/pokt-network/pocket/p2p""
+	rpcCHP ""github.com/pokt-network/pocket/p2p/providers/current_height_provider/rpc""
+	rpcPSP ""github.com/pokt-network/pocket/p2p/providers/peerstore_provider/rpc""
+	""github.com/pokt-network/pocket/runtime""
+	""github.com/pokt-network/pocket/shared/modules""
+)
+
+// P2PDependenciesPreRunE initializes peerstore & current height providers, and a
+// p2p module with consumes them. Everything is registered to the bus.",app/client/cli/helpers/setup.go,2023-06-13 06:47:20+00:00,2023-06-13T06:47:20Z,"```suggestion
// p2p module which consumes them. Everything is registered to the bus.
```",,,,,16,RIGHT,16,,line,https://api.github.com/repos/pokt-network/pocket/pulls/806,pokt-network/pocket,12f9f498c8b05a91f4c08c6b27227d94013d9232
https://api.github.com/repos/pokt-network/pocket/pulls/808,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1222327666,Olshansk,c79087e98c241203c372a36ec02a63fa767beada,cefecdb0dd1d32c268481640a9e354e88bdcd2e0,"@@ -90,6 +91,8 @@ const (
 // of the underlying trees by utilizing the lazy loading
 // functionality provided by the underlying smt library.
 type treeStore struct {
+	modules.Module",persistence/trees/trees.go,2023-06-08 00:55:01+00:00,2023-06-08T00:57:39Z,Add type assertion to guarantee that `treeStore` implements the module interface like we do with `var _ = `,,,,,94,RIGHT,12,,line,https://api.github.com/repos/pokt-network/pocket/pulls/808,pokt-network/pocket,f45db36550c056f95340ebdb46747cf8ef141e76
https://api.github.com/repos/pokt-network/pocket/pulls/808,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1222329520,Olshansk,c79087e98c241203c372a36ec02a63fa767beada,cefecdb0dd1d32c268481640a9e354e88bdcd2e0,"@@ -90,6 +91,8 @@ const (
 // of the underlying trees by utilizing the lazy loading
 // functionality provided by the underlying smt library.
 type treeStore struct {
+	modules.Module
+
 	treeStoreDir string
 	merkleTrees  map[merkleTree]*smt.SMT
 	nodeStores   map[merkleTree]kvstore.KVStore",persistence/trees/trees.go,2023-06-08 00:56:56+00:00,2023-06-08T00:57:39Z,"The fact that we still have `NewStateTrees` but also introduced `Create` seems like an anti-pattern: I don't know which one to use.

I think we should:
1.  rename `trees.go` to `module.go`
2. Consolidate all the business logic
3. Make the `dir` param part of the configs
4. Remove `NewStateTrees` altogether and use `Create` instead
",,,,100.0,98,RIGHT,16,41.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/808,pokt-network/pocket,f45db36550c056f95340ebdb46747cf8ef141e76
https://api.github.com/repos/pokt-network/pocket/pulls/808,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1231610798,Olshansk,ccd7d4169ec6fd4522a0f16576355a331d8f7219,cefecdb0dd1d32c268481640a9e354e88bdcd2e0,"@@ -0,0 +1,78 @@
+package trees
+
+import (
+	""crypto/sha256""
+	""fmt""
+
+	""github.com/pokt-network/pocket/persistence/kvstore""
+	""github.com/pokt-network/pocket/shared/modules""
+	""github.com/pokt-network/smt""
+)
+
+func (*treeStore) Create(bus modules.Bus, options ...modules.TreeStoreOption) (modules.TreeStoreModule, error) {
+	m := &treeStore{}
+
+	m.SetBus(bus)",persistence/trees/module.go,2023-06-15 22:59:54+00:00,2023-06-15T23:03:19Z,"Also, do this AFTER applying the options

```suggestion
	bus.RegisterModule(m)
```",,,,,15,RIGHT,15,,line,https://api.github.com/repos/pokt-network/pocket/pulls/808,pokt-network/pocket,f45db36550c056f95340ebdb46747cf8ef141e76
https://api.github.com/repos/pokt-network/pocket/pulls/808,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1231611682,Olshansk,ccd7d4169ec6fd4522a0f16576355a331d8f7219,cefecdb0dd1d32c268481640a9e354e88bdcd2e0,"@@ -0,0 +1,33 @@
+package modules
+
+import (
+	""github.com/jackc/pgx/v5""
+	""github.com/pokt-network/pocket/persistence/indexer""
+)
+
+const (
+	TreeStoreModuleName = ""tree_store""
+)
+
+type TreeStoreOption func(TreeStoreModule)
+
+type TreeStoreFactory = FactoryWithOptions[TreeStoreModule, TreeStoreOption]
+
+// TreeStoreModules defines the interface for atomic updates and rollbacks to the internal
+// merkle trees that compose the state hash of pocket.
+
+type TreeStoreModule interface {
+	IntegratableModule
+
+	// Update returns the new state hash for a given height.
+	// * Height is passed through to the Update function and is used to query the TxIndexer for transactions
+	// to update into the merkle tree set
+	// * Passing a higher height will cause a change but repeatedly calling the same or a lower height will
+	// not incur a change.
+	// * By nature of it taking a pgx transaction at runtime, Update inherits the pgx transaction's read view of the
+	// database.
+	// TECHDEBT: Remove the TxIndexer pass here and get it from the bus",shared/modules/treestore_module.go,2023-06-15 23:01:52+00:00,2023-06-15T23:03:19Z,"Is this going to be done in a separate PR?

Also, the previous comment we have in the other file is clearer IMO:

```
// TODO(#808): Change interface to `Update(pgtx pgx.Tx, height uint64) (string, error)`
```

Can you make sure the other text/comments are properly mirrored as well.",,,,,29,RIGHT,29,,line,https://api.github.com/repos/pokt-network/pocket/pulls/808,pokt-network/pocket,f45db36550c056f95340ebdb46747cf8ef141e76
https://api.github.com/repos/pokt-network/pocket/pulls/808,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1232085488,h5law,ccd7d4169ec6fd4522a0f16576355a331d8f7219,cefecdb0dd1d32c268481640a9e354e88bdcd2e0,"@@ -78,12 +79,17 @@ const (
 	numMerkleTrees
 )
 
+// Ensure treeStore implements TreeStore
+var _ modules.TreeStoreModule = &treeStore{}
+
 // treeStore stores a set of merkle trees that
 // it manages. It fulfills the modules.TreeStore interface.
 // * It is responsible for atomic commit or rollback behavior
 // of the underlying trees by utilizing the lazy loading
 // functionality provided by the underlying smt library.
 type treeStore struct {",persistence/trees/trees.go,2023-06-16 10:41:56+00:00,2023-06-16T10:41:56Z,@dylanlott Wdyt of adding a field here such as `rootTree *smt.SMT` which contains the different statetree name-hash pairings. This way we no longer need to keep track of the order of the trees we just insert their root into this tree and this trees root is our stateHash. Updates in any order to the SMT will produce the same tree.,,,,95.0,93,RIGHT,31,36.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/808,pokt-network/pocket,f45db36550c056f95340ebdb46747cf8ef141e76
https://api.github.com/repos/pokt-network/pocket/pulls/808,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1237692495,h5law,7d24987e71bd76bd014168b180a8f1b099c01af6,cefecdb0dd1d32c268481640a9e354e88bdcd2e0,"@@ -0,0 +1,73 @@
+package trees
+
+import (
+	""fmt""
+
+	""github.com/pokt-network/pocket/persistence/kvstore""
+	""github.com/pokt-network/pocket/shared/modules""
+	""github.com/pokt-network/smt""
+)
+
+func (*treeStore) Create(bus modules.Bus, options ...modules.TreeStoreOption) (modules.TreeStoreModule, error) {
+	m := &treeStore{}
+
+	for _, option := range options {
+		option(m)
+	}
+
+	m.SetBus(bus)",persistence/trees/module.go,2023-06-21 21:01:35+00:00,2023-06-21T21:09:13Z,"```suggestion
	bus.RegisterModule(m)
```

Is there a difference in these calls? I think doing this way and adding a method to the `Bus` interface would allow for `TreeStore` access outside of persistence, seeing as the method `GetTreeStore` was removed from the interface is this the intended way?

```go
treeStore := bus.GetTreeStore()
```",,,,18.0,18,RIGHT,18,18.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/808,pokt-network/pocket,f45db36550c056f95340ebdb46747cf8ef141e76
https://api.github.com/repos/pokt-network/pocket/pulls/808,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1237695386,h5law,7d24987e71bd76bd014168b180a8f1b099c01af6,cefecdb0dd1d32c268481640a9e354e88bdcd2e0,"@@ -25,10 +25,6 @@ type PersistenceModule interface {
 	// BlockStore maps a block height to an *coreTypes.IndexedTransaction
 	GetBlockStore() blockstore.BlockStore
 
-	// TreeStore manages atomic access to a set of merkle trees
-	// that compose the state hash.
-	GetTreeStore() TreeStore",shared/modules/persistence_module.go,2023-06-21 21:04:43+00:00,2023-06-21T21:04:44Z,As we are removing this from the persistence context how can we access the `TreeStore` module from outside of the persistence package if needed?,,,,30.0,30,LEFT,6,6.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/808,pokt-network/pocket,f45db36550c056f95340ebdb46747cf8ef141e76
https://api.github.com/repos/pokt-network/pocket/pulls/808,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1237696705,h5law,7d24987e71bd76bd014168b180a8f1b099c01af6,cefecdb0dd1d32c268481640a9e354e88bdcd2e0,"@@ -237,7 +235,7 @@ func (m *persistenceModule) GetTxIndexer() indexer.TxIndexer {
 	return m.txIndexer
 }
 
-func (m *persistenceModule) GetTreeStore() modules.TreeStore {
+func (m *persistenceModule) GetTreeStore() modules.TreeStoreModule {",persistence/module.go,2023-06-21 21:06:01+00:00,2023-06-21T21:06:01Z,I am confused as this is present but has been removed from the `PersistenceModule` interface?,,,,,238,RIGHT,41,,line,https://api.github.com/repos/pokt-network/pocket/pulls/808,pokt-network/pocket,f45db36550c056f95340ebdb46747cf8ef141e76
https://api.github.com/repos/pokt-network/pocket/pulls/808,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1237697426,h5law,7d24987e71bd76bd014168b180a8f1b099c01af6,cefecdb0dd1d32c268481640a9e354e88bdcd2e0,"@@ -18,7 +18,6 @@ import (
 
 var (
 	_ modules.PersistenceModule = &persistenceModule{}
-	_ modules.PersistenceModule = &persistenceModule{}",persistence/module.go,2023-06-21 21:07:01+00:00,2023-06-21T21:07:02Z,NIT: Can we also delete the line after,,,,21.0,21,LEFT,4,4.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/808,pokt-network/pocket,f45db36550c056f95340ebdb46747cf8ef141e76
https://api.github.com/repos/pokt-network/pocket/pulls/778,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1205986297,Olshansk,b93c50312e4967daff683ac9fd577e4e5edc2a3b,acec260d9987f4dba2b31bdf4b65f2ef6b654725,"@@ -169,6 +168,7 @@ func newEditStakeCmd(cmdDef actorCmdDef) *cobra.Command {
 				return err
 			}
 
+			// TODO: should skip if non-ineractive",app/client/cli/actor.go,2023-05-25 20:43:27+00:00,2023-05-25T21:21:55Z,Did it in #788. Feel free to remove,,,,,171,RIGHT,12,,line,https://api.github.com/repos/pokt-network/pocket/pulls/778,pokt-network/pocket,a516c51f2d000d25f1469d28e6586ef7875d5a37
https://api.github.com/repos/pokt-network/pocket/pulls/778,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1205990313,Olshansk,b93c50312e4967daff683ac9fd577e4e5edc2a3b,acec260d9987f4dba2b31bdf4b65f2ef6b654725,"@@ -0,0 +1,284 @@
+package cli
+
+import (
+	""context""
+	sha ""crypto""
+	""encoding/hex""
+	""encoding/json""
+	""fmt""
+	""net/http""
+
+	""github.com/spf13/cobra""
+
+	""github.com/pokt-network/pocket/rpc""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/crypto""
+)
+
+func init() {
+	rootCmd.AddCommand(NewServicerCommand())
+}
+
+// TECHDEBT: (unittest) unit test the command: e.g. on number of arguments",app/client/cli/servicer.go,2023-05-25 20:48:48+00:00,2023-05-25T21:21:55Z,"I don't think we're ever really going to write unit tests for cobra commands. Rather, E2E tests will be useful here.

See what @dylanlott is working on in #786.",,,,,22,RIGHT,22,,line,https://api.github.com/repos/pokt-network/pocket/pulls/778,pokt-network/pocket,a516c51f2d000d25f1469d28e6586ef7875d5a37
https://api.github.com/repos/pokt-network/pocket/pulls/778,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1205992493,Olshansk,b93c50312e4967daff683ac9fd577e4e5edc2a3b,acec260d9987f4dba2b31bdf4b65f2ef6b654725,"@@ -0,0 +1,284 @@
+package cli
+
+import (
+	""context""
+	sha ""crypto""
+	""encoding/hex""
+	""encoding/json""
+	""fmt""
+	""net/http""
+
+	""github.com/spf13/cobra""
+
+	""github.com/pokt-network/pocket/rpc""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/crypto""
+)
+
+func init() {
+	rootCmd.AddCommand(NewServicerCommand())
+}
+
+// TECHDEBT: (unittest) unit test the command: e.g. on number of arguments
+func NewServicerCommand() *cobra.Command {
+	cmd := &cobra.Command{
+		Use:     ""Servicer"",
+		Short:   ""Servicer specific commands"",
+		Aliases: []string{""servicer""},
+		Args:    cobra.ExactArgs(0),
+	}
+
+	cmds := servicerCommands()
+	applySubcommandOptions(cmds, attachPwdFlagToSubcommands())
+	applySubcommandOptions(cmds, attachKeybaseFlagsToSubcommands())
+
+	cmd.AddCommand(cmds...)
+
+	return cmd
+}
+
+func servicerCommands() []*cobra.Command {
+	cmdDef := actorCmdDef{""Servicer"", coreTypes.ActorType_ACTOR_TYPE_SERVICER}
+	cmds := []*cobra.Command{
+		newStakeCmd(cmdDef),
+		newEditStakeCmd(cmdDef),
+		newUnstakeCmd(cmdDef),
+		newUnpauseCmd(cmdDef),
+		{
+			Use:   ""Relay <servicer> <application> <relayChainID> <payload>"",
+			Short: ""Relay <servicer> <application> <relayChainID> <payload>"",",app/client/cli/servicer.go,2023-05-25 20:51:53+00:00,2023-05-25T21:21:55Z,"```suggestion
			Use:   ""Relay <applicationAddrHex> <servicerAddrHex>  <relayChainID> <payload>"",
			Short: ""Relay <applicationAddrHex> <servicerAddrHex> <relayChainID> <payload>"",
```",,48.0,RIGHT,,49,RIGHT,49,,line,https://api.github.com/repos/pokt-network/pocket/pulls/778,pokt-network/pocket,a516c51f2d000d25f1469d28e6586ef7875d5a37
https://api.github.com/repos/pokt-network/pocket/pulls/778,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1205997356,Olshansk,b93c50312e4967daff683ac9fd577e4e5edc2a3b,acec260d9987f4dba2b31bdf4b65f2ef6b654725,"@@ -0,0 +1,284 @@
+package cli
+
+import (
+	""context""
+	sha ""crypto""
+	""encoding/hex""
+	""encoding/json""
+	""fmt""
+	""net/http""
+
+	""github.com/spf13/cobra""
+
+	""github.com/pokt-network/pocket/rpc""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/crypto""
+)
+
+func init() {
+	rootCmd.AddCommand(NewServicerCommand())
+}
+
+// TECHDEBT: (unittest) unit test the command: e.g. on number of arguments
+func NewServicerCommand() *cobra.Command {
+	cmd := &cobra.Command{
+		Use:     ""Servicer"",
+		Short:   ""Servicer specific commands"",
+		Aliases: []string{""servicer""},
+		Args:    cobra.ExactArgs(0),
+	}
+
+	cmds := servicerCommands()
+	applySubcommandOptions(cmds, attachPwdFlagToSubcommands())
+	applySubcommandOptions(cmds, attachKeybaseFlagsToSubcommands())
+
+	cmd.AddCommand(cmds...)
+
+	return cmd
+}
+
+func servicerCommands() []*cobra.Command {
+	cmdDef := actorCmdDef{""Servicer"", coreTypes.ActorType_ACTOR_TYPE_SERVICER}
+	cmds := []*cobra.Command{
+		newStakeCmd(cmdDef),
+		newEditStakeCmd(cmdDef),
+		newUnstakeCmd(cmdDef),
+		newUnpauseCmd(cmdDef),
+		{
+			Use:   ""Relay <servicer> <application> <relayChainID> <payload>"",
+			Short: ""Relay <servicer> <application> <relayChainID> <payload>"",
+			Long: `Sends a trustless relay using <payload> as contents, to the specified active <servicer> in the the <application>'s session.
+Will prompt the user for the *application* account passphrase`,
+			Aliases: []string{},
+			Args:    cobra.ExactArgs(4),
+			RunE: func(cmd *cobra.Command, args []string) error {
+				servicerAddr := args[0]
+				applicationAddr := args[1]
+				chain := args[2]
+				relayPayload := args[3]
+
+				// TODO: (SUGGESTION) refactor to decouple the client logic from the CLI/command
+				pk, err := getPrivateKey(applicationAddr)
+				if err != nil {
+					return fmt.Errorf(""error getting application's private key: %w"", err)
+				}
+
+				session, servicer, err := fetchServicer(cmd.Context(), applicationAddr, chain, servicerAddr)
+				if err != nil {
+					return fmt.Errorf(""error getting servicer for the relay: %w"", err)
+				}
+
+				relay, err := buildRelay(relayPayload, pk, session, servicer)
+				if err != nil {
+					return fmt.Errorf(""error building relay from payload: %w"", err)
+				}
+
+				fmt.Printf(""sending trustless relay for %s to %v with payload: %s\n"", applicationAddr, servicer, relayPayload)
+
+				resp, err := sendTrustlessRelay(cmd.Context(), servicer.ServiceUrl, relay)
+				if err != nil {
+					return err
+				}
+
+				fmt.Printf(""HTTP status code: %d\n"", resp.HTTPResponse.StatusCode)
+				fmt.Println(""Response: "", resp.JSON200)
+
+				return nil
+			},
+		},
+	}
+
+	return cmds
+}
+
+// TODO: (QUESTION): do we need/want a cli subcommand for fetching servicers?
+
+// fetchServicer returns the servicer specified by the <servicer> argument.
+// It validates the following conditions:
+//
+//	A. The <application> argument is the address of an active application
+//	B. The <servicer> is the address of a servicer that is active in the application's current session.
+//
+// TODO: (SUGGESTION) use a package-internal interface for servicer and application?
+// TODO: (SUGGESTION) use a struct as input to combine all fields (same for output)
+func fetchServicer(ctx context.Context, appAddress, chain, servicerAddress string) (rpc.Session, rpc.ProtocolActor, error) {
+	// TECHDEBT: cache session data
+	session, err := getCurrentSession(ctx, appAddress, chain)
+	if err != nil {
+		return rpc.Session{}, rpc.ProtocolActor{}, fmt.Errorf(""Error getting servicer: %w"", err)
+	}
+
+	var (
+		servicer rpc.ProtocolActor
+		found    bool
+	)
+	// TODO: a map may be a better choice for storing servicers
+	for _, s := range session.Servicers {
+		if s.Address == servicerAddress {
+			servicer = s
+			found = true
+			break
+		}
+	}
+
+	// TODO: cover with unit tests
+	if !found {
+		return rpc.Session{}, rpc.ProtocolActor{}, fmt.Errorf(""Error getting servicer: address %s does not match any servicers in the session"", servicerAddress)
+	}
+
+	// TODO: cover with unit tests
+	found = false
+	for _, ch := range servicer.Chains {
+		if ch == chain {
+			found = true
+			break
+		}
+	}
+
+	if !found {
+		return rpc.Session{}, rpc.ProtocolActor{}, fmt.Errorf(""Error getting servicer: service %s does not support chain %s"", servicerAddress, chain)
+	}
+
+	return *session, servicer, nil
+}
+
+func getCurrentSession(ctx context.Context, appAddress, chain string) (*rpc.Session, error) {
+	// TODO: passing 0 as the height value to get the current session seems more optimal than this.
+	currentHeight, err := getCurrentHeight(ctx)
+	if err != nil {
+		return nil, fmt.Errorf(""Error getting current session: %w"", err)
+	}
+
+	req := rpc.SessionRequest{
+		AppAddress: appAddress,
+		Chain:      chain,
+		// TODO: Geozone
+		SessionHeight: currentHeight,
+	}
+
+	client, err := rpc.NewClientWithResponses(remoteCLIURL)
+	if err != nil {
+		return nil, fmt.Errorf(""Error getting current session for app/chain/height: %s/%s/%d: %w"", appAddress, chain, currentHeight, err)
+	}
+
+	resp, err := client.PostV1ClientGetSessionWithResponse(ctx, req)
+	if err != nil {
+		return nil, fmt.Errorf(""Error getting current session with request %v: %w"", req, err)
+	}
+	// TODO: refactor boiler-plate code
+	if resp.HTTPResponse.StatusCode != http.StatusOK {
+		return nil, fmt.Errorf(""Error getting current session: Unexpected status code %d for request %v"", resp.HTTPResponse.StatusCode, req)
+	}
+
+	if resp.JSON200 == nil {
+		return nil, fmt.Errorf(""Error getting current session: Unexpected response %v"", resp)
+	}
+
+	return resp.JSON200, nil
+}
+
+// TODO: reuse this function in the query commands
+func getCurrentHeight(ctx context.Context) (int64, error) {
+	client, err := rpc.NewClientWithResponses(remoteCLIURL)
+	if err != nil {
+		return 0, fmt.Errorf(""Error getting current height: %w"", err)
+	}
+	resp, err := client.GetV1QueryHeightWithResponse(ctx)
+	if err != nil {
+		return 0, fmt.Errorf(""Error getting current height: %w"", err)
+	}
+	if resp.HTTPResponse.StatusCode != http.StatusOK {
+		return 0, fmt.Errorf(""Error getting current height: Unexpected status code %d"", resp.HTTPResponse.StatusCode)
+	}
+
+	if resp.JSON200 == nil {
+		return 0, fmt.Errorf(""Error getting current height: Unexpected response %v"", resp)
+	}
+
+	return resp.JSON200.Height, nil
+}
+
+// TODO: (localnet) Publish Servicer(s) Host and Port as env. vars in K8s: similar to Validators
+// TODO: (REFACTOR) should we move package-level variables (e.g. remoteCLIURL) to a cli object?
+func sendTrustlessRelay(ctx context.Context, servicerUrl string, relay rpc.RelayRequest) (*rpc.PostV1ClientRelayResponse, error) {
+	client, err := rpc.NewClientWithResponses(servicerUrl)
+	if err != nil {
+		return nil, err
+	}
+
+	return client.PostV1ClientRelayWithResponse(ctx, relay)
+}
+
+// TODO: (NICE) allow reading the relay request from the command line arguments AND from a file
+func buildRelay(payload string, appPrivateKey crypto.PrivateKey, session rpc.Session, servicer rpc.ProtocolActor) (rpc.RelayRequest, error) {
+	// TECHDEBT: This is mostly COPIED from pocket-go: we should refactor pocket-go code and import this functionality from there instead.
+	relayPayload := rpc.Payload{
+		Data:   payload,
+		Method: ""POST"",
+		// TODO: Path: load Path field from the corresponding Blockchain (e.g. database)
+		// TODO: set Headers
+	}
+
+	relayMeta := rpc.RelayRequestMeta{
+		BlockHeight: session.SessionHeight,
+		// TODO: use Identifiable for Chain in Session (or string for Chain in Relay Meta)
+		Chain: rpc.Identifiable{
+			Id: session.Chain,
+		},
+		ServicerPubKey: servicer.PublicKey,
+		// TODO: Geozone
+		// TODO: Token
+	}
+
+	relay := rpc.RelayRequest{
+		Payload: relayPayload,
+		Meta:    relayMeta,
+		// TODO: (QUESTION) why is there no Proof field in v1 struct?
+	}
+	reqBytes, err := json.Marshal(relay)
+	if err != nil {
+		return rpc.RelayRequest{}, fmt.Errorf(""Error marshalling relay request %v: %w"", relay, err)
+	}
+	hashedReq, err := hash(reqBytes)
+	if err != nil {
+		return rpc.RelayRequest{}, fmt.Errorf(""Error hashing relay request bytes %s: %w"", string(reqBytes), err)
+	}
+	signature, err := appPrivateKey.Sign(hashedReq)
+	if err != nil {
+		return relay, fmt.Errorf(""Error signing relay: %w"", err)
+	}
+	relay.Meta.Signature = hex.EncodeToString(signature)
+
+	return relay, nil
+}
+
+func hash(data []byte) ([]byte, error) {",app/client/cli/servicer.go,2023-05-25 20:58:07+00:00,2023-05-25T21:21:55Z,We have a helper in `shared/crypto/sha3.go` you might be able to use. Can you see if it can be leveraged?,,,,,255,RIGHT,255,,line,https://api.github.com/repos/pokt-network/pocket/pulls/778,pokt-network/pocket,a516c51f2d000d25f1469d28e6586ef7875d5a37
https://api.github.com/repos/pokt-network/pocket/pulls/778,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1205998554,Olshansk,b93c50312e4967daff683ac9fd577e4e5edc2a3b,acec260d9987f4dba2b31bdf4b65f2ef6b654725,"@@ -0,0 +1,284 @@
+package cli
+
+import (
+	""context""
+	sha ""crypto""
+	""encoding/hex""
+	""encoding/json""
+	""fmt""
+	""net/http""
+
+	""github.com/spf13/cobra""
+
+	""github.com/pokt-network/pocket/rpc""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/crypto""
+)
+
+func init() {
+	rootCmd.AddCommand(NewServicerCommand())
+}
+
+// TECHDEBT: (unittest) unit test the command: e.g. on number of arguments
+func NewServicerCommand() *cobra.Command {
+	cmd := &cobra.Command{
+		Use:     ""Servicer"",
+		Short:   ""Servicer specific commands"",
+		Aliases: []string{""servicer""},
+		Args:    cobra.ExactArgs(0),
+	}
+
+	cmds := servicerCommands()
+	applySubcommandOptions(cmds, attachPwdFlagToSubcommands())
+	applySubcommandOptions(cmds, attachKeybaseFlagsToSubcommands())
+
+	cmd.AddCommand(cmds...)
+
+	return cmd
+}
+
+func servicerCommands() []*cobra.Command {
+	cmdDef := actorCmdDef{""Servicer"", coreTypes.ActorType_ACTOR_TYPE_SERVICER}
+	cmds := []*cobra.Command{
+		newStakeCmd(cmdDef),
+		newEditStakeCmd(cmdDef),
+		newUnstakeCmd(cmdDef),
+		newUnpauseCmd(cmdDef),
+		{
+			Use:   ""Relay <servicer> <application> <relayChainID> <payload>"",
+			Short: ""Relay <servicer> <application> <relayChainID> <payload>"",
+			Long: `Sends a trustless relay using <payload> as contents, to the specified active <servicer> in the the <application>'s session.
+Will prompt the user for the *application* account passphrase`,
+			Aliases: []string{},
+			Args:    cobra.ExactArgs(4),
+			RunE: func(cmd *cobra.Command, args []string) error {
+				servicerAddr := args[0]
+				applicationAddr := args[1]
+				chain := args[2]
+				relayPayload := args[3]
+
+				// TODO: (SUGGESTION) refactor to decouple the client logic from the CLI/command
+				pk, err := getPrivateKey(applicationAddr)
+				if err != nil {
+					return fmt.Errorf(""error getting application's private key: %w"", err)
+				}
+
+				session, servicer, err := fetchServicer(cmd.Context(), applicationAddr, chain, servicerAddr)
+				if err != nil {
+					return fmt.Errorf(""error getting servicer for the relay: %w"", err)
+				}
+
+				relay, err := buildRelay(relayPayload, pk, session, servicer)
+				if err != nil {
+					return fmt.Errorf(""error building relay from payload: %w"", err)
+				}
+
+				fmt.Printf(""sending trustless relay for %s to %v with payload: %s\n"", applicationAddr, servicer, relayPayload)
+
+				resp, err := sendTrustlessRelay(cmd.Context(), servicer.ServiceUrl, relay)
+				if err != nil {
+					return err
+				}
+
+				fmt.Printf(""HTTP status code: %d\n"", resp.HTTPResponse.StatusCode)
+				fmt.Println(""Response: "", resp.JSON200)
+
+				return nil
+			},
+		},
+	}
+
+	return cmds
+}
+
+// TODO: (QUESTION): do we need/want a cli subcommand for fetching servicers?
+
+// fetchServicer returns the servicer specified by the <servicer> argument.
+// It validates the following conditions:
+//
+//	A. The <application> argument is the address of an active application
+//	B. The <servicer> is the address of a servicer that is active in the application's current session.
+//
+// TODO: (SUGGESTION) use a package-internal interface for servicer and application?
+// TODO: (SUGGESTION) use a struct as input to combine all fields (same for output)
+func fetchServicer(ctx context.Context, appAddress, chain, servicerAddress string) (rpc.Session, rpc.ProtocolActor, error) {
+	// TECHDEBT: cache session data
+	session, err := getCurrentSession(ctx, appAddress, chain)
+	if err != nil {
+		return rpc.Session{}, rpc.ProtocolActor{}, fmt.Errorf(""Error getting servicer: %w"", err)
+	}
+
+	var (
+		servicer rpc.ProtocolActor
+		found    bool
+	)
+	// TODO: a map may be a better choice for storing servicers
+	for _, s := range session.Servicers {
+		if s.Address == servicerAddress {
+			servicer = s
+			found = true
+			break
+		}
+	}
+
+	// TODO: cover with unit tests
+	if !found {
+		return rpc.Session{}, rpc.ProtocolActor{}, fmt.Errorf(""Error getting servicer: address %s does not match any servicers in the session"", servicerAddress)
+	}
+
+	// TODO: cover with unit tests
+	found = false
+	for _, ch := range servicer.Chains {
+		if ch == chain {
+			found = true
+			break
+		}
+	}
+
+	if !found {
+		return rpc.Session{}, rpc.ProtocolActor{}, fmt.Errorf(""Error getting servicer: service %s does not support chain %s"", servicerAddress, chain)
+	}
+
+	return *session, servicer, nil
+}
+
+func getCurrentSession(ctx context.Context, appAddress, chain string) (*rpc.Session, error) {
+	// TODO: passing 0 as the height value to get the current session seems more optimal than this.
+	currentHeight, err := getCurrentHeight(ctx)
+	if err != nil {
+		return nil, fmt.Errorf(""Error getting current session: %w"", err)
+	}
+
+	req := rpc.SessionRequest{
+		AppAddress: appAddress,
+		Chain:      chain,
+		// TODO: Geozone
+		SessionHeight: currentHeight,
+	}
+
+	client, err := rpc.NewClientWithResponses(remoteCLIURL)
+	if err != nil {
+		return nil, fmt.Errorf(""Error getting current session for app/chain/height: %s/%s/%d: %w"", appAddress, chain, currentHeight, err)
+	}
+
+	resp, err := client.PostV1ClientGetSessionWithResponse(ctx, req)
+	if err != nil {
+		return nil, fmt.Errorf(""Error getting current session with request %v: %w"", req, err)
+	}
+	// TODO: refactor boiler-plate code
+	if resp.HTTPResponse.StatusCode != http.StatusOK {
+		return nil, fmt.Errorf(""Error getting current session: Unexpected status code %d for request %v"", resp.HTTPResponse.StatusCode, req)
+	}
+
+	if resp.JSON200 == nil {
+		return nil, fmt.Errorf(""Error getting current session: Unexpected response %v"", resp)
+	}
+
+	return resp.JSON200, nil
+}
+
+// TODO: reuse this function in the query commands
+func getCurrentHeight(ctx context.Context) (int64, error) {
+	client, err := rpc.NewClientWithResponses(remoteCLIURL)
+	if err != nil {
+		return 0, fmt.Errorf(""Error getting current height: %w"", err)
+	}
+	resp, err := client.GetV1QueryHeightWithResponse(ctx)
+	if err != nil {
+		return 0, fmt.Errorf(""Error getting current height: %w"", err)
+	}
+	if resp.HTTPResponse.StatusCode != http.StatusOK {
+		return 0, fmt.Errorf(""Error getting current height: Unexpected status code %d"", resp.HTTPResponse.StatusCode)
+	}
+
+	if resp.JSON200 == nil {
+		return 0, fmt.Errorf(""Error getting current height: Unexpected response %v"", resp)
+	}
+
+	return resp.JSON200.Height, nil
+}
+
+// TODO: (localnet) Publish Servicer(s) Host and Port as env. vars in K8s: similar to Validators
+// TODO: (REFACTOR) should we move package-level variables (e.g. remoteCLIURL) to a cli object?
+func sendTrustlessRelay(ctx context.Context, servicerUrl string, relay rpc.RelayRequest) (*rpc.PostV1ClientRelayResponse, error) {
+	client, err := rpc.NewClientWithResponses(servicerUrl)
+	if err != nil {
+		return nil, err
+	}
+
+	return client.PostV1ClientRelayWithResponse(ctx, relay)
+}
+
+// TODO: (NICE) allow reading the relay request from the command line arguments AND from a file
+func buildRelay(payload string, appPrivateKey crypto.PrivateKey, session rpc.Session, servicer rpc.ProtocolActor) (rpc.RelayRequest, error) {
+	// TECHDEBT: This is mostly COPIED from pocket-go: we should refactor pocket-go code and import this functionality from there instead.
+	relayPayload := rpc.Payload{
+		Data:   payload,
+		Method: ""POST"",
+		// TODO: Path: load Path field from the corresponding Blockchain (e.g. database)
+		// TODO: set Headers
+	}
+
+	relayMeta := rpc.RelayRequestMeta{
+		BlockHeight: session.SessionHeight,
+		// TODO: use Identifiable for Chain in Session (or string for Chain in Relay Meta)
+		Chain: rpc.Identifiable{
+			Id: session.Chain,
+		},
+		ServicerPubKey: servicer.PublicKey,
+		// TODO: Geozone
+		// TODO: Token
+	}
+
+	relay := rpc.RelayRequest{
+		Payload: relayPayload,
+		Meta:    relayMeta,
+		// TODO: (QUESTION) why is there no Proof field in v1 struct?
+	}
+	reqBytes, err := json.Marshal(relay)
+	if err != nil {
+		return rpc.RelayRequest{}, fmt.Errorf(""Error marshalling relay request %v: %w"", relay, err)
+	}
+	hashedReq, err := hash(reqBytes)
+	if err != nil {
+		return rpc.RelayRequest{}, fmt.Errorf(""Error hashing relay request bytes %s: %w"", string(reqBytes), err)
+	}
+	signature, err := appPrivateKey.Sign(hashedReq)
+	if err != nil {
+		return relay, fmt.Errorf(""Error signing relay: %w"", err)
+	}
+	relay.Meta.Signature = hex.EncodeToString(signature)
+
+	return relay, nil
+}
+
+func hash(data []byte) ([]byte, error) {
+	hasher := sha.SHA3_256.New()
+	if _, err := hasher.Write(data); err != nil {
+		return nil, fmt.Errorf(""Error hashing data: %w"", err)
+	}
+
+	return hasher.Sum(nil), nil
+}
+
+// TODO: remove use of package-level variables",app/client/cli/servicer.go,2023-05-25 20:59:46+00:00,2023-05-25T21:21:56Z,"```suggestion
// TECHDEBT: remove use of package-level variables
```

In the `Makefile`, we have a lot of different keywords you can use. Feel free to add more

![Screenshot 2023-05-25 at 1 59 17 PM](https://github.com/pokt-network/pocket/assets/1892194/832c8271-05fa-4d6b-9090-6023112505eb)
",,,,,264,RIGHT,264,,line,https://api.github.com/repos/pokt-network/pocket/pulls/778,pokt-network/pocket,a516c51f2d000d25f1469d28e6586ef7875d5a37
https://api.github.com/repos/pokt-network/pocket/pulls/778,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1205999181,Olshansk,b93c50312e4967daff683ac9fd577e4e5edc2a3b,acec260d9987f4dba2b31bdf4b65f2ef6b654725,"@@ -0,0 +1,284 @@
+package cli
+
+import (
+	""context""
+	sha ""crypto""
+	""encoding/hex""
+	""encoding/json""
+	""fmt""
+	""net/http""
+
+	""github.com/spf13/cobra""
+
+	""github.com/pokt-network/pocket/rpc""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/crypto""
+)
+
+func init() {
+	rootCmd.AddCommand(NewServicerCommand())
+}
+
+// TECHDEBT: (unittest) unit test the command: e.g. on number of arguments
+func NewServicerCommand() *cobra.Command {
+	cmd := &cobra.Command{
+		Use:     ""Servicer"",
+		Short:   ""Servicer specific commands"",
+		Aliases: []string{""servicer""},
+		Args:    cobra.ExactArgs(0),
+	}
+
+	cmds := servicerCommands()
+	applySubcommandOptions(cmds, attachPwdFlagToSubcommands())
+	applySubcommandOptions(cmds, attachKeybaseFlagsToSubcommands())
+
+	cmd.AddCommand(cmds...)
+
+	return cmd
+}
+
+func servicerCommands() []*cobra.Command {
+	cmdDef := actorCmdDef{""Servicer"", coreTypes.ActorType_ACTOR_TYPE_SERVICER}
+	cmds := []*cobra.Command{
+		newStakeCmd(cmdDef),
+		newEditStakeCmd(cmdDef),
+		newUnstakeCmd(cmdDef),
+		newUnpauseCmd(cmdDef),
+		{",app/client/cli/servicer.go,2023-05-25 21:00:39+00:00,2023-05-25T21:21:56Z,"Can you either implement or add a TODO to accept a payload from a file via `[--input_file]`. For example, see `cli/keys.go`.",,,,46.0,47,RIGHT,47,46.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/778,pokt-network/pocket,a516c51f2d000d25f1469d28e6586ef7875d5a37
https://api.github.com/repos/pokt-network/pocket/pulls/778,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1205999529,Olshansk,b93c50312e4967daff683ac9fd577e4e5edc2a3b,acec260d9987f4dba2b31bdf4b65f2ef6b654725,"@@ -0,0 +1,284 @@
+package cli
+
+import (
+	""context""
+	sha ""crypto""
+	""encoding/hex""
+	""encoding/json""
+	""fmt""
+	""net/http""
+
+	""github.com/spf13/cobra""
+
+	""github.com/pokt-network/pocket/rpc""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/crypto""
+)
+
+func init() {
+	rootCmd.AddCommand(NewServicerCommand())
+}
+
+// TECHDEBT: (unittest) unit test the command: e.g. on number of arguments
+func NewServicerCommand() *cobra.Command {
+	cmd := &cobra.Command{
+		Use:     ""Servicer"",
+		Short:   ""Servicer specific commands"",
+		Aliases: []string{""servicer""},
+		Args:    cobra.ExactArgs(0),
+	}
+
+	cmds := servicerCommands()
+	applySubcommandOptions(cmds, attachPwdFlagToSubcommands())
+	applySubcommandOptions(cmds, attachKeybaseFlagsToSubcommands())
+
+	cmd.AddCommand(cmds...)
+
+	return cmd
+}
+
+func servicerCommands() []*cobra.Command {
+	cmdDef := actorCmdDef{""Servicer"", coreTypes.ActorType_ACTOR_TYPE_SERVICER}
+	cmds := []*cobra.Command{
+		newStakeCmd(cmdDef),
+		newEditStakeCmd(cmdDef),
+		newUnstakeCmd(cmdDef),
+		newUnpauseCmd(cmdDef),
+		{
+			Use:   ""Relay <servicer> <application> <relayChainID> <payload>"",",app/client/cli/servicer.go,2023-05-25 21:01:05+00:00,2023-05-25T21:21:56Z,"`s/payload/payloadSerializedProto`?

Please rename `payload` so its self explanatory on what we expect",,,,,48,RIGHT,48,,line,https://api.github.com/repos/pokt-network/pocket/pulls/778,pokt-network/pocket,a516c51f2d000d25f1469d28e6586ef7875d5a37
https://api.github.com/repos/pokt-network/pocket/pulls/778,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1206000238,Olshansk,b93c50312e4967daff683ac9fd577e4e5edc2a3b,acec260d9987f4dba2b31bdf4b65f2ef6b654725,"@@ -0,0 +1,284 @@
+package cli
+
+import (
+	""context""
+	sha ""crypto""
+	""encoding/hex""
+	""encoding/json""
+	""fmt""
+	""net/http""
+
+	""github.com/spf13/cobra""
+
+	""github.com/pokt-network/pocket/rpc""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/crypto""
+)
+
+func init() {
+	rootCmd.AddCommand(NewServicerCommand())
+}
+
+// TECHDEBT: (unittest) unit test the command: e.g. on number of arguments
+func NewServicerCommand() *cobra.Command {
+	cmd := &cobra.Command{
+		Use:     ""Servicer"",
+		Short:   ""Servicer specific commands"",
+		Aliases: []string{""servicer""},
+		Args:    cobra.ExactArgs(0),
+	}
+
+	cmds := servicerCommands()
+	applySubcommandOptions(cmds, attachPwdFlagToSubcommands())
+	applySubcommandOptions(cmds, attachKeybaseFlagsToSubcommands())
+
+	cmd.AddCommand(cmds...)
+
+	return cmd
+}
+
+func servicerCommands() []*cobra.Command {
+	cmdDef := actorCmdDef{""Servicer"", coreTypes.ActorType_ACTOR_TYPE_SERVICER}
+	cmds := []*cobra.Command{
+		newStakeCmd(cmdDef),
+		newEditStakeCmd(cmdDef),
+		newUnstakeCmd(cmdDef),
+		newUnpauseCmd(cmdDef),
+		{
+			Use:   ""Relay <servicer> <application> <relayChainID> <payload>"",
+			Short: ""Relay <servicer> <application> <relayChainID> <payload>"",
+			Long: `Sends a trustless relay using <payload> as contents, to the specified active <servicer> in the the <application>'s session.
+Will prompt the user for the *application* account passphrase`,
+			Aliases: []string{},
+			Args:    cobra.ExactArgs(4),
+			RunE: func(cmd *cobra.Command, args []string) error {
+				servicerAddr := args[0]
+				applicationAddr := args[1]
+				chain := args[2]
+				relayPayload := args[3]
+
+				// TODO: (SUGGESTION) refactor to decouple the client logic from the CLI/command
+				pk, err := getPrivateKey(applicationAddr)
+				if err != nil {
+					return fmt.Errorf(""error getting application's private key: %w"", err)
+				}
+
+				session, servicer, err := fetchServicer(cmd.Context(), applicationAddr, chain, servicerAddr)
+				if err != nil {
+					return fmt.Errorf(""error getting servicer for the relay: %w"", err)
+				}
+
+				relay, err := buildRelay(relayPayload, pk, session, servicer)
+				if err != nil {
+					return fmt.Errorf(""error building relay from payload: %w"", err)
+				}
+
+				fmt.Printf(""sending trustless relay for %s to %v with payload: %s\n"", applicationAddr, servicer, relayPayload)
+
+				resp, err := sendTrustlessRelay(cmd.Context(), servicer.ServiceUrl, relay)
+				if err != nil {
+					return err
+				}
+
+				fmt.Printf(""HTTP status code: %d\n"", resp.HTTPResponse.StatusCode)
+				fmt.Println(""Response: "", resp.JSON200)
+
+				return nil
+			},
+		},
+	}
+
+	return cmds
+}
+
+// TODO: (QUESTION): do we need/want a cli subcommand for fetching servicers?
+
+// fetchServicer returns the servicer specified by the <servicer> argument.
+// It validates the following conditions:
+//
+//	A. The <application> argument is the address of an active application
+//	B. The <servicer> is the address of a servicer that is active in the application's current session.
+//
+// TODO: (SUGGESTION) use a package-internal interface for servicer and application?
+// TODO: (SUGGESTION) use a struct as input to combine all fields (same for output)
+func fetchServicer(ctx context.Context, appAddress, chain, servicerAddress string) (rpc.Session, rpc.ProtocolActor, error) {
+	// TECHDEBT: cache session data
+	session, err := getCurrentSession(ctx, appAddress, chain)
+	if err != nil {
+		return rpc.Session{}, rpc.ProtocolActor{}, fmt.Errorf(""Error getting servicer: %w"", err)
+	}
+
+	var (
+		servicer rpc.ProtocolActor
+		found    bool
+	)
+	// TODO: a map may be a better choice for storing servicers
+	for _, s := range session.Servicers {
+		if s.Address == servicerAddress {
+			servicer = s
+			found = true
+			break
+		}
+	}
+
+	// TODO: cover with unit tests
+	if !found {
+		return rpc.Session{}, rpc.ProtocolActor{}, fmt.Errorf(""Error getting servicer: address %s does not match any servicers in the session"", servicerAddress)
+	}
+
+	// TODO: cover with unit tests
+	found = false
+	for _, ch := range servicer.Chains {
+		if ch == chain {
+			found = true
+			break
+		}
+	}
+
+	if !found {
+		return rpc.Session{}, rpc.ProtocolActor{}, fmt.Errorf(""Error getting servicer: service %s does not support chain %s"", servicerAddress, chain)
+	}
+
+	return *session, servicer, nil
+}
+
+func getCurrentSession(ctx context.Context, appAddress, chain string) (*rpc.Session, error) {
+	// TODO: passing 0 as the height value to get the current session seems more optimal than this.
+	currentHeight, err := getCurrentHeight(ctx)
+	if err != nil {
+		return nil, fmt.Errorf(""Error getting current session: %w"", err)
+	}
+
+	req := rpc.SessionRequest{
+		AppAddress: appAddress,
+		Chain:      chain,
+		// TODO: Geozone
+		SessionHeight: currentHeight,
+	}
+
+	client, err := rpc.NewClientWithResponses(remoteCLIURL)
+	if err != nil {
+		return nil, fmt.Errorf(""Error getting current session for app/chain/height: %s/%s/%d: %w"", appAddress, chain, currentHeight, err)
+	}
+
+	resp, err := client.PostV1ClientGetSessionWithResponse(ctx, req)
+	if err != nil {
+		return nil, fmt.Errorf(""Error getting current session with request %v: %w"", req, err)
+	}
+	// TODO: refactor boiler-plate code
+	if resp.HTTPResponse.StatusCode != http.StatusOK {
+		return nil, fmt.Errorf(""Error getting current session: Unexpected status code %d for request %v"", resp.HTTPResponse.StatusCode, req)
+	}
+
+	if resp.JSON200 == nil {
+		return nil, fmt.Errorf(""Error getting current session: Unexpected response %v"", resp)
+	}
+
+	return resp.JSON200, nil
+}
+
+// TODO: reuse this function in the query commands
+func getCurrentHeight(ctx context.Context) (int64, error) {
+	client, err := rpc.NewClientWithResponses(remoteCLIURL)
+	if err != nil {
+		return 0, fmt.Errorf(""Error getting current height: %w"", err)
+	}
+	resp, err := client.GetV1QueryHeightWithResponse(ctx)
+	if err != nil {
+		return 0, fmt.Errorf(""Error getting current height: %w"", err)
+	}
+	if resp.HTTPResponse.StatusCode != http.StatusOK {
+		return 0, fmt.Errorf(""Error getting current height: Unexpected status code %d"", resp.HTTPResponse.StatusCode)
+	}
+
+	if resp.JSON200 == nil {
+		return 0, fmt.Errorf(""Error getting current height: Unexpected response %v"", resp)
+	}
+
+	return resp.JSON200.Height, nil
+}
+
+// TODO: (localnet) Publish Servicer(s) Host and Port as env. vars in K8s: similar to Validators
+// TODO: (REFACTOR) should we move package-level variables (e.g. remoteCLIURL) to a cli object?
+func sendTrustlessRelay(ctx context.Context, servicerUrl string, relay rpc.RelayRequest) (*rpc.PostV1ClientRelayResponse, error) {
+	client, err := rpc.NewClientWithResponses(servicerUrl)
+	if err != nil {
+		return nil, err
+	}
+
+	return client.PostV1ClientRelayWithResponse(ctx, relay)
+}
+
+// TODO: (NICE) allow reading the relay request from the command line arguments AND from a file
+func buildRelay(payload string, appPrivateKey crypto.PrivateKey, session rpc.Session, servicer rpc.ProtocolActor) (rpc.RelayRequest, error) {
+	// TECHDEBT: This is mostly COPIED from pocket-go: we should refactor pocket-go code and import this functionality from there instead.
+	relayPayload := rpc.Payload{
+		Data:   payload,
+		Method: ""POST"",
+		// TODO: Path: load Path field from the corresponding Blockchain (e.g. database)
+		// TODO: set Headers
+	}
+
+	relayMeta := rpc.RelayRequestMeta{
+		BlockHeight: session.SessionHeight,
+		// TODO: use Identifiable for Chain in Session (or string for Chain in Relay Meta)
+		Chain: rpc.Identifiable{
+			Id: session.Chain,
+		},
+		ServicerPubKey: servicer.PublicKey,
+		// TODO: Geozone
+		// TODO: Token
+	}
+
+	relay := rpc.RelayRequest{
+		Payload: relayPayload,
+		Meta:    relayMeta,
+		// TODO: (QUESTION) why is there no Proof field in v1 struct?
+	}
+	reqBytes, err := json.Marshal(relay)
+	if err != nil {
+		return rpc.RelayRequest{}, fmt.Errorf(""Error marshalling relay request %v: %w"", relay, err)
+	}
+	hashedReq, err := hash(reqBytes)
+	if err != nil {
+		return rpc.RelayRequest{}, fmt.Errorf(""Error hashing relay request bytes %s: %w"", string(reqBytes), err)
+	}
+	signature, err := appPrivateKey.Sign(hashedReq)
+	if err != nil {
+		return relay, fmt.Errorf(""Error signing relay: %w"", err)
+	}
+	relay.Meta.Signature = hex.EncodeToString(signature)
+
+	return relay, nil
+}
+
+func hash(data []byte) ([]byte, error) {
+	hasher := sha.SHA3_256.New()
+	if _, err := hasher.Write(data); err != nil {
+		return nil, fmt.Errorf(""Error hashing data: %w"", err)
+	}
+
+	return hasher.Sum(nil), nil
+}
+
+// TODO: remove use of package-level variables
+func getPrivateKey(address string) (crypto.PrivateKey, error) {",app/client/cli/servicer.go,2023-05-25 21:01:56+00:00,2023-05-25T21:21:56Z,s/getPrivateKey/getPrivateKeyFromKeybase,,,,,265,RIGHT,265,,line,https://api.github.com/repos/pokt-network/pocket/pulls/778,pokt-network/pocket,a516c51f2d000d25f1469d28e6586ef7875d5a37
https://api.github.com/repos/pokt-network/pocket/pulls/778,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1206000988,Olshansk,b93c50312e4967daff683ac9fd577e4e5edc2a3b,acec260d9987f4dba2b31bdf4b65f2ef6b654725,"@@ -0,0 +1,284 @@
+package cli
+
+import (
+	""context""
+	sha ""crypto""
+	""encoding/hex""
+	""encoding/json""
+	""fmt""
+	""net/http""
+
+	""github.com/spf13/cobra""
+
+	""github.com/pokt-network/pocket/rpc""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/crypto""
+)
+
+func init() {
+	rootCmd.AddCommand(NewServicerCommand())
+}
+
+// TECHDEBT: (unittest) unit test the command: e.g. on number of arguments
+func NewServicerCommand() *cobra.Command {
+	cmd := &cobra.Command{
+		Use:     ""Servicer"",
+		Short:   ""Servicer specific commands"",
+		Aliases: []string{""servicer""},
+		Args:    cobra.ExactArgs(0),
+	}
+
+	cmds := servicerCommands()
+	applySubcommandOptions(cmds, attachPwdFlagToSubcommands())
+	applySubcommandOptions(cmds, attachKeybaseFlagsToSubcommands())
+
+	cmd.AddCommand(cmds...)
+
+	return cmd
+}
+
+func servicerCommands() []*cobra.Command {
+	cmdDef := actorCmdDef{""Servicer"", coreTypes.ActorType_ACTOR_TYPE_SERVICER}
+	cmds := []*cobra.Command{
+		newStakeCmd(cmdDef),
+		newEditStakeCmd(cmdDef),
+		newUnstakeCmd(cmdDef),
+		newUnpauseCmd(cmdDef),
+		{
+			Use:   ""Relay <servicer> <application> <relayChainID> <payload>"",
+			Short: ""Relay <servicer> <application> <relayChainID> <payload>"",
+			Long: `Sends a trustless relay using <payload> as contents, to the specified active <servicer> in the the <application>'s session.
+Will prompt the user for the *application* account passphrase`,
+			Aliases: []string{},
+			Args:    cobra.ExactArgs(4),
+			RunE: func(cmd *cobra.Command, args []string) error {
+				servicerAddr := args[0]
+				applicationAddr := args[1]
+				chain := args[2]
+				relayPayload := args[3]
+
+				// TODO: (SUGGESTION) refactor to decouple the client logic from the CLI/command",app/client/cli/servicer.go,2023-05-25 21:02:58+00:00,2023-05-25T21:21:56Z,"Can you update the comment so its clearer what part is the client and what's in the CLI. In general, I support the sentiment but don't have an understanding of the suggested changes.",,,,,60,RIGHT,60,,line,https://api.github.com/repos/pokt-network/pocket/pulls/778,pokt-network/pocket,a516c51f2d000d25f1469d28e6586ef7875d5a37
https://api.github.com/repos/pokt-network/pocket/pulls/778,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1206002472,Olshansk,b93c50312e4967daff683ac9fd577e4e5edc2a3b,acec260d9987f4dba2b31bdf4b65f2ef6b654725,"@@ -0,0 +1,284 @@
+package cli
+
+import (
+	""context""
+	sha ""crypto""
+	""encoding/hex""
+	""encoding/json""
+	""fmt""
+	""net/http""
+
+	""github.com/spf13/cobra""
+
+	""github.com/pokt-network/pocket/rpc""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/crypto""
+)
+
+func init() {
+	rootCmd.AddCommand(NewServicerCommand())
+}
+
+// TECHDEBT: (unittest) unit test the command: e.g. on number of arguments
+func NewServicerCommand() *cobra.Command {
+	cmd := &cobra.Command{
+		Use:     ""Servicer"",
+		Short:   ""Servicer specific commands"",
+		Aliases: []string{""servicer""},
+		Args:    cobra.ExactArgs(0),
+	}
+
+	cmds := servicerCommands()
+	applySubcommandOptions(cmds, attachPwdFlagToSubcommands())
+	applySubcommandOptions(cmds, attachKeybaseFlagsToSubcommands())
+
+	cmd.AddCommand(cmds...)
+
+	return cmd
+}
+
+func servicerCommands() []*cobra.Command {
+	cmdDef := actorCmdDef{""Servicer"", coreTypes.ActorType_ACTOR_TYPE_SERVICER}
+	cmds := []*cobra.Command{
+		newStakeCmd(cmdDef),
+		newEditStakeCmd(cmdDef),
+		newUnstakeCmd(cmdDef),
+		newUnpauseCmd(cmdDef),
+		{
+			Use:   ""Relay <servicer> <application> <relayChainID> <payload>"",
+			Short: ""Relay <servicer> <application> <relayChainID> <payload>"",
+			Long: `Sends a trustless relay using <payload> as contents, to the specified active <servicer> in the the <application>'s session.
+Will prompt the user for the *application* account passphrase`,
+			Aliases: []string{},
+			Args:    cobra.ExactArgs(4),
+			RunE: func(cmd *cobra.Command, args []string) error {
+				servicerAddr := args[0]
+				applicationAddr := args[1]
+				chain := args[2]
+				relayPayload := args[3]
+
+				// TODO: (SUGGESTION) refactor to decouple the client logic from the CLI/command
+				pk, err := getPrivateKey(applicationAddr)
+				if err != nil {
+					return fmt.Errorf(""error getting application's private key: %w"", err)
+				}
+
+				session, servicer, err := fetchServicer(cmd.Context(), applicationAddr, chain, servicerAddr)
+				if err != nil {
+					return fmt.Errorf(""error getting servicer for the relay: %w"", err)
+				}
+
+				relay, err := buildRelay(relayPayload, pk, session, servicer)
+				if err != nil {
+					return fmt.Errorf(""error building relay from payload: %w"", err)
+				}
+
+				fmt.Printf(""sending trustless relay for %s to %v with payload: %s\n"", applicationAddr, servicer, relayPayload)
+
+				resp, err := sendTrustlessRelay(cmd.Context(), servicer.ServiceUrl, relay)
+				if err != nil {
+					return err
+				}
+
+				fmt.Printf(""HTTP status code: %d\n"", resp.HTTPResponse.StatusCode)
+				fmt.Println(""Response: "", resp.JSON200)
+
+				return nil
+			},
+		},
+	}
+
+	return cmds
+}
+
+// TODO: (QUESTION): do we need/want a cli subcommand for fetching servicers?
+
+// fetchServicer returns the servicer specified by the <servicer> argument.
+// It validates the following conditions:
+//
+//	A. The <application> argument is the address of an active application
+//	B. The <servicer> is the address of a servicer that is active in the application's current session.
+//
+// TODO: (SUGGESTION) use a package-internal interface for servicer and application?
+// TODO: (SUGGESTION) use a struct as input to combine all fields (same for output)
+func fetchServicer(ctx context.Context, appAddress, chain, servicerAddress string) (rpc.Session, rpc.ProtocolActor, error) {",app/client/cli/servicer.go,2023-05-25 21:05:02+00:00,2023-05-25T21:21:56Z,Why not return `*rpc.Session` so we can return `nil` if there's an error?,,,,,104,RIGHT,104,,line,https://api.github.com/repos/pokt-network/pocket/pulls/778,pokt-network/pocket,a516c51f2d000d25f1469d28e6586ef7875d5a37
https://api.github.com/repos/pokt-network/pocket/pulls/778,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1206003316,Olshansk,b93c50312e4967daff683ac9fd577e4e5edc2a3b,acec260d9987f4dba2b31bdf4b65f2ef6b654725,"@@ -0,0 +1,284 @@
+package cli
+
+import (
+	""context""
+	sha ""crypto""
+	""encoding/hex""
+	""encoding/json""
+	""fmt""
+	""net/http""
+
+	""github.com/spf13/cobra""
+
+	""github.com/pokt-network/pocket/rpc""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/crypto""
+)
+
+func init() {
+	rootCmd.AddCommand(NewServicerCommand())
+}
+
+// TECHDEBT: (unittest) unit test the command: e.g. on number of arguments
+func NewServicerCommand() *cobra.Command {
+	cmd := &cobra.Command{
+		Use:     ""Servicer"",
+		Short:   ""Servicer specific commands"",
+		Aliases: []string{""servicer""},
+		Args:    cobra.ExactArgs(0),
+	}
+
+	cmds := servicerCommands()
+	applySubcommandOptions(cmds, attachPwdFlagToSubcommands())
+	applySubcommandOptions(cmds, attachKeybaseFlagsToSubcommands())
+
+	cmd.AddCommand(cmds...)
+
+	return cmd
+}
+
+func servicerCommands() []*cobra.Command {
+	cmdDef := actorCmdDef{""Servicer"", coreTypes.ActorType_ACTOR_TYPE_SERVICER}
+	cmds := []*cobra.Command{
+		newStakeCmd(cmdDef),
+		newEditStakeCmd(cmdDef),
+		newUnstakeCmd(cmdDef),
+		newUnpauseCmd(cmdDef),
+		{
+			Use:   ""Relay <servicer> <application> <relayChainID> <payload>"",
+			Short: ""Relay <servicer> <application> <relayChainID> <payload>"",
+			Long: `Sends a trustless relay using <payload> as contents, to the specified active <servicer> in the the <application>'s session.
+Will prompt the user for the *application* account passphrase`,
+			Aliases: []string{},
+			Args:    cobra.ExactArgs(4),
+			RunE: func(cmd *cobra.Command, args []string) error {
+				servicerAddr := args[0]
+				applicationAddr := args[1]
+				chain := args[2]
+				relayPayload := args[3]
+
+				// TODO: (SUGGESTION) refactor to decouple the client logic from the CLI/command
+				pk, err := getPrivateKey(applicationAddr)
+				if err != nil {
+					return fmt.Errorf(""error getting application's private key: %w"", err)
+				}
+
+				session, servicer, err := fetchServicer(cmd.Context(), applicationAddr, chain, servicerAddr)
+				if err != nil {
+					return fmt.Errorf(""error getting servicer for the relay: %w"", err)
+				}
+
+				relay, err := buildRelay(relayPayload, pk, session, servicer)
+				if err != nil {
+					return fmt.Errorf(""error building relay from payload: %w"", err)
+				}
+
+				fmt.Printf(""sending trustless relay for %s to %v with payload: %s\n"", applicationAddr, servicer, relayPayload)
+
+				resp, err := sendTrustlessRelay(cmd.Context(), servicer.ServiceUrl, relay)
+				if err != nil {
+					return err
+				}
+
+				fmt.Printf(""HTTP status code: %d\n"", resp.HTTPResponse.StatusCode)
+				fmt.Println(""Response: "", resp.JSON200)
+
+				return nil
+			},
+		},
+	}
+
+	return cmds
+}
+
+// TODO: (QUESTION): do we need/want a cli subcommand for fetching servicers?
+
+// fetchServicer returns the servicer specified by the <servicer> argument.
+// It validates the following conditions:
+//
+//	A. The <application> argument is the address of an active application
+//	B. The <servicer> is the address of a servicer that is active in the application's current session.
+//
+// TODO: (SUGGESTION) use a package-internal interface for servicer and application?
+// TODO: (SUGGESTION) use a struct as input to combine all fields (same for output)
+func fetchServicer(ctx context.Context, appAddress, chain, servicerAddress string) (rpc.Session, rpc.ProtocolActor, error) {
+	// TECHDEBT: cache session data
+	session, err := getCurrentSession(ctx, appAddress, chain)
+	if err != nil {
+		return rpc.Session{}, rpc.ProtocolActor{}, fmt.Errorf(""Error getting servicer: %w"", err)
+	}
+
+	var (
+		servicer rpc.ProtocolActor
+		found    bool
+	)
+	// TODO: a map may be a better choice for storing servicers",app/client/cli/servicer.go,2023-05-25 21:06:16+00:00,2023-05-25T21:21:56Z,Can you move this TODO next to the appropriate field in `session.proto`?,,,,,115,RIGHT,115,,line,https://api.github.com/repos/pokt-network/pocket/pulls/778,pokt-network/pocket,a516c51f2d000d25f1469d28e6586ef7875d5a37
https://api.github.com/repos/pokt-network/pocket/pulls/778,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1206003615,Olshansk,b93c50312e4967daff683ac9fd577e4e5edc2a3b,acec260d9987f4dba2b31bdf4b65f2ef6b654725,"@@ -0,0 +1,284 @@
+package cli
+
+import (
+	""context""
+	sha ""crypto""
+	""encoding/hex""
+	""encoding/json""
+	""fmt""
+	""net/http""
+
+	""github.com/spf13/cobra""
+
+	""github.com/pokt-network/pocket/rpc""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/crypto""
+)
+
+func init() {
+	rootCmd.AddCommand(NewServicerCommand())
+}
+
+// TECHDEBT: (unittest) unit test the command: e.g. on number of arguments
+func NewServicerCommand() *cobra.Command {
+	cmd := &cobra.Command{
+		Use:     ""Servicer"",
+		Short:   ""Servicer specific commands"",
+		Aliases: []string{""servicer""},
+		Args:    cobra.ExactArgs(0),
+	}
+
+	cmds := servicerCommands()
+	applySubcommandOptions(cmds, attachPwdFlagToSubcommands())
+	applySubcommandOptions(cmds, attachKeybaseFlagsToSubcommands())
+
+	cmd.AddCommand(cmds...)
+
+	return cmd
+}
+
+func servicerCommands() []*cobra.Command {
+	cmdDef := actorCmdDef{""Servicer"", coreTypes.ActorType_ACTOR_TYPE_SERVICER}
+	cmds := []*cobra.Command{
+		newStakeCmd(cmdDef),
+		newEditStakeCmd(cmdDef),
+		newUnstakeCmd(cmdDef),
+		newUnpauseCmd(cmdDef),
+		{
+			Use:   ""Relay <servicer> <application> <relayChainID> <payload>"",
+			Short: ""Relay <servicer> <application> <relayChainID> <payload>"",
+			Long: `Sends a trustless relay using <payload> as contents, to the specified active <servicer> in the the <application>'s session.
+Will prompt the user for the *application* account passphrase`,
+			Aliases: []string{},
+			Args:    cobra.ExactArgs(4),
+			RunE: func(cmd *cobra.Command, args []string) error {
+				servicerAddr := args[0]
+				applicationAddr := args[1]
+				chain := args[2]
+				relayPayload := args[3]
+
+				// TODO: (SUGGESTION) refactor to decouple the client logic from the CLI/command
+				pk, err := getPrivateKey(applicationAddr)
+				if err != nil {
+					return fmt.Errorf(""error getting application's private key: %w"", err)
+				}
+
+				session, servicer, err := fetchServicer(cmd.Context(), applicationAddr, chain, servicerAddr)
+				if err != nil {
+					return fmt.Errorf(""error getting servicer for the relay: %w"", err)
+				}
+
+				relay, err := buildRelay(relayPayload, pk, session, servicer)
+				if err != nil {
+					return fmt.Errorf(""error building relay from payload: %w"", err)
+				}
+
+				fmt.Printf(""sending trustless relay for %s to %v with payload: %s\n"", applicationAddr, servicer, relayPayload)
+
+				resp, err := sendTrustlessRelay(cmd.Context(), servicer.ServiceUrl, relay)
+				if err != nil {
+					return err
+				}
+
+				fmt.Printf(""HTTP status code: %d\n"", resp.HTTPResponse.StatusCode)
+				fmt.Println(""Response: "", resp.JSON200)
+
+				return nil
+			},
+		},
+	}
+
+	return cmds
+}
+
+// TODO: (QUESTION): do we need/want a cli subcommand for fetching servicers?
+
+// fetchServicer returns the servicer specified by the <servicer> argument.
+// It validates the following conditions:
+//
+//	A. The <application> argument is the address of an active application
+//	B. The <servicer> is the address of a servicer that is active in the application's current session.
+//
+// TODO: (SUGGESTION) use a package-internal interface for servicer and application?
+// TODO: (SUGGESTION) use a struct as input to combine all fields (same for output)
+func fetchServicer(ctx context.Context, appAddress, chain, servicerAddress string) (rpc.Session, rpc.ProtocolActor, error) {
+	// TECHDEBT: cache session data
+	session, err := getCurrentSession(ctx, appAddress, chain)
+	if err != nil {
+		return rpc.Session{}, rpc.ProtocolActor{}, fmt.Errorf(""Error getting servicer: %w"", err)
+	}
+
+	var (
+		servicer rpc.ProtocolActor
+		found    bool
+	)
+	// TODO: a map may be a better choice for storing servicers
+	for _, s := range session.Servicers {
+		if s.Address == servicerAddress {
+			servicer = s
+			found = true
+			break
+		}
+	}
+
+	// TODO: cover with unit tests",app/client/cli/servicer.go,2023-05-25 21:06:42+00:00,2023-05-25T21:21:56Z,s/unit tests/gherkin tests,,,,,124,RIGHT,124,,line,https://api.github.com/repos/pokt-network/pocket/pulls/778,pokt-network/pocket,a516c51f2d000d25f1469d28e6586ef7875d5a37
https://api.github.com/repos/pokt-network/pocket/pulls/778,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1206004255,Olshansk,b93c50312e4967daff683ac9fd577e4e5edc2a3b,acec260d9987f4dba2b31bdf4b65f2ef6b654725,"@@ -0,0 +1,284 @@
+package cli
+
+import (
+	""context""
+	sha ""crypto""
+	""encoding/hex""
+	""encoding/json""
+	""fmt""
+	""net/http""
+
+	""github.com/spf13/cobra""
+
+	""github.com/pokt-network/pocket/rpc""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/crypto""
+)
+
+func init() {
+	rootCmd.AddCommand(NewServicerCommand())
+}
+
+// TECHDEBT: (unittest) unit test the command: e.g. on number of arguments
+func NewServicerCommand() *cobra.Command {
+	cmd := &cobra.Command{
+		Use:     ""Servicer"",
+		Short:   ""Servicer specific commands"",
+		Aliases: []string{""servicer""},
+		Args:    cobra.ExactArgs(0),
+	}
+
+	cmds := servicerCommands()
+	applySubcommandOptions(cmds, attachPwdFlagToSubcommands())
+	applySubcommandOptions(cmds, attachKeybaseFlagsToSubcommands())
+
+	cmd.AddCommand(cmds...)
+
+	return cmd
+}
+
+func servicerCommands() []*cobra.Command {
+	cmdDef := actorCmdDef{""Servicer"", coreTypes.ActorType_ACTOR_TYPE_SERVICER}
+	cmds := []*cobra.Command{
+		newStakeCmd(cmdDef),
+		newEditStakeCmd(cmdDef),
+		newUnstakeCmd(cmdDef),
+		newUnpauseCmd(cmdDef),
+		{
+			Use:   ""Relay <servicer> <application> <relayChainID> <payload>"",
+			Short: ""Relay <servicer> <application> <relayChainID> <payload>"",
+			Long: `Sends a trustless relay using <payload> as contents, to the specified active <servicer> in the the <application>'s session.
+Will prompt the user for the *application* account passphrase`,
+			Aliases: []string{},
+			Args:    cobra.ExactArgs(4),
+			RunE: func(cmd *cobra.Command, args []string) error {
+				servicerAddr := args[0]
+				applicationAddr := args[1]
+				chain := args[2]
+				relayPayload := args[3]
+
+				// TODO: (SUGGESTION) refactor to decouple the client logic from the CLI/command
+				pk, err := getPrivateKey(applicationAddr)
+				if err != nil {
+					return fmt.Errorf(""error getting application's private key: %w"", err)
+				}
+
+				session, servicer, err := fetchServicer(cmd.Context(), applicationAddr, chain, servicerAddr)
+				if err != nil {
+					return fmt.Errorf(""error getting servicer for the relay: %w"", err)
+				}
+
+				relay, err := buildRelay(relayPayload, pk, session, servicer)
+				if err != nil {
+					return fmt.Errorf(""error building relay from payload: %w"", err)
+				}
+
+				fmt.Printf(""sending trustless relay for %s to %v with payload: %s\n"", applicationAddr, servicer, relayPayload)
+
+				resp, err := sendTrustlessRelay(cmd.Context(), servicer.ServiceUrl, relay)
+				if err != nil {
+					return err
+				}
+
+				fmt.Printf(""HTTP status code: %d\n"", resp.HTTPResponse.StatusCode)
+				fmt.Println(""Response: "", resp.JSON200)
+
+				return nil
+			},
+		},
+	}
+
+	return cmds
+}
+
+// TODO: (QUESTION): do we need/want a cli subcommand for fetching servicers?
+
+// fetchServicer returns the servicer specified by the <servicer> argument.
+// It validates the following conditions:
+//
+//	A. The <application> argument is the address of an active application
+//	B. The <servicer> is the address of a servicer that is active in the application's current session.
+//
+// TODO: (SUGGESTION) use a package-internal interface for servicer and application?
+// TODO: (SUGGESTION) use a struct as input to combine all fields (same for output)
+func fetchServicer(ctx context.Context, appAddress, chain, servicerAddress string) (rpc.Session, rpc.ProtocolActor, error) {
+	// TECHDEBT: cache session data
+	session, err := getCurrentSession(ctx, appAddress, chain)
+	if err != nil {
+		return rpc.Session{}, rpc.ProtocolActor{}, fmt.Errorf(""Error getting servicer: %w"", err)
+	}
+
+	var (
+		servicer rpc.ProtocolActor
+		found    bool
+	)
+	// TODO: a map may be a better choice for storing servicers
+	for _, s := range session.Servicers {
+		if s.Address == servicerAddress {
+			servicer = s
+			found = true
+			break
+		}
+	}
+
+	// TODO: cover with unit tests
+	if !found {
+		return rpc.Session{}, rpc.ProtocolActor{}, fmt.Errorf(""Error getting servicer: address %s does not match any servicers in the session"", servicerAddress)
+	}
+
+	// TODO: cover with unit tests",app/client/cli/servicer.go,2023-05-25 21:07:34+00:00,2023-05-25T21:21:56Z,"You shouldn't need to do this. getCurrentSession accepts a chain, so the protocol wouldn't return a servicer unless it supports the chain for that height.",,,,,129,RIGHT,129,,line,https://api.github.com/repos/pokt-network/pocket/pulls/778,pokt-network/pocket,a516c51f2d000d25f1469d28e6586ef7875d5a37
https://api.github.com/repos/pokt-network/pocket/pulls/778,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1206004987,Olshansk,b93c50312e4967daff683ac9fd577e4e5edc2a3b,acec260d9987f4dba2b31bdf4b65f2ef6b654725,"@@ -0,0 +1,284 @@
+package cli
+
+import (
+	""context""
+	sha ""crypto""
+	""encoding/hex""
+	""encoding/json""
+	""fmt""
+	""net/http""
+
+	""github.com/spf13/cobra""
+
+	""github.com/pokt-network/pocket/rpc""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/crypto""
+)
+
+func init() {
+	rootCmd.AddCommand(NewServicerCommand())
+}
+
+// TECHDEBT: (unittest) unit test the command: e.g. on number of arguments
+func NewServicerCommand() *cobra.Command {
+	cmd := &cobra.Command{
+		Use:     ""Servicer"",
+		Short:   ""Servicer specific commands"",
+		Aliases: []string{""servicer""},
+		Args:    cobra.ExactArgs(0),
+	}
+
+	cmds := servicerCommands()
+	applySubcommandOptions(cmds, attachPwdFlagToSubcommands())
+	applySubcommandOptions(cmds, attachKeybaseFlagsToSubcommands())
+
+	cmd.AddCommand(cmds...)
+
+	return cmd
+}
+
+func servicerCommands() []*cobra.Command {
+	cmdDef := actorCmdDef{""Servicer"", coreTypes.ActorType_ACTOR_TYPE_SERVICER}
+	cmds := []*cobra.Command{
+		newStakeCmd(cmdDef),
+		newEditStakeCmd(cmdDef),
+		newUnstakeCmd(cmdDef),
+		newUnpauseCmd(cmdDef),
+		{
+			Use:   ""Relay <servicer> <application> <relayChainID> <payload>"",
+			Short: ""Relay <servicer> <application> <relayChainID> <payload>"",
+			Long: `Sends a trustless relay using <payload> as contents, to the specified active <servicer> in the the <application>'s session.
+Will prompt the user for the *application* account passphrase`,
+			Aliases: []string{},
+			Args:    cobra.ExactArgs(4),
+			RunE: func(cmd *cobra.Command, args []string) error {
+				servicerAddr := args[0]
+				applicationAddr := args[1]
+				chain := args[2]
+				relayPayload := args[3]
+
+				// TODO: (SUGGESTION) refactor to decouple the client logic from the CLI/command
+				pk, err := getPrivateKey(applicationAddr)
+				if err != nil {
+					return fmt.Errorf(""error getting application's private key: %w"", err)
+				}
+
+				session, servicer, err := fetchServicer(cmd.Context(), applicationAddr, chain, servicerAddr)
+				if err != nil {
+					return fmt.Errorf(""error getting servicer for the relay: %w"", err)
+				}
+
+				relay, err := buildRelay(relayPayload, pk, session, servicer)
+				if err != nil {
+					return fmt.Errorf(""error building relay from payload: %w"", err)
+				}
+
+				fmt.Printf(""sending trustless relay for %s to %v with payload: %s\n"", applicationAddr, servicer, relayPayload)
+
+				resp, err := sendTrustlessRelay(cmd.Context(), servicer.ServiceUrl, relay)
+				if err != nil {
+					return err
+				}
+
+				fmt.Printf(""HTTP status code: %d\n"", resp.HTTPResponse.StatusCode)
+				fmt.Println(""Response: "", resp.JSON200)
+
+				return nil
+			},
+		},
+	}
+
+	return cmds
+}
+
+// TODO: (QUESTION): do we need/want a cli subcommand for fetching servicers?
+
+// fetchServicer returns the servicer specified by the <servicer> argument.
+// It validates the following conditions:
+//
+//	A. The <application> argument is the address of an active application
+//	B. The <servicer> is the address of a servicer that is active in the application's current session.
+//
+// TODO: (SUGGESTION) use a package-internal interface for servicer and application?
+// TODO: (SUGGESTION) use a struct as input to combine all fields (same for output)",app/client/cli/servicer.go,2023-05-25 21:08:38+00:00,2023-05-25T21:21:56Z,"Personally I think it's overkill for this context. We pass individual parameters in many different places and I'd rather not overengineer unless we need to.

If we do end up needing this, it'll come up repeatedly, so I'd bias not to have an explicit TODO for it.",,,,,103,RIGHT,103,,line,https://api.github.com/repos/pokt-network/pocket/pulls/778,pokt-network/pocket,a516c51f2d000d25f1469d28e6586ef7875d5a37
https://api.github.com/repos/pokt-network/pocket/pulls/778,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1206005712,Olshansk,b93c50312e4967daff683ac9fd577e4e5edc2a3b,acec260d9987f4dba2b31bdf4b65f2ef6b654725,"@@ -0,0 +1,284 @@
+package cli
+
+import (
+	""context""
+	sha ""crypto""
+	""encoding/hex""
+	""encoding/json""
+	""fmt""
+	""net/http""
+
+	""github.com/spf13/cobra""
+
+	""github.com/pokt-network/pocket/rpc""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/crypto""
+)
+
+func init() {
+	rootCmd.AddCommand(NewServicerCommand())
+}
+
+// TECHDEBT: (unittest) unit test the command: e.g. on number of arguments
+func NewServicerCommand() *cobra.Command {
+	cmd := &cobra.Command{
+		Use:     ""Servicer"",
+		Short:   ""Servicer specific commands"",
+		Aliases: []string{""servicer""},
+		Args:    cobra.ExactArgs(0),
+	}
+
+	cmds := servicerCommands()
+	applySubcommandOptions(cmds, attachPwdFlagToSubcommands())
+	applySubcommandOptions(cmds, attachKeybaseFlagsToSubcommands())
+
+	cmd.AddCommand(cmds...)
+
+	return cmd
+}
+
+func servicerCommands() []*cobra.Command {
+	cmdDef := actorCmdDef{""Servicer"", coreTypes.ActorType_ACTOR_TYPE_SERVICER}
+	cmds := []*cobra.Command{
+		newStakeCmd(cmdDef),
+		newEditStakeCmd(cmdDef),
+		newUnstakeCmd(cmdDef),
+		newUnpauseCmd(cmdDef),
+		{
+			Use:   ""Relay <servicer> <application> <relayChainID> <payload>"",
+			Short: ""Relay <servicer> <application> <relayChainID> <payload>"",
+			Long: `Sends a trustless relay using <payload> as contents, to the specified active <servicer> in the the <application>'s session.
+Will prompt the user for the *application* account passphrase`,
+			Aliases: []string{},
+			Args:    cobra.ExactArgs(4),
+			RunE: func(cmd *cobra.Command, args []string) error {
+				servicerAddr := args[0]
+				applicationAddr := args[1]
+				chain := args[2]
+				relayPayload := args[3]
+
+				// TODO: (SUGGESTION) refactor to decouple the client logic from the CLI/command
+				pk, err := getPrivateKey(applicationAddr)
+				if err != nil {
+					return fmt.Errorf(""error getting application's private key: %w"", err)
+				}
+
+				session, servicer, err := fetchServicer(cmd.Context(), applicationAddr, chain, servicerAddr)
+				if err != nil {
+					return fmt.Errorf(""error getting servicer for the relay: %w"", err)
+				}
+
+				relay, err := buildRelay(relayPayload, pk, session, servicer)
+				if err != nil {
+					return fmt.Errorf(""error building relay from payload: %w"", err)
+				}
+
+				fmt.Printf(""sending trustless relay for %s to %v with payload: %s\n"", applicationAddr, servicer, relayPayload)
+
+				resp, err := sendTrustlessRelay(cmd.Context(), servicer.ServiceUrl, relay)
+				if err != nil {
+					return err
+				}
+
+				fmt.Printf(""HTTP status code: %d\n"", resp.HTTPResponse.StatusCode)
+				fmt.Println(""Response: "", resp.JSON200)
+
+				return nil
+			},
+		},
+	}
+
+	return cmds
+}
+
+// TODO: (QUESTION): do we need/want a cli subcommand for fetching servicers?
+
+// fetchServicer returns the servicer specified by the <servicer> argument.
+// It validates the following conditions:
+//
+//	A. The <application> argument is the address of an active application
+//	B. The <servicer> is the address of a servicer that is active in the application's current session.
+//
+// TODO: (SUGGESTION) use a package-internal interface for servicer and application?",app/client/cli/servicer.go,2023-05-25 21:09:43+00:00,2023-05-25T21:21:56Z,"We used to have many package specific interfaces for every type (e.g. the Validator interface in consensus, the Validator interface in persistence, etc) and had 6 different Validator interfaces at one point.

I'm open to either approach but would push back against this just because it got really confusing in the past.",,,,,102,RIGHT,102,,line,https://api.github.com/repos/pokt-network/pocket/pulls/778,pokt-network/pocket,a516c51f2d000d25f1469d28e6586ef7875d5a37
https://api.github.com/repos/pokt-network/pocket/pulls/778,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1206006512,Olshansk,b93c50312e4967daff683ac9fd577e4e5edc2a3b,acec260d9987f4dba2b31bdf4b65f2ef6b654725,"@@ -0,0 +1,284 @@
+package cli
+
+import (
+	""context""
+	sha ""crypto""
+	""encoding/hex""
+	""encoding/json""
+	""fmt""
+	""net/http""
+
+	""github.com/spf13/cobra""
+
+	""github.com/pokt-network/pocket/rpc""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/crypto""
+)
+
+func init() {
+	rootCmd.AddCommand(NewServicerCommand())
+}
+
+// TECHDEBT: (unittest) unit test the command: e.g. on number of arguments
+func NewServicerCommand() *cobra.Command {
+	cmd := &cobra.Command{
+		Use:     ""Servicer"",
+		Short:   ""Servicer specific commands"",
+		Aliases: []string{""servicer""},
+		Args:    cobra.ExactArgs(0),
+	}
+
+	cmds := servicerCommands()
+	applySubcommandOptions(cmds, attachPwdFlagToSubcommands())
+	applySubcommandOptions(cmds, attachKeybaseFlagsToSubcommands())
+
+	cmd.AddCommand(cmds...)
+
+	return cmd
+}
+
+func servicerCommands() []*cobra.Command {
+	cmdDef := actorCmdDef{""Servicer"", coreTypes.ActorType_ACTOR_TYPE_SERVICER}
+	cmds := []*cobra.Command{
+		newStakeCmd(cmdDef),
+		newEditStakeCmd(cmdDef),
+		newUnstakeCmd(cmdDef),
+		newUnpauseCmd(cmdDef),
+		{
+			Use:   ""Relay <servicer> <application> <relayChainID> <payload>"",
+			Short: ""Relay <servicer> <application> <relayChainID> <payload>"",
+			Long: `Sends a trustless relay using <payload> as contents, to the specified active <servicer> in the the <application>'s session.
+Will prompt the user for the *application* account passphrase`,
+			Aliases: []string{},
+			Args:    cobra.ExactArgs(4),
+			RunE: func(cmd *cobra.Command, args []string) error {
+				servicerAddr := args[0]
+				applicationAddr := args[1]
+				chain := args[2]
+				relayPayload := args[3]
+
+				// TODO: (SUGGESTION) refactor to decouple the client logic from the CLI/command
+				pk, err := getPrivateKey(applicationAddr)
+				if err != nil {
+					return fmt.Errorf(""error getting application's private key: %w"", err)
+				}
+
+				session, servicer, err := fetchServicer(cmd.Context(), applicationAddr, chain, servicerAddr)
+				if err != nil {
+					return fmt.Errorf(""error getting servicer for the relay: %w"", err)
+				}
+
+				relay, err := buildRelay(relayPayload, pk, session, servicer)
+				if err != nil {
+					return fmt.Errorf(""error building relay from payload: %w"", err)
+				}
+
+				fmt.Printf(""sending trustless relay for %s to %v with payload: %s\n"", applicationAddr, servicer, relayPayload)
+
+				resp, err := sendTrustlessRelay(cmd.Context(), servicer.ServiceUrl, relay)
+				if err != nil {
+					return err
+				}
+
+				fmt.Printf(""HTTP status code: %d\n"", resp.HTTPResponse.StatusCode)
+				fmt.Println(""Response: "", resp.JSON200)
+
+				return nil
+			},
+		},
+	}
+
+	return cmds
+}
+
+// TODO: (QUESTION): do we need/want a cli subcommand for fetching servicers?",app/client/cli/servicer.go,2023-05-25 21:10:45+00:00,2023-05-25T21:21:56Z,"1. Is that not what retrieving the session does?
2. What would the interface look like?
3. If/when we need it something custom, let's add it.",,,,,94,RIGHT,94,,line,https://api.github.com/repos/pokt-network/pocket/pulls/778,pokt-network/pocket,a516c51f2d000d25f1469d28e6586ef7875d5a37
https://api.github.com/repos/pokt-network/pocket/pulls/778,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1206007090,Olshansk,b93c50312e4967daff683ac9fd577e4e5edc2a3b,acec260d9987f4dba2b31bdf4b65f2ef6b654725,"@@ -0,0 +1,284 @@
+package cli
+
+import (
+	""context""
+	sha ""crypto""
+	""encoding/hex""
+	""encoding/json""
+	""fmt""
+	""net/http""
+
+	""github.com/spf13/cobra""
+
+	""github.com/pokt-network/pocket/rpc""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/crypto""
+)
+
+func init() {
+	rootCmd.AddCommand(NewServicerCommand())
+}
+
+// TECHDEBT: (unittest) unit test the command: e.g. on number of arguments
+func NewServicerCommand() *cobra.Command {
+	cmd := &cobra.Command{
+		Use:     ""Servicer"",
+		Short:   ""Servicer specific commands"",
+		Aliases: []string{""servicer""},
+		Args:    cobra.ExactArgs(0),
+	}
+
+	cmds := servicerCommands()
+	applySubcommandOptions(cmds, attachPwdFlagToSubcommands())
+	applySubcommandOptions(cmds, attachKeybaseFlagsToSubcommands())
+
+	cmd.AddCommand(cmds...)
+
+	return cmd
+}
+
+func servicerCommands() []*cobra.Command {
+	cmdDef := actorCmdDef{""Servicer"", coreTypes.ActorType_ACTOR_TYPE_SERVICER}
+	cmds := []*cobra.Command{
+		newStakeCmd(cmdDef),
+		newEditStakeCmd(cmdDef),
+		newUnstakeCmd(cmdDef),
+		newUnpauseCmd(cmdDef),
+		{
+			Use:   ""Relay <servicer> <application> <relayChainID> <payload>"",
+			Short: ""Relay <servicer> <application> <relayChainID> <payload>"",
+			Long: `Sends a trustless relay using <payload> as contents, to the specified active <servicer> in the the <application>'s session.
+Will prompt the user for the *application* account passphrase`,
+			Aliases: []string{},
+			Args:    cobra.ExactArgs(4),
+			RunE: func(cmd *cobra.Command, args []string) error {
+				servicerAddr := args[0]
+				applicationAddr := args[1]
+				chain := args[2]
+				relayPayload := args[3]
+
+				// TODO: (SUGGESTION) refactor to decouple the client logic from the CLI/command
+				pk, err := getPrivateKey(applicationAddr)
+				if err != nil {
+					return fmt.Errorf(""error getting application's private key: %w"", err)
+				}
+
+				session, servicer, err := fetchServicer(cmd.Context(), applicationAddr, chain, servicerAddr)",app/client/cli/servicer.go,2023-05-25 21:11:30+00:00,2023-05-25T21:21:56Z,"Thoughts on decoupling ""getSession"" and ""getServicer"" or getting the session in place and passing that to `fetchServicer`?

Feels weird to get back a session from a function called `fetchServicer`",,,,,66,RIGHT,66,,line,https://api.github.com/repos/pokt-network/pocket/pulls/778,pokt-network/pocket,a516c51f2d000d25f1469d28e6586ef7875d5a37
https://api.github.com/repos/pokt-network/pocket/pulls/778,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1206008315,Olshansk,b93c50312e4967daff683ac9fd577e4e5edc2a3b,acec260d9987f4dba2b31bdf4b65f2ef6b654725,"@@ -0,0 +1,284 @@
+package cli
+
+import (
+	""context""
+	sha ""crypto""
+	""encoding/hex""
+	""encoding/json""
+	""fmt""
+	""net/http""
+
+	""github.com/spf13/cobra""
+
+	""github.com/pokt-network/pocket/rpc""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/crypto""
+)
+
+func init() {
+	rootCmd.AddCommand(NewServicerCommand())
+}
+
+// TECHDEBT: (unittest) unit test the command: e.g. on number of arguments
+func NewServicerCommand() *cobra.Command {
+	cmd := &cobra.Command{
+		Use:     ""Servicer"",
+		Short:   ""Servicer specific commands"",
+		Aliases: []string{""servicer""},
+		Args:    cobra.ExactArgs(0),
+	}
+
+	cmds := servicerCommands()
+	applySubcommandOptions(cmds, attachPwdFlagToSubcommands())
+	applySubcommandOptions(cmds, attachKeybaseFlagsToSubcommands())
+
+	cmd.AddCommand(cmds...)
+
+	return cmd
+}
+
+func servicerCommands() []*cobra.Command {
+	cmdDef := actorCmdDef{""Servicer"", coreTypes.ActorType_ACTOR_TYPE_SERVICER}
+	cmds := []*cobra.Command{
+		newStakeCmd(cmdDef),
+		newEditStakeCmd(cmdDef),
+		newUnstakeCmd(cmdDef),
+		newUnpauseCmd(cmdDef),
+		{
+			Use:   ""Relay <servicer> <application> <relayChainID> <payload>"",
+			Short: ""Relay <servicer> <application> <relayChainID> <payload>"",
+			Long: `Sends a trustless relay using <payload> as contents, to the specified active <servicer> in the the <application>'s session.
+Will prompt the user for the *application* account passphrase`,
+			Aliases: []string{},
+			Args:    cobra.ExactArgs(4),
+			RunE: func(cmd *cobra.Command, args []string) error {
+				servicerAddr := args[0]
+				applicationAddr := args[1]
+				chain := args[2]
+				relayPayload := args[3]
+
+				// TODO: (SUGGESTION) refactor to decouple the client logic from the CLI/command
+				pk, err := getPrivateKey(applicationAddr)
+				if err != nil {
+					return fmt.Errorf(""error getting application's private key: %w"", err)
+				}
+
+				session, servicer, err := fetchServicer(cmd.Context(), applicationAddr, chain, servicerAddr)
+				if err != nil {
+					return fmt.Errorf(""error getting servicer for the relay: %w"", err)
+				}
+
+				relay, err := buildRelay(relayPayload, pk, session, servicer)
+				if err != nil {
+					return fmt.Errorf(""error building relay from payload: %w"", err)
+				}
+
+				fmt.Printf(""sending trustless relay for %s to %v with payload: %s\n"", applicationAddr, servicer, relayPayload)
+
+				resp, err := sendTrustlessRelay(cmd.Context(), servicer.ServiceUrl, relay)
+				if err != nil {
+					return err
+				}
+
+				fmt.Printf(""HTTP status code: %d\n"", resp.HTTPResponse.StatusCode)
+				fmt.Println(""Response: "", resp.JSON200)
+
+				return nil
+			},
+		},
+	}
+
+	return cmds
+}
+
+// TODO: (QUESTION): do we need/want a cli subcommand for fetching servicers?
+
+// fetchServicer returns the servicer specified by the <servicer> argument.
+// It validates the following conditions:
+//
+//	A. The <application> argument is the address of an active application
+//	B. The <servicer> is the address of a servicer that is active in the application's current session.
+//
+// TODO: (SUGGESTION) use a package-internal interface for servicer and application?
+// TODO: (SUGGESTION) use a struct as input to combine all fields (same for output)
+func fetchServicer(ctx context.Context, appAddress, chain, servicerAddress string) (rpc.Session, rpc.ProtocolActor, error) {
+	// TECHDEBT: cache session data",app/client/cli/servicer.go,2023-05-25 21:13:07+00:00,2023-05-25T21:21:56Z,I think this might event warrant creating a ticket. Then you can ` // TECHDEBT(#XXX): cache session data`,,,,,105,RIGHT,105,,line,https://api.github.com/repos/pokt-network/pocket/pulls/778,pokt-network/pocket,a516c51f2d000d25f1469d28e6586ef7875d5a37
https://api.github.com/repos/pokt-network/pocket/pulls/778,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1206009459,Olshansk,b93c50312e4967daff683ac9fd577e4e5edc2a3b,acec260d9987f4dba2b31bdf4b65f2ef6b654725,"@@ -0,0 +1,284 @@
+package cli
+
+import (
+	""context""
+	sha ""crypto""
+	""encoding/hex""
+	""encoding/json""
+	""fmt""
+	""net/http""
+
+	""github.com/spf13/cobra""
+
+	""github.com/pokt-network/pocket/rpc""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/crypto""
+)
+
+func init() {
+	rootCmd.AddCommand(NewServicerCommand())
+}
+
+// TECHDEBT: (unittest) unit test the command: e.g. on number of arguments
+func NewServicerCommand() *cobra.Command {
+	cmd := &cobra.Command{
+		Use:     ""Servicer"",
+		Short:   ""Servicer specific commands"",
+		Aliases: []string{""servicer""},
+		Args:    cobra.ExactArgs(0),
+	}
+
+	cmds := servicerCommands()
+	applySubcommandOptions(cmds, attachPwdFlagToSubcommands())
+	applySubcommandOptions(cmds, attachKeybaseFlagsToSubcommands())
+
+	cmd.AddCommand(cmds...)
+
+	return cmd
+}
+
+func servicerCommands() []*cobra.Command {
+	cmdDef := actorCmdDef{""Servicer"", coreTypes.ActorType_ACTOR_TYPE_SERVICER}
+	cmds := []*cobra.Command{
+		newStakeCmd(cmdDef),
+		newEditStakeCmd(cmdDef),
+		newUnstakeCmd(cmdDef),
+		newUnpauseCmd(cmdDef),
+		{
+			Use:   ""Relay <servicer> <application> <relayChainID> <payload>"",
+			Short: ""Relay <servicer> <application> <relayChainID> <payload>"",
+			Long: `Sends a trustless relay using <payload> as contents, to the specified active <servicer> in the the <application>'s session.
+Will prompt the user for the *application* account passphrase`,
+			Aliases: []string{},
+			Args:    cobra.ExactArgs(4),
+			RunE: func(cmd *cobra.Command, args []string) error {
+				servicerAddr := args[0]
+				applicationAddr := args[1]
+				chain := args[2]
+				relayPayload := args[3]
+
+				// TODO: (SUGGESTION) refactor to decouple the client logic from the CLI/command
+				pk, err := getPrivateKey(applicationAddr)
+				if err != nil {
+					return fmt.Errorf(""error getting application's private key: %w"", err)
+				}
+
+				session, servicer, err := fetchServicer(cmd.Context(), applicationAddr, chain, servicerAddr)
+				if err != nil {
+					return fmt.Errorf(""error getting servicer for the relay: %w"", err)
+				}
+
+				relay, err := buildRelay(relayPayload, pk, session, servicer)
+				if err != nil {
+					return fmt.Errorf(""error building relay from payload: %w"", err)
+				}
+
+				fmt.Printf(""sending trustless relay for %s to %v with payload: %s\n"", applicationAddr, servicer, relayPayload)
+
+				resp, err := sendTrustlessRelay(cmd.Context(), servicer.ServiceUrl, relay)
+				if err != nil {
+					return err
+				}
+
+				fmt.Printf(""HTTP status code: %d\n"", resp.HTTPResponse.StatusCode)
+				fmt.Println(""Response: "", resp.JSON200)
+
+				return nil
+			},
+		},
+	}
+
+	return cmds
+}
+
+// TODO: (QUESTION): do we need/want a cli subcommand for fetching servicers?
+
+// fetchServicer returns the servicer specified by the <servicer> argument.
+// It validates the following conditions:
+//
+//	A. The <application> argument is the address of an active application
+//	B. The <servicer> is the address of a servicer that is active in the application's current session.
+//
+// TODO: (SUGGESTION) use a package-internal interface for servicer and application?
+// TODO: (SUGGESTION) use a struct as input to combine all fields (same for output)
+func fetchServicer(ctx context.Context, appAddress, chain, servicerAddress string) (rpc.Session, rpc.ProtocolActor, error) {
+	// TECHDEBT: cache session data
+	session, err := getCurrentSession(ctx, appAddress, chain)
+	if err != nil {
+		return rpc.Session{}, rpc.ProtocolActor{}, fmt.Errorf(""Error getting servicer: %w"", err)
+	}
+
+	var (
+		servicer rpc.ProtocolActor
+		found    bool
+	)
+	// TODO: a map may be a better choice for storing servicers
+	for _, s := range session.Servicers {
+		if s.Address == servicerAddress {
+			servicer = s
+			found = true
+			break
+		}
+	}
+
+	// TODO: cover with unit tests
+	if !found {
+		return rpc.Session{}, rpc.ProtocolActor{}, fmt.Errorf(""Error getting servicer: address %s does not match any servicers in the session"", servicerAddress)
+	}
+
+	// TODO: cover with unit tests
+	found = false
+	for _, ch := range servicer.Chains {
+		if ch == chain {
+			found = true
+			break
+		}
+	}
+
+	if !found {
+		return rpc.Session{}, rpc.ProtocolActor{}, fmt.Errorf(""Error getting servicer: service %s does not support chain %s"", servicerAddress, chain)
+	}
+
+	return *session, servicer, nil
+}
+
+func getCurrentSession(ctx context.Context, appAddress, chain string) (*rpc.Session, error) {
+	// TODO: passing 0 as the height value to get the current session seems more optimal than this.",app/client/cli/servicer.go,2023-05-25 21:14:44+00:00,2023-05-25T21:21:56Z,"```suggestion
	// CONSIDERATION: passing 0 as the height value to get the current session seems more optimal than this.
```",,,,,146,RIGHT,146,,line,https://api.github.com/repos/pokt-network/pocket/pulls/778,pokt-network/pocket,a516c51f2d000d25f1469d28e6586ef7875d5a37
https://api.github.com/repos/pokt-network/pocket/pulls/778,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1206009809,Olshansk,b93c50312e4967daff683ac9fd577e4e5edc2a3b,acec260d9987f4dba2b31bdf4b65f2ef6b654725,"@@ -0,0 +1,284 @@
+package cli
+
+import (
+	""context""
+	sha ""crypto""
+	""encoding/hex""
+	""encoding/json""
+	""fmt""
+	""net/http""
+
+	""github.com/spf13/cobra""
+
+	""github.com/pokt-network/pocket/rpc""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/crypto""
+)
+
+func init() {
+	rootCmd.AddCommand(NewServicerCommand())
+}
+
+// TECHDEBT: (unittest) unit test the command: e.g. on number of arguments
+func NewServicerCommand() *cobra.Command {
+	cmd := &cobra.Command{
+		Use:     ""Servicer"",
+		Short:   ""Servicer specific commands"",
+		Aliases: []string{""servicer""},
+		Args:    cobra.ExactArgs(0),
+	}
+
+	cmds := servicerCommands()
+	applySubcommandOptions(cmds, attachPwdFlagToSubcommands())
+	applySubcommandOptions(cmds, attachKeybaseFlagsToSubcommands())
+
+	cmd.AddCommand(cmds...)
+
+	return cmd
+}
+
+func servicerCommands() []*cobra.Command {
+	cmdDef := actorCmdDef{""Servicer"", coreTypes.ActorType_ACTOR_TYPE_SERVICER}
+	cmds := []*cobra.Command{
+		newStakeCmd(cmdDef),
+		newEditStakeCmd(cmdDef),
+		newUnstakeCmd(cmdDef),
+		newUnpauseCmd(cmdDef),
+		{
+			Use:   ""Relay <servicer> <application> <relayChainID> <payload>"",
+			Short: ""Relay <servicer> <application> <relayChainID> <payload>"",
+			Long: `Sends a trustless relay using <payload> as contents, to the specified active <servicer> in the the <application>'s session.
+Will prompt the user for the *application* account passphrase`,
+			Aliases: []string{},
+			Args:    cobra.ExactArgs(4),
+			RunE: func(cmd *cobra.Command, args []string) error {
+				servicerAddr := args[0]
+				applicationAddr := args[1]
+				chain := args[2]
+				relayPayload := args[3]
+
+				// TODO: (SUGGESTION) refactor to decouple the client logic from the CLI/command
+				pk, err := getPrivateKey(applicationAddr)
+				if err != nil {
+					return fmt.Errorf(""error getting application's private key: %w"", err)
+				}
+
+				session, servicer, err := fetchServicer(cmd.Context(), applicationAddr, chain, servicerAddr)
+				if err != nil {
+					return fmt.Errorf(""error getting servicer for the relay: %w"", err)
+				}
+
+				relay, err := buildRelay(relayPayload, pk, session, servicer)
+				if err != nil {
+					return fmt.Errorf(""error building relay from payload: %w"", err)
+				}
+
+				fmt.Printf(""sending trustless relay for %s to %v with payload: %s\n"", applicationAddr, servicer, relayPayload)
+
+				resp, err := sendTrustlessRelay(cmd.Context(), servicer.ServiceUrl, relay)
+				if err != nil {
+					return err
+				}
+
+				fmt.Printf(""HTTP status code: %d\n"", resp.HTTPResponse.StatusCode)
+				fmt.Println(""Response: "", resp.JSON200)
+
+				return nil
+			},
+		},
+	}
+
+	return cmds
+}
+
+// TODO: (QUESTION): do we need/want a cli subcommand for fetching servicers?
+
+// fetchServicer returns the servicer specified by the <servicer> argument.
+// It validates the following conditions:
+//
+//	A. The <application> argument is the address of an active application
+//	B. The <servicer> is the address of a servicer that is active in the application's current session.
+//
+// TODO: (SUGGESTION) use a package-internal interface for servicer and application?
+// TODO: (SUGGESTION) use a struct as input to combine all fields (same for output)
+func fetchServicer(ctx context.Context, appAddress, chain, servicerAddress string) (rpc.Session, rpc.ProtocolActor, error) {
+	// TECHDEBT: cache session data
+	session, err := getCurrentSession(ctx, appAddress, chain)
+	if err != nil {
+		return rpc.Session{}, rpc.ProtocolActor{}, fmt.Errorf(""Error getting servicer: %w"", err)
+	}
+
+	var (
+		servicer rpc.ProtocolActor
+		found    bool
+	)
+	// TODO: a map may be a better choice for storing servicers
+	for _, s := range session.Servicers {
+		if s.Address == servicerAddress {
+			servicer = s
+			found = true
+			break
+		}
+	}
+
+	// TODO: cover with unit tests
+	if !found {
+		return rpc.Session{}, rpc.ProtocolActor{}, fmt.Errorf(""Error getting servicer: address %s does not match any servicers in the session"", servicerAddress)
+	}
+
+	// TODO: cover with unit tests
+	found = false
+	for _, ch := range servicer.Chains {
+		if ch == chain {
+			found = true
+			break
+		}
+	}
+
+	if !found {
+		return rpc.Session{}, rpc.ProtocolActor{}, fmt.Errorf(""Error getting servicer: service %s does not support chain %s"", servicerAddress, chain)
+	}
+
+	return *session, servicer, nil
+}
+
+func getCurrentSession(ctx context.Context, appAddress, chain string) (*rpc.Session, error) {
+	// TODO: passing 0 as the height value to get the current session seems more optimal than this.
+	currentHeight, err := getCurrentHeight(ctx)
+	if err != nil {
+		return nil, fmt.Errorf(""Error getting current session: %w"", err)
+	}
+
+	req := rpc.SessionRequest{
+		AppAddress: appAddress,
+		Chain:      chain,
+		// TODO: Geozone",app/client/cli/servicer.go,2023-05-25 21:15:16+00:00,2023-05-25T21:21:56Z,"```suggestion
		// TODO(#697): Geozone
```",,,,,155,RIGHT,155,,line,https://api.github.com/repos/pokt-network/pocket/pulls/778,pokt-network/pocket,a516c51f2d000d25f1469d28e6586ef7875d5a37
https://api.github.com/repos/pokt-network/pocket/pulls/778,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1206010648,Olshansk,b93c50312e4967daff683ac9fd577e4e5edc2a3b,acec260d9987f4dba2b31bdf4b65f2ef6b654725,"@@ -0,0 +1,284 @@
+package cli
+
+import (
+	""context""
+	sha ""crypto""
+	""encoding/hex""
+	""encoding/json""
+	""fmt""
+	""net/http""
+
+	""github.com/spf13/cobra""
+
+	""github.com/pokt-network/pocket/rpc""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/crypto""
+)
+
+func init() {
+	rootCmd.AddCommand(NewServicerCommand())
+}
+
+// TECHDEBT: (unittest) unit test the command: e.g. on number of arguments
+func NewServicerCommand() *cobra.Command {
+	cmd := &cobra.Command{
+		Use:     ""Servicer"",
+		Short:   ""Servicer specific commands"",
+		Aliases: []string{""servicer""},
+		Args:    cobra.ExactArgs(0),
+	}
+
+	cmds := servicerCommands()
+	applySubcommandOptions(cmds, attachPwdFlagToSubcommands())
+	applySubcommandOptions(cmds, attachKeybaseFlagsToSubcommands())
+
+	cmd.AddCommand(cmds...)
+
+	return cmd
+}
+
+func servicerCommands() []*cobra.Command {
+	cmdDef := actorCmdDef{""Servicer"", coreTypes.ActorType_ACTOR_TYPE_SERVICER}
+	cmds := []*cobra.Command{
+		newStakeCmd(cmdDef),
+		newEditStakeCmd(cmdDef),
+		newUnstakeCmd(cmdDef),
+		newUnpauseCmd(cmdDef),
+		{
+			Use:   ""Relay <servicer> <application> <relayChainID> <payload>"",
+			Short: ""Relay <servicer> <application> <relayChainID> <payload>"",
+			Long: `Sends a trustless relay using <payload> as contents, to the specified active <servicer> in the the <application>'s session.
+Will prompt the user for the *application* account passphrase`,
+			Aliases: []string{},
+			Args:    cobra.ExactArgs(4),
+			RunE: func(cmd *cobra.Command, args []string) error {
+				servicerAddr := args[0]
+				applicationAddr := args[1]
+				chain := args[2]
+				relayPayload := args[3]
+
+				// TODO: (SUGGESTION) refactor to decouple the client logic from the CLI/command
+				pk, err := getPrivateKey(applicationAddr)
+				if err != nil {
+					return fmt.Errorf(""error getting application's private key: %w"", err)
+				}
+
+				session, servicer, err := fetchServicer(cmd.Context(), applicationAddr, chain, servicerAddr)
+				if err != nil {
+					return fmt.Errorf(""error getting servicer for the relay: %w"", err)
+				}
+
+				relay, err := buildRelay(relayPayload, pk, session, servicer)
+				if err != nil {
+					return fmt.Errorf(""error building relay from payload: %w"", err)
+				}
+
+				fmt.Printf(""sending trustless relay for %s to %v with payload: %s\n"", applicationAddr, servicer, relayPayload)
+
+				resp, err := sendTrustlessRelay(cmd.Context(), servicer.ServiceUrl, relay)
+				if err != nil {
+					return err
+				}
+
+				fmt.Printf(""HTTP status code: %d\n"", resp.HTTPResponse.StatusCode)
+				fmt.Println(""Response: "", resp.JSON200)
+
+				return nil
+			},
+		},
+	}
+
+	return cmds
+}
+
+// TODO: (QUESTION): do we need/want a cli subcommand for fetching servicers?
+
+// fetchServicer returns the servicer specified by the <servicer> argument.
+// It validates the following conditions:
+//
+//	A. The <application> argument is the address of an active application
+//	B. The <servicer> is the address of a servicer that is active in the application's current session.
+//
+// TODO: (SUGGESTION) use a package-internal interface for servicer and application?
+// TODO: (SUGGESTION) use a struct as input to combine all fields (same for output)
+func fetchServicer(ctx context.Context, appAddress, chain, servicerAddress string) (rpc.Session, rpc.ProtocolActor, error) {
+	// TECHDEBT: cache session data
+	session, err := getCurrentSession(ctx, appAddress, chain)
+	if err != nil {
+		return rpc.Session{}, rpc.ProtocolActor{}, fmt.Errorf(""Error getting servicer: %w"", err)
+	}
+
+	var (
+		servicer rpc.ProtocolActor
+		found    bool
+	)
+	// TODO: a map may be a better choice for storing servicers
+	for _, s := range session.Servicers {
+		if s.Address == servicerAddress {
+			servicer = s
+			found = true
+			break
+		}
+	}
+
+	// TODO: cover with unit tests
+	if !found {
+		return rpc.Session{}, rpc.ProtocolActor{}, fmt.Errorf(""Error getting servicer: address %s does not match any servicers in the session"", servicerAddress)
+	}
+
+	// TODO: cover with unit tests
+	found = false
+	for _, ch := range servicer.Chains {
+		if ch == chain {
+			found = true
+			break
+		}
+	}
+
+	if !found {
+		return rpc.Session{}, rpc.ProtocolActor{}, fmt.Errorf(""Error getting servicer: service %s does not support chain %s"", servicerAddress, chain)
+	}
+
+	return *session, servicer, nil
+}
+
+func getCurrentSession(ctx context.Context, appAddress, chain string) (*rpc.Session, error) {
+	// TODO: passing 0 as the height value to get the current session seems more optimal than this.
+	currentHeight, err := getCurrentHeight(ctx)
+	if err != nil {
+		return nil, fmt.Errorf(""Error getting current session: %w"", err)
+	}
+
+	req := rpc.SessionRequest{
+		AppAddress: appAddress,
+		Chain:      chain,
+		// TODO: Geozone
+		SessionHeight: currentHeight,
+	}
+
+	client, err := rpc.NewClientWithResponses(remoteCLIURL)
+	if err != nil {
+		return nil, fmt.Errorf(""Error getting current session for app/chain/height: %s/%s/%d: %w"", appAddress, chain, currentHeight, err)
+	}
+
+	resp, err := client.PostV1ClientGetSessionWithResponse(ctx, req)
+	if err != nil {
+		return nil, fmt.Errorf(""Error getting current session with request %v: %w"", req, err)
+	}
+	// TODO: refactor boiler-plate code
+	if resp.HTTPResponse.StatusCode != http.StatusOK {
+		return nil, fmt.Errorf(""Error getting current session: Unexpected status code %d for request %v"", resp.HTTPResponse.StatusCode, req)
+	}
+
+	if resp.JSON200 == nil {
+		return nil, fmt.Errorf(""Error getting current session: Unexpected response %v"", resp)
+	}
+
+	return resp.JSON200, nil
+}
+
+// TODO: reuse this function in the query commands
+func getCurrentHeight(ctx context.Context) (int64, error) {
+	client, err := rpc.NewClientWithResponses(remoteCLIURL)
+	if err != nil {
+		return 0, fmt.Errorf(""Error getting current height: %w"", err)
+	}
+	resp, err := client.GetV1QueryHeightWithResponse(ctx)
+	if err != nil {
+		return 0, fmt.Errorf(""Error getting current height: %w"", err)
+	}
+	if resp.HTTPResponse.StatusCode != http.StatusOK {
+		return 0, fmt.Errorf(""Error getting current height: Unexpected status code %d"", resp.HTTPResponse.StatusCode)
+	}
+
+	if resp.JSON200 == nil {
+		return 0, fmt.Errorf(""Error getting current height: Unexpected response %v"", resp)
+	}
+
+	return resp.JSON200.Height, nil
+}
+
+// TODO: (localnet) Publish Servicer(s) Host and Port as env. vars in K8s: similar to Validators
+// TODO: (REFACTOR) should we move package-level variables (e.g. remoteCLIURL) to a cli object?",app/client/cli/servicer.go,2023-05-25 21:16:25+00:00,2023-05-25T21:21:56Z,"We have a `REFACTOR` tag (see Makefile). +1 to the refactor

cc @h5law for the idea",,,,,202,RIGHT,202,,line,https://api.github.com/repos/pokt-network/pocket/pulls/778,pokt-network/pocket,a516c51f2d000d25f1469d28e6586ef7875d5a37
https://api.github.com/repos/pokt-network/pocket/pulls/778,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1206011799,Olshansk,b93c50312e4967daff683ac9fd577e4e5edc2a3b,acec260d9987f4dba2b31bdf4b65f2ef6b654725,"@@ -0,0 +1,284 @@
+package cli
+
+import (
+	""context""
+	sha ""crypto""
+	""encoding/hex""
+	""encoding/json""
+	""fmt""
+	""net/http""
+
+	""github.com/spf13/cobra""
+
+	""github.com/pokt-network/pocket/rpc""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/crypto""
+)
+
+func init() {
+	rootCmd.AddCommand(NewServicerCommand())
+}
+
+// TECHDEBT: (unittest) unit test the command: e.g. on number of arguments
+func NewServicerCommand() *cobra.Command {
+	cmd := &cobra.Command{
+		Use:     ""Servicer"",
+		Short:   ""Servicer specific commands"",
+		Aliases: []string{""servicer""},
+		Args:    cobra.ExactArgs(0),
+	}
+
+	cmds := servicerCommands()
+	applySubcommandOptions(cmds, attachPwdFlagToSubcommands())
+	applySubcommandOptions(cmds, attachKeybaseFlagsToSubcommands())
+
+	cmd.AddCommand(cmds...)
+
+	return cmd
+}
+
+func servicerCommands() []*cobra.Command {
+	cmdDef := actorCmdDef{""Servicer"", coreTypes.ActorType_ACTOR_TYPE_SERVICER}
+	cmds := []*cobra.Command{
+		newStakeCmd(cmdDef),
+		newEditStakeCmd(cmdDef),
+		newUnstakeCmd(cmdDef),
+		newUnpauseCmd(cmdDef),
+		{
+			Use:   ""Relay <servicer> <application> <relayChainID> <payload>"",
+			Short: ""Relay <servicer> <application> <relayChainID> <payload>"",
+			Long: `Sends a trustless relay using <payload> as contents, to the specified active <servicer> in the the <application>'s session.
+Will prompt the user for the *application* account passphrase`,
+			Aliases: []string{},
+			Args:    cobra.ExactArgs(4),
+			RunE: func(cmd *cobra.Command, args []string) error {
+				servicerAddr := args[0]
+				applicationAddr := args[1]
+				chain := args[2]
+				relayPayload := args[3]
+
+				// TODO: (SUGGESTION) refactor to decouple the client logic from the CLI/command
+				pk, err := getPrivateKey(applicationAddr)
+				if err != nil {
+					return fmt.Errorf(""error getting application's private key: %w"", err)
+				}
+
+				session, servicer, err := fetchServicer(cmd.Context(), applicationAddr, chain, servicerAddr)
+				if err != nil {
+					return fmt.Errorf(""error getting servicer for the relay: %w"", err)
+				}
+
+				relay, err := buildRelay(relayPayload, pk, session, servicer)
+				if err != nil {
+					return fmt.Errorf(""error building relay from payload: %w"", err)
+				}
+
+				fmt.Printf(""sending trustless relay for %s to %v with payload: %s\n"", applicationAddr, servicer, relayPayload)
+
+				resp, err := sendTrustlessRelay(cmd.Context(), servicer.ServiceUrl, relay)
+				if err != nil {
+					return err
+				}
+
+				fmt.Printf(""HTTP status code: %d\n"", resp.HTTPResponse.StatusCode)
+				fmt.Println(""Response: "", resp.JSON200)
+
+				return nil
+			},
+		},
+	}
+
+	return cmds
+}
+
+// TODO: (QUESTION): do we need/want a cli subcommand for fetching servicers?
+
+// fetchServicer returns the servicer specified by the <servicer> argument.
+// It validates the following conditions:
+//
+//	A. The <application> argument is the address of an active application
+//	B. The <servicer> is the address of a servicer that is active in the application's current session.
+//
+// TODO: (SUGGESTION) use a package-internal interface for servicer and application?
+// TODO: (SUGGESTION) use a struct as input to combine all fields (same for output)
+func fetchServicer(ctx context.Context, appAddress, chain, servicerAddress string) (rpc.Session, rpc.ProtocolActor, error) {
+	// TECHDEBT: cache session data
+	session, err := getCurrentSession(ctx, appAddress, chain)
+	if err != nil {
+		return rpc.Session{}, rpc.ProtocolActor{}, fmt.Errorf(""Error getting servicer: %w"", err)
+	}
+
+	var (
+		servicer rpc.ProtocolActor
+		found    bool
+	)
+	// TODO: a map may be a better choice for storing servicers
+	for _, s := range session.Servicers {
+		if s.Address == servicerAddress {
+			servicer = s
+			found = true
+			break
+		}
+	}
+
+	// TODO: cover with unit tests
+	if !found {
+		return rpc.Session{}, rpc.ProtocolActor{}, fmt.Errorf(""Error getting servicer: address %s does not match any servicers in the session"", servicerAddress)
+	}
+
+	// TODO: cover with unit tests
+	found = false
+	for _, ch := range servicer.Chains {
+		if ch == chain {
+			found = true
+			break
+		}
+	}
+
+	if !found {
+		return rpc.Session{}, rpc.ProtocolActor{}, fmt.Errorf(""Error getting servicer: service %s does not support chain %s"", servicerAddress, chain)
+	}
+
+	return *session, servicer, nil
+}
+
+func getCurrentSession(ctx context.Context, appAddress, chain string) (*rpc.Session, error) {
+	// TODO: passing 0 as the height value to get the current session seems more optimal than this.
+	currentHeight, err := getCurrentHeight(ctx)
+	if err != nil {
+		return nil, fmt.Errorf(""Error getting current session: %w"", err)
+	}
+
+	req := rpc.SessionRequest{
+		AppAddress: appAddress,
+		Chain:      chain,
+		// TODO: Geozone
+		SessionHeight: currentHeight,
+	}
+
+	client, err := rpc.NewClientWithResponses(remoteCLIURL)
+	if err != nil {
+		return nil, fmt.Errorf(""Error getting current session for app/chain/height: %s/%s/%d: %w"", appAddress, chain, currentHeight, err)
+	}
+
+	resp, err := client.PostV1ClientGetSessionWithResponse(ctx, req)
+	if err != nil {
+		return nil, fmt.Errorf(""Error getting current session with request %v: %w"", req, err)
+	}
+	// TODO: refactor boiler-plate code
+	if resp.HTTPResponse.StatusCode != http.StatusOK {
+		return nil, fmt.Errorf(""Error getting current session: Unexpected status code %d for request %v"", resp.HTTPResponse.StatusCode, req)
+	}
+
+	if resp.JSON200 == nil {
+		return nil, fmt.Errorf(""Error getting current session: Unexpected response %v"", resp)
+	}
+
+	return resp.JSON200, nil
+}
+
+// TODO: reuse this function in the query commands
+func getCurrentHeight(ctx context.Context) (int64, error) {
+	client, err := rpc.NewClientWithResponses(remoteCLIURL)
+	if err != nil {
+		return 0, fmt.Errorf(""Error getting current height: %w"", err)
+	}
+	resp, err := client.GetV1QueryHeightWithResponse(ctx)
+	if err != nil {
+		return 0, fmt.Errorf(""Error getting current height: %w"", err)
+	}
+	if resp.HTTPResponse.StatusCode != http.StatusOK {
+		return 0, fmt.Errorf(""Error getting current height: Unexpected status code %d"", resp.HTTPResponse.StatusCode)
+	}
+
+	if resp.JSON200 == nil {
+		return 0, fmt.Errorf(""Error getting current height: Unexpected response %v"", resp)
+	}
+
+	return resp.JSON200.Height, nil
+}
+
+// TODO: (localnet) Publish Servicer(s) Host and Port as env. vars in K8s: similar to Validators
+// TODO: (REFACTOR) should we move package-level variables (e.g. remoteCLIURL) to a cli object?
+func sendTrustlessRelay(ctx context.Context, servicerUrl string, relay rpc.RelayRequest) (*rpc.PostV1ClientRelayResponse, error) {",app/client/cli/servicer.go,2023-05-25 21:18:03+00:00,2023-05-25T21:21:56Z,See suggestion from linters,,,,,203,RIGHT,203,,line,https://api.github.com/repos/pokt-network/pocket/pulls/778,pokt-network/pocket,a516c51f2d000d25f1469d28e6586ef7875d5a37
https://api.github.com/repos/pokt-network/pocket/pulls/778,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1206013809,Olshansk,b93c50312e4967daff683ac9fd577e4e5edc2a3b,acec260d9987f4dba2b31bdf4b65f2ef6b654725,"@@ -0,0 +1,284 @@
+package cli
+
+import (
+	""context""
+	sha ""crypto""
+	""encoding/hex""
+	""encoding/json""
+	""fmt""
+	""net/http""
+
+	""github.com/spf13/cobra""
+
+	""github.com/pokt-network/pocket/rpc""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/crypto""
+)
+
+func init() {
+	rootCmd.AddCommand(NewServicerCommand())
+}
+
+// TECHDEBT: (unittest) unit test the command: e.g. on number of arguments
+func NewServicerCommand() *cobra.Command {
+	cmd := &cobra.Command{
+		Use:     ""Servicer"",
+		Short:   ""Servicer specific commands"",
+		Aliases: []string{""servicer""},
+		Args:    cobra.ExactArgs(0),
+	}
+
+	cmds := servicerCommands()
+	applySubcommandOptions(cmds, attachPwdFlagToSubcommands())
+	applySubcommandOptions(cmds, attachKeybaseFlagsToSubcommands())
+
+	cmd.AddCommand(cmds...)
+
+	return cmd
+}
+
+func servicerCommands() []*cobra.Command {
+	cmdDef := actorCmdDef{""Servicer"", coreTypes.ActorType_ACTOR_TYPE_SERVICER}
+	cmds := []*cobra.Command{
+		newStakeCmd(cmdDef),
+		newEditStakeCmd(cmdDef),
+		newUnstakeCmd(cmdDef),
+		newUnpauseCmd(cmdDef),
+		{
+			Use:   ""Relay <servicer> <application> <relayChainID> <payload>"",
+			Short: ""Relay <servicer> <application> <relayChainID> <payload>"",
+			Long: `Sends a trustless relay using <payload> as contents, to the specified active <servicer> in the the <application>'s session.
+Will prompt the user for the *application* account passphrase`,
+			Aliases: []string{},
+			Args:    cobra.ExactArgs(4),
+			RunE: func(cmd *cobra.Command, args []string) error {
+				servicerAddr := args[0]
+				applicationAddr := args[1]
+				chain := args[2]
+				relayPayload := args[3]
+
+				// TODO: (SUGGESTION) refactor to decouple the client logic from the CLI/command
+				pk, err := getPrivateKey(applicationAddr)
+				if err != nil {
+					return fmt.Errorf(""error getting application's private key: %w"", err)
+				}
+
+				session, servicer, err := fetchServicer(cmd.Context(), applicationAddr, chain, servicerAddr)
+				if err != nil {
+					return fmt.Errorf(""error getting servicer for the relay: %w"", err)
+				}
+
+				relay, err := buildRelay(relayPayload, pk, session, servicer)
+				if err != nil {
+					return fmt.Errorf(""error building relay from payload: %w"", err)
+				}
+
+				fmt.Printf(""sending trustless relay for %s to %v with payload: %s\n"", applicationAddr, servicer, relayPayload)
+
+				resp, err := sendTrustlessRelay(cmd.Context(), servicer.ServiceUrl, relay)
+				if err != nil {
+					return err
+				}
+
+				fmt.Printf(""HTTP status code: %d\n"", resp.HTTPResponse.StatusCode)
+				fmt.Println(""Response: "", resp.JSON200)
+
+				return nil
+			},
+		},
+	}
+
+	return cmds
+}
+
+// TODO: (QUESTION): do we need/want a cli subcommand for fetching servicers?
+
+// fetchServicer returns the servicer specified by the <servicer> argument.
+// It validates the following conditions:
+//
+//	A. The <application> argument is the address of an active application
+//	B. The <servicer> is the address of a servicer that is active in the application's current session.
+//
+// TODO: (SUGGESTION) use a package-internal interface for servicer and application?
+// TODO: (SUGGESTION) use a struct as input to combine all fields (same for output)
+func fetchServicer(ctx context.Context, appAddress, chain, servicerAddress string) (rpc.Session, rpc.ProtocolActor, error) {
+	// TECHDEBT: cache session data
+	session, err := getCurrentSession(ctx, appAddress, chain)
+	if err != nil {
+		return rpc.Session{}, rpc.ProtocolActor{}, fmt.Errorf(""Error getting servicer: %w"", err)
+	}
+
+	var (
+		servicer rpc.ProtocolActor
+		found    bool
+	)
+	// TODO: a map may be a better choice for storing servicers
+	for _, s := range session.Servicers {
+		if s.Address == servicerAddress {
+			servicer = s
+			found = true
+			break
+		}
+	}
+
+	// TODO: cover with unit tests
+	if !found {
+		return rpc.Session{}, rpc.ProtocolActor{}, fmt.Errorf(""Error getting servicer: address %s does not match any servicers in the session"", servicerAddress)
+	}
+
+	// TODO: cover with unit tests
+	found = false
+	for _, ch := range servicer.Chains {
+		if ch == chain {
+			found = true
+			break
+		}
+	}
+
+	if !found {
+		return rpc.Session{}, rpc.ProtocolActor{}, fmt.Errorf(""Error getting servicer: service %s does not support chain %s"", servicerAddress, chain)
+	}
+
+	return *session, servicer, nil
+}
+
+func getCurrentSession(ctx context.Context, appAddress, chain string) (*rpc.Session, error) {
+	// TODO: passing 0 as the height value to get the current session seems more optimal than this.
+	currentHeight, err := getCurrentHeight(ctx)
+	if err != nil {
+		return nil, fmt.Errorf(""Error getting current session: %w"", err)
+	}
+
+	req := rpc.SessionRequest{
+		AppAddress: appAddress,
+		Chain:      chain,
+		// TODO: Geozone
+		SessionHeight: currentHeight,
+	}
+
+	client, err := rpc.NewClientWithResponses(remoteCLIURL)
+	if err != nil {
+		return nil, fmt.Errorf(""Error getting current session for app/chain/height: %s/%s/%d: %w"", appAddress, chain, currentHeight, err)
+	}
+
+	resp, err := client.PostV1ClientGetSessionWithResponse(ctx, req)
+	if err != nil {
+		return nil, fmt.Errorf(""Error getting current session with request %v: %w"", req, err)
+	}
+	// TODO: refactor boiler-plate code
+	if resp.HTTPResponse.StatusCode != http.StatusOK {
+		return nil, fmt.Errorf(""Error getting current session: Unexpected status code %d for request %v"", resp.HTTPResponse.StatusCode, req)
+	}
+
+	if resp.JSON200 == nil {
+		return nil, fmt.Errorf(""Error getting current session: Unexpected response %v"", resp)
+	}
+
+	return resp.JSON200, nil
+}
+
+// TODO: reuse this function in the query commands
+func getCurrentHeight(ctx context.Context) (int64, error) {
+	client, err := rpc.NewClientWithResponses(remoteCLIURL)
+	if err != nil {
+		return 0, fmt.Errorf(""Error getting current height: %w"", err)
+	}
+	resp, err := client.GetV1QueryHeightWithResponse(ctx)
+	if err != nil {
+		return 0, fmt.Errorf(""Error getting current height: %w"", err)
+	}
+	if resp.HTTPResponse.StatusCode != http.StatusOK {
+		return 0, fmt.Errorf(""Error getting current height: Unexpected status code %d"", resp.HTTPResponse.StatusCode)
+	}
+
+	if resp.JSON200 == nil {
+		return 0, fmt.Errorf(""Error getting current height: Unexpected response %v"", resp)
+	}
+
+	return resp.JSON200.Height, nil
+}
+
+// TODO: (localnet) Publish Servicer(s) Host and Port as env. vars in K8s: similar to Validators
+// TODO: (REFACTOR) should we move package-level variables (e.g. remoteCLIURL) to a cli object?
+func sendTrustlessRelay(ctx context.Context, servicerUrl string, relay rpc.RelayRequest) (*rpc.PostV1ClientRelayResponse, error) {
+	client, err := rpc.NewClientWithResponses(servicerUrl)
+	if err != nil {
+		return nil, err
+	}
+
+	return client.PostV1ClientRelayWithResponse(ctx, relay)
+}
+
+// TODO: (NICE) allow reading the relay request from the command line arguments AND from a file
+func buildRelay(payload string, appPrivateKey crypto.PrivateKey, session rpc.Session, servicer rpc.ProtocolActor) (rpc.RelayRequest, error) {
+	// TECHDEBT: This is mostly COPIED from pocket-go: we should refactor pocket-go code and import this functionality from there instead.
+	relayPayload := rpc.Payload{
+		Data:   payload,
+		Method: ""POST"",
+		// TODO: Path: load Path field from the corresponding Blockchain (e.g. database)
+		// TODO: set Headers
+	}
+
+	relayMeta := rpc.RelayRequestMeta{
+		BlockHeight: session.SessionHeight,
+		// TODO: use Identifiable for Chain in Session (or string for Chain in Relay Meta)
+		Chain: rpc.Identifiable{
+			Id: session.Chain,
+		},
+		ServicerPubKey: servicer.PublicKey,
+		// TODO: Geozone
+		// TODO: Token",app/client/cli/servicer.go,2023-05-25 21:20:49+00:00,2023-05-25T21:21:56Z,Remove token,,,,,230,RIGHT,230,,line,https://api.github.com/repos/pokt-network/pocket/pulls/778,pokt-network/pocket,a516c51f2d000d25f1469d28e6586ef7875d5a37
https://api.github.com/repos/pokt-network/pocket/pulls/778,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1206014014,Olshansk,b93c50312e4967daff683ac9fd577e4e5edc2a3b,acec260d9987f4dba2b31bdf4b65f2ef6b654725,"@@ -0,0 +1,284 @@
+package cli
+
+import (
+	""context""
+	sha ""crypto""
+	""encoding/hex""
+	""encoding/json""
+	""fmt""
+	""net/http""
+
+	""github.com/spf13/cobra""
+
+	""github.com/pokt-network/pocket/rpc""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/crypto""
+)
+
+func init() {
+	rootCmd.AddCommand(NewServicerCommand())
+}
+
+// TECHDEBT: (unittest) unit test the command: e.g. on number of arguments
+func NewServicerCommand() *cobra.Command {
+	cmd := &cobra.Command{
+		Use:     ""Servicer"",
+		Short:   ""Servicer specific commands"",
+		Aliases: []string{""servicer""},
+		Args:    cobra.ExactArgs(0),
+	}
+
+	cmds := servicerCommands()
+	applySubcommandOptions(cmds, attachPwdFlagToSubcommands())
+	applySubcommandOptions(cmds, attachKeybaseFlagsToSubcommands())
+
+	cmd.AddCommand(cmds...)
+
+	return cmd
+}
+
+func servicerCommands() []*cobra.Command {
+	cmdDef := actorCmdDef{""Servicer"", coreTypes.ActorType_ACTOR_TYPE_SERVICER}
+	cmds := []*cobra.Command{
+		newStakeCmd(cmdDef),
+		newEditStakeCmd(cmdDef),
+		newUnstakeCmd(cmdDef),
+		newUnpauseCmd(cmdDef),
+		{
+			Use:   ""Relay <servicer> <application> <relayChainID> <payload>"",
+			Short: ""Relay <servicer> <application> <relayChainID> <payload>"",
+			Long: `Sends a trustless relay using <payload> as contents, to the specified active <servicer> in the the <application>'s session.
+Will prompt the user for the *application* account passphrase`,
+			Aliases: []string{},
+			Args:    cobra.ExactArgs(4),
+			RunE: func(cmd *cobra.Command, args []string) error {
+				servicerAddr := args[0]
+				applicationAddr := args[1]
+				chain := args[2]
+				relayPayload := args[3]
+
+				// TODO: (SUGGESTION) refactor to decouple the client logic from the CLI/command
+				pk, err := getPrivateKey(applicationAddr)
+				if err != nil {
+					return fmt.Errorf(""error getting application's private key: %w"", err)
+				}
+
+				session, servicer, err := fetchServicer(cmd.Context(), applicationAddr, chain, servicerAddr)
+				if err != nil {
+					return fmt.Errorf(""error getting servicer for the relay: %w"", err)
+				}
+
+				relay, err := buildRelay(relayPayload, pk, session, servicer)
+				if err != nil {
+					return fmt.Errorf(""error building relay from payload: %w"", err)
+				}
+
+				fmt.Printf(""sending trustless relay for %s to %v with payload: %s\n"", applicationAddr, servicer, relayPayload)
+
+				resp, err := sendTrustlessRelay(cmd.Context(), servicer.ServiceUrl, relay)
+				if err != nil {
+					return err
+				}
+
+				fmt.Printf(""HTTP status code: %d\n"", resp.HTTPResponse.StatusCode)
+				fmt.Println(""Response: "", resp.JSON200)
+
+				return nil
+			},
+		},
+	}
+
+	return cmds
+}
+
+// TODO: (QUESTION): do we need/want a cli subcommand for fetching servicers?
+
+// fetchServicer returns the servicer specified by the <servicer> argument.
+// It validates the following conditions:
+//
+//	A. The <application> argument is the address of an active application
+//	B. The <servicer> is the address of a servicer that is active in the application's current session.
+//
+// TODO: (SUGGESTION) use a package-internal interface for servicer and application?
+// TODO: (SUGGESTION) use a struct as input to combine all fields (same for output)
+func fetchServicer(ctx context.Context, appAddress, chain, servicerAddress string) (rpc.Session, rpc.ProtocolActor, error) {
+	// TECHDEBT: cache session data
+	session, err := getCurrentSession(ctx, appAddress, chain)
+	if err != nil {
+		return rpc.Session{}, rpc.ProtocolActor{}, fmt.Errorf(""Error getting servicer: %w"", err)
+	}
+
+	var (
+		servicer rpc.ProtocolActor
+		found    bool
+	)
+	// TODO: a map may be a better choice for storing servicers
+	for _, s := range session.Servicers {
+		if s.Address == servicerAddress {
+			servicer = s
+			found = true
+			break
+		}
+	}
+
+	// TODO: cover with unit tests
+	if !found {
+		return rpc.Session{}, rpc.ProtocolActor{}, fmt.Errorf(""Error getting servicer: address %s does not match any servicers in the session"", servicerAddress)
+	}
+
+	// TODO: cover with unit tests
+	found = false
+	for _, ch := range servicer.Chains {
+		if ch == chain {
+			found = true
+			break
+		}
+	}
+
+	if !found {
+		return rpc.Session{}, rpc.ProtocolActor{}, fmt.Errorf(""Error getting servicer: service %s does not support chain %s"", servicerAddress, chain)
+	}
+
+	return *session, servicer, nil
+}
+
+func getCurrentSession(ctx context.Context, appAddress, chain string) (*rpc.Session, error) {
+	// TODO: passing 0 as the height value to get the current session seems more optimal than this.
+	currentHeight, err := getCurrentHeight(ctx)
+	if err != nil {
+		return nil, fmt.Errorf(""Error getting current session: %w"", err)
+	}
+
+	req := rpc.SessionRequest{
+		AppAddress: appAddress,
+		Chain:      chain,
+		// TODO: Geozone
+		SessionHeight: currentHeight,
+	}
+
+	client, err := rpc.NewClientWithResponses(remoteCLIURL)
+	if err != nil {
+		return nil, fmt.Errorf(""Error getting current session for app/chain/height: %s/%s/%d: %w"", appAddress, chain, currentHeight, err)
+	}
+
+	resp, err := client.PostV1ClientGetSessionWithResponse(ctx, req)
+	if err != nil {
+		return nil, fmt.Errorf(""Error getting current session with request %v: %w"", req, err)
+	}
+	// TODO: refactor boiler-plate code
+	if resp.HTTPResponse.StatusCode != http.StatusOK {
+		return nil, fmt.Errorf(""Error getting current session: Unexpected status code %d for request %v"", resp.HTTPResponse.StatusCode, req)
+	}
+
+	if resp.JSON200 == nil {
+		return nil, fmt.Errorf(""Error getting current session: Unexpected response %v"", resp)
+	}
+
+	return resp.JSON200, nil
+}
+
+// TODO: reuse this function in the query commands
+func getCurrentHeight(ctx context.Context) (int64, error) {
+	client, err := rpc.NewClientWithResponses(remoteCLIURL)
+	if err != nil {
+		return 0, fmt.Errorf(""Error getting current height: %w"", err)
+	}
+	resp, err := client.GetV1QueryHeightWithResponse(ctx)
+	if err != nil {
+		return 0, fmt.Errorf(""Error getting current height: %w"", err)
+	}
+	if resp.HTTPResponse.StatusCode != http.StatusOK {
+		return 0, fmt.Errorf(""Error getting current height: Unexpected status code %d"", resp.HTTPResponse.StatusCode)
+	}
+
+	if resp.JSON200 == nil {
+		return 0, fmt.Errorf(""Error getting current height: Unexpected response %v"", resp)
+	}
+
+	return resp.JSON200.Height, nil
+}
+
+// TODO: (localnet) Publish Servicer(s) Host and Port as env. vars in K8s: similar to Validators
+// TODO: (REFACTOR) should we move package-level variables (e.g. remoteCLIURL) to a cli object?
+func sendTrustlessRelay(ctx context.Context, servicerUrl string, relay rpc.RelayRequest) (*rpc.PostV1ClientRelayResponse, error) {
+	client, err := rpc.NewClientWithResponses(servicerUrl)
+	if err != nil {
+		return nil, err
+	}
+
+	return client.PostV1ClientRelayWithResponse(ctx, relay)
+}
+
+// TODO: (NICE) allow reading the relay request from the command line arguments AND from a file
+func buildRelay(payload string, appPrivateKey crypto.PrivateKey, session rpc.Session, servicer rpc.ProtocolActor) (rpc.RelayRequest, error) {
+	// TECHDEBT: This is mostly COPIED from pocket-go: we should refactor pocket-go code and import this functionality from there instead.
+	relayPayload := rpc.Payload{
+		Data:   payload,
+		Method: ""POST"",
+		// TODO: Path: load Path field from the corresponding Blockchain (e.g. database)
+		// TODO: set Headers
+	}
+
+	relayMeta := rpc.RelayRequestMeta{
+		BlockHeight: session.SessionHeight,
+		// TODO: use Identifiable for Chain in Session (or string for Chain in Relay Meta)
+		Chain: rpc.Identifiable{
+			Id: session.Chain,
+		},
+		ServicerPubKey: servicer.PublicKey,
+		// TODO: Geozone",app/client/cli/servicer.go,2023-05-25 21:21:04+00:00,2023-05-25T21:21:56Z,"Add the same github issue related to geozones as what I pasted to above
",,,,,229,RIGHT,229,,line,https://api.github.com/repos/pokt-network/pocket/pulls/778,pokt-network/pocket,a516c51f2d000d25f1469d28e6586ef7875d5a37
https://api.github.com/repos/pokt-network/pocket/pulls/778,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1206014097,Olshansk,b93c50312e4967daff683ac9fd577e4e5edc2a3b,acec260d9987f4dba2b31bdf4b65f2ef6b654725,"@@ -0,0 +1,284 @@
+package cli
+
+import (
+	""context""
+	sha ""crypto""
+	""encoding/hex""
+	""encoding/json""
+	""fmt""
+	""net/http""
+
+	""github.com/spf13/cobra""
+
+	""github.com/pokt-network/pocket/rpc""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/crypto""
+)
+
+func init() {
+	rootCmd.AddCommand(NewServicerCommand())
+}
+
+// TECHDEBT: (unittest) unit test the command: e.g. on number of arguments
+func NewServicerCommand() *cobra.Command {
+	cmd := &cobra.Command{
+		Use:     ""Servicer"",
+		Short:   ""Servicer specific commands"",
+		Aliases: []string{""servicer""},
+		Args:    cobra.ExactArgs(0),
+	}
+
+	cmds := servicerCommands()
+	applySubcommandOptions(cmds, attachPwdFlagToSubcommands())
+	applySubcommandOptions(cmds, attachKeybaseFlagsToSubcommands())
+
+	cmd.AddCommand(cmds...)
+
+	return cmd
+}
+
+func servicerCommands() []*cobra.Command {
+	cmdDef := actorCmdDef{""Servicer"", coreTypes.ActorType_ACTOR_TYPE_SERVICER}
+	cmds := []*cobra.Command{
+		newStakeCmd(cmdDef),
+		newEditStakeCmd(cmdDef),
+		newUnstakeCmd(cmdDef),
+		newUnpauseCmd(cmdDef),
+		{
+			Use:   ""Relay <servicer> <application> <relayChainID> <payload>"",
+			Short: ""Relay <servicer> <application> <relayChainID> <payload>"",
+			Long: `Sends a trustless relay using <payload> as contents, to the specified active <servicer> in the the <application>'s session.
+Will prompt the user for the *application* account passphrase`,
+			Aliases: []string{},
+			Args:    cobra.ExactArgs(4),
+			RunE: func(cmd *cobra.Command, args []string) error {
+				servicerAddr := args[0]
+				applicationAddr := args[1]
+				chain := args[2]
+				relayPayload := args[3]
+
+				// TODO: (SUGGESTION) refactor to decouple the client logic from the CLI/command
+				pk, err := getPrivateKey(applicationAddr)
+				if err != nil {
+					return fmt.Errorf(""error getting application's private key: %w"", err)
+				}
+
+				session, servicer, err := fetchServicer(cmd.Context(), applicationAddr, chain, servicerAddr)
+				if err != nil {
+					return fmt.Errorf(""error getting servicer for the relay: %w"", err)
+				}
+
+				relay, err := buildRelay(relayPayload, pk, session, servicer)
+				if err != nil {
+					return fmt.Errorf(""error building relay from payload: %w"", err)
+				}
+
+				fmt.Printf(""sending trustless relay for %s to %v with payload: %s\n"", applicationAddr, servicer, relayPayload)
+
+				resp, err := sendTrustlessRelay(cmd.Context(), servicer.ServiceUrl, relay)
+				if err != nil {
+					return err
+				}
+
+				fmt.Printf(""HTTP status code: %d\n"", resp.HTTPResponse.StatusCode)
+				fmt.Println(""Response: "", resp.JSON200)
+
+				return nil
+			},
+		},
+	}
+
+	return cmds
+}
+
+// TODO: (QUESTION): do we need/want a cli subcommand for fetching servicers?
+
+// fetchServicer returns the servicer specified by the <servicer> argument.
+// It validates the following conditions:
+//
+//	A. The <application> argument is the address of an active application
+//	B. The <servicer> is the address of a servicer that is active in the application's current session.
+//
+// TODO: (SUGGESTION) use a package-internal interface for servicer and application?
+// TODO: (SUGGESTION) use a struct as input to combine all fields (same for output)
+func fetchServicer(ctx context.Context, appAddress, chain, servicerAddress string) (rpc.Session, rpc.ProtocolActor, error) {
+	// TECHDEBT: cache session data
+	session, err := getCurrentSession(ctx, appAddress, chain)
+	if err != nil {
+		return rpc.Session{}, rpc.ProtocolActor{}, fmt.Errorf(""Error getting servicer: %w"", err)
+	}
+
+	var (
+		servicer rpc.ProtocolActor
+		found    bool
+	)
+	// TODO: a map may be a better choice for storing servicers
+	for _, s := range session.Servicers {
+		if s.Address == servicerAddress {
+			servicer = s
+			found = true
+			break
+		}
+	}
+
+	// TODO: cover with unit tests
+	if !found {
+		return rpc.Session{}, rpc.ProtocolActor{}, fmt.Errorf(""Error getting servicer: address %s does not match any servicers in the session"", servicerAddress)
+	}
+
+	// TODO: cover with unit tests
+	found = false
+	for _, ch := range servicer.Chains {
+		if ch == chain {
+			found = true
+			break
+		}
+	}
+
+	if !found {
+		return rpc.Session{}, rpc.ProtocolActor{}, fmt.Errorf(""Error getting servicer: service %s does not support chain %s"", servicerAddress, chain)
+	}
+
+	return *session, servicer, nil
+}
+
+func getCurrentSession(ctx context.Context, appAddress, chain string) (*rpc.Session, error) {
+	// TODO: passing 0 as the height value to get the current session seems more optimal than this.
+	currentHeight, err := getCurrentHeight(ctx)
+	if err != nil {
+		return nil, fmt.Errorf(""Error getting current session: %w"", err)
+	}
+
+	req := rpc.SessionRequest{
+		AppAddress: appAddress,
+		Chain:      chain,
+		// TODO: Geozone
+		SessionHeight: currentHeight,
+	}
+
+	client, err := rpc.NewClientWithResponses(remoteCLIURL)
+	if err != nil {
+		return nil, fmt.Errorf(""Error getting current session for app/chain/height: %s/%s/%d: %w"", appAddress, chain, currentHeight, err)
+	}
+
+	resp, err := client.PostV1ClientGetSessionWithResponse(ctx, req)
+	if err != nil {
+		return nil, fmt.Errorf(""Error getting current session with request %v: %w"", req, err)
+	}
+	// TODO: refactor boiler-plate code
+	if resp.HTTPResponse.StatusCode != http.StatusOK {
+		return nil, fmt.Errorf(""Error getting current session: Unexpected status code %d for request %v"", resp.HTTPResponse.StatusCode, req)
+	}
+
+	if resp.JSON200 == nil {
+		return nil, fmt.Errorf(""Error getting current session: Unexpected response %v"", resp)
+	}
+
+	return resp.JSON200, nil
+}
+
+// TODO: reuse this function in the query commands
+func getCurrentHeight(ctx context.Context) (int64, error) {
+	client, err := rpc.NewClientWithResponses(remoteCLIURL)
+	if err != nil {
+		return 0, fmt.Errorf(""Error getting current height: %w"", err)
+	}
+	resp, err := client.GetV1QueryHeightWithResponse(ctx)
+	if err != nil {
+		return 0, fmt.Errorf(""Error getting current height: %w"", err)
+	}
+	if resp.HTTPResponse.StatusCode != http.StatusOK {
+		return 0, fmt.Errorf(""Error getting current height: Unexpected status code %d"", resp.HTTPResponse.StatusCode)
+	}
+
+	if resp.JSON200 == nil {
+		return 0, fmt.Errorf(""Error getting current height: Unexpected response %v"", resp)
+	}
+
+	return resp.JSON200.Height, nil
+}
+
+// TODO: (localnet) Publish Servicer(s) Host and Port as env. vars in K8s: similar to Validators
+// TODO: (REFACTOR) should we move package-level variables (e.g. remoteCLIURL) to a cli object?
+func sendTrustlessRelay(ctx context.Context, servicerUrl string, relay rpc.RelayRequest) (*rpc.PostV1ClientRelayResponse, error) {
+	client, err := rpc.NewClientWithResponses(servicerUrl)
+	if err != nil {
+		return nil, err
+	}
+
+	return client.PostV1ClientRelayWithResponse(ctx, relay)
+}
+
+// TODO: (NICE) allow reading the relay request from the command line arguments AND from a file
+func buildRelay(payload string, appPrivateKey crypto.PrivateKey, session rpc.Session, servicer rpc.ProtocolActor) (rpc.RelayRequest, error) {
+	// TECHDEBT: This is mostly COPIED from pocket-go: we should refactor pocket-go code and import this functionality from there instead.",app/client/cli/servicer.go,2023-05-25 21:21:11+00:00,2023-05-25T21:21:56Z,Noted,,,,187.0,214,RIGHT,214,187.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/778,pokt-network/pocket,a516c51f2d000d25f1469d28e6586ef7875d5a37
https://api.github.com/repos/pokt-network/pocket/pulls/778,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1206014512,Olshansk,b93c50312e4967daff683ac9fd577e4e5edc2a3b,acec260d9987f4dba2b31bdf4b65f2ef6b654725,"@@ -0,0 +1,284 @@
+package cli
+
+import (
+	""context""
+	sha ""crypto""
+	""encoding/hex""
+	""encoding/json""
+	""fmt""
+	""net/http""
+
+	""github.com/spf13/cobra""
+
+	""github.com/pokt-network/pocket/rpc""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/crypto""
+)
+
+func init() {
+	rootCmd.AddCommand(NewServicerCommand())
+}
+
+// TECHDEBT: (unittest) unit test the command: e.g. on number of arguments
+func NewServicerCommand() *cobra.Command {
+	cmd := &cobra.Command{
+		Use:     ""Servicer"",
+		Short:   ""Servicer specific commands"",
+		Aliases: []string{""servicer""},
+		Args:    cobra.ExactArgs(0),
+	}
+
+	cmds := servicerCommands()
+	applySubcommandOptions(cmds, attachPwdFlagToSubcommands())
+	applySubcommandOptions(cmds, attachKeybaseFlagsToSubcommands())
+
+	cmd.AddCommand(cmds...)
+
+	return cmd
+}
+
+func servicerCommands() []*cobra.Command {
+	cmdDef := actorCmdDef{""Servicer"", coreTypes.ActorType_ACTOR_TYPE_SERVICER}
+	cmds := []*cobra.Command{
+		newStakeCmd(cmdDef),
+		newEditStakeCmd(cmdDef),
+		newUnstakeCmd(cmdDef),
+		newUnpauseCmd(cmdDef),
+		{
+			Use:   ""Relay <servicer> <application> <relayChainID> <payload>"",
+			Short: ""Relay <servicer> <application> <relayChainID> <payload>"",
+			Long: `Sends a trustless relay using <payload> as contents, to the specified active <servicer> in the the <application>'s session.
+Will prompt the user for the *application* account passphrase`,
+			Aliases: []string{},
+			Args:    cobra.ExactArgs(4),
+			RunE: func(cmd *cobra.Command, args []string) error {
+				servicerAddr := args[0]
+				applicationAddr := args[1]
+				chain := args[2]
+				relayPayload := args[3]
+
+				// TODO: (SUGGESTION) refactor to decouple the client logic from the CLI/command
+				pk, err := getPrivateKey(applicationAddr)
+				if err != nil {
+					return fmt.Errorf(""error getting application's private key: %w"", err)
+				}
+
+				session, servicer, err := fetchServicer(cmd.Context(), applicationAddr, chain, servicerAddr)
+				if err != nil {
+					return fmt.Errorf(""error getting servicer for the relay: %w"", err)
+				}
+
+				relay, err := buildRelay(relayPayload, pk, session, servicer)
+				if err != nil {
+					return fmt.Errorf(""error building relay from payload: %w"", err)
+				}
+
+				fmt.Printf(""sending trustless relay for %s to %v with payload: %s\n"", applicationAddr, servicer, relayPayload)
+
+				resp, err := sendTrustlessRelay(cmd.Context(), servicer.ServiceUrl, relay)
+				if err != nil {
+					return err
+				}
+
+				fmt.Printf(""HTTP status code: %d\n"", resp.HTTPResponse.StatusCode)
+				fmt.Println(""Response: "", resp.JSON200)
+
+				return nil
+			},
+		},
+	}
+
+	return cmds
+}
+
+// TODO: (QUESTION): do we need/want a cli subcommand for fetching servicers?
+
+// fetchServicer returns the servicer specified by the <servicer> argument.
+// It validates the following conditions:
+//
+//	A. The <application> argument is the address of an active application
+//	B. The <servicer> is the address of a servicer that is active in the application's current session.
+//
+// TODO: (SUGGESTION) use a package-internal interface for servicer and application?
+// TODO: (SUGGESTION) use a struct as input to combine all fields (same for output)
+func fetchServicer(ctx context.Context, appAddress, chain, servicerAddress string) (rpc.Session, rpc.ProtocolActor, error) {
+	// TECHDEBT: cache session data
+	session, err := getCurrentSession(ctx, appAddress, chain)
+	if err != nil {
+		return rpc.Session{}, rpc.ProtocolActor{}, fmt.Errorf(""Error getting servicer: %w"", err)
+	}
+
+	var (
+		servicer rpc.ProtocolActor
+		found    bool
+	)
+	// TODO: a map may be a better choice for storing servicers
+	for _, s := range session.Servicers {
+		if s.Address == servicerAddress {
+			servicer = s
+			found = true
+			break
+		}
+	}
+
+	// TODO: cover with unit tests
+	if !found {
+		return rpc.Session{}, rpc.ProtocolActor{}, fmt.Errorf(""Error getting servicer: address %s does not match any servicers in the session"", servicerAddress)
+	}
+
+	// TODO: cover with unit tests
+	found = false
+	for _, ch := range servicer.Chains {
+		if ch == chain {
+			found = true
+			break
+		}
+	}
+
+	if !found {
+		return rpc.Session{}, rpc.ProtocolActor{}, fmt.Errorf(""Error getting servicer: service %s does not support chain %s"", servicerAddress, chain)
+	}
+
+	return *session, servicer, nil
+}
+
+func getCurrentSession(ctx context.Context, appAddress, chain string) (*rpc.Session, error) {
+	// TODO: passing 0 as the height value to get the current session seems more optimal than this.
+	currentHeight, err := getCurrentHeight(ctx)
+	if err != nil {
+		return nil, fmt.Errorf(""Error getting current session: %w"", err)
+	}
+
+	req := rpc.SessionRequest{
+		AppAddress: appAddress,
+		Chain:      chain,
+		// TODO: Geozone
+		SessionHeight: currentHeight,
+	}
+
+	client, err := rpc.NewClientWithResponses(remoteCLIURL)
+	if err != nil {
+		return nil, fmt.Errorf(""Error getting current session for app/chain/height: %s/%s/%d: %w"", appAddress, chain, currentHeight, err)
+	}
+
+	resp, err := client.PostV1ClientGetSessionWithResponse(ctx, req)
+	if err != nil {
+		return nil, fmt.Errorf(""Error getting current session with request %v: %w"", req, err)
+	}
+	// TODO: refactor boiler-plate code
+	if resp.HTTPResponse.StatusCode != http.StatusOK {
+		return nil, fmt.Errorf(""Error getting current session: Unexpected status code %d for request %v"", resp.HTTPResponse.StatusCode, req)
+	}
+
+	if resp.JSON200 == nil {
+		return nil, fmt.Errorf(""Error getting current session: Unexpected response %v"", resp)
+	}
+
+	return resp.JSON200, nil
+}
+
+// TODO: reuse this function in the query commands
+func getCurrentHeight(ctx context.Context) (int64, error) {
+	client, err := rpc.NewClientWithResponses(remoteCLIURL)
+	if err != nil {
+		return 0, fmt.Errorf(""Error getting current height: %w"", err)
+	}
+	resp, err := client.GetV1QueryHeightWithResponse(ctx)
+	if err != nil {
+		return 0, fmt.Errorf(""Error getting current height: %w"", err)
+	}
+	if resp.HTTPResponse.StatusCode != http.StatusOK {
+		return 0, fmt.Errorf(""Error getting current height: Unexpected status code %d"", resp.HTTPResponse.StatusCode)
+	}
+
+	if resp.JSON200 == nil {
+		return 0, fmt.Errorf(""Error getting current height: Unexpected response %v"", resp)
+	}
+
+	return resp.JSON200.Height, nil
+}
+
+// TODO: (localnet) Publish Servicer(s) Host and Port as env. vars in K8s: similar to Validators
+// TODO: (REFACTOR) should we move package-level variables (e.g. remoteCLIURL) to a cli object?
+func sendTrustlessRelay(ctx context.Context, servicerUrl string, relay rpc.RelayRequest) (*rpc.PostV1ClientRelayResponse, error) {
+	client, err := rpc.NewClientWithResponses(servicerUrl)
+	if err != nil {
+		return nil, err
+	}
+
+	return client.PostV1ClientRelayWithResponse(ctx, relay)
+}
+
+// TODO: (NICE) allow reading the relay request from the command line arguments AND from a file
+func buildRelay(payload string, appPrivateKey crypto.PrivateKey, session rpc.Session, servicer rpc.ProtocolActor) (rpc.RelayRequest, error) {
+	// TECHDEBT: This is mostly COPIED from pocket-go: we should refactor pocket-go code and import this functionality from there instead.
+	relayPayload := rpc.Payload{",app/client/cli/servicer.go,2023-05-25 21:21:49+00:00,2023-05-25T21:21:56Z,"Just FYI. As you're working on this, can you also refactor `relay.proto` to enable other request types?

I was thinking something like

```proto
message Relay {
    oneof RelayPayload {
        JSONRPCPayload json_rpc_payload = 1;
        RESTPayload rest_payload = 2;
        GRPCPayload grpc_payload = 3;
        GraphQLPayload graphql_payload = 4;
        WebSocketsPayload websockets_payload = 5;
    }
	...
}
```",,,,188.0,215,RIGHT,215,188.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/778,pokt-network/pocket,a516c51f2d000d25f1469d28e6586ef7875d5a37
https://api.github.com/repos/pokt-network/pocket/pulls/778,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1210818286,Olshansk,3f7c8f63ff1d05e64f8672113a70545632501fca,acec260d9987f4dba2b31bdf4b65f2ef6b654725,"@@ -0,0 +1,243 @@
+package cli
+
+import (
+	""context""
+	""encoding/hex""
+	""encoding/json""
+	""fmt""
+	""net/http""
+
+	""github.com/spf13/cobra""
+
+	""github.com/pokt-network/pocket/rpc""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/crypto""
+)
+
+func init() {
+	rootCmd.AddCommand(NewServicerCommand())
+}
+
+func NewServicerCommand() *cobra.Command {
+	cmd := &cobra.Command{
+		Use:     ""Servicer"",
+		Short:   ""Servicer specific commands"",
+		Aliases: []string{""servicer""},
+		Args:    cobra.ExactArgs(0),
+	}
+
+	cmds := servicerCommands()
+	applySubcommandOptions(cmds, attachPwdFlagToSubcommands())
+	applySubcommandOptions(cmds, attachKeybaseFlagsToSubcommands())
+
+	cmd.AddCommand(cmds...)
+
+	return cmd
+}
+
+func servicerCommands() []*cobra.Command {
+	cmdDef := actorCmdDef{""Servicer"", coreTypes.ActorType_ACTOR_TYPE_SERVICER}
+	cmds := []*cobra.Command{
+		newStakeCmd(cmdDef),
+		newEditStakeCmd(cmdDef),
+		newUnstakeCmd(cmdDef),
+		newUnpauseCmd(cmdDef),
+		{
+			// IMPROVE: allow reading the relay payload from a file",app/client/cli/servicer.go,2023-05-30 20:58:51+00:00,2023-05-30T22:42:12Z,"```suggestion
			// IMPROVE: allow reading the relay payload from a file with the serialized protobuf via [--input_file]
```",,,,,46,RIGHT,46,,line,https://api.github.com/repos/pokt-network/pocket/pulls/778,pokt-network/pocket,a516c51f2d000d25f1469d28e6586ef7875d5a37
https://api.github.com/repos/pokt-network/pocket/pulls/778,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1210828448,Olshansk,3f7c8f63ff1d05e64f8672113a70545632501fca,acec260d9987f4dba2b31bdf4b65f2ef6b654725,"@@ -0,0 +1,243 @@
+package cli
+
+import (
+	""context""
+	""encoding/hex""
+	""encoding/json""
+	""fmt""
+	""net/http""
+
+	""github.com/spf13/cobra""
+
+	""github.com/pokt-network/pocket/rpc""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/crypto""
+)
+
+func init() {
+	rootCmd.AddCommand(NewServicerCommand())
+}
+
+func NewServicerCommand() *cobra.Command {
+	cmd := &cobra.Command{
+		Use:     ""Servicer"",
+		Short:   ""Servicer specific commands"",
+		Aliases: []string{""servicer""},
+		Args:    cobra.ExactArgs(0),
+	}
+
+	cmds := servicerCommands()
+	applySubcommandOptions(cmds, attachPwdFlagToSubcommands())
+	applySubcommandOptions(cmds, attachKeybaseFlagsToSubcommands())
+
+	cmd.AddCommand(cmds...)
+
+	return cmd
+}
+
+func servicerCommands() []*cobra.Command {
+	cmdDef := actorCmdDef{""Servicer"", coreTypes.ActorType_ACTOR_TYPE_SERVICER}
+	cmds := []*cobra.Command{
+		newStakeCmd(cmdDef),
+		newEditStakeCmd(cmdDef),
+		newUnstakeCmd(cmdDef),
+		newUnpauseCmd(cmdDef),
+		{
+			// IMPROVE: allow reading the relay payload from a file
+			Use:   ""Relay <applicationAddrHex> <servicerAddrHex> <relayChainID> <relayPayload>"",
+			Short: ""Relay <applicationAddrHex> <servicerAddrHex> <relayChainID> <relayPayload>"",
+			Long: `Sends a trustless relay using <relayPayload> as contents, to the specified active <servicerAddrHex> in the the <applicationAddrHex>'s session.
+Will prompt the user for the *application* account passphrase`,
+			Aliases: []string{},
+			Args:    cobra.ExactArgs(4),
+			RunE: func(cmd *cobra.Command, args []string) error {
+				applicationAddr := args[0]
+				servicerAddr := args[1]
+				chain := args[2]
+				relayPayload := args[3]
+
+				// REFACTOR: decouple the client logic from the CLI
+				//	The client will: send the trustless relay and return the response (using a single function as entrypoint)
+				//	The CLI will:
+				//		1) extract the required input from the command arguments
+				//		2) call the client function that performs the trustless relay",app/client/cli/servicer.go,2023-05-30 21:11:38+00:00,2023-05-30T22:42:12Z,"```suggestion
				//		2) call the client function (with the inputs above) that performs the trustless relay
```",,,,,63,RIGHT,63,,line,https://api.github.com/repos/pokt-network/pocket/pulls/778,pokt-network/pocket,a516c51f2d000d25f1469d28e6586ef7875d5a37
https://api.github.com/repos/pokt-network/pocket/pulls/778,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1210829395,Olshansk,3f7c8f63ff1d05e64f8672113a70545632501fca,acec260d9987f4dba2b31bdf4b65f2ef6b654725,"@@ -0,0 +1,243 @@
+package cli
+
+import (
+	""context""
+	""encoding/hex""
+	""encoding/json""
+	""fmt""
+	""net/http""
+
+	""github.com/spf13/cobra""
+
+	""github.com/pokt-network/pocket/rpc""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/crypto""
+)
+
+func init() {
+	rootCmd.AddCommand(NewServicerCommand())
+}
+
+func NewServicerCommand() *cobra.Command {
+	cmd := &cobra.Command{
+		Use:     ""Servicer"",
+		Short:   ""Servicer specific commands"",
+		Aliases: []string{""servicer""},
+		Args:    cobra.ExactArgs(0),
+	}
+
+	cmds := servicerCommands()
+	applySubcommandOptions(cmds, attachPwdFlagToSubcommands())
+	applySubcommandOptions(cmds, attachKeybaseFlagsToSubcommands())
+
+	cmd.AddCommand(cmds...)
+
+	return cmd
+}
+
+func servicerCommands() []*cobra.Command {
+	cmdDef := actorCmdDef{""Servicer"", coreTypes.ActorType_ACTOR_TYPE_SERVICER}
+	cmds := []*cobra.Command{
+		newStakeCmd(cmdDef),
+		newEditStakeCmd(cmdDef),
+		newUnstakeCmd(cmdDef),
+		newUnpauseCmd(cmdDef),
+		{
+			// IMPROVE: allow reading the relay payload from a file
+			Use:   ""Relay <applicationAddrHex> <servicerAddrHex> <relayChainID> <relayPayload>"",
+			Short: ""Relay <applicationAddrHex> <servicerAddrHex> <relayChainID> <relayPayload>"",
+			Long: `Sends a trustless relay using <relayPayload> as contents, to the specified active <servicerAddrHex> in the the <applicationAddrHex>'s session.
+Will prompt the user for the *application* account passphrase`,
+			Aliases: []string{},
+			Args:    cobra.ExactArgs(4),
+			RunE: func(cmd *cobra.Command, args []string) error {
+				applicationAddr := args[0]
+				servicerAddr := args[1]
+				chain := args[2]
+				relayPayload := args[3]
+
+				// REFACTOR: decouple the client logic from the CLI
+				//	The client will: send the trustless relay and return the response (using a single function as entrypoint)
+				//	The CLI will:
+				//		1) extract the required input from the command arguments
+				//		2) call the client function that performs the trustless relay
+				pk, err := getPrivateKeyFromKeybase(applicationAddr)
+				if err != nil {
+					return fmt.Errorf(""error getting application's private key: %w"", err)
+				}
+
+				// TECHDEBT(#791): cache session data
+				session, err := getCurrentSession(cmd.Context(), applicationAddr, chain)
+				if err != nil {
+					return fmt.Errorf(""Error getting current session: %w"", err)
+				}
+
+				servicer, err := validateServicer(cmd.Context(), session, servicerAddr)
+				if err != nil {
+					return fmt.Errorf(""error getting servicer for the relay: %w"", err)
+				}
+
+				relay, err := buildRelay(relayPayload, pk, session, servicer)
+				if err != nil {
+					return fmt.Errorf(""error building relay from payload: %w"", err)
+				}
+
+				fmt.Printf(""sending trustless relay for %s to %v with payload: %s\n"", applicationAddr, servicer, relayPayload)",app/client/cli/servicer.go,2023-05-30 21:12:52+00:00,2023-05-30T22:42:12Z,NIT: Might be easier to read if s/servicer/servicerAddr,,,,,85,RIGHT,85,,line,https://api.github.com/repos/pokt-network/pocket/pulls/778,pokt-network/pocket,a516c51f2d000d25f1469d28e6586ef7875d5a37
https://api.github.com/repos/pokt-network/pocket/pulls/778,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1210830146,Olshansk,3f7c8f63ff1d05e64f8672113a70545632501fca,acec260d9987f4dba2b31bdf4b65f2ef6b654725,"@@ -0,0 +1,243 @@
+package cli
+
+import (
+	""context""
+	""encoding/hex""
+	""encoding/json""
+	""fmt""
+	""net/http""
+
+	""github.com/spf13/cobra""
+
+	""github.com/pokt-network/pocket/rpc""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/crypto""
+)
+
+func init() {
+	rootCmd.AddCommand(NewServicerCommand())
+}
+
+func NewServicerCommand() *cobra.Command {
+	cmd := &cobra.Command{
+		Use:     ""Servicer"",
+		Short:   ""Servicer specific commands"",
+		Aliases: []string{""servicer""},
+		Args:    cobra.ExactArgs(0),
+	}
+
+	cmds := servicerCommands()
+	applySubcommandOptions(cmds, attachPwdFlagToSubcommands())
+	applySubcommandOptions(cmds, attachKeybaseFlagsToSubcommands())
+
+	cmd.AddCommand(cmds...)
+
+	return cmd
+}
+
+func servicerCommands() []*cobra.Command {
+	cmdDef := actorCmdDef{""Servicer"", coreTypes.ActorType_ACTOR_TYPE_SERVICER}
+	cmds := []*cobra.Command{
+		newStakeCmd(cmdDef),
+		newEditStakeCmd(cmdDef),
+		newUnstakeCmd(cmdDef),
+		newUnpauseCmd(cmdDef),
+		{
+			// IMPROVE: allow reading the relay payload from a file
+			Use:   ""Relay <applicationAddrHex> <servicerAddrHex> <relayChainID> <relayPayload>"",
+			Short: ""Relay <applicationAddrHex> <servicerAddrHex> <relayChainID> <relayPayload>"",
+			Long: `Sends a trustless relay using <relayPayload> as contents, to the specified active <servicerAddrHex> in the the <applicationAddrHex>'s session.
+Will prompt the user for the *application* account passphrase`,
+			Aliases: []string{},
+			Args:    cobra.ExactArgs(4),
+			RunE: func(cmd *cobra.Command, args []string) error {
+				applicationAddr := args[0]
+				servicerAddr := args[1]
+				chain := args[2]
+				relayPayload := args[3]
+
+				// REFACTOR: decouple the client logic from the CLI
+				//	The client will: send the trustless relay and return the response (using a single function as entrypoint)
+				//	The CLI will:
+				//		1) extract the required input from the command arguments
+				//		2) call the client function that performs the trustless relay
+				pk, err := getPrivateKeyFromKeybase(applicationAddr)
+				if err != nil {
+					return fmt.Errorf(""error getting application's private key: %w"", err)
+				}
+
+				// TECHDEBT(#791): cache session data
+				session, err := getCurrentSession(cmd.Context(), applicationAddr, chain)
+				if err != nil {
+					return fmt.Errorf(""Error getting current session: %w"", err)
+				}
+
+				servicer, err := validateServicer(cmd.Context(), session, servicerAddr)
+				if err != nil {
+					return fmt.Errorf(""error getting servicer for the relay: %w"", err)
+				}
+
+				relay, err := buildRelay(relayPayload, pk, session, servicer)
+				if err != nil {
+					return fmt.Errorf(""error building relay from payload: %w"", err)
+				}
+
+				fmt.Printf(""sending trustless relay for %s to %v with payload: %s\n"", applicationAddr, servicer, relayPayload)
+
+				resp, err := sendTrustlessRelay(cmd.Context(), servicer.ServiceUrl, relay)
+				if err != nil {
+					return err
+				}
+
+				fmt.Printf(""HTTP status code: %d\n"", resp.HTTPResponse.StatusCode)
+				fmt.Println(""Response: "", resp.JSON200)
+
+				return nil
+			},
+		},
+	}
+
+	return cmds
+}
+
+// DECIDE: do we need/want a cli subcommand for fetching sessions?",app/client/cli/servicer.go,2023-05-30 21:13:56+00:00,2023-05-30T22:42:12Z,"Yes. 

Devs will definitely use it for development, and we can use it for debugging and E2E testing.

Replace the command and modify `DECIDE` to`TODO`.",,,,,103,RIGHT,103,,line,https://api.github.com/repos/pokt-network/pocket/pulls/778,pokt-network/pocket,a516c51f2d000d25f1469d28e6586ef7875d5a37
https://api.github.com/repos/pokt-network/pocket/pulls/778,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1210830397,Olshansk,3f7c8f63ff1d05e64f8672113a70545632501fca,acec260d9987f4dba2b31bdf4b65f2ef6b654725,"@@ -0,0 +1,243 @@
+package cli
+
+import (
+	""context""
+	""encoding/hex""
+	""encoding/json""
+	""fmt""
+	""net/http""
+
+	""github.com/spf13/cobra""
+
+	""github.com/pokt-network/pocket/rpc""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/crypto""
+)
+
+func init() {
+	rootCmd.AddCommand(NewServicerCommand())
+}
+
+func NewServicerCommand() *cobra.Command {
+	cmd := &cobra.Command{
+		Use:     ""Servicer"",
+		Short:   ""Servicer specific commands"",
+		Aliases: []string{""servicer""},
+		Args:    cobra.ExactArgs(0),
+	}
+
+	cmds := servicerCommands()
+	applySubcommandOptions(cmds, attachPwdFlagToSubcommands())
+	applySubcommandOptions(cmds, attachKeybaseFlagsToSubcommands())
+
+	cmd.AddCommand(cmds...)
+
+	return cmd
+}
+
+func servicerCommands() []*cobra.Command {
+	cmdDef := actorCmdDef{""Servicer"", coreTypes.ActorType_ACTOR_TYPE_SERVICER}
+	cmds := []*cobra.Command{
+		newStakeCmd(cmdDef),
+		newEditStakeCmd(cmdDef),
+		newUnstakeCmd(cmdDef),
+		newUnpauseCmd(cmdDef),
+		{
+			// IMPROVE: allow reading the relay payload from a file
+			Use:   ""Relay <applicationAddrHex> <servicerAddrHex> <relayChainID> <relayPayload>"",
+			Short: ""Relay <applicationAddrHex> <servicerAddrHex> <relayChainID> <relayPayload>"",
+			Long: `Sends a trustless relay using <relayPayload> as contents, to the specified active <servicerAddrHex> in the the <applicationAddrHex>'s session.
+Will prompt the user for the *application* account passphrase`,
+			Aliases: []string{},
+			Args:    cobra.ExactArgs(4),
+			RunE: func(cmd *cobra.Command, args []string) error {
+				applicationAddr := args[0]
+				servicerAddr := args[1]
+				chain := args[2]
+				relayPayload := args[3]
+
+				// REFACTOR: decouple the client logic from the CLI
+				//	The client will: send the trustless relay and return the response (using a single function as entrypoint)
+				//	The CLI will:
+				//		1) extract the required input from the command arguments
+				//		2) call the client function that performs the trustless relay
+				pk, err := getPrivateKeyFromKeybase(applicationAddr)
+				if err != nil {
+					return fmt.Errorf(""error getting application's private key: %w"", err)
+				}
+
+				// TECHDEBT(#791): cache session data
+				session, err := getCurrentSession(cmd.Context(), applicationAddr, chain)
+				if err != nil {
+					return fmt.Errorf(""Error getting current session: %w"", err)
+				}
+
+				servicer, err := validateServicer(cmd.Context(), session, servicerAddr)
+				if err != nil {
+					return fmt.Errorf(""error getting servicer for the relay: %w"", err)
+				}
+
+				relay, err := buildRelay(relayPayload, pk, session, servicer)
+				if err != nil {
+					return fmt.Errorf(""error building relay from payload: %w"", err)
+				}
+
+				fmt.Printf(""sending trustless relay for %s to %v with payload: %s\n"", applicationAddr, servicer, relayPayload)
+
+				resp, err := sendTrustlessRelay(cmd.Context(), servicer.ServiceUrl, relay)
+				if err != nil {
+					return err
+				}
+
+				fmt.Printf(""HTTP status code: %d\n"", resp.HTTPResponse.StatusCode)
+				fmt.Println(""Response: "", resp.JSON200)
+
+				return nil
+			},
+		},
+	}
+
+	return cmds
+}
+
+// DECIDE: do we need/want a cli subcommand for fetching sessions?
+// validateServicer returns the servicer specified by the <servicer> argument.
+// It validates that the <servicer> is the address of a servicer that is active in the passed session.",app/client/cli/servicer.go,2023-05-30 21:14:16+00:00,2023-05-30T22:42:12Z,s/passed/current ? ,,,,,105,RIGHT,105,,line,https://api.github.com/repos/pokt-network/pocket/pulls/778,pokt-network/pocket,a516c51f2d000d25f1469d28e6586ef7875d5a37
https://api.github.com/repos/pokt-network/pocket/pulls/778,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1210831781,Olshansk,3f7c8f63ff1d05e64f8672113a70545632501fca,acec260d9987f4dba2b31bdf4b65f2ef6b654725,"@@ -6,24 +6,37 @@ option go_package = ""github.com/pokt-network/pocket/shared/core/types"";
 
 // TECHDEBT: These structures were copied as placeholders from v0 and need to be updated to reflect changes in v1",shared/core/types/proto/relay.proto,2023-05-30 21:16:04+00:00,2023-05-30T22:42:12Z,Remove this TECHDEBT comment,,,,,7,RIGHT,2,,line,https://api.github.com/repos/pokt-network/pocket/pulls/778,pokt-network/pocket,a516c51f2d000d25f1469d28e6586ef7875d5a37
https://api.github.com/repos/pokt-network/pocket/pulls/778,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1210833003,Olshansk,3f7c8f63ff1d05e64f8672113a70545632501fca,acec260d9987f4dba2b31bdf4b65f2ef6b654725,"@@ -123,11 +123,12 @@ paths:
             text/plain:
               example: ""description of failure""
   # TODO: Update this handler and its schemas when the HandleRelay function has been implemented
+  # DISCUSS: do we need separate JSON and JSONRPC endpoints?",rpc/v1/openapi.yaml,2023-05-30 21:17:48+00:00,2023-05-30T22:42:12Z,"We do not. The payload (protobuf) is serialized and the server is responsible for unpacking this. It should be transparent to the user.

Please update the summary and description to reflect this.",,,,,126,RIGHT,4,,line,https://api.github.com/repos/pokt-network/pocket/pulls/778,pokt-network/pocket,a516c51f2d000d25f1469d28e6586ef7875d5a37
https://api.github.com/repos/pokt-network/pocket/pulls/778,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1210847204,Olshansk,3f7c8f63ff1d05e64f8672113a70545632501fca,acec260d9987f4dba2b31bdf4b65f2ef6b654725,"@@ -20,6 +20,7 @@ message Session {
     // CONSIDERATION: Should a single session support multiple geo zones?
     string geo_zone = 6; // the target geographic region where the actors are present
     core.Actor application = 7; // the application that is being served
+    // IMPROVE: a map may be a better choice for storing servicers/fishermen",shared/core/types/proto/session.proto,2023-05-30 21:35:17+00:00,2023-05-30T22:42:12Z,"```suggestion
    // IMPROVE: `map<string, core.Actor>` with the address as the key can simplify and optimize the logic on the clients
```

One piece of feedback I'll provide is adding more context/detail to the TODO-like comments you're adding.

You, as the author, will understand it. I, as the person who has full context, will understand it, but others might not. If we step away from some part of the code, we may be in the same shoes too.

IMO it takes an extra 30 seconds but goes a long way.",,,,,23,RIGHT,4,,line,https://api.github.com/repos/pokt-network/pocket/pulls/778,pokt-network/pocket,a516c51f2d000d25f1469d28e6586ef7875d5a37
https://api.github.com/repos/pokt-network/pocket/pulls/778,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1210848626,Olshansk,3f7c8f63ff1d05e64f8672113a70545632501fca,acec260d9987f4dba2b31bdf4b65f2ef6b654725,"@@ -6,24 +6,37 @@ option go_package = ""github.com/pokt-network/pocket/shared/core/types"";
 
 // TECHDEBT: These structures were copied as placeholders from v0 and need to be updated to reflect changes in v1
 message Relay {
-    RelayPayload payload = 1;
-    RelayMeta meta = 2;
+    RelayMeta meta = 1;
+    oneof RelayPayload {
+        JSONRPCPayload json_rpc_payload = 2;
+        RESTPayload rest_payload = 3;
+        //DISCUSS: content of the following types:
+        // GRPCPayload grpc_payload = 3;
+        // GraphQLPayload graphql_payload = 4;
+        // WebSocketsPayload websockets_payload = 5;
+    }
 }
 
-message RelayPayload {
-    string data = 1;
-    string method = 2;
-    string http_path = 3;
-    map<string, string> headers = 4;
+message RESTPayload {
+    string contents = 1;
+}
+
+message JSONRPCPayload {
+    bytes id = 1;
+    string json_rpc = 2;
+    string method = 3;
+    bytes parameters = 4;
+    // DISCUSS: is HttpPath needed and is it a Meta field or Payload field?
+    string http_path = 5;
+    map<string, string> headers = 6;
 }
 
 message RelayMeta {
     int64 block_height = 1;
     string servicer_public_key = 2;
     Identifiable relay_chain = 3;
     Identifiable geo_zone = 4;
-    AAT token = 5;
-    string signature = 6;
+    string signature = 5;",shared/core/types/proto/relay.proto,2023-05-30 21:37:23+00:00,2023-05-30T22:42:12Z,"```suggestion
    string signature = 5; // TECHDEBT: Consolidate with `Signature` proto used elsewhere in the future
```",,,,,39,RIGHT,43,,line,https://api.github.com/repos/pokt-network/pocket/pulls/778,pokt-network/pocket,a516c51f2d000d25f1469d28e6586ef7875d5a37
https://api.github.com/repos/pokt-network/pocket/pulls/778,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1210849819,Olshansk,3f7c8f63ff1d05e64f8672113a70545632501fca,acec260d9987f4dba2b31bdf4b65f2ef6b654725,"@@ -0,0 +1,243 @@
+package cli
+
+import (
+	""context""
+	""encoding/hex""
+	""encoding/json""
+	""fmt""
+	""net/http""
+
+	""github.com/spf13/cobra""
+
+	""github.com/pokt-network/pocket/rpc""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/crypto""
+)
+
+func init() {
+	rootCmd.AddCommand(NewServicerCommand())
+}
+
+func NewServicerCommand() *cobra.Command {
+	cmd := &cobra.Command{
+		Use:     ""Servicer"",
+		Short:   ""Servicer specific commands"",
+		Aliases: []string{""servicer""},
+		Args:    cobra.ExactArgs(0),
+	}
+
+	cmds := servicerCommands()
+	applySubcommandOptions(cmds, attachPwdFlagToSubcommands())
+	applySubcommandOptions(cmds, attachKeybaseFlagsToSubcommands())
+
+	cmd.AddCommand(cmds...)
+
+	return cmd
+}
+
+func servicerCommands() []*cobra.Command {
+	cmdDef := actorCmdDef{""Servicer"", coreTypes.ActorType_ACTOR_TYPE_SERVICER}
+	cmds := []*cobra.Command{
+		newStakeCmd(cmdDef),
+		newEditStakeCmd(cmdDef),
+		newUnstakeCmd(cmdDef),
+		newUnpauseCmd(cmdDef),
+		{
+			// IMPROVE: allow reading the relay payload from a file
+			Use:   ""Relay <applicationAddrHex> <servicerAddrHex> <relayChainID> <relayPayload>"",
+			Short: ""Relay <applicationAddrHex> <servicerAddrHex> <relayChainID> <relayPayload>"",
+			Long: `Sends a trustless relay using <relayPayload> as contents, to the specified active <servicerAddrHex> in the the <applicationAddrHex>'s session.
+Will prompt the user for the *application* account passphrase`,
+			Aliases: []string{},
+			Args:    cobra.ExactArgs(4),
+			RunE: func(cmd *cobra.Command, args []string) error {
+				applicationAddr := args[0]
+				servicerAddr := args[1]
+				chain := args[2]
+				relayPayload := args[3]
+
+				// REFACTOR: decouple the client logic from the CLI
+				//	The client will: send the trustless relay and return the response (using a single function as entrypoint)
+				//	The CLI will:
+				//		1) extract the required input from the command arguments
+				//		2) call the client function that performs the trustless relay
+				pk, err := getPrivateKeyFromKeybase(applicationAddr)
+				if err != nil {
+					return fmt.Errorf(""error getting application's private key: %w"", err)
+				}
+
+				// TECHDEBT(#791): cache session data
+				session, err := getCurrentSession(cmd.Context(), applicationAddr, chain)
+				if err != nil {
+					return fmt.Errorf(""Error getting current session: %w"", err)
+				}
+
+				servicer, err := validateServicer(cmd.Context(), session, servicerAddr)
+				if err != nil {
+					return fmt.Errorf(""error getting servicer for the relay: %w"", err)
+				}
+
+				relay, err := buildRelay(relayPayload, pk, session, servicer)
+				if err != nil {
+					return fmt.Errorf(""error building relay from payload: %w"", err)
+				}
+
+				fmt.Printf(""sending trustless relay for %s to %v with payload: %s\n"", applicationAddr, servicer, relayPayload)
+
+				resp, err := sendTrustlessRelay(cmd.Context(), servicer.ServiceUrl, relay)
+				if err != nil {
+					return err
+				}
+
+				fmt.Printf(""HTTP status code: %d\n"", resp.HTTPResponse.StatusCode)
+				fmt.Println(""Response: "", resp.JSON200)
+
+				return nil",app/client/cli/servicer.go,2023-05-30 21:39:09+00:00,2023-05-30T22:42:12Z,"Nice, I like how clean & easy to read this is.",,,,96.0,95,RIGHT,95,96.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/778,pokt-network/pocket,a516c51f2d000d25f1469d28e6586ef7875d5a37
https://api.github.com/repos/pokt-network/pocket/pulls/778,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1210850419,Olshansk,3f7c8f63ff1d05e64f8672113a70545632501fca,acec260d9987f4dba2b31bdf4b65f2ef6b654725,"@@ -0,0 +1,243 @@
+package cli
+
+import (
+	""context""
+	""encoding/hex""
+	""encoding/json""
+	""fmt""
+	""net/http""
+
+	""github.com/spf13/cobra""
+
+	""github.com/pokt-network/pocket/rpc""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/crypto""
+)
+
+func init() {
+	rootCmd.AddCommand(NewServicerCommand())
+}
+
+func NewServicerCommand() *cobra.Command {
+	cmd := &cobra.Command{
+		Use:     ""Servicer"",
+		Short:   ""Servicer specific commands"",
+		Aliases: []string{""servicer""},
+		Args:    cobra.ExactArgs(0),
+	}
+
+	cmds := servicerCommands()
+	applySubcommandOptions(cmds, attachPwdFlagToSubcommands())
+	applySubcommandOptions(cmds, attachKeybaseFlagsToSubcommands())
+
+	cmd.AddCommand(cmds...)
+
+	return cmd
+}
+
+func servicerCommands() []*cobra.Command {
+	cmdDef := actorCmdDef{""Servicer"", coreTypes.ActorType_ACTOR_TYPE_SERVICER}
+	cmds := []*cobra.Command{
+		newStakeCmd(cmdDef),
+		newEditStakeCmd(cmdDef),
+		newUnstakeCmd(cmdDef),
+		newUnpauseCmd(cmdDef),
+		{
+			// IMPROVE: allow reading the relay payload from a file
+			Use:   ""Relay <applicationAddrHex> <servicerAddrHex> <relayChainID> <relayPayload>"",
+			Short: ""Relay <applicationAddrHex> <servicerAddrHex> <relayChainID> <relayPayload>"",
+			Long: `Sends a trustless relay using <relayPayload> as contents, to the specified active <servicerAddrHex> in the the <applicationAddrHex>'s session.
+Will prompt the user for the *application* account passphrase`,
+			Aliases: []string{},
+			Args:    cobra.ExactArgs(4),
+			RunE: func(cmd *cobra.Command, args []string) error {
+				applicationAddr := args[0]
+				servicerAddr := args[1]
+				chain := args[2]
+				relayPayload := args[3]
+
+				// REFACTOR: decouple the client logic from the CLI
+				//	The client will: send the trustless relay and return the response (using a single function as entrypoint)
+				//	The CLI will:
+				//		1) extract the required input from the command arguments
+				//		2) call the client function that performs the trustless relay
+				pk, err := getPrivateKeyFromKeybase(applicationAddr)
+				if err != nil {
+					return fmt.Errorf(""error getting application's private key: %w"", err)
+				}
+
+				// TECHDEBT(#791): cache session data
+				session, err := getCurrentSession(cmd.Context(), applicationAddr, chain)
+				if err != nil {
+					return fmt.Errorf(""Error getting current session: %w"", err)
+				}
+
+				servicer, err := validateServicer(cmd.Context(), session, servicerAddr)
+				if err != nil {
+					return fmt.Errorf(""error getting servicer for the relay: %w"", err)
+				}
+
+				relay, err := buildRelay(relayPayload, pk, session, servicer)
+				if err != nil {
+					return fmt.Errorf(""error building relay from payload: %w"", err)
+				}
+
+				fmt.Printf(""sending trustless relay for %s to %v with payload: %s\n"", applicationAddr, servicer, relayPayload)
+
+				resp, err := sendTrustlessRelay(cmd.Context(), servicer.ServiceUrl, relay)
+				if err != nil {
+					return err
+				}
+
+				fmt.Printf(""HTTP status code: %d\n"", resp.HTTPResponse.StatusCode)
+				fmt.Println(""Response: "", resp.JSON200)
+
+				return nil
+			},
+		},
+	}
+
+	return cmds
+}
+
+// DECIDE: do we need/want a cli subcommand for fetching sessions?
+// validateServicer returns the servicer specified by the <servicer> argument.
+// It validates that the <servicer> is the address of a servicer that is active in the passed session.
+func validateServicer(ctx context.Context, session *rpc.Session, servicerAddress string) (*rpc.ProtocolActor, error) {
+	for _, s := range session.Servicers {
+		if s.Address == servicerAddress {
+			return &s, nil
+		}
+	}
+
+	// ADDTEST: cover with gherkin tests
+	return nil, fmt.Errorf(""Error getting servicer: address %s does not match any servicers in the session %d"", servicerAddress, session.SessionNumber)
+}
+
+func getCurrentSession(ctx context.Context, appAddress, chain string) (*rpc.Session, error) {
+	// CONSIDERATION: passing 0 as the height value to get the current session seems more optimal than this.
+	currentHeight, err := getCurrentHeight(ctx)
+	if err != nil {
+		return nil, fmt.Errorf(""Error getting current session: %w"", err)
+	}
+
+	req := rpc.SessionRequest{
+		AppAddress: appAddress,
+		Chain:      chain,
+		// TODO(#697): Geozone
+		SessionHeight: currentHeight,
+	}
+
+	client, err := rpc.NewClientWithResponses(remoteCLIURL)
+	if err != nil {
+		return nil, fmt.Errorf(""Error getting current session for app/chain/height: %s/%s/%d: %w"", appAddress, chain, currentHeight, err)
+	}
+
+	resp, err := client.PostV1ClientGetSessionWithResponse(ctx, req)
+	if err != nil {
+		return nil, fmt.Errorf(""Error getting current session with request %v: %w"", req, err)
+	}",app/client/cli/servicer.go,2023-05-30 21:40:02+00:00,2023-05-30T22:42:12Z,"```suggestion
	}
	
```",,,,140.0,139,RIGHT,139,140.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/778,pokt-network/pocket,a516c51f2d000d25f1469d28e6586ef7875d5a37
https://api.github.com/repos/pokt-network/pocket/pulls/778,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1210850666,Olshansk,3f7c8f63ff1d05e64f8672113a70545632501fca,acec260d9987f4dba2b31bdf4b65f2ef6b654725,"@@ -0,0 +1,243 @@
+package cli
+
+import (
+	""context""
+	""encoding/hex""
+	""encoding/json""
+	""fmt""
+	""net/http""
+
+	""github.com/spf13/cobra""
+
+	""github.com/pokt-network/pocket/rpc""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/crypto""
+)
+
+func init() {
+	rootCmd.AddCommand(NewServicerCommand())
+}
+
+func NewServicerCommand() *cobra.Command {
+	cmd := &cobra.Command{
+		Use:     ""Servicer"",
+		Short:   ""Servicer specific commands"",
+		Aliases: []string{""servicer""},
+		Args:    cobra.ExactArgs(0),
+	}
+
+	cmds := servicerCommands()
+	applySubcommandOptions(cmds, attachPwdFlagToSubcommands())
+	applySubcommandOptions(cmds, attachKeybaseFlagsToSubcommands())
+
+	cmd.AddCommand(cmds...)
+
+	return cmd
+}
+
+func servicerCommands() []*cobra.Command {
+	cmdDef := actorCmdDef{""Servicer"", coreTypes.ActorType_ACTOR_TYPE_SERVICER}
+	cmds := []*cobra.Command{
+		newStakeCmd(cmdDef),
+		newEditStakeCmd(cmdDef),
+		newUnstakeCmd(cmdDef),
+		newUnpauseCmd(cmdDef),
+		{
+			// IMPROVE: allow reading the relay payload from a file
+			Use:   ""Relay <applicationAddrHex> <servicerAddrHex> <relayChainID> <relayPayload>"",
+			Short: ""Relay <applicationAddrHex> <servicerAddrHex> <relayChainID> <relayPayload>"",
+			Long: `Sends a trustless relay using <relayPayload> as contents, to the specified active <servicerAddrHex> in the the <applicationAddrHex>'s session.
+Will prompt the user for the *application* account passphrase`,
+			Aliases: []string{},
+			Args:    cobra.ExactArgs(4),
+			RunE: func(cmd *cobra.Command, args []string) error {
+				applicationAddr := args[0]
+				servicerAddr := args[1]
+				chain := args[2]
+				relayPayload := args[3]
+
+				// REFACTOR: decouple the client logic from the CLI
+				//	The client will: send the trustless relay and return the response (using a single function as entrypoint)
+				//	The CLI will:
+				//		1) extract the required input from the command arguments
+				//		2) call the client function that performs the trustless relay
+				pk, err := getPrivateKeyFromKeybase(applicationAddr)
+				if err != nil {
+					return fmt.Errorf(""error getting application's private key: %w"", err)
+				}
+
+				// TECHDEBT(#791): cache session data
+				session, err := getCurrentSession(cmd.Context(), applicationAddr, chain)
+				if err != nil {
+					return fmt.Errorf(""Error getting current session: %w"", err)
+				}
+
+				servicer, err := validateServicer(cmd.Context(), session, servicerAddr)
+				if err != nil {
+					return fmt.Errorf(""error getting servicer for the relay: %w"", err)
+				}
+
+				relay, err := buildRelay(relayPayload, pk, session, servicer)
+				if err != nil {
+					return fmt.Errorf(""error building relay from payload: %w"", err)
+				}
+
+				fmt.Printf(""sending trustless relay for %s to %v with payload: %s\n"", applicationAddr, servicer, relayPayload)
+
+				resp, err := sendTrustlessRelay(cmd.Context(), servicer.ServiceUrl, relay)
+				if err != nil {
+					return err
+				}
+
+				fmt.Printf(""HTTP status code: %d\n"", resp.HTTPResponse.StatusCode)
+				fmt.Println(""Response: "", resp.JSON200)
+
+				return nil
+			},
+		},
+	}
+
+	return cmds
+}
+
+// DECIDE: do we need/want a cli subcommand for fetching sessions?
+// validateServicer returns the servicer specified by the <servicer> argument.
+// It validates that the <servicer> is the address of a servicer that is active in the passed session.
+func validateServicer(ctx context.Context, session *rpc.Session, servicerAddress string) (*rpc.ProtocolActor, error) {
+	for _, s := range session.Servicers {
+		if s.Address == servicerAddress {
+			return &s, nil
+		}
+	}
+
+	// ADDTEST: cover with gherkin tests
+	return nil, fmt.Errorf(""Error getting servicer: address %s does not match any servicers in the session %d"", servicerAddress, session.SessionNumber)
+}
+
+func getCurrentSession(ctx context.Context, appAddress, chain string) (*rpc.Session, error) {
+	// CONSIDERATION: passing 0 as the height value to get the current session seems more optimal than this.
+	currentHeight, err := getCurrentHeight(ctx)
+	if err != nil {
+		return nil, fmt.Errorf(""Error getting current session: %w"", err)
+	}
+
+	req := rpc.SessionRequest{
+		AppAddress: appAddress,
+		Chain:      chain,
+		// TODO(#697): Geozone
+		SessionHeight: currentHeight,
+	}
+
+	client, err := rpc.NewClientWithResponses(remoteCLIURL)
+	if err != nil {
+		return nil, fmt.Errorf(""Error getting current session for app/chain/height: %s/%s/%d: %w"", appAddress, chain, currentHeight, err)
+	}
+
+	resp, err := client.PostV1ClientGetSessionWithResponse(ctx, req)
+	if err != nil {
+		return nil, fmt.Errorf(""Error getting current session with request %v: %w"", req, err)
+	}
+	// TODO: refactor boiler-plate code",app/client/cli/servicer.go,2023-05-30 21:40:18+00:00,2023-05-30T22:42:12Z,What do you mean by this?,,,,,140,RIGHT,140,,line,https://api.github.com/repos/pokt-network/pocket/pulls/778,pokt-network/pocket,a516c51f2d000d25f1469d28e6586ef7875d5a37
https://api.github.com/repos/pokt-network/pocket/pulls/778,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1210850937,Olshansk,3f7c8f63ff1d05e64f8672113a70545632501fca,acec260d9987f4dba2b31bdf4b65f2ef6b654725,"@@ -0,0 +1,243 @@
+package cli
+
+import (
+	""context""
+	""encoding/hex""
+	""encoding/json""
+	""fmt""
+	""net/http""
+
+	""github.com/spf13/cobra""
+
+	""github.com/pokt-network/pocket/rpc""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/crypto""
+)
+
+func init() {
+	rootCmd.AddCommand(NewServicerCommand())
+}
+
+func NewServicerCommand() *cobra.Command {
+	cmd := &cobra.Command{
+		Use:     ""Servicer"",
+		Short:   ""Servicer specific commands"",
+		Aliases: []string{""servicer""},
+		Args:    cobra.ExactArgs(0),
+	}
+
+	cmds := servicerCommands()
+	applySubcommandOptions(cmds, attachPwdFlagToSubcommands())
+	applySubcommandOptions(cmds, attachKeybaseFlagsToSubcommands())
+
+	cmd.AddCommand(cmds...)
+
+	return cmd
+}
+
+func servicerCommands() []*cobra.Command {
+	cmdDef := actorCmdDef{""Servicer"", coreTypes.ActorType_ACTOR_TYPE_SERVICER}
+	cmds := []*cobra.Command{
+		newStakeCmd(cmdDef),
+		newEditStakeCmd(cmdDef),
+		newUnstakeCmd(cmdDef),
+		newUnpauseCmd(cmdDef),
+		{
+			// IMPROVE: allow reading the relay payload from a file
+			Use:   ""Relay <applicationAddrHex> <servicerAddrHex> <relayChainID> <relayPayload>"",
+			Short: ""Relay <applicationAddrHex> <servicerAddrHex> <relayChainID> <relayPayload>"",
+			Long: `Sends a trustless relay using <relayPayload> as contents, to the specified active <servicerAddrHex> in the the <applicationAddrHex>'s session.
+Will prompt the user for the *application* account passphrase`,
+			Aliases: []string{},
+			Args:    cobra.ExactArgs(4),
+			RunE: func(cmd *cobra.Command, args []string) error {
+				applicationAddr := args[0]
+				servicerAddr := args[1]
+				chain := args[2]
+				relayPayload := args[3]
+
+				// REFACTOR: decouple the client logic from the CLI
+				//	The client will: send the trustless relay and return the response (using a single function as entrypoint)
+				//	The CLI will:
+				//		1) extract the required input from the command arguments
+				//		2) call the client function that performs the trustless relay
+				pk, err := getPrivateKeyFromKeybase(applicationAddr)
+				if err != nil {
+					return fmt.Errorf(""error getting application's private key: %w"", err)
+				}
+
+				// TECHDEBT(#791): cache session data
+				session, err := getCurrentSession(cmd.Context(), applicationAddr, chain)
+				if err != nil {
+					return fmt.Errorf(""Error getting current session: %w"", err)
+				}
+
+				servicer, err := validateServicer(cmd.Context(), session, servicerAddr)
+				if err != nil {
+					return fmt.Errorf(""error getting servicer for the relay: %w"", err)
+				}
+
+				relay, err := buildRelay(relayPayload, pk, session, servicer)
+				if err != nil {
+					return fmt.Errorf(""error building relay from payload: %w"", err)
+				}
+
+				fmt.Printf(""sending trustless relay for %s to %v with payload: %s\n"", applicationAddr, servicer, relayPayload)
+
+				resp, err := sendTrustlessRelay(cmd.Context(), servicer.ServiceUrl, relay)
+				if err != nil {
+					return err
+				}
+
+				fmt.Printf(""HTTP status code: %d\n"", resp.HTTPResponse.StatusCode)
+				fmt.Println(""Response: "", resp.JSON200)
+
+				return nil
+			},
+		},
+	}
+
+	return cmds
+}
+
+// DECIDE: do we need/want a cli subcommand for fetching sessions?
+// validateServicer returns the servicer specified by the <servicer> argument.
+// It validates that the <servicer> is the address of a servicer that is active in the passed session.
+func validateServicer(ctx context.Context, session *rpc.Session, servicerAddress string) (*rpc.ProtocolActor, error) {
+	for _, s := range session.Servicers {
+		if s.Address == servicerAddress {
+			return &s, nil
+		}
+	}
+
+	// ADDTEST: cover with gherkin tests
+	return nil, fmt.Errorf(""Error getting servicer: address %s does not match any servicers in the session %d"", servicerAddress, session.SessionNumber)
+}
+
+func getCurrentSession(ctx context.Context, appAddress, chain string) (*rpc.Session, error) {
+	// CONSIDERATION: passing 0 as the height value to get the current session seems more optimal than this.
+	currentHeight, err := getCurrentHeight(ctx)
+	if err != nil {
+		return nil, fmt.Errorf(""Error getting current session: %w"", err)
+	}
+
+	req := rpc.SessionRequest{
+		AppAddress: appAddress,
+		Chain:      chain,
+		// TODO(#697): Geozone
+		SessionHeight: currentHeight,
+	}
+
+	client, err := rpc.NewClientWithResponses(remoteCLIURL)
+	if err != nil {
+		return nil, fmt.Errorf(""Error getting current session for app/chain/height: %s/%s/%d: %w"", appAddress, chain, currentHeight, err)
+	}
+
+	resp, err := client.PostV1ClientGetSessionWithResponse(ctx, req)
+	if err != nil {
+		return nil, fmt.Errorf(""Error getting current session with request %v: %w"", req, err)
+	}
+	// TODO: refactor boiler-plate code
+	if resp.HTTPResponse.StatusCode != http.StatusOK {
+		return nil, fmt.Errorf(""Error getting current session: Unexpected status code %d for request %v"", resp.HTTPResponse.StatusCode, req)
+	}
+
+	if resp.JSON200 == nil {
+		return nil, fmt.Errorf(""Error getting current session: Unexpected response %v"", resp)
+	}
+
+	return resp.JSON200, nil
+}
+
+// TODO: reuse this function in the query commands",app/client/cli/servicer.go,2023-05-30 21:40:42+00:00,2023-05-30T22:42:12Z,"```suggestion
// REFACTOR: reuse this function in all the query commands
```",,,,,152,RIGHT,152,,line,https://api.github.com/repos/pokt-network/pocket/pulls/778,pokt-network/pocket,a516c51f2d000d25f1469d28e6586ef7875d5a37
https://api.github.com/repos/pokt-network/pocket/pulls/778,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1210851415,Olshansk,3f7c8f63ff1d05e64f8672113a70545632501fca,acec260d9987f4dba2b31bdf4b65f2ef6b654725,"@@ -0,0 +1,243 @@
+package cli
+
+import (
+	""context""
+	""encoding/hex""
+	""encoding/json""
+	""fmt""
+	""net/http""
+
+	""github.com/spf13/cobra""
+
+	""github.com/pokt-network/pocket/rpc""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/crypto""
+)
+
+func init() {
+	rootCmd.AddCommand(NewServicerCommand())
+}
+
+func NewServicerCommand() *cobra.Command {
+	cmd := &cobra.Command{
+		Use:     ""Servicer"",
+		Short:   ""Servicer specific commands"",
+		Aliases: []string{""servicer""},
+		Args:    cobra.ExactArgs(0),
+	}
+
+	cmds := servicerCommands()
+	applySubcommandOptions(cmds, attachPwdFlagToSubcommands())
+	applySubcommandOptions(cmds, attachKeybaseFlagsToSubcommands())
+
+	cmd.AddCommand(cmds...)
+
+	return cmd
+}
+
+func servicerCommands() []*cobra.Command {
+	cmdDef := actorCmdDef{""Servicer"", coreTypes.ActorType_ACTOR_TYPE_SERVICER}
+	cmds := []*cobra.Command{
+		newStakeCmd(cmdDef),
+		newEditStakeCmd(cmdDef),
+		newUnstakeCmd(cmdDef),
+		newUnpauseCmd(cmdDef),
+		{
+			// IMPROVE: allow reading the relay payload from a file
+			Use:   ""Relay <applicationAddrHex> <servicerAddrHex> <relayChainID> <relayPayload>"",
+			Short: ""Relay <applicationAddrHex> <servicerAddrHex> <relayChainID> <relayPayload>"",
+			Long: `Sends a trustless relay using <relayPayload> as contents, to the specified active <servicerAddrHex> in the the <applicationAddrHex>'s session.
+Will prompt the user for the *application* account passphrase`,
+			Aliases: []string{},
+			Args:    cobra.ExactArgs(4),
+			RunE: func(cmd *cobra.Command, args []string) error {
+				applicationAddr := args[0]
+				servicerAddr := args[1]
+				chain := args[2]
+				relayPayload := args[3]
+
+				// REFACTOR: decouple the client logic from the CLI
+				//	The client will: send the trustless relay and return the response (using a single function as entrypoint)
+				//	The CLI will:
+				//		1) extract the required input from the command arguments
+				//		2) call the client function that performs the trustless relay
+				pk, err := getPrivateKeyFromKeybase(applicationAddr)
+				if err != nil {
+					return fmt.Errorf(""error getting application's private key: %w"", err)
+				}
+
+				// TECHDEBT(#791): cache session data
+				session, err := getCurrentSession(cmd.Context(), applicationAddr, chain)
+				if err != nil {
+					return fmt.Errorf(""Error getting current session: %w"", err)
+				}
+
+				servicer, err := validateServicer(cmd.Context(), session, servicerAddr)
+				if err != nil {
+					return fmt.Errorf(""error getting servicer for the relay: %w"", err)
+				}
+
+				relay, err := buildRelay(relayPayload, pk, session, servicer)
+				if err != nil {
+					return fmt.Errorf(""error building relay from payload: %w"", err)
+				}
+
+				fmt.Printf(""sending trustless relay for %s to %v with payload: %s\n"", applicationAddr, servicer, relayPayload)
+
+				resp, err := sendTrustlessRelay(cmd.Context(), servicer.ServiceUrl, relay)
+				if err != nil {
+					return err
+				}
+
+				fmt.Printf(""HTTP status code: %d\n"", resp.HTTPResponse.StatusCode)
+				fmt.Println(""Response: "", resp.JSON200)
+
+				return nil
+			},
+		},
+	}
+
+	return cmds
+}
+
+// DECIDE: do we need/want a cli subcommand for fetching sessions?
+// validateServicer returns the servicer specified by the <servicer> argument.
+// It validates that the <servicer> is the address of a servicer that is active in the passed session.
+func validateServicer(ctx context.Context, session *rpc.Session, servicerAddress string) (*rpc.ProtocolActor, error) {
+	for _, s := range session.Servicers {
+		if s.Address == servicerAddress {
+			return &s, nil
+		}
+	}
+
+	// ADDTEST: cover with gherkin tests
+	return nil, fmt.Errorf(""Error getting servicer: address %s does not match any servicers in the session %d"", servicerAddress, session.SessionNumber)
+}
+
+func getCurrentSession(ctx context.Context, appAddress, chain string) (*rpc.Session, error) {
+	// CONSIDERATION: passing 0 as the height value to get the current session seems more optimal than this.
+	currentHeight, err := getCurrentHeight(ctx)
+	if err != nil {
+		return nil, fmt.Errorf(""Error getting current session: %w"", err)
+	}
+
+	req := rpc.SessionRequest{
+		AppAddress: appAddress,
+		Chain:      chain,
+		// TODO(#697): Geozone
+		SessionHeight: currentHeight,
+	}
+
+	client, err := rpc.NewClientWithResponses(remoteCLIURL)
+	if err != nil {
+		return nil, fmt.Errorf(""Error getting current session for app/chain/height: %s/%s/%d: %w"", appAddress, chain, currentHeight, err)
+	}
+
+	resp, err := client.PostV1ClientGetSessionWithResponse(ctx, req)
+	if err != nil {
+		return nil, fmt.Errorf(""Error getting current session with request %v: %w"", req, err)
+	}
+	// TODO: refactor boiler-plate code
+	if resp.HTTPResponse.StatusCode != http.StatusOK {
+		return nil, fmt.Errorf(""Error getting current session: Unexpected status code %d for request %v"", resp.HTTPResponse.StatusCode, req)
+	}
+
+	if resp.JSON200 == nil {
+		return nil, fmt.Errorf(""Error getting current session: Unexpected response %v"", resp)
+	}
+
+	return resp.JSON200, nil
+}
+
+// TODO: reuse this function in the query commands
+func getCurrentHeight(ctx context.Context) (int64, error) {
+	client, err := rpc.NewClientWithResponses(remoteCLIURL)
+	if err != nil {
+		return 0, fmt.Errorf(""Error getting current height: %w"", err)
+	}
+	resp, err := client.GetV1QueryHeightWithResponse(ctx)
+	if err != nil {
+		return 0, fmt.Errorf(""Error getting current height: %w"", err)
+	}
+	if resp.HTTPResponse.StatusCode != http.StatusOK {
+		return 0, fmt.Errorf(""Error getting current height: Unexpected status code %d"", resp.HTTPResponse.StatusCode)
+	}
+
+	if resp.JSON200 == nil {
+		return 0, fmt.Errorf(""Error getting current height: Unexpected response %v"", resp)
+	}
+
+	return resp.JSON200.Height, nil
+}
+
+// IMPROVE: [K8s][LocalNet] Publish Servicer(s) Host and Port as env. vars in K8s: similar to Validators",app/client/cli/servicer.go,2023-05-30 21:41:28+00:00,2023-05-30T22:42:12Z,Can you create a ticket with the details and assign it to @okdas?,,,,,173,RIGHT,173,,line,https://api.github.com/repos/pokt-network/pocket/pulls/778,pokt-network/pocket,a516c51f2d000d25f1469d28e6586ef7875d5a37
https://api.github.com/repos/pokt-network/pocket/pulls/778,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1210851806,Olshansk,3f7c8f63ff1d05e64f8672113a70545632501fca,acec260d9987f4dba2b31bdf4b65f2ef6b654725,"@@ -0,0 +1,243 @@
+package cli
+
+import (
+	""context""
+	""encoding/hex""
+	""encoding/json""
+	""fmt""
+	""net/http""
+
+	""github.com/spf13/cobra""
+
+	""github.com/pokt-network/pocket/rpc""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/crypto""
+)
+
+func init() {
+	rootCmd.AddCommand(NewServicerCommand())
+}
+
+func NewServicerCommand() *cobra.Command {
+	cmd := &cobra.Command{
+		Use:     ""Servicer"",
+		Short:   ""Servicer specific commands"",
+		Aliases: []string{""servicer""},
+		Args:    cobra.ExactArgs(0),
+	}
+
+	cmds := servicerCommands()
+	applySubcommandOptions(cmds, attachPwdFlagToSubcommands())
+	applySubcommandOptions(cmds, attachKeybaseFlagsToSubcommands())
+
+	cmd.AddCommand(cmds...)
+
+	return cmd
+}
+
+func servicerCommands() []*cobra.Command {
+	cmdDef := actorCmdDef{""Servicer"", coreTypes.ActorType_ACTOR_TYPE_SERVICER}
+	cmds := []*cobra.Command{
+		newStakeCmd(cmdDef),
+		newEditStakeCmd(cmdDef),
+		newUnstakeCmd(cmdDef),
+		newUnpauseCmd(cmdDef),
+		{
+			// IMPROVE: allow reading the relay payload from a file
+			Use:   ""Relay <applicationAddrHex> <servicerAddrHex> <relayChainID> <relayPayload>"",
+			Short: ""Relay <applicationAddrHex> <servicerAddrHex> <relayChainID> <relayPayload>"",
+			Long: `Sends a trustless relay using <relayPayload> as contents, to the specified active <servicerAddrHex> in the the <applicationAddrHex>'s session.
+Will prompt the user for the *application* account passphrase`,
+			Aliases: []string{},
+			Args:    cobra.ExactArgs(4),
+			RunE: func(cmd *cobra.Command, args []string) error {
+				applicationAddr := args[0]
+				servicerAddr := args[1]
+				chain := args[2]
+				relayPayload := args[3]
+
+				// REFACTOR: decouple the client logic from the CLI
+				//	The client will: send the trustless relay and return the response (using a single function as entrypoint)
+				//	The CLI will:
+				//		1) extract the required input from the command arguments
+				//		2) call the client function that performs the trustless relay
+				pk, err := getPrivateKeyFromKeybase(applicationAddr)
+				if err != nil {
+					return fmt.Errorf(""error getting application's private key: %w"", err)
+				}
+
+				// TECHDEBT(#791): cache session data
+				session, err := getCurrentSession(cmd.Context(), applicationAddr, chain)
+				if err != nil {
+					return fmt.Errorf(""Error getting current session: %w"", err)
+				}
+
+				servicer, err := validateServicer(cmd.Context(), session, servicerAddr)
+				if err != nil {
+					return fmt.Errorf(""error getting servicer for the relay: %w"", err)
+				}
+
+				relay, err := buildRelay(relayPayload, pk, session, servicer)
+				if err != nil {
+					return fmt.Errorf(""error building relay from payload: %w"", err)
+				}
+
+				fmt.Printf(""sending trustless relay for %s to %v with payload: %s\n"", applicationAddr, servicer, relayPayload)
+
+				resp, err := sendTrustlessRelay(cmd.Context(), servicer.ServiceUrl, relay)
+				if err != nil {
+					return err
+				}
+
+				fmt.Printf(""HTTP status code: %d\n"", resp.HTTPResponse.StatusCode)
+				fmt.Println(""Response: "", resp.JSON200)
+
+				return nil
+			},
+		},
+	}
+
+	return cmds
+}
+
+// DECIDE: do we need/want a cli subcommand for fetching sessions?
+// validateServicer returns the servicer specified by the <servicer> argument.
+// It validates that the <servicer> is the address of a servicer that is active in the passed session.
+func validateServicer(ctx context.Context, session *rpc.Session, servicerAddress string) (*rpc.ProtocolActor, error) {
+	for _, s := range session.Servicers {
+		if s.Address == servicerAddress {
+			return &s, nil
+		}
+	}
+
+	// ADDTEST: cover with gherkin tests
+	return nil, fmt.Errorf(""Error getting servicer: address %s does not match any servicers in the session %d"", servicerAddress, session.SessionNumber)
+}
+
+func getCurrentSession(ctx context.Context, appAddress, chain string) (*rpc.Session, error) {
+	// CONSIDERATION: passing 0 as the height value to get the current session seems more optimal than this.
+	currentHeight, err := getCurrentHeight(ctx)
+	if err != nil {
+		return nil, fmt.Errorf(""Error getting current session: %w"", err)
+	}
+
+	req := rpc.SessionRequest{
+		AppAddress: appAddress,
+		Chain:      chain,
+		// TODO(#697): Geozone
+		SessionHeight: currentHeight,
+	}
+
+	client, err := rpc.NewClientWithResponses(remoteCLIURL)
+	if err != nil {
+		return nil, fmt.Errorf(""Error getting current session for app/chain/height: %s/%s/%d: %w"", appAddress, chain, currentHeight, err)
+	}
+
+	resp, err := client.PostV1ClientGetSessionWithResponse(ctx, req)
+	if err != nil {
+		return nil, fmt.Errorf(""Error getting current session with request %v: %w"", req, err)
+	}
+	// TODO: refactor boiler-plate code
+	if resp.HTTPResponse.StatusCode != http.StatusOK {
+		return nil, fmt.Errorf(""Error getting current session: Unexpected status code %d for request %v"", resp.HTTPResponse.StatusCode, req)
+	}
+
+	if resp.JSON200 == nil {
+		return nil, fmt.Errorf(""Error getting current session: Unexpected response %v"", resp)
+	}
+
+	return resp.JSON200, nil
+}
+
+// TODO: reuse this function in the query commands
+func getCurrentHeight(ctx context.Context) (int64, error) {
+	client, err := rpc.NewClientWithResponses(remoteCLIURL)
+	if err != nil {
+		return 0, fmt.Errorf(""Error getting current height: %w"", err)
+	}
+	resp, err := client.GetV1QueryHeightWithResponse(ctx)
+	if err != nil {
+		return 0, fmt.Errorf(""Error getting current height: %w"", err)
+	}
+	if resp.HTTPResponse.StatusCode != http.StatusOK {
+		return 0, fmt.Errorf(""Error getting current height: Unexpected status code %d"", resp.HTTPResponse.StatusCode)
+	}
+
+	if resp.JSON200 == nil {
+		return 0, fmt.Errorf(""Error getting current height: Unexpected response %v"", resp)
+	}
+
+	return resp.JSON200.Height, nil
+}
+
+// IMPROVE: [K8s][LocalNet] Publish Servicer(s) Host and Port as env. vars in K8s: similar to Validators
+// REFACTOR: move package-level variables (e.g. remoteCLIURL) to a cli object.",app/client/cli/servicer.go,2023-05-30 21:42:03+00:00,2023-05-30T22:42:12Z,"```suggestion
// REFACTOR: move package-level variables (e.g. remoteCLIURL) to a cli object and consider storing it in the context
```",,,,,174,RIGHT,174,,line,https://api.github.com/repos/pokt-network/pocket/pulls/778,pokt-network/pocket,a516c51f2d000d25f1469d28e6586ef7875d5a37
https://api.github.com/repos/pokt-network/pocket/pulls/778,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1210852435,Olshansk,3f7c8f63ff1d05e64f8672113a70545632501fca,acec260d9987f4dba2b31bdf4b65f2ef6b654725,"@@ -0,0 +1,243 @@
+package cli
+
+import (
+	""context""
+	""encoding/hex""
+	""encoding/json""
+	""fmt""
+	""net/http""
+
+	""github.com/spf13/cobra""
+
+	""github.com/pokt-network/pocket/rpc""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/crypto""
+)
+
+func init() {
+	rootCmd.AddCommand(NewServicerCommand())
+}
+
+func NewServicerCommand() *cobra.Command {
+	cmd := &cobra.Command{
+		Use:     ""Servicer"",
+		Short:   ""Servicer specific commands"",
+		Aliases: []string{""servicer""},
+		Args:    cobra.ExactArgs(0),
+	}
+
+	cmds := servicerCommands()
+	applySubcommandOptions(cmds, attachPwdFlagToSubcommands())
+	applySubcommandOptions(cmds, attachKeybaseFlagsToSubcommands())
+
+	cmd.AddCommand(cmds...)
+
+	return cmd
+}
+
+func servicerCommands() []*cobra.Command {
+	cmdDef := actorCmdDef{""Servicer"", coreTypes.ActorType_ACTOR_TYPE_SERVICER}
+	cmds := []*cobra.Command{
+		newStakeCmd(cmdDef),
+		newEditStakeCmd(cmdDef),
+		newUnstakeCmd(cmdDef),
+		newUnpauseCmd(cmdDef),
+		{
+			// IMPROVE: allow reading the relay payload from a file
+			Use:   ""Relay <applicationAddrHex> <servicerAddrHex> <relayChainID> <relayPayload>"",
+			Short: ""Relay <applicationAddrHex> <servicerAddrHex> <relayChainID> <relayPayload>"",
+			Long: `Sends a trustless relay using <relayPayload> as contents, to the specified active <servicerAddrHex> in the the <applicationAddrHex>'s session.
+Will prompt the user for the *application* account passphrase`,
+			Aliases: []string{},
+			Args:    cobra.ExactArgs(4),
+			RunE: func(cmd *cobra.Command, args []string) error {
+				applicationAddr := args[0]
+				servicerAddr := args[1]
+				chain := args[2]
+				relayPayload := args[3]
+
+				// REFACTOR: decouple the client logic from the CLI
+				//	The client will: send the trustless relay and return the response (using a single function as entrypoint)
+				//	The CLI will:
+				//		1) extract the required input from the command arguments
+				//		2) call the client function that performs the trustless relay
+				pk, err := getPrivateKeyFromKeybase(applicationAddr)
+				if err != nil {
+					return fmt.Errorf(""error getting application's private key: %w"", err)
+				}
+
+				// TECHDEBT(#791): cache session data
+				session, err := getCurrentSession(cmd.Context(), applicationAddr, chain)
+				if err != nil {
+					return fmt.Errorf(""Error getting current session: %w"", err)
+				}
+
+				servicer, err := validateServicer(cmd.Context(), session, servicerAddr)
+				if err != nil {
+					return fmt.Errorf(""error getting servicer for the relay: %w"", err)
+				}
+
+				relay, err := buildRelay(relayPayload, pk, session, servicer)
+				if err != nil {
+					return fmt.Errorf(""error building relay from payload: %w"", err)
+				}
+
+				fmt.Printf(""sending trustless relay for %s to %v with payload: %s\n"", applicationAddr, servicer, relayPayload)
+
+				resp, err := sendTrustlessRelay(cmd.Context(), servicer.ServiceUrl, relay)
+				if err != nil {
+					return err
+				}
+
+				fmt.Printf(""HTTP status code: %d\n"", resp.HTTPResponse.StatusCode)
+				fmt.Println(""Response: "", resp.JSON200)
+
+				return nil
+			},
+		},
+	}
+
+	return cmds
+}
+
+// DECIDE: do we need/want a cli subcommand for fetching sessions?
+// validateServicer returns the servicer specified by the <servicer> argument.
+// It validates that the <servicer> is the address of a servicer that is active in the passed session.
+func validateServicer(ctx context.Context, session *rpc.Session, servicerAddress string) (*rpc.ProtocolActor, error) {
+	for _, s := range session.Servicers {
+		if s.Address == servicerAddress {
+			return &s, nil
+		}
+	}
+
+	// ADDTEST: cover with gherkin tests
+	return nil, fmt.Errorf(""Error getting servicer: address %s does not match any servicers in the session %d"", servicerAddress, session.SessionNumber)
+}
+
+func getCurrentSession(ctx context.Context, appAddress, chain string) (*rpc.Session, error) {
+	// CONSIDERATION: passing 0 as the height value to get the current session seems more optimal than this.
+	currentHeight, err := getCurrentHeight(ctx)
+	if err != nil {
+		return nil, fmt.Errorf(""Error getting current session: %w"", err)
+	}
+
+	req := rpc.SessionRequest{
+		AppAddress: appAddress,
+		Chain:      chain,
+		// TODO(#697): Geozone
+		SessionHeight: currentHeight,
+	}
+
+	client, err := rpc.NewClientWithResponses(remoteCLIURL)
+	if err != nil {
+		return nil, fmt.Errorf(""Error getting current session for app/chain/height: %s/%s/%d: %w"", appAddress, chain, currentHeight, err)
+	}
+
+	resp, err := client.PostV1ClientGetSessionWithResponse(ctx, req)
+	if err != nil {
+		return nil, fmt.Errorf(""Error getting current session with request %v: %w"", req, err)
+	}
+	// TODO: refactor boiler-plate code
+	if resp.HTTPResponse.StatusCode != http.StatusOK {
+		return nil, fmt.Errorf(""Error getting current session: Unexpected status code %d for request %v"", resp.HTTPResponse.StatusCode, req)
+	}
+
+	if resp.JSON200 == nil {
+		return nil, fmt.Errorf(""Error getting current session: Unexpected response %v"", resp)
+	}
+
+	return resp.JSON200, nil
+}
+
+// TODO: reuse this function in the query commands
+func getCurrentHeight(ctx context.Context) (int64, error) {
+	client, err := rpc.NewClientWithResponses(remoteCLIURL)
+	if err != nil {
+		return 0, fmt.Errorf(""Error getting current height: %w"", err)
+	}
+	resp, err := client.GetV1QueryHeightWithResponse(ctx)
+	if err != nil {
+		return 0, fmt.Errorf(""Error getting current height: %w"", err)
+	}
+	if resp.HTTPResponse.StatusCode != http.StatusOK {
+		return 0, fmt.Errorf(""Error getting current height: Unexpected status code %d"", resp.HTTPResponse.StatusCode)
+	}
+
+	if resp.JSON200 == nil {
+		return 0, fmt.Errorf(""Error getting current height: Unexpected response %v"", resp)
+	}
+
+	return resp.JSON200.Height, nil
+}
+
+// IMPROVE: [K8s][LocalNet] Publish Servicer(s) Host and Port as env. vars in K8s: similar to Validators
+// REFACTOR: move package-level variables (e.g. remoteCLIURL) to a cli object.
+func sendTrustlessRelay(ctx context.Context, servicerUrl string, relay *rpc.RelayRequest) (*rpc.PostV1ClientRelayResponse, error) {
+	client, err := rpc.NewClientWithResponses(servicerUrl)
+	if err != nil {
+		return nil, err
+	}
+
+	return client.PostV1ClientRelayWithResponse(ctx, *relay)
+}
+
+func buildRelay(payload string, appPrivateKey crypto.PrivateKey, session *rpc.Session, servicer *rpc.ProtocolActor) (*rpc.RelayRequest, error) {
+	// TECHDEBT: This is mostly COPIED from pocket-go: we should refactor pocket-go code and import this functionality from there instead.
+	relayPayload := rpc.Payload{
+		// INCOMPLETE: need to unmarshal into JSONRPC (and other supported relay formats), using a custom unmarshaller",app/client/cli/servicer.go,2023-05-30 21:43:04+00:00,2023-05-30T22:42:12Z,Can you add the ticket number you're working on in `INCOMPLETE(#XXX)`,,,,,187,RIGHT,187,,line,https://api.github.com/repos/pokt-network/pocket/pulls/778,pokt-network/pocket,a516c51f2d000d25f1469d28e6586ef7875d5a37
https://api.github.com/repos/pokt-network/pocket/pulls/778,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1210853041,Olshansk,3f7c8f63ff1d05e64f8672113a70545632501fca,acec260d9987f4dba2b31bdf4b65f2ef6b654725,"@@ -0,0 +1,243 @@
+package cli
+
+import (
+	""context""
+	""encoding/hex""
+	""encoding/json""
+	""fmt""
+	""net/http""
+
+	""github.com/spf13/cobra""
+
+	""github.com/pokt-network/pocket/rpc""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/crypto""
+)
+
+func init() {
+	rootCmd.AddCommand(NewServicerCommand())
+}
+
+func NewServicerCommand() *cobra.Command {
+	cmd := &cobra.Command{
+		Use:     ""Servicer"",
+		Short:   ""Servicer specific commands"",
+		Aliases: []string{""servicer""},
+		Args:    cobra.ExactArgs(0),
+	}
+
+	cmds := servicerCommands()
+	applySubcommandOptions(cmds, attachPwdFlagToSubcommands())
+	applySubcommandOptions(cmds, attachKeybaseFlagsToSubcommands())
+
+	cmd.AddCommand(cmds...)
+
+	return cmd
+}
+
+func servicerCommands() []*cobra.Command {
+	cmdDef := actorCmdDef{""Servicer"", coreTypes.ActorType_ACTOR_TYPE_SERVICER}
+	cmds := []*cobra.Command{
+		newStakeCmd(cmdDef),
+		newEditStakeCmd(cmdDef),
+		newUnstakeCmd(cmdDef),
+		newUnpauseCmd(cmdDef),
+		{
+			// IMPROVE: allow reading the relay payload from a file
+			Use:   ""Relay <applicationAddrHex> <servicerAddrHex> <relayChainID> <relayPayload>"",
+			Short: ""Relay <applicationAddrHex> <servicerAddrHex> <relayChainID> <relayPayload>"",
+			Long: `Sends a trustless relay using <relayPayload> as contents, to the specified active <servicerAddrHex> in the the <applicationAddrHex>'s session.
+Will prompt the user for the *application* account passphrase`,
+			Aliases: []string{},
+			Args:    cobra.ExactArgs(4),
+			RunE: func(cmd *cobra.Command, args []string) error {
+				applicationAddr := args[0]
+				servicerAddr := args[1]
+				chain := args[2]
+				relayPayload := args[3]
+
+				// REFACTOR: decouple the client logic from the CLI
+				//	The client will: send the trustless relay and return the response (using a single function as entrypoint)
+				//	The CLI will:
+				//		1) extract the required input from the command arguments
+				//		2) call the client function that performs the trustless relay
+				pk, err := getPrivateKeyFromKeybase(applicationAddr)
+				if err != nil {
+					return fmt.Errorf(""error getting application's private key: %w"", err)
+				}
+
+				// TECHDEBT(#791): cache session data
+				session, err := getCurrentSession(cmd.Context(), applicationAddr, chain)
+				if err != nil {
+					return fmt.Errorf(""Error getting current session: %w"", err)
+				}
+
+				servicer, err := validateServicer(cmd.Context(), session, servicerAddr)
+				if err != nil {
+					return fmt.Errorf(""error getting servicer for the relay: %w"", err)
+				}
+
+				relay, err := buildRelay(relayPayload, pk, session, servicer)
+				if err != nil {
+					return fmt.Errorf(""error building relay from payload: %w"", err)
+				}
+
+				fmt.Printf(""sending trustless relay for %s to %v with payload: %s\n"", applicationAddr, servicer, relayPayload)
+
+				resp, err := sendTrustlessRelay(cmd.Context(), servicer.ServiceUrl, relay)
+				if err != nil {
+					return err
+				}
+
+				fmt.Printf(""HTTP status code: %d\n"", resp.HTTPResponse.StatusCode)
+				fmt.Println(""Response: "", resp.JSON200)
+
+				return nil
+			},
+		},
+	}
+
+	return cmds
+}
+
+// DECIDE: do we need/want a cli subcommand for fetching sessions?
+// validateServicer returns the servicer specified by the <servicer> argument.
+// It validates that the <servicer> is the address of a servicer that is active in the passed session.
+func validateServicer(ctx context.Context, session *rpc.Session, servicerAddress string) (*rpc.ProtocolActor, error) {
+	for _, s := range session.Servicers {
+		if s.Address == servicerAddress {
+			return &s, nil
+		}
+	}
+
+	// ADDTEST: cover with gherkin tests
+	return nil, fmt.Errorf(""Error getting servicer: address %s does not match any servicers in the session %d"", servicerAddress, session.SessionNumber)
+}
+
+func getCurrentSession(ctx context.Context, appAddress, chain string) (*rpc.Session, error) {
+	// CONSIDERATION: passing 0 as the height value to get the current session seems more optimal than this.
+	currentHeight, err := getCurrentHeight(ctx)
+	if err != nil {
+		return nil, fmt.Errorf(""Error getting current session: %w"", err)
+	}
+
+	req := rpc.SessionRequest{
+		AppAddress: appAddress,
+		Chain:      chain,
+		// TODO(#697): Geozone
+		SessionHeight: currentHeight,
+	}
+
+	client, err := rpc.NewClientWithResponses(remoteCLIURL)
+	if err != nil {
+		return nil, fmt.Errorf(""Error getting current session for app/chain/height: %s/%s/%d: %w"", appAddress, chain, currentHeight, err)
+	}
+
+	resp, err := client.PostV1ClientGetSessionWithResponse(ctx, req)
+	if err != nil {
+		return nil, fmt.Errorf(""Error getting current session with request %v: %w"", req, err)
+	}
+	// TODO: refactor boiler-plate code
+	if resp.HTTPResponse.StatusCode != http.StatusOK {
+		return nil, fmt.Errorf(""Error getting current session: Unexpected status code %d for request %v"", resp.HTTPResponse.StatusCode, req)
+	}
+
+	if resp.JSON200 == nil {
+		return nil, fmt.Errorf(""Error getting current session: Unexpected response %v"", resp)
+	}
+
+	return resp.JSON200, nil
+}
+
+// TODO: reuse this function in the query commands
+func getCurrentHeight(ctx context.Context) (int64, error) {
+	client, err := rpc.NewClientWithResponses(remoteCLIURL)
+	if err != nil {
+		return 0, fmt.Errorf(""Error getting current height: %w"", err)
+	}
+	resp, err := client.GetV1QueryHeightWithResponse(ctx)
+	if err != nil {
+		return 0, fmt.Errorf(""Error getting current height: %w"", err)
+	}
+	if resp.HTTPResponse.StatusCode != http.StatusOK {
+		return 0, fmt.Errorf(""Error getting current height: Unexpected status code %d"", resp.HTTPResponse.StatusCode)
+	}
+
+	if resp.JSON200 == nil {
+		return 0, fmt.Errorf(""Error getting current height: Unexpected response %v"", resp)
+	}
+
+	return resp.JSON200.Height, nil
+}
+
+// IMPROVE: [K8s][LocalNet] Publish Servicer(s) Host and Port as env. vars in K8s: similar to Validators
+// REFACTOR: move package-level variables (e.g. remoteCLIURL) to a cli object.
+func sendTrustlessRelay(ctx context.Context, servicerUrl string, relay *rpc.RelayRequest) (*rpc.PostV1ClientRelayResponse, error) {
+	client, err := rpc.NewClientWithResponses(servicerUrl)
+	if err != nil {
+		return nil, err
+	}
+
+	return client.PostV1ClientRelayWithResponse(ctx, *relay)
+}
+
+func buildRelay(payload string, appPrivateKey crypto.PrivateKey, session *rpc.Session, servicer *rpc.ProtocolActor) (*rpc.RelayRequest, error) {
+	// TECHDEBT: This is mostly COPIED from pocket-go: we should refactor pocket-go code and import this functionality from there instead.
+	relayPayload := rpc.Payload{
+		// INCOMPLETE: need to unmarshal into JSONRPC (and other supported relay formats), using a custom unmarshaller
+		Jsonrpc: ""2.0"",
+		Method:  payload,
+		// TODO: Path: load Path field from the corresponding Blockchain (e.g. database)
+		// TODO: set Headers
+	}
+
+	relayMeta := rpc.RelayRequestMeta{
+		BlockHeight: session.SessionHeight,
+		// TODO: use Identifiable for Chain in Session (or string for Chain in Relay Meta)",app/client/cli/servicer.go,2023-05-30 21:43:58+00:00,2023-05-30T22:42:12Z,"I don't fully understand what the action item is here.

Can you clarify the TODO comment",,,,,196,RIGHT,196,,line,https://api.github.com/repos/pokt-network/pocket/pulls/778,pokt-network/pocket,a516c51f2d000d25f1469d28e6586ef7875d5a37
https://api.github.com/repos/pokt-network/pocket/pulls/778,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1210853609,Olshansk,3f7c8f63ff1d05e64f8672113a70545632501fca,acec260d9987f4dba2b31bdf4b65f2ef6b654725,"@@ -0,0 +1,243 @@
+package cli
+
+import (
+	""context""
+	""encoding/hex""
+	""encoding/json""
+	""fmt""
+	""net/http""
+
+	""github.com/spf13/cobra""
+
+	""github.com/pokt-network/pocket/rpc""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/crypto""
+)
+
+func init() {
+	rootCmd.AddCommand(NewServicerCommand())
+}
+
+func NewServicerCommand() *cobra.Command {
+	cmd := &cobra.Command{
+		Use:     ""Servicer"",
+		Short:   ""Servicer specific commands"",
+		Aliases: []string{""servicer""},
+		Args:    cobra.ExactArgs(0),
+	}
+
+	cmds := servicerCommands()
+	applySubcommandOptions(cmds, attachPwdFlagToSubcommands())
+	applySubcommandOptions(cmds, attachKeybaseFlagsToSubcommands())
+
+	cmd.AddCommand(cmds...)
+
+	return cmd
+}
+
+func servicerCommands() []*cobra.Command {
+	cmdDef := actorCmdDef{""Servicer"", coreTypes.ActorType_ACTOR_TYPE_SERVICER}
+	cmds := []*cobra.Command{
+		newStakeCmd(cmdDef),
+		newEditStakeCmd(cmdDef),
+		newUnstakeCmd(cmdDef),
+		newUnpauseCmd(cmdDef),
+		{
+			// IMPROVE: allow reading the relay payload from a file
+			Use:   ""Relay <applicationAddrHex> <servicerAddrHex> <relayChainID> <relayPayload>"",
+			Short: ""Relay <applicationAddrHex> <servicerAddrHex> <relayChainID> <relayPayload>"",
+			Long: `Sends a trustless relay using <relayPayload> as contents, to the specified active <servicerAddrHex> in the the <applicationAddrHex>'s session.
+Will prompt the user for the *application* account passphrase`,
+			Aliases: []string{},
+			Args:    cobra.ExactArgs(4),
+			RunE: func(cmd *cobra.Command, args []string) error {
+				applicationAddr := args[0]
+				servicerAddr := args[1]
+				chain := args[2]
+				relayPayload := args[3]
+
+				// REFACTOR: decouple the client logic from the CLI
+				//	The client will: send the trustless relay and return the response (using a single function as entrypoint)
+				//	The CLI will:
+				//		1) extract the required input from the command arguments
+				//		2) call the client function that performs the trustless relay
+				pk, err := getPrivateKeyFromKeybase(applicationAddr)
+				if err != nil {
+					return fmt.Errorf(""error getting application's private key: %w"", err)
+				}
+
+				// TECHDEBT(#791): cache session data
+				session, err := getCurrentSession(cmd.Context(), applicationAddr, chain)
+				if err != nil {
+					return fmt.Errorf(""Error getting current session: %w"", err)
+				}
+
+				servicer, err := validateServicer(cmd.Context(), session, servicerAddr)
+				if err != nil {
+					return fmt.Errorf(""error getting servicer for the relay: %w"", err)
+				}
+
+				relay, err := buildRelay(relayPayload, pk, session, servicer)
+				if err != nil {
+					return fmt.Errorf(""error building relay from payload: %w"", err)
+				}
+
+				fmt.Printf(""sending trustless relay for %s to %v with payload: %s\n"", applicationAddr, servicer, relayPayload)
+
+				resp, err := sendTrustlessRelay(cmd.Context(), servicer.ServiceUrl, relay)
+				if err != nil {
+					return err
+				}
+
+				fmt.Printf(""HTTP status code: %d\n"", resp.HTTPResponse.StatusCode)
+				fmt.Println(""Response: "", resp.JSON200)
+
+				return nil
+			},
+		},
+	}
+
+	return cmds
+}
+
+// DECIDE: do we need/want a cli subcommand for fetching sessions?
+// validateServicer returns the servicer specified by the <servicer> argument.
+// It validates that the <servicer> is the address of a servicer that is active in the passed session.
+func validateServicer(ctx context.Context, session *rpc.Session, servicerAddress string) (*rpc.ProtocolActor, error) {
+	for _, s := range session.Servicers {
+		if s.Address == servicerAddress {
+			return &s, nil
+		}
+	}
+
+	// ADDTEST: cover with gherkin tests
+	return nil, fmt.Errorf(""Error getting servicer: address %s does not match any servicers in the session %d"", servicerAddress, session.SessionNumber)
+}
+
+func getCurrentSession(ctx context.Context, appAddress, chain string) (*rpc.Session, error) {
+	// CONSIDERATION: passing 0 as the height value to get the current session seems more optimal than this.
+	currentHeight, err := getCurrentHeight(ctx)
+	if err != nil {
+		return nil, fmt.Errorf(""Error getting current session: %w"", err)
+	}
+
+	req := rpc.SessionRequest{
+		AppAddress: appAddress,
+		Chain:      chain,
+		// TODO(#697): Geozone
+		SessionHeight: currentHeight,
+	}
+
+	client, err := rpc.NewClientWithResponses(remoteCLIURL)
+	if err != nil {
+		return nil, fmt.Errorf(""Error getting current session for app/chain/height: %s/%s/%d: %w"", appAddress, chain, currentHeight, err)
+	}
+
+	resp, err := client.PostV1ClientGetSessionWithResponse(ctx, req)
+	if err != nil {
+		return nil, fmt.Errorf(""Error getting current session with request %v: %w"", req, err)
+	}
+	// TODO: refactor boiler-plate code
+	if resp.HTTPResponse.StatusCode != http.StatusOK {
+		return nil, fmt.Errorf(""Error getting current session: Unexpected status code %d for request %v"", resp.HTTPResponse.StatusCode, req)
+	}
+
+	if resp.JSON200 == nil {
+		return nil, fmt.Errorf(""Error getting current session: Unexpected response %v"", resp)
+	}
+
+	return resp.JSON200, nil
+}
+
+// TODO: reuse this function in the query commands
+func getCurrentHeight(ctx context.Context) (int64, error) {
+	client, err := rpc.NewClientWithResponses(remoteCLIURL)
+	if err != nil {
+		return 0, fmt.Errorf(""Error getting current height: %w"", err)
+	}
+	resp, err := client.GetV1QueryHeightWithResponse(ctx)
+	if err != nil {
+		return 0, fmt.Errorf(""Error getting current height: %w"", err)
+	}
+	if resp.HTTPResponse.StatusCode != http.StatusOK {
+		return 0, fmt.Errorf(""Error getting current height: Unexpected status code %d"", resp.HTTPResponse.StatusCode)
+	}
+
+	if resp.JSON200 == nil {
+		return 0, fmt.Errorf(""Error getting current height: Unexpected response %v"", resp)
+	}
+
+	return resp.JSON200.Height, nil
+}
+
+// IMPROVE: [K8s][LocalNet] Publish Servicer(s) Host and Port as env. vars in K8s: similar to Validators
+// REFACTOR: move package-level variables (e.g. remoteCLIURL) to a cli object.
+func sendTrustlessRelay(ctx context.Context, servicerUrl string, relay *rpc.RelayRequest) (*rpc.PostV1ClientRelayResponse, error) {
+	client, err := rpc.NewClientWithResponses(servicerUrl)
+	if err != nil {
+		return nil, err
+	}
+
+	return client.PostV1ClientRelayWithResponse(ctx, *relay)
+}
+
+func buildRelay(payload string, appPrivateKey crypto.PrivateKey, session *rpc.Session, servicer *rpc.ProtocolActor) (*rpc.RelayRequest, error) {
+	// TECHDEBT: This is mostly COPIED from pocket-go: we should refactor pocket-go code and import this functionality from there instead.
+	relayPayload := rpc.Payload{
+		// INCOMPLETE: need to unmarshal into JSONRPC (and other supported relay formats), using a custom unmarshaller
+		Jsonrpc: ""2.0"",
+		Method:  payload,
+		// TODO: Path: load Path field from the corresponding Blockchain (e.g. database)
+		// TODO: set Headers
+	}
+
+	relayMeta := rpc.RelayRequestMeta{
+		BlockHeight: session.SessionHeight,
+		// TODO: use Identifiable for Chain in Session (or string for Chain in Relay Meta)
+		Chain: rpc.Identifiable{
+			Id: session.Chain,
+		},
+		ServicerPubKey: servicer.PublicKey,
+		// TODO(#697): Geozone
+	}
+
+	relay := &rpc.RelayRequest{
+		Payload: relayPayload,
+		Meta:    relayMeta,
+		// DISCUSS: why is there no Proof field in v1 struct?",app/client/cli/servicer.go,2023-05-30 21:44:53+00:00,2023-05-30T22:42:12Z,"1. What does the proof give you?
2. The signature of the relay request is what we need for:
- Integrity of the request
- Authentication of the application (or portal it delegated to)",,,,,207,RIGHT,207,,line,https://api.github.com/repos/pokt-network/pocket/pulls/778,pokt-network/pocket,a516c51f2d000d25f1469d28e6586ef7875d5a37
https://api.github.com/repos/pokt-network/pocket/pulls/778,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1210854669,Olshansk,3f7c8f63ff1d05e64f8672113a70545632501fca,acec260d9987f4dba2b31bdf4b65f2ef6b654725,"@@ -0,0 +1,243 @@
+package cli
+
+import (
+	""context""
+	""encoding/hex""
+	""encoding/json""
+	""fmt""
+	""net/http""
+
+	""github.com/spf13/cobra""
+
+	""github.com/pokt-network/pocket/rpc""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/crypto""
+)
+
+func init() {
+	rootCmd.AddCommand(NewServicerCommand())
+}
+
+func NewServicerCommand() *cobra.Command {
+	cmd := &cobra.Command{
+		Use:     ""Servicer"",
+		Short:   ""Servicer specific commands"",
+		Aliases: []string{""servicer""},
+		Args:    cobra.ExactArgs(0),
+	}
+
+	cmds := servicerCommands()
+	applySubcommandOptions(cmds, attachPwdFlagToSubcommands())
+	applySubcommandOptions(cmds, attachKeybaseFlagsToSubcommands())
+
+	cmd.AddCommand(cmds...)
+
+	return cmd
+}
+
+func servicerCommands() []*cobra.Command {
+	cmdDef := actorCmdDef{""Servicer"", coreTypes.ActorType_ACTOR_TYPE_SERVICER}
+	cmds := []*cobra.Command{
+		newStakeCmd(cmdDef),
+		newEditStakeCmd(cmdDef),
+		newUnstakeCmd(cmdDef),
+		newUnpauseCmd(cmdDef),
+		{
+			// IMPROVE: allow reading the relay payload from a file
+			Use:   ""Relay <applicationAddrHex> <servicerAddrHex> <relayChainID> <relayPayload>"",
+			Short: ""Relay <applicationAddrHex> <servicerAddrHex> <relayChainID> <relayPayload>"",
+			Long: `Sends a trustless relay using <relayPayload> as contents, to the specified active <servicerAddrHex> in the the <applicationAddrHex>'s session.
+Will prompt the user for the *application* account passphrase`,
+			Aliases: []string{},
+			Args:    cobra.ExactArgs(4),
+			RunE: func(cmd *cobra.Command, args []string) error {
+				applicationAddr := args[0]
+				servicerAddr := args[1]
+				chain := args[2]
+				relayPayload := args[3]
+
+				// REFACTOR: decouple the client logic from the CLI
+				//	The client will: send the trustless relay and return the response (using a single function as entrypoint)
+				//	The CLI will:
+				//		1) extract the required input from the command arguments
+				//		2) call the client function that performs the trustless relay
+				pk, err := getPrivateKeyFromKeybase(applicationAddr)
+				if err != nil {
+					return fmt.Errorf(""error getting application's private key: %w"", err)
+				}
+
+				// TECHDEBT(#791): cache session data
+				session, err := getCurrentSession(cmd.Context(), applicationAddr, chain)
+				if err != nil {
+					return fmt.Errorf(""Error getting current session: %w"", err)
+				}
+
+				servicer, err := validateServicer(cmd.Context(), session, servicerAddr)
+				if err != nil {
+					return fmt.Errorf(""error getting servicer for the relay: %w"", err)
+				}
+
+				relay, err := buildRelay(relayPayload, pk, session, servicer)
+				if err != nil {
+					return fmt.Errorf(""error building relay from payload: %w"", err)
+				}
+
+				fmt.Printf(""sending trustless relay for %s to %v with payload: %s\n"", applicationAddr, servicer, relayPayload)
+
+				resp, err := sendTrustlessRelay(cmd.Context(), servicer.ServiceUrl, relay)
+				if err != nil {
+					return err
+				}
+
+				fmt.Printf(""HTTP status code: %d\n"", resp.HTTPResponse.StatusCode)
+				fmt.Println(""Response: "", resp.JSON200)
+
+				return nil
+			},
+		},
+	}
+
+	return cmds
+}
+
+// DECIDE: do we need/want a cli subcommand for fetching sessions?
+// validateServicer returns the servicer specified by the <servicer> argument.
+// It validates that the <servicer> is the address of a servicer that is active in the passed session.
+func validateServicer(ctx context.Context, session *rpc.Session, servicerAddress string) (*rpc.ProtocolActor, error) {
+	for _, s := range session.Servicers {
+		if s.Address == servicerAddress {
+			return &s, nil
+		}
+	}
+
+	// ADDTEST: cover with gherkin tests
+	return nil, fmt.Errorf(""Error getting servicer: address %s does not match any servicers in the session %d"", servicerAddress, session.SessionNumber)
+}
+
+func getCurrentSession(ctx context.Context, appAddress, chain string) (*rpc.Session, error) {
+	// CONSIDERATION: passing 0 as the height value to get the current session seems more optimal than this.
+	currentHeight, err := getCurrentHeight(ctx)
+	if err != nil {
+		return nil, fmt.Errorf(""Error getting current session: %w"", err)
+	}
+
+	req := rpc.SessionRequest{
+		AppAddress: appAddress,
+		Chain:      chain,
+		// TODO(#697): Geozone
+		SessionHeight: currentHeight,
+	}
+
+	client, err := rpc.NewClientWithResponses(remoteCLIURL)
+	if err != nil {
+		return nil, fmt.Errorf(""Error getting current session for app/chain/height: %s/%s/%d: %w"", appAddress, chain, currentHeight, err)
+	}
+
+	resp, err := client.PostV1ClientGetSessionWithResponse(ctx, req)
+	if err != nil {
+		return nil, fmt.Errorf(""Error getting current session with request %v: %w"", req, err)
+	}
+	// TODO: refactor boiler-plate code
+	if resp.HTTPResponse.StatusCode != http.StatusOK {
+		return nil, fmt.Errorf(""Error getting current session: Unexpected status code %d for request %v"", resp.HTTPResponse.StatusCode, req)
+	}
+
+	if resp.JSON200 == nil {
+		return nil, fmt.Errorf(""Error getting current session: Unexpected response %v"", resp)
+	}
+
+	return resp.JSON200, nil
+}
+
+// TODO: reuse this function in the query commands
+func getCurrentHeight(ctx context.Context) (int64, error) {
+	client, err := rpc.NewClientWithResponses(remoteCLIURL)
+	if err != nil {
+		return 0, fmt.Errorf(""Error getting current height: %w"", err)
+	}
+	resp, err := client.GetV1QueryHeightWithResponse(ctx)
+	if err != nil {
+		return 0, fmt.Errorf(""Error getting current height: %w"", err)
+	}
+	if resp.HTTPResponse.StatusCode != http.StatusOK {
+		return 0, fmt.Errorf(""Error getting current height: Unexpected status code %d"", resp.HTTPResponse.StatusCode)
+	}
+
+	if resp.JSON200 == nil {
+		return 0, fmt.Errorf(""Error getting current height: Unexpected response %v"", resp)
+	}
+
+	return resp.JSON200.Height, nil
+}
+
+// IMPROVE: [K8s][LocalNet] Publish Servicer(s) Host and Port as env. vars in K8s: similar to Validators
+// REFACTOR: move package-level variables (e.g. remoteCLIURL) to a cli object.
+func sendTrustlessRelay(ctx context.Context, servicerUrl string, relay *rpc.RelayRequest) (*rpc.PostV1ClientRelayResponse, error) {
+	client, err := rpc.NewClientWithResponses(servicerUrl)
+	if err != nil {
+		return nil, err
+	}
+
+	return client.PostV1ClientRelayWithResponse(ctx, *relay)
+}
+
+func buildRelay(payload string, appPrivateKey crypto.PrivateKey, session *rpc.Session, servicer *rpc.ProtocolActor) (*rpc.RelayRequest, error) {
+	// TECHDEBT: This is mostly COPIED from pocket-go: we should refactor pocket-go code and import this functionality from there instead.
+	relayPayload := rpc.Payload{
+		// INCOMPLETE: need to unmarshal into JSONRPC (and other supported relay formats), using a custom unmarshaller
+		Jsonrpc: ""2.0"",
+		Method:  payload,
+		// TODO: Path: load Path field from the corresponding Blockchain (e.g. database)
+		// TODO: set Headers
+	}
+
+	relayMeta := rpc.RelayRequestMeta{
+		BlockHeight: session.SessionHeight,
+		// TODO: use Identifiable for Chain in Session (or string for Chain in Relay Meta)
+		Chain: rpc.Identifiable{
+			Id: session.Chain,
+		},
+		ServicerPubKey: servicer.PublicKey,
+		// TODO(#697): Geozone
+	}
+
+	relay := &rpc.RelayRequest{
+		Payload: relayPayload,
+		Meta:    relayMeta,
+		// DISCUSS: why is there no Proof field in v1 struct?
+	}
+	reqBytes, err := json.Marshal(relay)",app/client/cli/servicer.go,2023-05-30 21:46:16+00:00,2023-05-30T22:42:12Z,"```suggestion
	// TECHDEBT: Evaluate which fields we should and shouldn't marshall when signing the payload
	reqBytes, err := json.Marshal(relay)
```",,,,210.0,209,RIGHT,209,210.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/778,pokt-network/pocket,a516c51f2d000d25f1469d28e6586ef7875d5a37
https://api.github.com/repos/pokt-network/pocket/pulls/778,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1210855748,Olshansk,3f7c8f63ff1d05e64f8672113a70545632501fca,acec260d9987f4dba2b31bdf4b65f2ef6b654725,"@@ -0,0 +1,243 @@
+package cli
+
+import (
+	""context""
+	""encoding/hex""
+	""encoding/json""
+	""fmt""
+	""net/http""
+
+	""github.com/spf13/cobra""
+
+	""github.com/pokt-network/pocket/rpc""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/crypto""
+)
+
+func init() {
+	rootCmd.AddCommand(NewServicerCommand())
+}
+
+func NewServicerCommand() *cobra.Command {
+	cmd := &cobra.Command{
+		Use:     ""Servicer"",
+		Short:   ""Servicer specific commands"",
+		Aliases: []string{""servicer""},
+		Args:    cobra.ExactArgs(0),
+	}
+
+	cmds := servicerCommands()
+	applySubcommandOptions(cmds, attachPwdFlagToSubcommands())
+	applySubcommandOptions(cmds, attachKeybaseFlagsToSubcommands())
+
+	cmd.AddCommand(cmds...)
+
+	return cmd
+}
+
+func servicerCommands() []*cobra.Command {
+	cmdDef := actorCmdDef{""Servicer"", coreTypes.ActorType_ACTOR_TYPE_SERVICER}
+	cmds := []*cobra.Command{
+		newStakeCmd(cmdDef),
+		newEditStakeCmd(cmdDef),
+		newUnstakeCmd(cmdDef),
+		newUnpauseCmd(cmdDef),
+		{
+			// IMPROVE: allow reading the relay payload from a file
+			Use:   ""Relay <applicationAddrHex> <servicerAddrHex> <relayChainID> <relayPayload>"",
+			Short: ""Relay <applicationAddrHex> <servicerAddrHex> <relayChainID> <relayPayload>"",
+			Long: `Sends a trustless relay using <relayPayload> as contents, to the specified active <servicerAddrHex> in the the <applicationAddrHex>'s session.
+Will prompt the user for the *application* account passphrase`,
+			Aliases: []string{},
+			Args:    cobra.ExactArgs(4),
+			RunE: func(cmd *cobra.Command, args []string) error {
+				applicationAddr := args[0]
+				servicerAddr := args[1]
+				chain := args[2]
+				relayPayload := args[3]
+
+				// REFACTOR: decouple the client logic from the CLI
+				//	The client will: send the trustless relay and return the response (using a single function as entrypoint)
+				//	The CLI will:
+				//		1) extract the required input from the command arguments
+				//		2) call the client function that performs the trustless relay
+				pk, err := getPrivateKeyFromKeybase(applicationAddr)
+				if err != nil {
+					return fmt.Errorf(""error getting application's private key: %w"", err)
+				}
+
+				// TECHDEBT(#791): cache session data
+				session, err := getCurrentSession(cmd.Context(), applicationAddr, chain)
+				if err != nil {
+					return fmt.Errorf(""Error getting current session: %w"", err)
+				}
+
+				servicer, err := validateServicer(cmd.Context(), session, servicerAddr)
+				if err != nil {
+					return fmt.Errorf(""error getting servicer for the relay: %w"", err)
+				}
+
+				relay, err := buildRelay(relayPayload, pk, session, servicer)
+				if err != nil {
+					return fmt.Errorf(""error building relay from payload: %w"", err)
+				}
+
+				fmt.Printf(""sending trustless relay for %s to %v with payload: %s\n"", applicationAddr, servicer, relayPayload)
+
+				resp, err := sendTrustlessRelay(cmd.Context(), servicer.ServiceUrl, relay)
+				if err != nil {
+					return err
+				}
+
+				fmt.Printf(""HTTP status code: %d\n"", resp.HTTPResponse.StatusCode)
+				fmt.Println(""Response: "", resp.JSON200)
+
+				return nil
+			},
+		},
+	}
+
+	return cmds
+}
+
+// DECIDE: do we need/want a cli subcommand for fetching sessions?
+// validateServicer returns the servicer specified by the <servicer> argument.
+// It validates that the <servicer> is the address of a servicer that is active in the passed session.
+func validateServicer(ctx context.Context, session *rpc.Session, servicerAddress string) (*rpc.ProtocolActor, error) {
+	for _, s := range session.Servicers {
+		if s.Address == servicerAddress {
+			return &s, nil
+		}
+	}
+
+	// ADDTEST: cover with gherkin tests
+	return nil, fmt.Errorf(""Error getting servicer: address %s does not match any servicers in the session %d"", servicerAddress, session.SessionNumber)
+}
+
+func getCurrentSession(ctx context.Context, appAddress, chain string) (*rpc.Session, error) {
+	// CONSIDERATION: passing 0 as the height value to get the current session seems more optimal than this.
+	currentHeight, err := getCurrentHeight(ctx)
+	if err != nil {
+		return nil, fmt.Errorf(""Error getting current session: %w"", err)
+	}
+
+	req := rpc.SessionRequest{
+		AppAddress: appAddress,
+		Chain:      chain,
+		// TODO(#697): Geozone
+		SessionHeight: currentHeight,
+	}
+
+	client, err := rpc.NewClientWithResponses(remoteCLIURL)
+	if err != nil {
+		return nil, fmt.Errorf(""Error getting current session for app/chain/height: %s/%s/%d: %w"", appAddress, chain, currentHeight, err)
+	}
+
+	resp, err := client.PostV1ClientGetSessionWithResponse(ctx, req)
+	if err != nil {
+		return nil, fmt.Errorf(""Error getting current session with request %v: %w"", req, err)
+	}
+	// TODO: refactor boiler-plate code
+	if resp.HTTPResponse.StatusCode != http.StatusOK {
+		return nil, fmt.Errorf(""Error getting current session: Unexpected status code %d for request %v"", resp.HTTPResponse.StatusCode, req)
+	}
+
+	if resp.JSON200 == nil {
+		return nil, fmt.Errorf(""Error getting current session: Unexpected response %v"", resp)
+	}
+
+	return resp.JSON200, nil
+}
+
+// TODO: reuse this function in the query commands
+func getCurrentHeight(ctx context.Context) (int64, error) {
+	client, err := rpc.NewClientWithResponses(remoteCLIURL)
+	if err != nil {
+		return 0, fmt.Errorf(""Error getting current height: %w"", err)
+	}
+	resp, err := client.GetV1QueryHeightWithResponse(ctx)
+	if err != nil {
+		return 0, fmt.Errorf(""Error getting current height: %w"", err)
+	}
+	if resp.HTTPResponse.StatusCode != http.StatusOK {
+		return 0, fmt.Errorf(""Error getting current height: Unexpected status code %d"", resp.HTTPResponse.StatusCode)
+	}
+
+	if resp.JSON200 == nil {
+		return 0, fmt.Errorf(""Error getting current height: Unexpected response %v"", resp)
+	}
+
+	return resp.JSON200.Height, nil
+}
+
+// IMPROVE: [K8s][LocalNet] Publish Servicer(s) Host and Port as env. vars in K8s: similar to Validators
+// REFACTOR: move package-level variables (e.g. remoteCLIURL) to a cli object.
+func sendTrustlessRelay(ctx context.Context, servicerUrl string, relay *rpc.RelayRequest) (*rpc.PostV1ClientRelayResponse, error) {
+	client, err := rpc.NewClientWithResponses(servicerUrl)
+	if err != nil {
+		return nil, err
+	}
+
+	return client.PostV1ClientRelayWithResponse(ctx, *relay)
+}
+
+func buildRelay(payload string, appPrivateKey crypto.PrivateKey, session *rpc.Session, servicer *rpc.ProtocolActor) (*rpc.RelayRequest, error) {
+	// TECHDEBT: This is mostly COPIED from pocket-go: we should refactor pocket-go code and import this functionality from there instead.
+	relayPayload := rpc.Payload{
+		// INCOMPLETE: need to unmarshal into JSONRPC (and other supported relay formats), using a custom unmarshaller
+		Jsonrpc: ""2.0"",
+		Method:  payload,
+		// TODO: Path: load Path field from the corresponding Blockchain (e.g. database)
+		// TODO: set Headers
+	}
+
+	relayMeta := rpc.RelayRequestMeta{
+		BlockHeight: session.SessionHeight,
+		// TODO: use Identifiable for Chain in Session (or string for Chain in Relay Meta)
+		Chain: rpc.Identifiable{
+			Id: session.Chain,
+		},
+		ServicerPubKey: servicer.PublicKey,
+		// TODO(#697): Geozone
+	}
+
+	relay := &rpc.RelayRequest{
+		Payload: relayPayload,
+		Meta:    relayMeta,
+		// DISCUSS: why is there no Proof field in v1 struct?
+	}
+	reqBytes, err := json.Marshal(relay)
+	if err != nil {
+		return nil, fmt.Errorf(""Error marshalling relay request %v: %w"", relay, err)
+	}
+	hashedReq := crypto.SHA3Hash(reqBytes)
+	signature, err := appPrivateKey.Sign(hashedReq)
+	if err != nil {
+		return relay, fmt.Errorf(""Error signing relay: %w"", err)
+	}
+	relay.Meta.Signature = hex.EncodeToString(signature)
+
+	return relay, nil
+}
+
+// TECHDEBT: remove use of package-level variables",app/client/cli/servicer.go,2023-05-30 21:47:06+00:00,2023-05-30T22:42:12Z,"Can you add a few examples for the reader `... variables such as nonInteractive, remoteCLIURL, etc...`",,,,,223,RIGHT,223,,line,https://api.github.com/repos/pokt-network/pocket/pulls/778,pokt-network/pocket,a516c51f2d000d25f1469d28e6586ef7875d5a37
https://api.github.com/repos/pokt-network/pocket/pulls/778,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1210857076,Olshansk,3f7c8f63ff1d05e64f8672113a70545632501fca,acec260d9987f4dba2b31bdf4b65f2ef6b654725,"@@ -229,3 +206,37 @@ func (s *rpcServer) GetV1P2pStakedActorsAddressBook(ctx echo.Context, params Get
 
 	return ctx.JSON(http.StatusOK, response)
 }
+
+// TECHDEBT: handle other relay payload types
+func buildRelayPayload(body RelayRequest) *coreTypes.Relay {",rpc/handlers.go,2023-05-30 21:48:44+00:00,2023-05-30T22:42:12Z,Optional NIT/overkill: Consider renaming to `buildJsonRPCRelayPayload` or add a helper called underneath.,,,,,211,RIGHT,55,,line,https://api.github.com/repos/pokt-network/pocket/pulls/778,pokt-network/pocket,a516c51f2d000d25f1469d28e6586ef7875d5a37
https://api.github.com/repos/pokt-network/pocket/pulls/778,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1210857492,Olshansk,3f7c8f63ff1d05e64f8672113a70545632501fca,acec260d9987f4dba2b31bdf4b65f2ef6b654725,"@@ -229,3 +206,37 @@ func (s *rpcServer) GetV1P2pStakedActorsAddressBook(ctx echo.Context, params Get
 
 	return ctx.JSON(http.StatusOK, response)
 }
+
+// TECHDEBT: handle other relay payload types
+func buildRelayPayload(body RelayRequest) *coreTypes.Relay {
+	payload := &coreTypes.Relay_JsonRpcPayload{
+		JsonRpcPayload: &coreTypes.JSONRPCPayload{
+			JsonRpc: body.Payload.Jsonrpc,
+			Method:  body.Payload.Method,
+		},
+	}
+
+	if body.Payload.Id != nil {
+		payload.JsonRpcPayload.Id = []byte(*body.Payload.Id)
+	}
+
+	if body.Payload.Path != nil {",rpc/handlers.go,2023-05-30 21:49:15+00:00,2023-05-30T22:42:12Z,Should we succeed if these are unspecified?,,,,,223,RIGHT,67,,line,https://api.github.com/repos/pokt-network/pocket/pulls/778,pokt-network/pocket,a516c51f2d000d25f1469d28e6586ef7875d5a37
https://api.github.com/repos/pokt-network/pocket/pulls/778,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1210857956,Olshansk,3f7c8f63ff1d05e64f8672113a70545632501fca,acec260d9987f4dba2b31bdf4b65f2ef6b654725,"@@ -229,3 +206,37 @@ func (s *rpcServer) GetV1P2pStakedActorsAddressBook(ctx echo.Context, params Get
 
 	return ctx.JSON(http.StatusOK, response)
 }
+
+// TECHDEBT: handle other relay payload types
+func buildRelayPayload(body RelayRequest) *coreTypes.Relay {
+	payload := &coreTypes.Relay_JsonRpcPayload{
+		JsonRpcPayload: &coreTypes.JSONRPCPayload{
+			JsonRpc: body.Payload.Jsonrpc,
+			Method:  body.Payload.Method,
+		},
+	}
+
+	if body.Payload.Id != nil {
+		payload.JsonRpcPayload.Id = []byte(*body.Payload.Id)
+	}
+
+	if body.Payload.Path != nil {
+		payload.JsonRpcPayload.HttpPath = *body.Payload.Path
+	}
+
+	if body.Payload.Parameters != nil {
+		payload.JsonRpcPayload.Parameters = *body.Payload.Parameters
+	}
+
+	if body.Payload.Headers != nil {
+		headers := make(map[string]string)
+		for _, header := range *body.Payload.Headers {",rpc/handlers.go,2023-05-30 21:49:54+00:00,2023-05-30T22:42:13Z,Why do we need to dereference `body.Payload.Headers` here?,,,,238.0,233,RIGHT,77,58.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/778,pokt-network/pocket,a516c51f2d000d25f1469d28e6586ef7875d5a37
https://api.github.com/repos/pokt-network/pocket/pulls/778,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1210858477,Olshansk,3f7c8f63ff1d05e64f8672113a70545632501fca,acec260d9987f4dba2b31bdf4b65f2ef6b654725,"@@ -229,3 +206,37 @@ func (s *rpcServer) GetV1P2pStakedActorsAddressBook(ctx echo.Context, params Get
 
 	return ctx.JSON(http.StatusOK, response)
 }
+
+// TECHDEBT: handle other relay payload types
+func buildRelayPayload(body RelayRequest) *coreTypes.Relay {
+	payload := &coreTypes.Relay_JsonRpcPayload{
+		JsonRpcPayload: &coreTypes.JSONRPCPayload{
+			JsonRpc: body.Payload.Jsonrpc,
+			Method:  body.Payload.Method,
+		},
+	}
+
+	if body.Payload.Id != nil {
+		payload.JsonRpcPayload.Id = []byte(*body.Payload.Id)
+	}
+
+	if body.Payload.Path != nil {
+		payload.JsonRpcPayload.HttpPath = *body.Payload.Path
+	}
+
+	if body.Payload.Parameters != nil {
+		payload.JsonRpcPayload.Parameters = *body.Payload.Parameters
+	}
+
+	if body.Payload.Headers != nil {
+		headers := make(map[string]string)
+		for _, header := range *body.Payload.Headers {
+			headers[header.Name] = header.Value",rpc/handlers.go,2023-05-30 21:50:31+00:00,2023-05-30T22:42:13Z,Why not assign to `payload.JsonRpcPayload.Headers[header.Name]` directly? I believe it's auto initialized to an empty map.,,,,239.0,234,RIGHT,78,59.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/778,pokt-network/pocket,a516c51f2d000d25f1469d28e6586ef7875d5a37
https://api.github.com/repos/pokt-network/pocket/pulls/778,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1210858705,Olshansk,3f7c8f63ff1d05e64f8672113a70545632501fca,acec260d9987f4dba2b31bdf4b65f2ef6b654725,"@@ -6,24 +6,37 @@ option go_package = ""github.com/pokt-network/pocket/shared/core/types"";
 
 // TECHDEBT: These structures were copied as placeholders from v0 and need to be updated to reflect changes in v1
 message Relay {
-    RelayPayload payload = 1;
-    RelayMeta meta = 2;
+    RelayMeta meta = 1;
+    oneof RelayPayload {
+        JSONRPCPayload json_rpc_payload = 2;
+        RESTPayload rest_payload = 3;
+        //DISCUSS: content of the following types:",shared/core/types/proto/relay.proto,2023-05-30 21:50:51+00:00,2023-05-30T22:42:13Z,"```suggestion
        // DISCUSS: design and content of other relay types
```",,,,,13,RIGHT,10,,line,https://api.github.com/repos/pokt-network/pocket/pulls/778,pokt-network/pocket,a516c51f2d000d25f1469d28e6586ef7875d5a37
https://api.github.com/repos/pokt-network/pocket/pulls/778,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1210869602,Olshansk,3f7c8f63ff1d05e64f8672113a70545632501fca,acec260d9987f4dba2b31bdf4b65f2ef6b654725,"@@ -6,24 +6,37 @@ option go_package = ""github.com/pokt-network/pocket/shared/core/types"";
 
 // TECHDEBT: These structures were copied as placeholders from v0 and need to be updated to reflect changes in v1
 message Relay {
-    RelayPayload payload = 1;
-    RelayMeta meta = 2;
+    RelayMeta meta = 1;
+    oneof RelayPayload {
+        JSONRPCPayload json_rpc_payload = 2;
+        RESTPayload rest_payload = 3;
+        //DISCUSS: content of the following types:
+        // GRPCPayload grpc_payload = 3;
+        // GraphQLPayload graphql_payload = 4;
+        // WebSocketsPayload websockets_payload = 5;
+    }
 }
 
-message RelayPayload {
-    string data = 1;
-    string method = 2;
-    string http_path = 3;
-    map<string, string> headers = 4;
+message RESTPayload {
+    string contents = 1;
+}
+
+message JSONRPCPayload {
+    bytes id = 1;
+    string json_rpc = 2;
+    string method = 3;
+    bytes parameters = 4;",shared/core/types/proto/relay.proto,2023-05-30 22:04:55+00:00,2023-05-30T22:42:13Z,should this be `repeated bytes parameters`?,,,,46.0,28,RIGHT,30,51.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/778,pokt-network/pocket,a516c51f2d000d25f1469d28e6586ef7875d5a37
https://api.github.com/repos/pokt-network/pocket/pulls/778,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1210870081,Olshansk,3f7c8f63ff1d05e64f8672113a70545632501fca,acec260d9987f4dba2b31bdf4b65f2ef6b654725,"@@ -6,24 +6,37 @@ option go_package = ""github.com/pokt-network/pocket/shared/core/types"";
 
 // TECHDEBT: These structures were copied as placeholders from v0 and need to be updated to reflect changes in v1
 message Relay {
-    RelayPayload payload = 1;
-    RelayMeta meta = 2;
+    RelayMeta meta = 1;
+    oneof RelayPayload {
+        JSONRPCPayload json_rpc_payload = 2;
+        RESTPayload rest_payload = 3;
+        //DISCUSS: content of the following types:
+        // GRPCPayload grpc_payload = 3;
+        // GraphQLPayload graphql_payload = 4;
+        // WebSocketsPayload websockets_payload = 5;
+    }
 }
 
-message RelayPayload {
-    string data = 1;
-    string method = 2;
-    string http_path = 3;
-    map<string, string> headers = 4;
+message RESTPayload {
+    string contents = 1;
+}
+
+message JSONRPCPayload {
+    bytes id = 1;",shared/core/types/proto/relay.proto,2023-05-30 22:05:19+00:00,2023-05-30T22:42:13Z,What does the `id` represent?,,,,36.0,25,RIGHT,27,41.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/778,pokt-network/pocket,a516c51f2d000d25f1469d28e6586ef7875d5a37
https://api.github.com/repos/pokt-network/pocket/pulls/778,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1210870421,Olshansk,3f7c8f63ff1d05e64f8672113a70545632501fca,acec260d9987f4dba2b31bdf4b65f2ef6b654725,"@@ -6,24 +6,37 @@ option go_package = ""github.com/pokt-network/pocket/shared/core/types"";
 
 // TECHDEBT: These structures were copied as placeholders from v0 and need to be updated to reflect changes in v1
 message Relay {
-    RelayPayload payload = 1;
-    RelayMeta meta = 2;
+    RelayMeta meta = 1;
+    oneof RelayPayload {
+        JSONRPCPayload json_rpc_payload = 2;
+        RESTPayload rest_payload = 3;
+        //DISCUSS: content of the following types:
+        // GRPCPayload grpc_payload = 3;
+        // GraphQLPayload graphql_payload = 4;
+        // WebSocketsPayload websockets_payload = 5;
+    }
 }
 
-message RelayPayload {
-    string data = 1;
-    string method = 2;
-    string http_path = 3;
-    map<string, string> headers = 4;
+message RESTPayload {
+    string contents = 1;
+}
+
+message JSONRPCPayload {
+    bytes id = 1;
+    string json_rpc = 2;
+    string method = 3;
+    bytes parameters = 4;
+    // DISCUSS: is HttpPath needed and is it a Meta field or Payload field?",shared/core/types/proto/relay.proto,2023-05-30 22:05:40+00:00,2023-05-30T22:42:13Z,"I don't really see/understand how `http_path` would be used in json-rpc because the method captures the functionality we are calling.

Can you:
1. Move http_path from `JSONRPCPayload` to `RESTPayload`
2. Add an enum in `RESTPayload` for the request type; `GET/SET/DELETE/etc`",,,,,29,RIGHT,31,,line,https://api.github.com/repos/pokt-network/pocket/pulls/778,pokt-network/pocket,a516c51f2d000d25f1469d28e6586ef7875d5a37
https://api.github.com/repos/pokt-network/pocket/pulls/778,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1210871683,Olshansk,3f7c8f63ff1d05e64f8672113a70545632501fca,acec260d9987f4dba2b31bdf4b65f2ef6b654725,"@@ -0,0 +1,53 @@
+package types
+
+import (
+	""encoding/json""
+	""errors""
+	""fmt""
+)
+
+var (
+	errInvalidRelayInvalidPayload  = errors.New(""invalid relay payload"")
+	errInvalidJSONRPCInvalidRPC    = errors.New(""invalid value for JSONRPC field"")",shared/core/types/relay.go,2023-05-30 22:07:12+00:00,2023-05-30T22:42:13Z,NIT: Do we need the second `Invalid` in the naming of these variables? I think can be omitted.,,10.0,RIGHT,,11,RIGHT,11,,line,https://api.github.com/repos/pokt-network/pocket/pulls/778,pokt-network/pocket,a516c51f2d000d25f1469d28e6586ef7875d5a37
https://api.github.com/repos/pokt-network/pocket/pulls/778,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1210872347,Olshansk,3f7c8f63ff1d05e64f8672113a70545632501fca,acec260d9987f4dba2b31bdf4b65f2ef6b654725,"@@ -0,0 +1,53 @@
+package types
+
+import (
+	""encoding/json""
+	""errors""
+	""fmt""
+)
+
+var (
+	errInvalidRelayInvalidPayload  = errors.New(""invalid relay payload"")",shared/core/types/relay.go,2023-05-30 22:07:57+00:00,2023-05-30T22:42:13Z,"```suggestion
	// TODO: Once the proto structures are finalized, add an exhaustive list of errors and tests
	errInvalidRelayInvalidPayload  = errors.New(""invalid relay payload"")
```",,,,,10,RIGHT,10,,line,https://api.github.com/repos/pokt-network/pocket/pulls/778,pokt-network/pocket,a516c51f2d000d25f1469d28e6586ef7875d5a37
https://api.github.com/repos/pokt-network/pocket/pulls/778,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1210883275,Olshansk,3f7c8f63ff1d05e64f8672113a70545632501fca,acec260d9987f4dba2b31bdf4b65f2ef6b654725,"@@ -6,24 +6,37 @@ option go_package = ""github.com/pokt-network/pocket/shared/core/types"";
 
 // TECHDEBT: These structures were copied as placeholders from v0 and need to be updated to reflect changes in v1
 message Relay {
-    RelayPayload payload = 1;
-    RelayMeta meta = 2;
+    RelayMeta meta = 1;
+    oneof RelayPayload {",shared/core/types/proto/relay.proto,2023-05-30 22:24:10+00:00,2023-05-30T22:42:13Z,Should we `snake_case` `RelayPayload` to stay consistent with other proto fields? I believe it gets auto camel-cased when converted to a go struct.,,,,,10,RIGHT,7,,line,https://api.github.com/repos/pokt-network/pocket/pulls/778,pokt-network/pocket,a516c51f2d000d25f1469d28e6586ef7875d5a37
https://api.github.com/repos/pokt-network/pocket/pulls/778,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1210883684,Olshansk,3f7c8f63ff1d05e64f8672113a70545632501fca,acec260d9987f4dba2b31bdf4b65f2ef6b654725,"@@ -0,0 +1,53 @@
+package types
+
+import (
+	""encoding/json""
+	""errors""
+	""fmt""
+)
+
+var (
+	errInvalidRelayInvalidPayload  = errors.New(""invalid relay payload"")
+	errInvalidJSONRPCInvalidRPC    = errors.New(""invalid value for JSONRPC field"")
+	errInvalidJSONRPCMissingMethod = errors.New(""Method field not set"")
+	errInvalidRESTPayload          = errors.New(""invalid REST payload"")
+)
+
+// INCOMPLETE: perform any possible metadata validation
+// Validate performs validation on the relay payload
+func (r Relay) Validate() error {",shared/core/types/relay.go,2023-05-30 22:24:47+00:00,2023-05-30T22:42:13Z,Question: Why not do a switch-case statement on `switch r.RelayPayload.(type) {`,,,,,18,RIGHT,18,,line,https://api.github.com/repos/pokt-network/pocket/pulls/778,pokt-network/pocket,a516c51f2d000d25f1469d28e6586ef7875d5a37
https://api.github.com/repos/pokt-network/pocket/pulls/778,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1210884036,Olshansk,3f7c8f63ff1d05e64f8672113a70545632501fca,acec260d9987f4dba2b31bdf4b65f2ef6b654725,"@@ -0,0 +1,53 @@
+package types
+
+import (
+	""encoding/json""
+	""errors""
+	""fmt""
+)
+
+var (
+	errInvalidRelayInvalidPayload  = errors.New(""invalid relay payload"")
+	errInvalidJSONRPCInvalidRPC    = errors.New(""invalid value for JSONRPC field"")
+	errInvalidJSONRPCMissingMethod = errors.New(""Method field not set"")
+	errInvalidRESTPayload          = errors.New(""invalid REST payload"")
+)
+
+// INCOMPLETE: perform any possible metadata validation
+// Validate performs validation on the relay payload
+func (r Relay) Validate() error {
+	if jsonRpcPayload := r.GetJsonRpcPayload(); jsonRpcPayload != nil {
+		return jsonRpcPayload.Validate()
+	}
+
+	if jsonPayload := r.GetRestPayload(); jsonPayload != nil {
+		return jsonPayload.Validate()
+	}
+
+	return fmt.Errorf(""%w: %v"", errInvalidRelayInvalidPayload, r)
+}
+
+// Validate performs validation on JSONRPC payload. More specifically, it verifies that:
+//  1. The JSONRPC field is set to ""2.0"" as per the JSONRPC spec requirement, and
+//  2. The Method field is not empty
+func (p JSONRPCPayload) Validate() error {
+	if p.JsonRpc != ""2.0"" {",shared/core/types/relay.go,2023-05-30 22:25:23+00:00,2023-05-30T22:42:13Z,"Consider moving ""2.0"" into a local constant",,,,,34,RIGHT,34,,line,https://api.github.com/repos/pokt-network/pocket/pulls/778,pokt-network/pocket,a516c51f2d000d25f1469d28e6586ef7875d5a37
https://api.github.com/repos/pokt-network/pocket/pulls/778,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1210886115,Olshansk,3f7c8f63ff1d05e64f8672113a70545632501fca,acec260d9987f4dba2b31bdf4b65f2ef6b654725,"@@ -0,0 +1,53 @@
+package types
+
+import (
+	""encoding/json""
+	""errors""
+	""fmt""
+)
+
+var (
+	errInvalidRelayInvalidPayload  = errors.New(""invalid relay payload"")
+	errInvalidJSONRPCInvalidRPC    = errors.New(""invalid value for JSONRPC field"")
+	errInvalidJSONRPCMissingMethod = errors.New(""Method field not set"")
+	errInvalidRESTPayload          = errors.New(""invalid REST payload"")
+)
+
+// INCOMPLETE: perform any possible metadata validation
+// Validate performs validation on the relay payload
+func (r Relay) Validate() error {
+	if jsonRpcPayload := r.GetJsonRpcPayload(); jsonRpcPayload != nil {
+		return jsonRpcPayload.Validate()
+	}
+
+	if jsonPayload := r.GetRestPayload(); jsonPayload != nil {
+		return jsonPayload.Validate()
+	}
+
+	return fmt.Errorf(""%w: %v"", errInvalidRelayInvalidPayload, r)
+}
+
+// Validate performs validation on JSONRPC payload. More specifically, it verifies that:
+//  1. The JSONRPC field is set to ""2.0"" as per the JSONRPC spec requirement, and
+//  2. The Method field is not empty
+func (p JSONRPCPayload) Validate() error {
+	if p.JsonRpc != ""2.0"" {
+		return fmt.Errorf(""%w: %s"", errInvalidJSONRPCInvalidRPC, p.JsonRpc)
+	}
+
+	// DISCUSS: do we need/want chain-specific validation? Potential for reusing the existing logic of Portal V2/pocket-go",shared/core/types/relay.go,2023-05-30 22:29:21+00:00,2023-05-30T22:42:13Z,"We still haven't fully defined what relay chains will look like.

For example, what if they're `JWT` like tokens/strings that can hold more data to support general purpose RPC? `<Type>.<ID>.<Config>`. See slide 26 form https://docs.google.com/presentation/d/19NqPV0e6JbQzzwqEnfJ_WiMqpjaPwWo-qui6Xr3pNSQ/edit#slide=id.g23e8b9d22f1_0_134.

I think updating the TODO with some extra details and leaving as is should be good.

",,,,41.0,38,RIGHT,38,41.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/778,pokt-network/pocket,a516c51f2d000d25f1469d28e6586ef7875d5a37
https://api.github.com/repos/pokt-network/pocket/pulls/778,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1210886498,Olshansk,3f7c8f63ff1d05e64f8672113a70545632501fca,acec260d9987f4dba2b31bdf4b65f2ef6b654725,"@@ -0,0 +1,53 @@
+package types
+
+import (
+	""encoding/json""
+	""errors""
+	""fmt""
+)
+
+var (
+	errInvalidRelayInvalidPayload  = errors.New(""invalid relay payload"")
+	errInvalidJSONRPCInvalidRPC    = errors.New(""invalid value for JSONRPC field"")
+	errInvalidJSONRPCMissingMethod = errors.New(""Method field not set"")
+	errInvalidRESTPayload          = errors.New(""invalid REST payload"")
+)
+
+// INCOMPLETE: perform any possible metadata validation
+// Validate performs validation on the relay payload
+func (r Relay) Validate() error {
+	if jsonRpcPayload := r.GetJsonRpcPayload(); jsonRpcPayload != nil {
+		return jsonRpcPayload.Validate()
+	}
+
+	if jsonPayload := r.GetRestPayload(); jsonPayload != nil {
+		return jsonPayload.Validate()
+	}
+
+	return fmt.Errorf(""%w: %v"", errInvalidRelayInvalidPayload, r)
+}
+
+// Validate performs validation on JSONRPC payload. More specifically, it verifies that:
+//  1. The JSONRPC field is set to ""2.0"" as per the JSONRPC spec requirement, and
+//  2. The Method field is not empty
+func (p JSONRPCPayload) Validate() error {
+	if p.JsonRpc != ""2.0"" {
+		return fmt.Errorf(""%w: %s"", errInvalidJSONRPCInvalidRPC, p.JsonRpc)
+	}
+
+	// DISCUSS: do we need/want chain-specific validation? Potential for reusing the existing logic of Portal V2/pocket-go
+	if p.Method == """" {
+		return errInvalidJSONRPCMissingMethod
+	}
+	return nil
+}
+
+// Validate verifies that the payload is valid REST, i.e. valid JSON
+func (p RESTPayload) Validate() error {
+	var parsed json.RawMessage
+	err := json.Unmarshal([]byte(p.Contents), &parsed)
+	if err != nil {",shared/core/types/relay.go,2023-05-30 22:30:04+00:00,2023-05-30T22:42:13Z,"```suggestion
	if err := json.Unmarshal([]byte(p.Contents), &parsed); err != nil {
```",,48.0,RIGHT,,49,RIGHT,49,,line,https://api.github.com/repos/pokt-network/pocket/pulls/778,pokt-network/pocket,a516c51f2d000d25f1469d28e6586ef7875d5a37
https://api.github.com/repos/pokt-network/pocket/pulls/778,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1210887371,Olshansk,3f7c8f63ff1d05e64f8672113a70545632501fca,acec260d9987f4dba2b31bdf4b65f2ef6b654725,"@@ -0,0 +1,137 @@
+package types
+
+import (
+	""errors""
+	""testing""
+)
+
+func TestRelayValidate(t *testing.T) {
+	testCases := []struct {
+		name     string
+		relay    Relay
+		expected error
+	}{
+		{
+			name: ""valid Relay: JSONRPC"",
+			// IMPROVE: use a factory function to build test relays",shared/core/types/relay_test.go,2023-05-30 22:30:44+00:00,2023-05-30T22:42:13Z,"I think this `IMPROVE` belongs in `relay.go` instead of test, no?",,,,,16,RIGHT,16,,line,https://api.github.com/repos/pokt-network/pocket/pulls/778,pokt-network/pocket,a516c51f2d000d25f1469d28e6586ef7875d5a37
https://api.github.com/repos/pokt-network/pocket/pulls/778,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1210890155,Olshansk,3f7c8f63ff1d05e64f8672113a70545632501fca,acec260d9987f4dba2b31bdf4b65f2ef6b654725,"@@ -0,0 +1,137 @@
+package types
+
+import (
+	""errors""
+	""testing""
+)
+
+func TestRelayValidate(t *testing.T) {
+	testCases := []struct {
+		name     string
+		relay    Relay
+		expected error
+	}{
+		{
+			name: ""valid Relay: JSONRPC"",
+			// IMPROVE: use a factory function to build test relays
+			relay: Relay{
+				RelayPayload: &Relay_JsonRpcPayload{
+					JsonRpcPayload: &JSONRPCPayload{JsonRpc: ""2.0"", Method: ""eth_blockNumber""},
+				},
+			},
+		},
+		{
+			name: ""valid Relay: REST"",
+			relay: Relay{
+				RelayPayload: &Relay_RestPayload{
+					RestPayload: &RESTPayload{Contents: `{""field1"": ""value1"", ""field2"": ""value2""}`},
+				},
+			},
+		},
+		{
+			name:     ""invalid Relay: missing payload"",
+			expected: errInvalidRelayInvalidPayload,
+		},
+		{
+			name: ""invalid Relay: invalid JSONRPC Payload"",
+			relay: Relay{
+				RelayPayload: &Relay_JsonRpcPayload{
+					JsonRpcPayload: &JSONRPCPayload{JsonRpc: ""foo""},
+				},
+			},
+			expected: errInvalidJSONRPCInvalidRPC,
+		},
+		{
+			name: ""invalid Relay: invalid REST Payload"",
+			relay: Relay{
+				RelayPayload: &Relay_RestPayload{
+					RestPayload: &RESTPayload{Contents: ""foo""},
+				},
+			},
+			expected: errInvalidRESTPayload,
+		},
+	}
+
+	for _, testCase := range testCases {
+		t.Run(testCase.name, func(t *testing.T) {
+			err := testCase.relay.Validate()
+			switch {
+			case err == nil && testCase.expected != nil:
+				t.Fatalf(""Expected error %v, got: nil"", testCase.expected)",shared/core/types/relay_test.go,2023-05-30 22:35:05+00:00,2023-05-30T22:42:13Z,"We use the `testify` package, which does automatic ""expected vs got"" type comments. https://pkg.go.dev/github.com/stretchr/testify/require#Error

You should be able to do:

```go
if testCase.expected == nil {
	require.NoError(t, err)
} else {
	require.ErrorIs(t, err, testCase.expected)
}
```

Ditto below",,,,,60,RIGHT,60,,line,https://api.github.com/repos/pokt-network/pocket/pulls/778,pokt-network/pocket,a516c51f2d000d25f1469d28e6586ef7875d5a37
https://api.github.com/repos/pokt-network/pocket/pulls/778,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1231600186,Olshansk,78515389863161a80de1f110688d58090fbc0efc,acec260d9987f4dba2b31bdf4b65f2ef6b654725,"@@ -0,0 +1,243 @@
+package cli
+
+import (
+	""context""
+	""encoding/hex""
+	""encoding/json""
+	""fmt""
+	""net/http""
+
+	""github.com/spf13/cobra""
+
+	""github.com/pokt-network/pocket/rpc""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/crypto""
+)
+
+func init() {
+	rootCmd.AddCommand(NewServicerCommand())
+}
+
+func NewServicerCommand() *cobra.Command {
+	cmd := &cobra.Command{
+		Use:     ""Servicer"",
+		Short:   ""Servicer specific commands"",
+		Aliases: []string{""servicer""},
+		Args:    cobra.ExactArgs(0),
+	}
+
+	cmds := servicerCommands()
+	applySubcommandOptions(cmds, attachPwdFlagToSubcommands())
+	applySubcommandOptions(cmds, attachKeybaseFlagsToSubcommands())
+
+	cmd.AddCommand(cmds...)
+
+	return cmd
+}
+
+func servicerCommands() []*cobra.Command {
+	cmdDef := actorCmdDef{""Servicer"", coreTypes.ActorType_ACTOR_TYPE_SERVICER}
+	cmds := []*cobra.Command{
+		newStakeCmd(cmdDef),
+		newEditStakeCmd(cmdDef),
+		newUnstakeCmd(cmdDef),
+		newUnpauseCmd(cmdDef),
+		{
+			// IMPROVE: allow reading the relay payload from a file with the serialized protobuf via [--input_file]
+			Use:   ""Relay <applicationAddrHex> <servicerAddrHex> <relayChainID> <relayPayload>"",
+			Short: ""Relay <applicationAddrHex> <servicerAddrHex> <relayChainID> <relayPayload>"",
+			Long: `Sends a trustless relay using <relayPayload> as contents, to the specified active <servicerAddrHex> in the the <applicationAddrHex>'s session.
+Will prompt the user for the *application* account passphrase`,
+			Aliases: []string{},
+			Args:    cobra.ExactArgs(4),
+			RunE: func(cmd *cobra.Command, args []string) error {
+				applicationAddr := args[0]
+				servicerAddr := args[1]
+				chain := args[2]
+				relayPayload := args[3]
+
+				// REFACTOR: decouple the client logic from the CLI
+				//	The client will: send the trustless relay and return the response (using a single function as entrypoint)
+				//	The CLI will:
+				//		1) extract the required input from the command arguments
+				//		2) call the client function (with the inputs above) that performs the trustless relay
+				pk, err := getPrivateKeyFromKeybase(applicationAddr)
+				if err != nil {
+					return fmt.Errorf(""error getting application's private key: %w"", err)
+				}
+
+				// TECHDEBT(#791): cache session data
+				session, err := getCurrentSession(cmd.Context(), applicationAddr, chain)
+				if err != nil {
+					return fmt.Errorf(""Error getting current session: %w"", err)
+				}
+
+				servicer, err := validateServicer(cmd.Context(), session, servicerAddr)
+				if err != nil {
+					return fmt.Errorf(""error getting servicer for the relay: %w"", err)
+				}
+
+				relay, err := buildRelay(relayPayload, pk, session, servicer)
+				if err != nil {
+					return fmt.Errorf(""error building relay from payload: %w"", err)
+				}
+
+				fmt.Printf(""sending trustless relay for %s to %s with payload: %s\n"", applicationAddr, servicerAddr, relayPayload)
+
+				resp, err := sendTrustlessRelay(cmd.Context(), servicer.ServiceUrl, relay)
+				if err != nil {
+					return err
+				}
+
+				fmt.Printf(""HTTP status code: %d\n"", resp.HTTPResponse.StatusCode)
+				fmt.Println(""Response: "", resp.JSON200)
+
+				return nil
+			},
+		},
+	}
+
+	return cmds
+}
+
+// TODO: add a cli command for fetching sessions",app/client/cli/servicer.go,2023-06-15 22:37:15+00:00,2023-06-15T22:57:24Z,I think I already asked this but why is `/v1/client/get_session:` insufficient?,,,,104.0,103,RIGHT,103,104.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/778,pokt-network/pocket,a516c51f2d000d25f1469d28e6586ef7875d5a37
https://api.github.com/repos/pokt-network/pocket/pulls/778,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1231600955,Olshansk,78515389863161a80de1f110688d58090fbc0efc,acec260d9987f4dba2b31bdf4b65f2ef6b654725,"@@ -0,0 +1,243 @@
+package cli
+
+import (
+	""context""
+	""encoding/hex""
+	""encoding/json""
+	""fmt""
+	""net/http""
+
+	""github.com/spf13/cobra""
+
+	""github.com/pokt-network/pocket/rpc""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/crypto""
+)
+
+func init() {
+	rootCmd.AddCommand(NewServicerCommand())
+}
+
+func NewServicerCommand() *cobra.Command {
+	cmd := &cobra.Command{
+		Use:     ""Servicer"",
+		Short:   ""Servicer specific commands"",
+		Aliases: []string{""servicer""},
+		Args:    cobra.ExactArgs(0),
+	}
+
+	cmds := servicerCommands()
+	applySubcommandOptions(cmds, attachPwdFlagToSubcommands())
+	applySubcommandOptions(cmds, attachKeybaseFlagsToSubcommands())
+
+	cmd.AddCommand(cmds...)
+
+	return cmd
+}
+
+func servicerCommands() []*cobra.Command {
+	cmdDef := actorCmdDef{""Servicer"", coreTypes.ActorType_ACTOR_TYPE_SERVICER}
+	cmds := []*cobra.Command{
+		newStakeCmd(cmdDef),
+		newEditStakeCmd(cmdDef),
+		newUnstakeCmd(cmdDef),
+		newUnpauseCmd(cmdDef),
+		{
+			// IMPROVE: allow reading the relay payload from a file with the serialized protobuf via [--input_file]
+			Use:   ""Relay <applicationAddrHex> <servicerAddrHex> <relayChainID> <relayPayload>"",
+			Short: ""Relay <applicationAddrHex> <servicerAddrHex> <relayChainID> <relayPayload>"",
+			Long: `Sends a trustless relay using <relayPayload> as contents, to the specified active <servicerAddrHex> in the the <applicationAddrHex>'s session.
+Will prompt the user for the *application* account passphrase`,
+			Aliases: []string{},
+			Args:    cobra.ExactArgs(4),
+			RunE: func(cmd *cobra.Command, args []string) error {
+				applicationAddr := args[0]
+				servicerAddr := args[1]
+				chain := args[2]
+				relayPayload := args[3]
+
+				// REFACTOR: decouple the client logic from the CLI
+				//	The client will: send the trustless relay and return the response (using a single function as entrypoint)
+				//	The CLI will:
+				//		1) extract the required input from the command arguments
+				//		2) call the client function (with the inputs above) that performs the trustless relay
+				pk, err := getPrivateKeyFromKeybase(applicationAddr)
+				if err != nil {
+					return fmt.Errorf(""error getting application's private key: %w"", err)
+				}
+
+				// TECHDEBT(#791): cache session data
+				session, err := getCurrentSession(cmd.Context(), applicationAddr, chain)
+				if err != nil {
+					return fmt.Errorf(""Error getting current session: %w"", err)
+				}
+
+				servicer, err := validateServicer(cmd.Context(), session, servicerAddr)
+				if err != nil {
+					return fmt.Errorf(""error getting servicer for the relay: %w"", err)
+				}
+
+				relay, err := buildRelay(relayPayload, pk, session, servicer)
+				if err != nil {
+					return fmt.Errorf(""error building relay from payload: %w"", err)
+				}
+
+				fmt.Printf(""sending trustless relay for %s to %s with payload: %s\n"", applicationAddr, servicerAddr, relayPayload)
+
+				resp, err := sendTrustlessRelay(cmd.Context(), servicer.ServiceUrl, relay)
+				if err != nil {
+					return err
+				}
+
+				fmt.Printf(""HTTP status code: %d\n"", resp.HTTPResponse.StatusCode)
+				fmt.Println(""Response: "", resp.JSON200)
+
+				return nil
+			},
+		},
+	}
+
+	return cmds
+}
+
+// TODO: add a cli command for fetching sessions
+// validateServicer returns the servicer specified by the <servicer> argument.
+// It validates that the <servicer> is the address of a servicer that is active in the current session.
+func validateServicer(ctx context.Context, session *rpc.Session, servicerAddress string) (*rpc.ProtocolActor, error) {
+	for _, s := range session.Servicers {
+		if s.Address == servicerAddress {
+			return &s, nil
+		}
+	}
+
+	// ADDTEST: cover with gherkin tests
+	return nil, fmt.Errorf(""Error getting servicer: address %s does not match any servicers in the session %d"", servicerAddress, session.SessionNumber)
+}
+
+func getCurrentSession(ctx context.Context, appAddress, chain string) (*rpc.Session, error) {
+	// CONSIDERATION: passing 0 as the height value to get the current session seems more optimal than this.
+	currentHeight, err := getCurrentHeight(ctx)
+	if err != nil {
+		return nil, fmt.Errorf(""Error getting current session: %w"", err)
+	}
+
+	req := rpc.SessionRequest{
+		AppAddress: appAddress,
+		Chain:      chain,
+		// TODO(#697): Geozone
+		SessionHeight: currentHeight,
+	}
+
+	client, err := rpc.NewClientWithResponses(remoteCLIURL)
+	if err != nil {
+		return nil, fmt.Errorf(""Error getting current session for app/chain/height: %s/%s/%d: %w"", appAddress, chain, currentHeight, err)
+	}
+
+	resp, err := client.PostV1ClientGetSessionWithResponse(ctx, req)
+	if err != nil {
+		return nil, fmt.Errorf(""Error getting current session with request %v: %w"", req, err)
+	}
+
+	// IMPROVE: move the HTTP response processing code to a separate function to enable reuse.",app/client/cli/servicer.go,2023-06-15 22:38:42+00:00,2023-06-15T22:57:24Z,"```suggestion
	// CLEANUP: move the HTTP response processing code to a separate function to enable reuse.
```",,,,,141,RIGHT,141,,line,https://api.github.com/repos/pokt-network/pocket/pulls/778,pokt-network/pocket,a516c51f2d000d25f1469d28e6586ef7875d5a37
https://api.github.com/repos/pokt-network/pocket/pulls/778,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1231601395,Olshansk,78515389863161a80de1f110688d58090fbc0efc,acec260d9987f4dba2b31bdf4b65f2ef6b654725,"@@ -0,0 +1,243 @@
+package cli
+
+import (
+	""context""
+	""encoding/hex""
+	""encoding/json""
+	""fmt""
+	""net/http""
+
+	""github.com/spf13/cobra""
+
+	""github.com/pokt-network/pocket/rpc""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/crypto""
+)
+
+func init() {
+	rootCmd.AddCommand(NewServicerCommand())
+}
+
+func NewServicerCommand() *cobra.Command {
+	cmd := &cobra.Command{
+		Use:     ""Servicer"",
+		Short:   ""Servicer specific commands"",
+		Aliases: []string{""servicer""},
+		Args:    cobra.ExactArgs(0),
+	}
+
+	cmds := servicerCommands()
+	applySubcommandOptions(cmds, attachPwdFlagToSubcommands())
+	applySubcommandOptions(cmds, attachKeybaseFlagsToSubcommands())
+
+	cmd.AddCommand(cmds...)
+
+	return cmd
+}
+
+func servicerCommands() []*cobra.Command {
+	cmdDef := actorCmdDef{""Servicer"", coreTypes.ActorType_ACTOR_TYPE_SERVICER}
+	cmds := []*cobra.Command{
+		newStakeCmd(cmdDef),
+		newEditStakeCmd(cmdDef),
+		newUnstakeCmd(cmdDef),
+		newUnpauseCmd(cmdDef),
+		{
+			// IMPROVE: allow reading the relay payload from a file with the serialized protobuf via [--input_file]
+			Use:   ""Relay <applicationAddrHex> <servicerAddrHex> <relayChainID> <relayPayload>"",
+			Short: ""Relay <applicationAddrHex> <servicerAddrHex> <relayChainID> <relayPayload>"",
+			Long: `Sends a trustless relay using <relayPayload> as contents, to the specified active <servicerAddrHex> in the the <applicationAddrHex>'s session.
+Will prompt the user for the *application* account passphrase`,
+			Aliases: []string{},
+			Args:    cobra.ExactArgs(4),
+			RunE: func(cmd *cobra.Command, args []string) error {
+				applicationAddr := args[0]
+				servicerAddr := args[1]
+				chain := args[2]
+				relayPayload := args[3]
+
+				// REFACTOR: decouple the client logic from the CLI
+				//	The client will: send the trustless relay and return the response (using a single function as entrypoint)
+				//	The CLI will:
+				//		1) extract the required input from the command arguments
+				//		2) call the client function (with the inputs above) that performs the trustless relay
+				pk, err := getPrivateKeyFromKeybase(applicationAddr)
+				if err != nil {
+					return fmt.Errorf(""error getting application's private key: %w"", err)
+				}
+
+				// TECHDEBT(#791): cache session data
+				session, err := getCurrentSession(cmd.Context(), applicationAddr, chain)
+				if err != nil {
+					return fmt.Errorf(""Error getting current session: %w"", err)
+				}
+
+				servicer, err := validateServicer(cmd.Context(), session, servicerAddr)
+				if err != nil {
+					return fmt.Errorf(""error getting servicer for the relay: %w"", err)
+				}
+
+				relay, err := buildRelay(relayPayload, pk, session, servicer)
+				if err != nil {
+					return fmt.Errorf(""error building relay from payload: %w"", err)
+				}
+
+				fmt.Printf(""sending trustless relay for %s to %s with payload: %s\n"", applicationAddr, servicerAddr, relayPayload)
+
+				resp, err := sendTrustlessRelay(cmd.Context(), servicer.ServiceUrl, relay)
+				if err != nil {
+					return err
+				}
+
+				fmt.Printf(""HTTP status code: %d\n"", resp.HTTPResponse.StatusCode)
+				fmt.Println(""Response: "", resp.JSON200)
+
+				return nil
+			},
+		},
+	}
+
+	return cmds
+}
+
+// TODO: add a cli command for fetching sessions
+// validateServicer returns the servicer specified by the <servicer> argument.
+// It validates that the <servicer> is the address of a servicer that is active in the current session.
+func validateServicer(ctx context.Context, session *rpc.Session, servicerAddress string) (*rpc.ProtocolActor, error) {
+	for _, s := range session.Servicers {
+		if s.Address == servicerAddress {
+			return &s, nil
+		}
+	}
+
+	// ADDTEST: cover with gherkin tests
+	return nil, fmt.Errorf(""Error getting servicer: address %s does not match any servicers in the session %d"", servicerAddress, session.SessionNumber)
+}
+
+func getCurrentSession(ctx context.Context, appAddress, chain string) (*rpc.Session, error) {
+	// CONSIDERATION: passing 0 as the height value to get the current session seems more optimal than this.
+	currentHeight, err := getCurrentHeight(ctx)
+	if err != nil {
+		return nil, fmt.Errorf(""Error getting current session: %w"", err)
+	}
+
+	req := rpc.SessionRequest{
+		AppAddress: appAddress,
+		Chain:      chain,
+		// TODO(#697): Geozone
+		SessionHeight: currentHeight,
+	}
+
+	client, err := rpc.NewClientWithResponses(remoteCLIURL)
+	if err != nil {
+		return nil, fmt.Errorf(""Error getting current session for app/chain/height: %s/%s/%d: %w"", appAddress, chain, currentHeight, err)
+	}
+
+	resp, err := client.PostV1ClientGetSessionWithResponse(ctx, req)
+	if err != nil {
+		return nil, fmt.Errorf(""Error getting current session with request %v: %w"", req, err)
+	}
+
+	// IMPROVE: move the HTTP response processing code to a separate function to enable reuse.
+	if resp.HTTPResponse.StatusCode != http.StatusOK {
+		return nil, fmt.Errorf(""Error getting current session: Unexpected status code %d for request %v"", resp.HTTPResponse.StatusCode, req)
+	}
+
+	if resp.JSON200 == nil {
+		return nil, fmt.Errorf(""Error getting current session: Unexpected response %v"", resp)
+	}
+
+	return resp.JSON200, nil
+}
+
+// REFACTOR: reuse this function in all the query commands
+func getCurrentHeight(ctx context.Context) (int64, error) {
+	client, err := rpc.NewClientWithResponses(remoteCLIURL)
+	if err != nil {
+		return 0, fmt.Errorf(""Error getting current height: %w"", err)
+	}
+	resp, err := client.GetV1QueryHeightWithResponse(ctx)
+	if err != nil {
+		return 0, fmt.Errorf(""Error getting current height: %w"", err)
+	}
+	if resp.HTTPResponse.StatusCode != http.StatusOK {
+		return 0, fmt.Errorf(""Error getting current height: Unexpected status code %d"", resp.HTTPResponse.StatusCode)
+	}
+
+	if resp.JSON200 == nil {
+		return 0, fmt.Errorf(""Error getting current height: Unexpected response %v"", resp)
+	}
+
+	return resp.JSON200.Height, nil
+}
+
+// IMPROVE: [K8s][LocalNet] Publish Servicer(s) Host and Port as env. vars in K8s: similar to Validators: #823",app/client/cli/servicer.go,2023-06-15 22:39:40+00:00,2023-06-15T22:57:24Z,"```suggestion
// IMPROVE(#823): [K8s][LocalNet] Publish Servicer(s) Host and Port as env. vars in K8s: similar to Validators
```",,,,,174,RIGHT,174,,line,https://api.github.com/repos/pokt-network/pocket/pulls/778,pokt-network/pocket,a516c51f2d000d25f1469d28e6586ef7875d5a37
https://api.github.com/repos/pokt-network/pocket/pulls/778,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1231601753,Olshansk,78515389863161a80de1f110688d58090fbc0efc,acec260d9987f4dba2b31bdf4b65f2ef6b654725,"@@ -0,0 +1,243 @@
+package cli
+
+import (
+	""context""
+	""encoding/hex""
+	""encoding/json""
+	""fmt""
+	""net/http""
+
+	""github.com/spf13/cobra""
+
+	""github.com/pokt-network/pocket/rpc""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/crypto""
+)
+
+func init() {
+	rootCmd.AddCommand(NewServicerCommand())
+}
+
+func NewServicerCommand() *cobra.Command {
+	cmd := &cobra.Command{
+		Use:     ""Servicer"",
+		Short:   ""Servicer specific commands"",
+		Aliases: []string{""servicer""},
+		Args:    cobra.ExactArgs(0),
+	}
+
+	cmds := servicerCommands()
+	applySubcommandOptions(cmds, attachPwdFlagToSubcommands())
+	applySubcommandOptions(cmds, attachKeybaseFlagsToSubcommands())
+
+	cmd.AddCommand(cmds...)
+
+	return cmd
+}
+
+func servicerCommands() []*cobra.Command {
+	cmdDef := actorCmdDef{""Servicer"", coreTypes.ActorType_ACTOR_TYPE_SERVICER}
+	cmds := []*cobra.Command{
+		newStakeCmd(cmdDef),
+		newEditStakeCmd(cmdDef),
+		newUnstakeCmd(cmdDef),
+		newUnpauseCmd(cmdDef),
+		{
+			// IMPROVE: allow reading the relay payload from a file with the serialized protobuf via [--input_file]
+			Use:   ""Relay <applicationAddrHex> <servicerAddrHex> <relayChainID> <relayPayload>"",
+			Short: ""Relay <applicationAddrHex> <servicerAddrHex> <relayChainID> <relayPayload>"",
+			Long: `Sends a trustless relay using <relayPayload> as contents, to the specified active <servicerAddrHex> in the the <applicationAddrHex>'s session.
+Will prompt the user for the *application* account passphrase`,
+			Aliases: []string{},
+			Args:    cobra.ExactArgs(4),
+			RunE: func(cmd *cobra.Command, args []string) error {
+				applicationAddr := args[0]
+				servicerAddr := args[1]
+				chain := args[2]
+				relayPayload := args[3]
+
+				// REFACTOR: decouple the client logic from the CLI
+				//	The client will: send the trustless relay and return the response (using a single function as entrypoint)
+				//	The CLI will:
+				//		1) extract the required input from the command arguments
+				//		2) call the client function (with the inputs above) that performs the trustless relay
+				pk, err := getPrivateKeyFromKeybase(applicationAddr)
+				if err != nil {
+					return fmt.Errorf(""error getting application's private key: %w"", err)
+				}
+
+				// TECHDEBT(#791): cache session data
+				session, err := getCurrentSession(cmd.Context(), applicationAddr, chain)
+				if err != nil {
+					return fmt.Errorf(""Error getting current session: %w"", err)
+				}
+
+				servicer, err := validateServicer(cmd.Context(), session, servicerAddr)
+				if err != nil {
+					return fmt.Errorf(""error getting servicer for the relay: %w"", err)
+				}
+
+				relay, err := buildRelay(relayPayload, pk, session, servicer)
+				if err != nil {
+					return fmt.Errorf(""error building relay from payload: %w"", err)
+				}
+
+				fmt.Printf(""sending trustless relay for %s to %s with payload: %s\n"", applicationAddr, servicerAddr, relayPayload)
+
+				resp, err := sendTrustlessRelay(cmd.Context(), servicer.ServiceUrl, relay)
+				if err != nil {
+					return err
+				}
+
+				fmt.Printf(""HTTP status code: %d\n"", resp.HTTPResponse.StatusCode)
+				fmt.Println(""Response: "", resp.JSON200)
+
+				return nil
+			},
+		},
+	}
+
+	return cmds
+}
+
+// TODO: add a cli command for fetching sessions
+// validateServicer returns the servicer specified by the <servicer> argument.
+// It validates that the <servicer> is the address of a servicer that is active in the current session.
+func validateServicer(ctx context.Context, session *rpc.Session, servicerAddress string) (*rpc.ProtocolActor, error) {
+	for _, s := range session.Servicers {
+		if s.Address == servicerAddress {
+			return &s, nil
+		}
+	}
+
+	// ADDTEST: cover with gherkin tests
+	return nil, fmt.Errorf(""Error getting servicer: address %s does not match any servicers in the session %d"", servicerAddress, session.SessionNumber)
+}
+
+func getCurrentSession(ctx context.Context, appAddress, chain string) (*rpc.Session, error) {
+	// CONSIDERATION: passing 0 as the height value to get the current session seems more optimal than this.
+	currentHeight, err := getCurrentHeight(ctx)
+	if err != nil {
+		return nil, fmt.Errorf(""Error getting current session: %w"", err)
+	}
+
+	req := rpc.SessionRequest{
+		AppAddress: appAddress,
+		Chain:      chain,
+		// TODO(#697): Geozone
+		SessionHeight: currentHeight,
+	}
+
+	client, err := rpc.NewClientWithResponses(remoteCLIURL)
+	if err != nil {
+		return nil, fmt.Errorf(""Error getting current session for app/chain/height: %s/%s/%d: %w"", appAddress, chain, currentHeight, err)
+	}
+
+	resp, err := client.PostV1ClientGetSessionWithResponse(ctx, req)
+	if err != nil {
+		return nil, fmt.Errorf(""Error getting current session with request %v: %w"", req, err)
+	}
+
+	// IMPROVE: move the HTTP response processing code to a separate function to enable reuse.
+	if resp.HTTPResponse.StatusCode != http.StatusOK {
+		return nil, fmt.Errorf(""Error getting current session: Unexpected status code %d for request %v"", resp.HTTPResponse.StatusCode, req)
+	}
+
+	if resp.JSON200 == nil {
+		return nil, fmt.Errorf(""Error getting current session: Unexpected response %v"", resp)
+	}
+
+	return resp.JSON200, nil
+}
+
+// REFACTOR: reuse this function in all the query commands
+func getCurrentHeight(ctx context.Context) (int64, error) {
+	client, err := rpc.NewClientWithResponses(remoteCLIURL)
+	if err != nil {
+		return 0, fmt.Errorf(""Error getting current height: %w"", err)
+	}
+	resp, err := client.GetV1QueryHeightWithResponse(ctx)
+	if err != nil {
+		return 0, fmt.Errorf(""Error getting current height: %w"", err)
+	}
+	if resp.HTTPResponse.StatusCode != http.StatusOK {
+		return 0, fmt.Errorf(""Error getting current height: Unexpected status code %d"", resp.HTTPResponse.StatusCode)
+	}
+
+	if resp.JSON200 == nil {
+		return 0, fmt.Errorf(""Error getting current height: Unexpected response %v"", resp)
+	}
+
+	return resp.JSON200.Height, nil
+}
+
+// IMPROVE: [K8s][LocalNet] Publish Servicer(s) Host and Port as env. vars in K8s: similar to Validators: #823
+// REFACTOR: move package-level variables (e.g. remoteCLIURL) to a cli object and consider storing it in the context",app/client/cli/servicer.go,2023-06-15 22:40:20+00:00,2023-06-15T22:57:24Z,"```suggestion
// CONSIDERATION: move package-level variables (e.g. remoteCLIURL) to a cli object and consider storing it in the context
```

@bryanchriswhite recently refactored it to consolidate and export them from on eplace",,,,,175,RIGHT,175,,line,https://api.github.com/repos/pokt-network/pocket/pulls/778,pokt-network/pocket,a516c51f2d000d25f1469d28e6586ef7875d5a37
https://api.github.com/repos/pokt-network/pocket/pulls/778,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1231602406,Olshansk,78515389863161a80de1f110688d58090fbc0efc,acec260d9987f4dba2b31bdf4b65f2ef6b654725,"@@ -0,0 +1,243 @@
+package cli
+
+import (
+	""context""
+	""encoding/hex""
+	""encoding/json""
+	""fmt""
+	""net/http""
+
+	""github.com/spf13/cobra""
+
+	""github.com/pokt-network/pocket/rpc""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/crypto""
+)
+
+func init() {
+	rootCmd.AddCommand(NewServicerCommand())
+}
+
+func NewServicerCommand() *cobra.Command {
+	cmd := &cobra.Command{
+		Use:     ""Servicer"",
+		Short:   ""Servicer specific commands"",
+		Aliases: []string{""servicer""},
+		Args:    cobra.ExactArgs(0),
+	}
+
+	cmds := servicerCommands()
+	applySubcommandOptions(cmds, attachPwdFlagToSubcommands())
+	applySubcommandOptions(cmds, attachKeybaseFlagsToSubcommands())
+
+	cmd.AddCommand(cmds...)
+
+	return cmd
+}
+
+func servicerCommands() []*cobra.Command {
+	cmdDef := actorCmdDef{""Servicer"", coreTypes.ActorType_ACTOR_TYPE_SERVICER}
+	cmds := []*cobra.Command{
+		newStakeCmd(cmdDef),
+		newEditStakeCmd(cmdDef),
+		newUnstakeCmd(cmdDef),
+		newUnpauseCmd(cmdDef),
+		{
+			// IMPROVE: allow reading the relay payload from a file with the serialized protobuf via [--input_file]
+			Use:   ""Relay <applicationAddrHex> <servicerAddrHex> <relayChainID> <relayPayload>"",
+			Short: ""Relay <applicationAddrHex> <servicerAddrHex> <relayChainID> <relayPayload>"",
+			Long: `Sends a trustless relay using <relayPayload> as contents, to the specified active <servicerAddrHex> in the the <applicationAddrHex>'s session.
+Will prompt the user for the *application* account passphrase`,
+			Aliases: []string{},
+			Args:    cobra.ExactArgs(4),
+			RunE: func(cmd *cobra.Command, args []string) error {
+				applicationAddr := args[0]
+				servicerAddr := args[1]
+				chain := args[2]
+				relayPayload := args[3]
+
+				// REFACTOR: decouple the client logic from the CLI
+				//	The client will: send the trustless relay and return the response (using a single function as entrypoint)
+				//	The CLI will:
+				//		1) extract the required input from the command arguments
+				//		2) call the client function (with the inputs above) that performs the trustless relay
+				pk, err := getPrivateKeyFromKeybase(applicationAddr)
+				if err != nil {
+					return fmt.Errorf(""error getting application's private key: %w"", err)
+				}
+
+				// TECHDEBT(#791): cache session data
+				session, err := getCurrentSession(cmd.Context(), applicationAddr, chain)
+				if err != nil {
+					return fmt.Errorf(""Error getting current session: %w"", err)
+				}
+
+				servicer, err := validateServicer(cmd.Context(), session, servicerAddr)
+				if err != nil {
+					return fmt.Errorf(""error getting servicer for the relay: %w"", err)
+				}
+
+				relay, err := buildRelay(relayPayload, pk, session, servicer)
+				if err != nil {
+					return fmt.Errorf(""error building relay from payload: %w"", err)
+				}
+
+				fmt.Printf(""sending trustless relay for %s to %s with payload: %s\n"", applicationAddr, servicerAddr, relayPayload)
+
+				resp, err := sendTrustlessRelay(cmd.Context(), servicer.ServiceUrl, relay)
+				if err != nil {
+					return err
+				}
+
+				fmt.Printf(""HTTP status code: %d\n"", resp.HTTPResponse.StatusCode)
+				fmt.Println(""Response: "", resp.JSON200)
+
+				return nil
+			},
+		},
+	}
+
+	return cmds
+}
+
+// TODO: add a cli command for fetching sessions
+// validateServicer returns the servicer specified by the <servicer> argument.
+// It validates that the <servicer> is the address of a servicer that is active in the current session.
+func validateServicer(ctx context.Context, session *rpc.Session, servicerAddress string) (*rpc.ProtocolActor, error) {
+	for _, s := range session.Servicers {
+		if s.Address == servicerAddress {
+			return &s, nil
+		}
+	}
+
+	// ADDTEST: cover with gherkin tests
+	return nil, fmt.Errorf(""Error getting servicer: address %s does not match any servicers in the session %d"", servicerAddress, session.SessionNumber)
+}
+
+func getCurrentSession(ctx context.Context, appAddress, chain string) (*rpc.Session, error) {
+	// CONSIDERATION: passing 0 as the height value to get the current session seems more optimal than this.
+	currentHeight, err := getCurrentHeight(ctx)
+	if err != nil {
+		return nil, fmt.Errorf(""Error getting current session: %w"", err)
+	}
+
+	req := rpc.SessionRequest{
+		AppAddress: appAddress,
+		Chain:      chain,
+		// TODO(#697): Geozone
+		SessionHeight: currentHeight,
+	}
+
+	client, err := rpc.NewClientWithResponses(remoteCLIURL)
+	if err != nil {
+		return nil, fmt.Errorf(""Error getting current session for app/chain/height: %s/%s/%d: %w"", appAddress, chain, currentHeight, err)
+	}
+
+	resp, err := client.PostV1ClientGetSessionWithResponse(ctx, req)
+	if err != nil {
+		return nil, fmt.Errorf(""Error getting current session with request %v: %w"", req, err)
+	}
+
+	// IMPROVE: move the HTTP response processing code to a separate function to enable reuse.
+	if resp.HTTPResponse.StatusCode != http.StatusOK {
+		return nil, fmt.Errorf(""Error getting current session: Unexpected status code %d for request %v"", resp.HTTPResponse.StatusCode, req)
+	}
+
+	if resp.JSON200 == nil {
+		return nil, fmt.Errorf(""Error getting current session: Unexpected response %v"", resp)
+	}
+
+	return resp.JSON200, nil
+}
+
+// REFACTOR: reuse this function in all the query commands
+func getCurrentHeight(ctx context.Context) (int64, error) {
+	client, err := rpc.NewClientWithResponses(remoteCLIURL)
+	if err != nil {
+		return 0, fmt.Errorf(""Error getting current height: %w"", err)
+	}
+	resp, err := client.GetV1QueryHeightWithResponse(ctx)
+	if err != nil {
+		return 0, fmt.Errorf(""Error getting current height: %w"", err)
+	}
+	if resp.HTTPResponse.StatusCode != http.StatusOK {
+		return 0, fmt.Errorf(""Error getting current height: Unexpected status code %d"", resp.HTTPResponse.StatusCode)
+	}
+
+	if resp.JSON200 == nil {
+		return 0, fmt.Errorf(""Error getting current height: Unexpected response %v"", resp)
+	}
+
+	return resp.JSON200.Height, nil
+}
+
+// IMPROVE: [K8s][LocalNet] Publish Servicer(s) Host and Port as env. vars in K8s: similar to Validators: #823
+// REFACTOR: move package-level variables (e.g. remoteCLIURL) to a cli object and consider storing it in the context
+func sendTrustlessRelay(ctx context.Context, servicerUrl string, relay *rpc.RelayRequest) (*rpc.PostV1ClientRelayResponse, error) {
+	client, err := rpc.NewClientWithResponses(servicerUrl)
+	if err != nil {
+		return nil, err
+	}
+
+	return client.PostV1ClientRelayWithResponse(ctx, *relay)
+}
+
+func buildRelay(payload string, appPrivateKey crypto.PrivateKey, session *rpc.Session, servicer *rpc.ProtocolActor) (*rpc.RelayRequest, error) {
+	// TECHDEBT: This is mostly COPIED from pocket-go: we should refactor pocket-go code and import this functionality from there instead.
+	relayPayload := rpc.Payload{
+		// INCOMPLETE(#803): need to unmarshal into JSONRPC and other supported relay formats once proto-generated custom types are added.
+		Jsonrpc: ""2.0"",
+		Method:  payload,
+		// INCOMPLETE: set Headers for HTTP relays
+	}
+
+	relayMeta := rpc.RelayRequestMeta{
+		BlockHeight: session.SessionHeight,
+		// TODO: Make Chain Identifier type consistent in Session and Meta use Identifiable for Chain in Session (or string for Chain in Relay Meta)
+		Chain: rpc.Identifiable{
+			Id: session.Chain,
+		},
+		ServicerPubKey: servicer.PublicKey,
+		// TODO(#697): Geozone
+	}
+
+	relay := &rpc.RelayRequest{
+		Payload: relayPayload,
+		Meta:    relayMeta,
+	}
+	// TECHDEBT: Evaluate which fields we should and shouldn't marshall when signing the payload
+	reqBytes, err := json.Marshal(relay)
+	if err != nil {
+		return nil, fmt.Errorf(""Error marshalling relay request %v: %w"", relay, err)
+	}
+	hashedReq := crypto.SHA3Hash(reqBytes)
+	signature, err := appPrivateKey.Sign(hashedReq)
+	if err != nil {
+		return relay, fmt.Errorf(""Error signing relay: %w"", err)
+	}
+	relay.Meta.Signature = hex.EncodeToString(signature)
+
+	return relay, nil",app/client/cli/servicer.go,2023-06-15 22:41:47+00:00,2023-06-15T22:57:24Z,"I'm pretty sure we're going to hit problems/issues with this function, but we'll deal with it when we hit it in the E2E test",,,,221.0,220,RIGHT,220,221.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/778,pokt-network/pocket,a516c51f2d000d25f1469d28e6586ef7875d5a37
https://api.github.com/repos/pokt-network/pocket/pulls/778,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1231602914,Olshansk,78515389863161a80de1f110688d58090fbc0efc,acec260d9987f4dba2b31bdf4b65f2ef6b654725,"@@ -127,9 +127,9 @@ paths:
     post:
       tags:
         - client
-      summary: Sends a relay to the servicer to receive a response
+      summary: Sends a relay to the servicer to receive a response. The payload is the serialized form of one of the supported formats.",rpc/v1/openapi.yaml,2023-06-15 22:42:54+00:00,2023-06-15T22:57:24Z,"```suggestion
      summary: Sends a relay to the servicer to receive a response. The payload is the serialized form of one of the supported formats in a protobuf.
```",,,,,130,RIGHT,5,,line,https://api.github.com/repos/pokt-network/pocket/pulls/778,pokt-network/pocket,a516c51f2d000d25f1469d28e6586ef7875d5a37
https://api.github.com/repos/pokt-network/pocket/pulls/778,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1231609115,Olshansk,78515389863161a80de1f110688d58090fbc0efc,acec260d9987f4dba2b31bdf4b65f2ef6b654725,"@@ -0,0 +1,116 @@
+package types
+
+import (
+	""testing""
+
+	""github.com/stretchr/testify/require""
+)
+
+func TestRelayValidate(t *testing.T) {
+	testCases := []struct {
+		name     string
+		relay    Relay
+		expected error
+	}{
+		{
+			name: ""valid Relay: JSONRPC"",
+			relay: Relay{
+				RelayPayload: &Relay_JsonRpcPayload{
+					JsonRpcPayload: &JSONRPCPayload{JsonRpc: ""2.0"", Method: ""eth_blockNumber""},
+				},
+			},
+		},
+		{
+			name: ""valid Relay: REST"",
+			relay: Relay{
+				RelayPayload: &Relay_RestPayload{
+					RestPayload: &RESTPayload{Contents: `{""field1"": ""value1"", ""field2"": ""value2""}`},
+				},
+			},
+		},
+		{
+			name:     ""invalid Relay: missing payload"",
+			expected: errInvalidRelayPayload,
+		},
+		{
+			name: ""invalid Relay: invalid JSONRPC Payload"",
+			relay: Relay{
+				RelayPayload: &Relay_JsonRpcPayload{
+					JsonRpcPayload: &JSONRPCPayload{JsonRpc: ""foo""},
+				},
+			},
+			expected: errInvalidJSONRPC,
+		},
+		{
+			name: ""invalid Relay: invalid REST Payload"",
+			relay: Relay{
+				RelayPayload: &Relay_RestPayload{
+					RestPayload: &RESTPayload{Contents: ""foo""},
+				},
+			},
+			expected: errInvalidRESTPayload,
+		},
+	}
+
+	for _, testCase := range testCases {
+		t.Run(testCase.name, func(t *testing.T) {
+			err := testCase.relay.Validate()
+			require.ErrorIs(t, err, testCase.expected)
+		})
+	}
+}
+
+func TestJsonRpcValidate(t *testing.T) {
+	testCases := []struct {
+		name     string
+		payload  JSONRPCPayload
+		expected error
+	}{
+		{
+			name:    ""valid JSONRPC"",
+			payload: JSONRPCPayload{JsonRpc: ""2.0"", Method: ""eth_blockNumber""},
+		},
+		{
+			name:     ""invalid JSONRPC: invalid JsonRpc field value"",
+			payload:  JSONRPCPayload{JsonRpc: ""foo"", Method: ""eth_blockNumber""},
+			expected: errInvalidJSONRPC,
+		},
+		{
+			name:     ""invalid JSONRPC: Method field not set"",
+			payload:  JSONRPCPayload{JsonRpc: ""2.0""},
+			expected: errInvalidJSONRPCMissingMethod,
+		},
+	}
+
+	for _, testCase := range testCases {
+		t.Run(testCase.name, func(t *testing.T) {
+			err := testCase.payload.Validate()
+			require.ErrorIs(t, err, testCase.expected)
+		})
+	}
+}
+
+func TestRESTValidate(t *testing.T) {",shared/core/types/relay_test.go,2023-06-15 22:56:15+00:00,2023-06-15T22:57:24Z,"NIT: Can you update all of these to `TestRelay_ValidateREST`, `TestRelay_ValidJSONRPC`, etc...so we can run them with `go test -run TestRelay`",,,,,93,RIGHT,93,,line,https://api.github.com/repos/pokt-network/pocket/pulls/778,pokt-network/pocket,a516c51f2d000d25f1469d28e6586ef7875d5a37
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1220336319,Olshansk,f37b394454f45c27d058dac20af974a6ed273903,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -129,6 +131,8 @@ type PersistenceWriteContext interface {
 	// Flag Operations
 	InitFlags() error
 	SetFlag(paramName string, value any, enabled bool) error
+",shared/modules/persistence_module.go,2023-06-06 20:49:05+00:00,2023-06-06T23:53:54Z,"We didn't do really good at this early on, but can you please add comments when adding new functions to the core interfaces?

@bryanchriswhite started doing this in P2P and then simply adds a comment next to the implementation, for example:

```go
// GetPeer implements the respective `Peerstore` interface member.
func (paMap PeerAddrMap) GetPeer(addr crypto.Address) Peer {
	return paMap[addr.String()]
}
```",,,,146.0,134,RIGHT,13,38.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1220338535,Olshansk,f37b394454f45c27d058dac20af974a6ed273903,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -79,3 +80,15 @@ func (p *PostgresContext) SetServicerPauseHeight(address []byte, height int64) e
 func (p *PostgresContext) GetServicerOutputAddress(operator []byte, height int64) (output []byte, err error) {
 	return p.GetActorOutputAddress(types.ServicerActor, operator, height)
 }
+
+// INCOMPLETE: implement this
+// DISCUSS: both the relay and the response can be large structures: we may need to truncate the stored values
+func (p *PostgresContext) RecordRelayService(applicationAddress string, key []byte, relay *coreTypes.Relay, response *coreTypes.RelayResponse) error {
+	return nil
+}
+
+// INCOMPLETE: implement this
+// GetServicerTokenUsage returns the number of tokens used by the servicer in the current session, i.e. for the application associated with the session",persistence/servicer.go,2023-06-06 20:50:51+00:00,2023-06-06T23:53:54Z,"Per my other comment, let's move this into the interface and make this comment say what it implements",,,,91.0,91,RIGHT,20,20.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1220341698,Olshansk,f37b394454f45c27d058dac20af974a6ed273903,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -79,3 +80,15 @@ func (p *PostgresContext) SetServicerPauseHeight(address []byte, height int64) e
 func (p *PostgresContext) GetServicerOutputAddress(operator []byte, height int64) (output []byte, err error) {
 	return p.GetActorOutputAddress(types.ServicerActor, operator, height)
 }
+
+// INCOMPLETE: implement this
+// DISCUSS: both the relay and the response can be large structures: we may need to truncate the stored values",persistence/servicer.go,2023-06-06 20:53:38+00:00,2023-06-06T23:53:54Z,s/DISCUSS/OPTIMIZE,,,,85.0,85,RIGHT,14,14.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1220348888,Olshansk,f37b394454f45c27d058dac20af974a6ed273903,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -14,5 +14,18 @@ message UtilityConfig {
 message ServicerConfig {
   string public_key = 1;
   string address = 2;
-  repeated string chains = 3;
+  map<string, ChainConfig> chains = 3;
+}
+
+message ChainConfig {",runtime/configs/proto/utility_config.proto,2023-06-06 20:55:50+00:00,2023-06-06T23:53:54Z,"s/ChainConfig/ServiceConfig

---

V1 can be a decentralized RPC network for any service - not just blockchains and I don't see anything blockchain specific here.",,,,,20,RIGHT,8,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1220349260,Olshansk,f37b394454f45c27d058dac20af974a6ed273903,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -14,5 +14,18 @@ message UtilityConfig {
 message ServicerConfig {
   string public_key = 1;
   string address = 2;
-  repeated string chains = 3;
+  map<string, ChainConfig> chains = 3;",runtime/configs/proto/utility_config.proto,2023-06-06 20:56:03+00:00,2023-06-06T23:53:54Z,s/chains/services,,,,,17,RIGHT,5,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1220359745,Olshansk,f37b394454f45c27d058dac20af974a6ed273903,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -14,5 +14,18 @@ message UtilityConfig {
 message ServicerConfig {
   string public_key = 1;
   string address = 2;
-  repeated string chains = 3;
+  map<string, ChainConfig> chains = 3;
+}
+
+message ChainConfig {
+  string url = 1;
+  string user_agent = 2;",runtime/configs/proto/utility_config.proto,2023-06-06 21:02:55+00:00,2023-06-06T23:53:54Z,"Given that we have `map<string, string> headers = 4;` in `RelayPayload`, do we really need an explicit `user_agent` parameter in the `Chain` (i.e. Service) config?

I realize that v0 might have it, but note that it was done by 1 person in 3 months so we should leverage the liberty of being able to challenge some of those decisions.",,,,,22,RIGHT,10,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1220360626,Olshansk,f37b394454f45c27d058dac20af974a6ed273903,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -14,5 +14,18 @@ message UtilityConfig {
 message ServicerConfig {
   string public_key = 1;
   string address = 2;
-  repeated string chains = 3;
+  map<string, ChainConfig> chains = 3;
+}
+
+message ChainConfig {
+  string url = 1;
+  string user_agent = 2;
+  uint64 timeout_milliseconds = 3;",runtime/configs/proto/utility_config.proto,2023-06-06 21:03:44+00:00,2023-06-06T23:53:54Z,Optional NITE: s/milliseconds/msec,,,,,23,RIGHT,11,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1220361352,Olshansk,f37b394454f45c27d058dac20af974a6ed273903,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -14,5 +14,18 @@ message UtilityConfig {
 message ServicerConfig {
   string public_key = 1;
   string address = 2;
-  repeated string chains = 3;
+  map<string, ChainConfig> chains = 3;
+}
+
+message ChainConfig {
+  string url = 1;
+  string user_agent = 2;
+  uint64 timeout_milliseconds = 3;
+  BasicAuth basic_auth = 4;
+}
+
+message BasicAuth {
+  string user_name = 1;
+  // DISCUSS: does this need to be encrypted?",runtime/configs/proto/utility_config.proto,2023-06-06 21:04:19+00:00,2023-06-06T23:53:54Z,Make this a `IMPROVE: enforce encryption of plaintext password`,,,,,29,RIGHT,17,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1220362640,Olshansk,f37b394454f45c27d058dac20af974a6ed273903,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -14,5 +14,18 @@ message UtilityConfig {
 message ServicerConfig {
   string public_key = 1;
   string address = 2;
-  repeated string chains = 3;
+  map<string, ChainConfig> chains = 3;
+}
+
+message ChainConfig {",runtime/configs/proto/utility_config.proto,2023-06-06 21:05:18+00:00,2023-06-06T23:53:54Z,"Can you add some comments around the types and how they should be used?

For example, I'm assuming that `BasicAuth` is optional. I'm also assuming that `username:password` will be pre-pended to the `url` if it's present. 

Whether these assumptions are correct or not, they'll help the future reader.",,,,,20,RIGHT,8,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1220363889,Olshansk,f37b394454f45c27d058dac20af974a6ed273903,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -10,6 +10,7 @@ message Relay {
     RelayMeta meta = 2;
 }
 
+// INCOMPLETE: add support for different payloads, e.g. JSON, GRPC, etc.",shared/core/types/proto/relay.proto,2023-06-06 21:06:25+00:00,2023-06-06T23:53:54Z,"Would json & grpc payloads not be part of `data`?

I'm thinking we could potentially switch `data` from being `string` to being `bytes`",,,,,13,RIGHT,4,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1220365450,Olshansk,f37b394454f45c27d058dac20af974a6ed273903,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -7,6 +7,10 @@ and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0
 
 ## [Unreleased]
 
+## [0.0.0.41] - 2023-06-06
+
+- Add a new ChainConfig configuration field to servicer config",runtime/docs/CHANGELOG.md,2023-06-06 21:07:31+00:00,2023-06-06T23:53:55Z,"If we do decide to rename it (let's discuss there), don't forget to update these too.",,,,,12,RIGHT,6,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1220366831,Olshansk,f37b394454f45c27d058dac20af974a6ed273903,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -129,6 +131,8 @@ type PersistenceWriteContext interface {
 	// Flag Operations
 	InitFlags() error
 	SetFlag(paramName string, value any, enabled bool) error
+
+	RecordRelayService(applicationAddress string, key []byte, relay *coreTypes.Relay, response *coreTypes.RelayResponse) error",shared/modules/persistence_module.go,2023-06-06 21:08:42+00:00,2023-06-06T23:53:55Z,"1. Wdyt of this instead: `StoreServiceRelay`
2. What is `key` - please use a more self descriptive name
3. Optional: I think `appAddr` is sufficient but it's a mater of style and preference and doesn't matter if you prefer `applicationAddress`",,,,147.0,135,RIGHT,14,39.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1220368706,Olshansk,f37b394454f45c27d058dac20af974a6ed273903,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -219,4 +223,7 @@ type PersistenceReadContext interface {
 	GetIntFlag(paramName string, height int64) (int, bool, error)
 	GetStringFlag(paramName string, height int64) (string, bool, error)
 	GetBytesFlag(paramName string, height int64) ([]byte, bool, error)
+
+	// Servicer application tokens
+	GetServicerTokenUsage(session *coreTypes.Session) (*big.Int, error)",shared/modules/persistence_module.go,2023-06-06 21:10:21+00:00,2023-06-06T23:53:55Z,"Other than adding a comment, it's unclear what `GetServicerTokenUsage` returns.
1. Is it the number of tokens used?
2. Is it the number of tokens remaining?
3. How about `GetSessionTokensUsed` or `GetSessionTokensRemaining`?
4. Alternatively, we can even do `GetSessionTokens` which returns `(remaining_tokens, used_tokens)`

Not picky about which approach we take, but let's iterate on what we have first.",,,,,228,RIGHT,24,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1220442735,Olshansk,f37b394454f45c27d058dac20af974a6ed273903,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -121,7 +121,17 @@ func NewDefaultConfig(options ...func(*Config)) *Config {
 		},
 		Utility: &UtilityConfig{
 			ServicerConfig: &ServicerConfig{
-				Chains: []string{""0001""},
+				Chains: map[string]*ChainConfig{
+					""0021"": {",runtime/configs/config.go,2023-06-06 22:12:56+00:00,2023-06-06T23:53:55Z,"_tl;dr Let's make it POKT pointing to loalhost_

---

`0021` is a very ""v0"" thing.

I'm thinking a few things:
1. Let's make the default config be the `Pocket V1 blockchains"" and have the `url` be `localhost` so we can serve relays to itself
2. Maybe we should make it `ETHM` or `POKT`?

I don't think we'll have an answer to (2), but just leave a comment so we don't end up reimplementing v0 and think of what we can do.

1. Strings?
2. Enums?
3. JWT like structure for Chain IDs?
4. The sky is the elimit",,,,,125,RIGHT,6,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1220445042,Olshansk,f37b394454f45c27d058dac20af974a6ed273903,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -12,21 +21,38 @@ import (
 	""github.com/pokt-network/pocket/shared/crypto""
 	""github.com/pokt-network/pocket/shared/modules""
 	""github.com/pokt-network/pocket/shared/modules/base_modules""
+	""github.com/pokt-network/pocket/shared/utils""
+	typesUtil ""github.com/pokt-network/pocket/utility/types""
 )
 
+// DISCUSS: where should the RelayAccracyParameter be defined?",utility/service/service.go,2023-06-06 22:15:23+00:00,2023-06-06T23:53:55Z,"`UtilityConfig`

It's client configurable based on how much risk (opportunity?) they're willing to take to mine.

Let's also rename it to `RelayMiningVolumeAccuracy` and point to https://arxiv.org/abs/2305.10672",,,,,28,RIGHT,26,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1220445639,Olshansk,f37b394454f45c27d058dac20af974a6ed273903,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -12,21 +21,38 @@ import (
 	""github.com/pokt-network/pocket/shared/crypto""
 	""github.com/pokt-network/pocket/shared/modules""
 	""github.com/pokt-network/pocket/shared/modules/base_modules""
+	""github.com/pokt-network/pocket/shared/utils""
+	typesUtil ""github.com/pokt-network/pocket/utility/types""
 )
 
+// DISCUSS: where should the RelayAccracyParameter be defined?
+const RelayAccuracyParameter = 0.2
+
 var (
 	errValidateBlockHeight = errors.New(""relay failed block height validation"")
 	errValidateRelayMeta   = errors.New(""relay failed metadata validation"")
+	errValidateServicer    = errors.New(""relay does not match the servicer"")",utility/service/service.go,2023-06-06 22:15:59+00:00,2023-06-06T23:53:55Z,"```suggestion
	errValidateServicer    = errors.New(""relay failed servicer validation"")
```",,,,,34,RIGHT,32,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1220496306,Olshansk,f37b394454f45c27d058dac20af974a6ed273903,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -12,21 +21,38 @@ import (
 	""github.com/pokt-network/pocket/shared/crypto""
 	""github.com/pokt-network/pocket/shared/modules""
 	""github.com/pokt-network/pocket/shared/modules/base_modules""
+	""github.com/pokt-network/pocket/shared/utils""
+	typesUtil ""github.com/pokt-network/pocket/utility/types""
 )
 
+// DISCUSS: where should the RelayAccracyParameter be defined?
+const RelayAccuracyParameter = 0.2
+
 var (
 	errValidateBlockHeight = errors.New(""relay failed block height validation"")
 	errValidateRelayMeta   = errors.New(""relay failed metadata validation"")
+	errValidateServicer    = errors.New(""relay does not match the servicer"")
+	errValidateApplication = errors.New(""relay failed application validation"")
 
 	_ modules.Servicer = &servicer{}
 )
 
+type sessionTokens struct {
+	SessionNumber int64",utility/service/service.go,2023-06-06 22:48:23+00:00,2023-06-06T23:53:55Z,"Do the fields of this struct need to be publically exported?

If not, lowercase",,,,,41,RIGHT,39,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1220498698,Olshansk,f37b394454f45c27d058dac20af974a6ed273903,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -12,21 +21,38 @@ import (
 	""github.com/pokt-network/pocket/shared/crypto""
 	""github.com/pokt-network/pocket/shared/modules""
 	""github.com/pokt-network/pocket/shared/modules/base_modules""
+	""github.com/pokt-network/pocket/shared/utils""
+	typesUtil ""github.com/pokt-network/pocket/utility/types""
 )
 
+// DISCUSS: where should the RelayAccracyParameter be defined?
+const RelayAccuracyParameter = 0.2
+
 var (
 	errValidateBlockHeight = errors.New(""relay failed block height validation"")
 	errValidateRelayMeta   = errors.New(""relay failed metadata validation"")
+	errValidateServicer    = errors.New(""relay does not match the servicer"")
+	errValidateApplication = errors.New(""relay failed application validation"")
 
 	_ modules.Servicer = &servicer{}
 )
 
+type sessionTokens struct {
+	SessionNumber int64
+	Count         *big.Int",utility/service/service.go,2023-06-06 22:51:08+00:00,2023-06-06T23:53:55Z,"Is this the `countRemaining`, `countUsed` or `originalCountAvailable`.

Please rename appropriately and consider having more than one if you need to.",,41.0,RIGHT,,42,RIGHT,40,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1220498929,Olshansk,f37b394454f45c27d058dac20af974a6ed273903,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -12,21 +21,38 @@ import (
 	""github.com/pokt-network/pocket/shared/crypto""
 	""github.com/pokt-network/pocket/shared/modules""
 	""github.com/pokt-network/pocket/shared/modules/base_modules""
+	""github.com/pokt-network/pocket/shared/utils""
+	typesUtil ""github.com/pokt-network/pocket/utility/types""
 )
 
+// DISCUSS: where should the RelayAccracyParameter be defined?
+const RelayAccuracyParameter = 0.2
+
 var (
 	errValidateBlockHeight = errors.New(""relay failed block height validation"")
 	errValidateRelayMeta   = errors.New(""relay failed metadata validation"")
+	errValidateServicer    = errors.New(""relay does not match the servicer"")
+	errValidateApplication = errors.New(""relay failed application validation"")
 
 	_ modules.Servicer = &servicer{}
 )
 
+type sessionTokens struct {
+	SessionNumber int64
+	Count         *big.Int
+}
+
 type servicer struct {
 	base_modules.IntegratableModule
 	base_modules.InterruptableModule
 
 	logger *modules.Logger
 	config *configs.ServicerConfig
+
+	rwlock sync.RWMutex",utility/service/service.go,2023-06-06 22:51:21+00:00,2023-06-06T23:53:55Z,Please add a comment on why/how we need this.,,,,,52,RIGHT,50,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1220500107,Olshansk,f37b394454f45c27d058dac20af974a6ed273903,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -12,21 +21,38 @@ import (
 	""github.com/pokt-network/pocket/shared/crypto""
 	""github.com/pokt-network/pocket/shared/modules""
 	""github.com/pokt-network/pocket/shared/modules/base_modules""
+	""github.com/pokt-network/pocket/shared/utils""
+	typesUtil ""github.com/pokt-network/pocket/utility/types""
 )
 
+// DISCUSS: where should the RelayAccracyParameter be defined?
+const RelayAccuracyParameter = 0.2
+
 var (
 	errValidateBlockHeight = errors.New(""relay failed block height validation"")
 	errValidateRelayMeta   = errors.New(""relay failed metadata validation"")
+	errValidateServicer    = errors.New(""relay does not match the servicer"")
+	errValidateApplication = errors.New(""relay failed application validation"")
 
 	_ modules.Servicer = &servicer{}
 )
 
+type sessionTokens struct {
+	SessionNumber int64
+	Count         *big.Int
+}
+
 type servicer struct {
 	base_modules.IntegratableModule
 	base_modules.InterruptableModule
 
 	logger *modules.Logger
 	config *configs.ServicerConfig
+
+	rwlock sync.RWMutex
+	// totalTokens holds the total number of tokens assigned to this servicer for the app in the current session",utility/service/service.go,2023-06-06 22:52:26+00:00,2023-06-06T23:53:55Z,"```suggestion
	// totalTokens is a mapping from application addresses to session metadata to keep track of session tokens
```",,,,,53,RIGHT,51,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1220500337,Olshansk,f37b394454f45c27d058dac20af974a6ed273903,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -12,21 +21,38 @@ import (
 	""github.com/pokt-network/pocket/shared/crypto""
 	""github.com/pokt-network/pocket/shared/modules""
 	""github.com/pokt-network/pocket/shared/modules/base_modules""
+	""github.com/pokt-network/pocket/shared/utils""
+	typesUtil ""github.com/pokt-network/pocket/utility/types""
 )
 
+// DISCUSS: where should the RelayAccracyParameter be defined?
+const RelayAccuracyParameter = 0.2
+
 var (
 	errValidateBlockHeight = errors.New(""relay failed block height validation"")
 	errValidateRelayMeta   = errors.New(""relay failed metadata validation"")
+	errValidateServicer    = errors.New(""relay does not match the servicer"")
+	errValidateApplication = errors.New(""relay failed application validation"")
 
 	_ modules.Servicer = &servicer{}
 )
 
+type sessionTokens struct {
+	SessionNumber int64
+	Count         *big.Int
+}
+
 type servicer struct {
 	base_modules.IntegratableModule
 	base_modules.InterruptableModule
 
 	logger *modules.Logger
 	config *configs.ServicerConfig
+
+	rwlock sync.RWMutex
+	// totalTokens holds the total number of tokens assigned to this servicer for the app in the current session
+	// DISCUSS: considering the computational complexity, should we skip caching this value?",utility/service/service.go,2023-06-06 22:52:42+00:00,2023-06-06T23:53:55Z,"```suggestion
	// INVESTIGATE: considering the computational complexity, should we skip caching this value?
```",,,,,54,RIGHT,52,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1220507358,Olshansk,f37b394454f45c27d058dac20af974a6ed273903,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -70,17 +96,102 @@ func (s *servicer) HandleRelay(relay *coreTypes.Relay) (*coreTypes.RelayResponse
 		return nil, fmt.Errorf(""Error admitting relay: %w"", err)
 	}
 
-	// TODO: implement Persist Relay
-	// TODO: implement execution
-	// TODO: implement state maintenance
-	// TODO: validate the response from the node?
-	// TODO: (QUESTION) Should we persist SignedRPC?
-	return nil, nil
+	response, err := s.executeRelay(relay)
+	if err != nil {
+		return nil, fmt.Errorf(""Error executing relay: %w"", err)
+	}
+
+	// DISCUSS: should we validate the response from the node?
+	relayDigest, shouldStore, err := s.hasCollision(relay, response)
+	if err != nil {
+		return nil, fmt.Errorf(""Error calculating relay service digest: %w"", err)
+	}
+	if !shouldStore {
+		return response, nil
+	}
+
+	height := s.GetBus().GetConsensusModule().CurrentHeight()
+	writeCtx, err := s.GetBus().GetPersistenceModule().NewRWContext(int64(height))
+	if err != nil {
+		return nil, fmt.Errorf(""Error getting a write context to update token usage for application %s: %w"", relay.Meta.ApplicationAddress, err)
+	}
+	defer writeCtx.Release()",utility/service/service.go,2023-06-06 22:59:00+00:00,2023-06-06T23:53:55Z,Nice following of all of our patterns :),,113.0,RIGHT,,118,RIGHT,86,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1220507982,Olshansk,f37b394454f45c27d058dac20af974a6ed273903,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -70,17 +96,102 @@ func (s *servicer) HandleRelay(relay *coreTypes.Relay) (*coreTypes.RelayResponse
 		return nil, fmt.Errorf(""Error admitting relay: %w"", err)
 	}
 
-	// TODO: implement Persist Relay
-	// TODO: implement execution
-	// TODO: implement state maintenance
-	// TODO: validate the response from the node?
-	// TODO: (QUESTION) Should we persist SignedRPC?
-	return nil, nil
+	response, err := s.executeRelay(relay)
+	if err != nil {
+		return nil, fmt.Errorf(""Error executing relay: %w"", err)
+	}
+
+	// DISCUSS: should we validate the response from the node?
+	relayDigest, shouldStore, err := s.hasCollision(relay, response)
+	if err != nil {
+		return nil, fmt.Errorf(""Error calculating relay service digest: %w"", err)
+	}
+	if !shouldStore {
+		return response, nil
+	}
+
+	height := s.GetBus().GetConsensusModule().CurrentHeight()
+	writeCtx, err := s.GetBus().GetPersistenceModule().NewRWContext(int64(height))
+	if err != nil {
+		return nil, fmt.Errorf(""Error getting a write context to update token usage for application %s: %w"", relay.Meta.ApplicationAddress, err)
+	}
+	defer writeCtx.Release()
+
+	// DISCUSS: should we extend/use UnitOfWork for updating/retrieving token usage?
+	if err := writeCtx.RecordRelayService(relay.Meta.ApplicationAddress, relayDigest, relay, response); err != nil {
+		return nil, fmt.Errorf(""Error recording service proof for application %s: %w"", relay.Meta.ApplicationAddress, err)
+	}
+
+	return response, nil
+}
+
+// hasCollision returns:",utility/service/service.go,2023-06-06 22:59:42+00:00,2023-06-06T23:53:55Z,Thoughts on renaming to `isRelayReplay` so it's still short but explicit and clear to the reader,,,,,128,RIGHT,96,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1220515295,Olshansk,f37b394454f45c27d058dac20af974a6ed273903,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -70,17 +96,102 @@ func (s *servicer) HandleRelay(relay *coreTypes.Relay) (*coreTypes.RelayResponse
 		return nil, fmt.Errorf(""Error admitting relay: %w"", err)
 	}
 
-	// TODO: implement Persist Relay
-	// TODO: implement execution
-	// TODO: implement state maintenance
-	// TODO: validate the response from the node?
-	// TODO: (QUESTION) Should we persist SignedRPC?
-	return nil, nil
+	response, err := s.executeRelay(relay)
+	if err != nil {
+		return nil, fmt.Errorf(""Error executing relay: %w"", err)
+	}
+
+	// DISCUSS: should we validate the response from the node?",utility/service/service.go,2023-06-06 23:08:08+00:00,2023-06-06T23:53:55Z,"This is a big topic (data integrity, etc...)

I would add something like: `// TODO(M6): Look into data integrity checks and response validation.`",,,,,104,RIGHT,72,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1220520012,Olshansk,f37b394454f45c27d058dac20af974a6ed273903,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -11,25 +15,53 @@ import (
 	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
 	""github.com/pokt-network/pocket/shared/modules""
 	mockModules ""github.com/pokt-network/pocket/shared/modules/mocks""
+	typesUtil ""github.com/pokt-network/pocket/utility/types""
 )
 
-var testServicer1 = &coreTypes.Actor{
-	ActorType: coreTypes.ActorType_ACTOR_TYPE_SERVICER,
-	Address:   ""a3d9ea9d9ad9c58bb96ec41340f83cb2cabb6496"",
-	PublicKey: ""a6cd0a304c38d76271f74dd3c90325144425d904ef1b9a6fbab9b201d75a998b"",
-	Chains:    []string{""0021""},
-}
+const (
+	testAppsTokensMultiplier = int(2)
+	testCurrentHeight        = int64(9)
+)
+
+var (
+	testServicer1 = &coreTypes.Actor{
+		ActorType: coreTypes.ActorType_ACTOR_TYPE_SERVICER,
+		Address:   ""a3d9ea9d9ad9c58bb96ec41340f83cb2cabb6496"",
+		PublicKey: ""a6cd0a304c38d76271f74dd3c90325144425d904ef1b9a6fbab9b201d75a998b"",
+		Chains:    []string{""0021""},
+	}
+
+	testApp1 = &coreTypes.Actor{
+		Address:      ""98a792b7aca673620132ef01f50e62caa58eca83"",
+		PublicKey:    ""b5cd0a304c38d76271f74dd3c90325144425d904ef1b9a6fbab9b201d86b009c"",
+		StakedAmount: ""1000"",
+	}
+
+	testChainConfig1 = &configs.ChainConfig{
+		Url:                 ""http://chain-url.pokt.network"",
+		UserAgent:           ""user-agent-1"",
+		TimeoutMilliseconds: 1234,
+		BasicAuth: &configs.BasicAuth{
+			UserName: ""user1"",
+			Password: ""password1"",
+		},
+	}
+)
 
 func TestAdmitRelay(t *testing.T) {
-	currentHeight := uint64(9)
+	const (
+		currentSessionNumber = 2
+	)
+
 	testCases := []struct {
-		name     string
-		relay    *coreTypes.Relay
-		expected error
+		name       string
+		usedTokens int64",utility/service/service_test.go,2023-06-06 23:13:41+00:00,2023-06-06T23:53:55Z,"s/usedTokens/usedSessionTokens

Is this `total` or `perRelay`?",,,,,58,RIGHT,65,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1220520306,Olshansk,f37b394454f45c27d058dac20af974a6ed273903,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -43,63 +75,148 @@ func TestAdmitRelay(t *testing.T) {
 		},
 		{
 			name:     ""Relay for unsupported chain is rejected"",
-			relay:    testRelay(""foo"", 8),
+			relay:    testRelay(testRelayChain(""foo"")),
 			expected: errValidateRelayMeta,
 		},
 		{
 			name:     ""Relay with height set in a past session is rejected"",
-			relay:    testRelay(""0021"", 5),
+			relay:    testRelay(testRelayHeight(5)),
 			expected: errValidateBlockHeight,
 		},
 		{
 			name:     ""Relay with height set in a future session is rejected"",
-			relay:    testRelay(""0021"", 9999),
+			relay:    testRelay(testRelayHeight(9999)),
 			expected: errValidateBlockHeight,
 		},
+		{
+			name:     ""Relay not matching the servicer is rejected"",",utility/service/service_test.go,2023-06-06 23:14:01+00:00,2023-06-06T23:53:55Z,"```suggestion
			name:     ""Relay not matching the servicer in this session is rejected"",
```",,,,,92,RIGHT,97,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1220520526,Olshansk,f37b394454f45c27d058dac20af974a6ed273903,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -43,63 +75,148 @@ func TestAdmitRelay(t *testing.T) {
 		},
 		{
 			name:     ""Relay for unsupported chain is rejected"",
-			relay:    testRelay(""foo"", 8),
+			relay:    testRelay(testRelayChain(""foo"")),
 			expected: errValidateRelayMeta,
 		},
 		{
 			name:     ""Relay with height set in a past session is rejected"",
-			relay:    testRelay(""0021"", 5),
+			relay:    testRelay(testRelayHeight(5)),
 			expected: errValidateBlockHeight,
 		},
 		{
 			name:     ""Relay with height set in a future session is rejected"",
-			relay:    testRelay(""0021"", 9999),
+			relay:    testRelay(testRelayHeight(9999)),
 			expected: errValidateBlockHeight,
 		},
+		{
+			name:     ""Relay not matching the servicer is rejected"",
+			relay:    testRelay(testRelayServicer(""bar"")),
+			expected: errValidateServicer,
+		},
+		{
+			name:       ""Relay for maxed-out app is rejected"",",utility/service/service_test.go,2023-06-06 23:14:18+00:00,2023-06-06T23:53:55Z,"```suggestion
			name:       ""Relay for app out of quota is rejected"",
```",,,,,97,RIGHT,102,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1220521229,Olshansk,f37b394454f45c27d058dac20af974a6ed273903,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -43,63 +75,148 @@ func TestAdmitRelay(t *testing.T) {
 		},
 		{
 			name:     ""Relay for unsupported chain is rejected"",
-			relay:    testRelay(""foo"", 8),
+			relay:    testRelay(testRelayChain(""foo"")),
 			expected: errValidateRelayMeta,
 		},
 		{
 			name:     ""Relay with height set in a past session is rejected"",
-			relay:    testRelay(""0021"", 5),
+			relay:    testRelay(testRelayHeight(5)),
 			expected: errValidateBlockHeight,
 		},
 		{
 			name:     ""Relay with height set in a future session is rejected"",
-			relay:    testRelay(""0021"", 9999),
+			relay:    testRelay(testRelayHeight(9999)),
 			expected: errValidateBlockHeight,
 		},
+		{
+			name:     ""Relay not matching the servicer is rejected"",
+			relay:    testRelay(testRelayServicer(""bar"")),
+			expected: errValidateServicer,
+		},
+		{
+			name:       ""Relay for maxed-out app is rejected"",
+			relay:      testRelay(),
+			usedTokens: 999999,
+			expected:   errValidateApplication,
+		},
 	}
 
 	for _, testCase := range testCases {
 		t.Run(testCase.name, func(t *testing.T) {
 			config := testServicerConfig()
 			session := testSession(
-				sessionNumber(2),
+				sessionNumber(currentSessionNumber),
 				sessionBlocks(4),
 				sessionHeight(2),
 				sessionServicers(testServicer1),
 			)
-			mockBus := mockBus(t, &config, currentHeight, session)
+			mockBus := mockBus(t, &config, uint64(testCurrentHeight), session, testCase.usedTokens)
 
 			servicerMod, err := CreateServicer(mockBus)
 			require.NoError(t, err)
 
-			err = servicerMod.(*servicer).admitRelay(testCase.relay)
+			servicer := servicerMod.(*servicer)",utility/service/service_test.go,2023-06-06 23:15:10+00:00,2023-06-06T23:53:55Z,"```suggestion
			servicer, ok := servicerMod.(*servicer)
			require.True(t, ok)
```",,,,,118,RIGHT,126,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1220521910,Olshansk,f37b394454f45c27d058dac20af974a6ed273903,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -70,17 +96,102 @@ func (s *servicer) HandleRelay(relay *coreTypes.Relay) (*coreTypes.RelayResponse
 		return nil, fmt.Errorf(""Error admitting relay: %w"", err)
 	}
 
-	// TODO: implement Persist Relay
-	// TODO: implement execution
-	// TODO: implement state maintenance
-	// TODO: validate the response from the node?
-	// TODO: (QUESTION) Should we persist SignedRPC?
-	return nil, nil
+	response, err := s.executeRelay(relay)
+	if err != nil {
+		return nil, fmt.Errorf(""Error executing relay: %w"", err)
+	}
+
+	// DISCUSS: should we validate the response from the node?
+	relayDigest, shouldStore, err := s.hasCollision(relay, response)
+	if err != nil {
+		return nil, fmt.Errorf(""Error calculating relay service digest: %w"", err)
+	}
+	if !shouldStore {
+		return response, nil
+	}
+
+	height := s.GetBus().GetConsensusModule().CurrentHeight()
+	writeCtx, err := s.GetBus().GetPersistenceModule().NewRWContext(int64(height))
+	if err != nil {
+		return nil, fmt.Errorf(""Error getting a write context to update token usage for application %s: %w"", relay.Meta.ApplicationAddress, err)
+	}
+	defer writeCtx.Release()
+
+	// DISCUSS: should we extend/use UnitOfWork for updating/retrieving token usage?
+	if err := writeCtx.RecordRelayService(relay.Meta.ApplicationAddress, relayDigest, relay, response); err != nil {
+		return nil, fmt.Errorf(""Error recording service proof for application %s: %w"", relay.Meta.ApplicationAddress, err)
+	}
+
+	return response, nil
+}
+
+// hasCollision returns:
+//  1. The signed digest of a relay/response pair,
+//  2. Whether there was a collision for the specific chain (i.e. should the service proof be stored for claiming later)
+func (s *servicer) hasCollision(relay *coreTypes.Relay, response *coreTypes.RelayResponse) (digest []byte, collides bool, err error) {",utility/service/service.go,2023-06-06 23:15:57+00:00,2023-06-06T23:53:55Z,s/collides/isReplay,,,,,131,RIGHT,99,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1220526043,Olshansk,f37b394454f45c27d058dac20af974a6ed273903,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -70,17 +96,102 @@ func (s *servicer) HandleRelay(relay *coreTypes.Relay) (*coreTypes.RelayResponse
 		return nil, fmt.Errorf(""Error admitting relay: %w"", err)
 	}
 
-	// TODO: implement Persist Relay
-	// TODO: implement execution
-	// TODO: implement state maintenance
-	// TODO: validate the response from the node?
-	// TODO: (QUESTION) Should we persist SignedRPC?
-	return nil, nil
+	response, err := s.executeRelay(relay)
+	if err != nil {
+		return nil, fmt.Errorf(""Error executing relay: %w"", err)
+	}
+
+	// DISCUSS: should we validate the response from the node?
+	relayDigest, shouldStore, err := s.hasCollision(relay, response)
+	if err != nil {
+		return nil, fmt.Errorf(""Error calculating relay service digest: %w"", err)
+	}
+	if !shouldStore {
+		return response, nil
+	}
+
+	height := s.GetBus().GetConsensusModule().CurrentHeight()
+	writeCtx, err := s.GetBus().GetPersistenceModule().NewRWContext(int64(height))
+	if err != nil {
+		return nil, fmt.Errorf(""Error getting a write context to update token usage for application %s: %w"", relay.Meta.ApplicationAddress, err)
+	}
+	defer writeCtx.Release()
+
+	// DISCUSS: should we extend/use UnitOfWork for updating/retrieving token usage?
+	if err := writeCtx.RecordRelayService(relay.Meta.ApplicationAddress, relayDigest, relay, response); err != nil {
+		return nil, fmt.Errorf(""Error recording service proof for application %s: %w"", relay.Meta.ApplicationAddress, err)
+	}
+
+	return response, nil
+}
+
+// hasCollision returns:
+//  1. The signed digest of a relay/response pair,
+//  2. Whether there was a collision for the specific chain (i.e. should the service proof be stored for claiming later)
+func (s *servicer) hasCollision(relay *coreTypes.Relay, response *coreTypes.RelayResponse) (digest []byte, collides bool, err error) {
+	relayBytes, err := marshal(relay, response)
+	if err != nil {
+		return nil, false, fmt.Errorf(""Error marshalling relay and/or response: %w"", err)
+	}
+
+	relayDigest := crypto.SHA3Hash(relayBytes)
+
+	signedDigest := s.sign(relayDigest)
+	response.ServicerSignature = hex.EncodeToString(signedDigest)
+	collision, err := s.hasCollisionOnChain(relayDigest, relay.Meta.RelayChain.Id)
+	if err != nil {
+		return nil, false, fmt.Errorf(""Error checking collision for chain %s: %w"", relay.Meta.RelayChain.Id, err)
+	}
+
+	return signedDigest, collision, nil
+}
+
+// INCOMPLETE: implement this
+func (s *servicer) sign(bz []byte) []byte {
+	return bz
+}
+
+// INCOMPLETE: implement this
+func (s *servicer) hasCollisionOnChain(digest []byte, relayChainId string) (bool, error) {
+	return false, nil
+}
+
+func marshal(request *coreTypes.Relay, response *coreTypes.RelayResponse) ([]byte, error) {",utility/service/service.go,2023-06-06 23:20:35+00:00,2023-06-06T23:53:55Z,"s/marshal/marshalWhat?

1. Rename
s/marshal/marshalWhat?

2. Comment

Even though it's an internal helper, add a comment because this functionality is VERY important for the core of the protocol.

3. Refactor

The integrity of the blockchain (i.e. the protobufs and their serialized values in the tree) are the most important piece of the state. Ideally, people should be able to use the protos and implement it on their own. 

Can you create a proto in `relay.proto` that accepts both of these so that the marshaling of the digest is done by `codec.GetCodec().Marshal(RelayReqRes)`. That way we are language and framework agnostic and others, for example, could reimplement v1 in rust using the same protos.

```proto
message RelayReqRes {
	RelayReq
	RelayRes
}
```",,,,,159,RIGHT,127,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1220534736,Olshansk,f37b394454f45c27d058dac20af974a6ed273903,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -70,17 +96,102 @@ func (s *servicer) HandleRelay(relay *coreTypes.Relay) (*coreTypes.RelayResponse
 		return nil, fmt.Errorf(""Error admitting relay: %w"", err)
 	}
 
-	// TODO: implement Persist Relay
-	// TODO: implement execution
-	// TODO: implement state maintenance
-	// TODO: validate the response from the node?
-	// TODO: (QUESTION) Should we persist SignedRPC?
-	return nil, nil
+	response, err := s.executeRelay(relay)
+	if err != nil {
+		return nil, fmt.Errorf(""Error executing relay: %w"", err)
+	}
+
+	// DISCUSS: should we validate the response from the node?
+	relayDigest, shouldStore, err := s.hasCollision(relay, response)
+	if err != nil {
+		return nil, fmt.Errorf(""Error calculating relay service digest: %w"", err)
+	}
+	if !shouldStore {
+		return response, nil
+	}
+
+	height := s.GetBus().GetConsensusModule().CurrentHeight()
+	writeCtx, err := s.GetBus().GetPersistenceModule().NewRWContext(int64(height))
+	if err != nil {
+		return nil, fmt.Errorf(""Error getting a write context to update token usage for application %s: %w"", relay.Meta.ApplicationAddress, err)
+	}
+	defer writeCtx.Release()
+
+	// DISCUSS: should we extend/use UnitOfWork for updating/retrieving token usage?
+	if err := writeCtx.RecordRelayService(relay.Meta.ApplicationAddress, relayDigest, relay, response); err != nil {
+		return nil, fmt.Errorf(""Error recording service proof for application %s: %w"", relay.Meta.ApplicationAddress, err)
+	}
+
+	return response, nil
+}
+
+// hasCollision returns:
+//  1. The signed digest of a relay/response pair,
+//  2. Whether there was a collision for the specific chain (i.e. should the service proof be stored for claiming later)
+func (s *servicer) hasCollision(relay *coreTypes.Relay, response *coreTypes.RelayResponse) (digest []byte, collides bool, err error) {
+	relayBytes, err := marshal(relay, response)
+	if err != nil {
+		return nil, false, fmt.Errorf(""Error marshalling relay and/or response: %w"", err)
+	}
+
+	relayDigest := crypto.SHA3Hash(relayBytes)
+
+	signedDigest := s.sign(relayDigest)
+	response.ServicerSignature = hex.EncodeToString(signedDigest)
+	collision, err := s.hasCollisionOnChain(relayDigest, relay.Meta.RelayChain.Id)
+	if err != nil {
+		return nil, false, fmt.Errorf(""Error checking collision for chain %s: %w"", relay.Meta.RelayChain.Id, err)
+	}
+
+	return signedDigest, collision, nil
+}
+
+// INCOMPLETE: implement this
+func (s *servicer) sign(bz []byte) []byte {
+	return bz
+}
+
+// INCOMPLETE: implement this
+func (s *servicer) hasCollisionOnChain(digest []byte, relayChainId string) (bool, error) {
+	return false, nil
+}
+
+func marshal(request *coreTypes.Relay, response *coreTypes.RelayResponse) ([]byte, error) {
+	if request == nil || response == nil {
+		return nil, fmt.Errorf(""error marshalling: got nil value as input"")
+	}
+
+	s := struct {
+		*coreTypes.Relay
+		*coreTypes.RelayResponse
+	}{
+		request,
+		response,
+	}
+	return json.Marshal(s)
+}
+
+// executeRelay performs the passed relay using an HTTP request to the chain-specific target URL
+func (s *servicer) executeRelay(relay *coreTypes.Relay) (*coreTypes.RelayResponse, error) {",utility/service/service.go,2023-06-06 23:29:18+00:00,2023-06-06T23:53:55Z,"Should we:

1. Rename to `executeHttpRelay`
2. Add a TODO to add support for others?
3. Add a switch-case inside to add support for other requests in the future?",,,,,175,RIGHT,143,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1220537383,Olshansk,f37b394454f45c27d058dac20af974a6ed273903,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -122,19 +232,84 @@ func (s servicer) validateRelayChainSupport(relayChain *coreTypes.Identifiable,
 	return nil
 }
 
-// TODO: implement
 // validateApplication makes sure the application has not received more relays than allocated in the current session.
-func (s servicer) validateApplication(meta *coreTypes.RelayMeta, session *coreTypes.Session) error {
-	/*
-		// if maxRelaysPerSession, overServiced := calculateAppSessionTokens(); overServiced {
-			return fmt.Errorf(""application %s has exceeded its allocated relays %d for the session %d"", meta.ApplicationPublicKey, maxRelaysPerSession)
-		}
-	*/
-	return nil
+func (s *servicer) validateApplication(session *coreTypes.Session, currentHeight int64) error {
+	// IMPROVE: use a function to get current height from the current session
+	servicerAppSessionTokens, err := s.calculateServicerAppSessionTokens(session, currentHeight)
+	if err != nil {
+		return fmt.Errorf(""Error calculating servicer tokens for application: %w"", err)
+	}
+
+	readCtx, err := s.GetBus().GetPersistenceModule().NewReadContext(currentHeight)
+	if err != nil {
+		return fmt.Errorf(""Error getting read context: application %s session number %d: %w"", session.Application.PublicKey, session.SessionNumber, err)
+	}
+
+	usedAppSessionTokens, err := readCtx.GetServicerTokenUsage(session)
+	if err != nil {
+		return fmt.Errorf(""Error getting servicer token usage: application %s session number %d: %w"", session.Application.PublicKey, session.SessionNumber, err)
+	}
+
+	if usedAppSessionTokens == nil || usedAppSessionTokens.Cmp(servicerAppSessionTokens) < 0 {",utility/service/service.go,2023-06-06 23:32:36+00:00,2023-06-06T23:53:55Z,I think we should log a warning for `usedAppSessionTokens.Cmp(servicerAppSessionTokens) < 0`,,,,,253,RIGHT,216,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1220544069,Olshansk,f37b394454f45c27d058dac20af974a6ed273903,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -70,17 +96,102 @@ func (s *servicer) HandleRelay(relay *coreTypes.Relay) (*coreTypes.RelayResponse
 		return nil, fmt.Errorf(""Error admitting relay: %w"", err)
 	}
 
-	// TODO: implement Persist Relay
-	// TODO: implement execution
-	// TODO: implement state maintenance
-	// TODO: validate the response from the node?
-	// TODO: (QUESTION) Should we persist SignedRPC?
-	return nil, nil
+	response, err := s.executeRelay(relay)
+	if err != nil {
+		return nil, fmt.Errorf(""Error executing relay: %w"", err)
+	}
+
+	// DISCUSS: should we validate the response from the node?
+	relayDigest, shouldStore, err := s.hasCollision(relay, response)
+	if err != nil {
+		return nil, fmt.Errorf(""Error calculating relay service digest: %w"", err)
+	}
+	if !shouldStore {
+		return response, nil
+	}
+
+	height := s.GetBus().GetConsensusModule().CurrentHeight()
+	writeCtx, err := s.GetBus().GetPersistenceModule().NewRWContext(int64(height))
+	if err != nil {
+		return nil, fmt.Errorf(""Error getting a write context to update token usage for application %s: %w"", relay.Meta.ApplicationAddress, err)
+	}
+	defer writeCtx.Release()
+
+	// DISCUSS: should we extend/use UnitOfWork for updating/retrieving token usage?",utility/service/service.go,2023-06-06 23:40:22+00:00,2023-06-06T23:53:55Z,"This is a good question. `UnitOfWork` was meant to be more related to a single, atomic, rollbackable state transition related to on-chain things. A session is more of an ""off chain"" behaviour (spanning multiple blocks) that eventually transfers into a state transition.

Does that make sense? If so, can you add some of this context to the `UnitOfWork` interface?",,,,,120,RIGHT,88,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1220544304,Olshansk,f37b394454f45c27d058dac20af974a6ed273903,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -70,17 +96,102 @@ func (s *servicer) HandleRelay(relay *coreTypes.Relay) (*coreTypes.RelayResponse
 		return nil, fmt.Errorf(""Error admitting relay: %w"", err)
 	}
 
-	// TODO: implement Persist Relay
-	// TODO: implement execution
-	// TODO: implement state maintenance
-	// TODO: validate the response from the node?
-	// TODO: (QUESTION) Should we persist SignedRPC?
-	return nil, nil
+	response, err := s.executeRelay(relay)
+	if err != nil {
+		return nil, fmt.Errorf(""Error executing relay: %w"", err)
+	}
+
+	// DISCUSS: should we validate the response from the node?
+	relayDigest, shouldStore, err := s.hasCollision(relay, response)
+	if err != nil {
+		return nil, fmt.Errorf(""Error calculating relay service digest: %w"", err)
+	}
+	if !shouldStore {
+		return response, nil
+	}
+
+	height := s.GetBus().GetConsensusModule().CurrentHeight()
+	writeCtx, err := s.GetBus().GetPersistenceModule().NewRWContext(int64(height))
+	if err != nil {
+		return nil, fmt.Errorf(""Error getting a write context to update token usage for application %s: %w"", relay.Meta.ApplicationAddress, err)
+	}
+	defer writeCtx.Release()
+
+	// DISCUSS: should we extend/use UnitOfWork for updating/retrieving token usage?
+	if err := writeCtx.RecordRelayService(relay.Meta.ApplicationAddress, relayDigest, relay, response); err != nil {",utility/service/service.go,2023-06-06 23:40:42+00:00,2023-06-06T23:53:55Z,"IMPORTANT: @adshmh I unfortunately led you down the wrong path after our call yesterday.

- `readCtx` is used to read `on-chain` data (at a specific height)
	- We read on-chain data to understand the session quota (num tokens)

 -`writeCtx` is used to write to `on-chain` data (at a specific height)
	- We write on-chain data when the session is complete (e.g. need to send claim & proof transactions)

While the session is ongoing, we need to persist things (locally on disk or in memory but not on chain). Therefore, I think we might need to do something similar to `NonceDeduper` by leveraging `NewGenericFIFOSet` with a very large capacity.

I glossed over this but happy to go into more detail if need be. Just let me know.",,,,,121,RIGHT,89,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1220551512,Olshansk,f37b394454f45c27d058dac20af974a6ed273903,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -122,19 +232,84 @@ func (s servicer) validateRelayChainSupport(relayChain *coreTypes.Identifiable,
 	return nil
 }
 
-// TODO: implement
 // validateApplication makes sure the application has not received more relays than allocated in the current session.
-func (s servicer) validateApplication(meta *coreTypes.RelayMeta, session *coreTypes.Session) error {
-	/*
-		// if maxRelaysPerSession, overServiced := calculateAppSessionTokens(); overServiced {
-			return fmt.Errorf(""application %s has exceeded its allocated relays %d for the session %d"", meta.ApplicationPublicKey, maxRelaysPerSession)
-		}
-	*/
-	return nil
+func (s *servicer) validateApplication(session *coreTypes.Session, currentHeight int64) error {
+	// IMPROVE: use a function to get current height from the current session
+	servicerAppSessionTokens, err := s.calculateServicerAppSessionTokens(session, currentHeight)
+	if err != nil {
+		return fmt.Errorf(""Error calculating servicer tokens for application: %w"", err)
+	}
+
+	readCtx, err := s.GetBus().GetPersistenceModule().NewReadContext(currentHeight)
+	if err != nil {
+		return fmt.Errorf(""Error getting read context: application %s session number %d: %w"", session.Application.PublicKey, session.SessionNumber, err)
+	}
+
+	usedAppSessionTokens, err := readCtx.GetServicerTokenUsage(session)
+	if err != nil {
+		return fmt.Errorf(""Error getting servicer token usage: application %s session number %d: %w"", session.Application.PublicKey, session.SessionNumber, err)
+	}
+
+	if usedAppSessionTokens == nil || usedAppSessionTokens.Cmp(servicerAppSessionTokens) < 0 {
+		return nil
+	}
+
+	return fmt.Errorf(""application %s has exceeded its allocated relays %s for session %d"",
+		session.Application.PublicKey,
+		servicerAppSessionTokens,
+		session.SessionNumber)
+}
+
+func (s *servicer) cachedAppTokens(session *coreTypes.Session) *sessionTokens {
+	s.rwlock.RLock()
+	defer s.rwlock.RUnlock()
+
+	return s.totalTokens[session.Application.PublicKey]
+}
+
+// calculateServicerAppSessionTokens return the number of tokens the servicer can use for the application in the current session
+func (s *servicer) calculateServicerAppSessionTokens(session *coreTypes.Session, currentHeight int64) (*big.Int, error) {
+	tokens := s.cachedAppTokens(session)
+	if tokens != nil && tokens.Count != nil && tokens.SessionNumber == session.SessionNumber {
+		return big.NewInt(1).Set(tokens.Count), nil
+	}
+
+	// Calculate this servicer's limit for the application in the current session.
+	//	This is distributed rate limiting (DRL): no need to know how many requests have
+	//		been performed for this application by other servicers. Instead, simply enforce
+	//		this servicer's share of the application's tokens for this session.
+	appSessionTokens, err := s.calculateAppSessionTokens(session.Application.StakedAmount, currentHeight)
+	if err != nil {
+		return nil, fmt.Errorf(""Error calculating application %s total tokens for session %d: %w"", session.Application.PublicKey, session.SessionNumber, err)
+	}
+
+	// type conversion from big.Int to big.Float
+	appTokens := big.NewFloat(1).SetInt(appSessionTokens)
+	servicerTokens := appTokens.Quo(appTokens, big.NewFloat(float64(len(session.Servicers))))
+
+	// This multiplication is performed to minimize the chance of under-utilization of application's tokens,
+	//	while removing the overhead of communication between servicers which would be necessary otherwise.
+	// see https://arxiv.org/abs/2305.10672 for details on application and servicer distributed rate-limiting
+	adjustedTokens := servicerTokens.Mul(servicerTokens, big.NewFloat(1+RelayAccuracyParameter))",utility/service/service.go,2023-06-06 23:46:05+00:00,2023-06-06T23:53:55Z,"Amazing 💯 
",,,,,293,RIGHT,256,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1220554141,Olshansk,f37b394454f45c27d058dac20af974a6ed273903,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -122,19 +232,84 @@ func (s servicer) validateRelayChainSupport(relayChain *coreTypes.Identifiable,
 	return nil
 }
 
-// TODO: implement
 // validateApplication makes sure the application has not received more relays than allocated in the current session.
-func (s servicer) validateApplication(meta *coreTypes.RelayMeta, session *coreTypes.Session) error {
-	/*
-		// if maxRelaysPerSession, overServiced := calculateAppSessionTokens(); overServiced {
-			return fmt.Errorf(""application %s has exceeded its allocated relays %d for the session %d"", meta.ApplicationPublicKey, maxRelaysPerSession)
-		}
-	*/
-	return nil
+func (s *servicer) validateApplication(session *coreTypes.Session, currentHeight int64) error {
+	// IMPROVE: use a function to get current height from the current session
+	servicerAppSessionTokens, err := s.calculateServicerAppSessionTokens(session, currentHeight)
+	if err != nil {
+		return fmt.Errorf(""Error calculating servicer tokens for application: %w"", err)
+	}
+
+	readCtx, err := s.GetBus().GetPersistenceModule().NewReadContext(currentHeight)
+	if err != nil {
+		return fmt.Errorf(""Error getting read context: application %s session number %d: %w"", session.Application.PublicKey, session.SessionNumber, err)
+	}
+
+	usedAppSessionTokens, err := readCtx.GetServicerTokenUsage(session)
+	if err != nil {
+		return fmt.Errorf(""Error getting servicer token usage: application %s session number %d: %w"", session.Application.PublicKey, session.SessionNumber, err)
+	}
+
+	if usedAppSessionTokens == nil || usedAppSessionTokens.Cmp(servicerAppSessionTokens) < 0 {
+		return nil
+	}
+
+	return fmt.Errorf(""application %s has exceeded its allocated relays %s for session %d"",
+		session.Application.PublicKey,
+		servicerAppSessionTokens,
+		session.SessionNumber)
+}
+
+func (s *servicer) cachedAppTokens(session *coreTypes.Session) *sessionTokens {
+	s.rwlock.RLock()
+	defer s.rwlock.RUnlock()
+
+	return s.totalTokens[session.Application.PublicKey]
+}
+
+// calculateServicerAppSessionTokens return the number of tokens the servicer can use for the application in the current session",utility/service/service.go,2023-06-06 23:49:03+00:00,2023-06-06T23:53:55Z,"```suggestion
// calculateServicerAppSessionTokens return the number of tokens the servicer has remaining for the Application in the session provided. If nothing is cached, the maximum number of session tokens is computed.
```",,,,,270,RIGHT,233,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1220554441,Olshansk,f37b394454f45c27d058dac20af974a6ed273903,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -122,19 +232,84 @@ func (s servicer) validateRelayChainSupport(relayChain *coreTypes.Identifiable,
 	return nil
 }
 
-// TODO: implement
 // validateApplication makes sure the application has not received more relays than allocated in the current session.
-func (s servicer) validateApplication(meta *coreTypes.RelayMeta, session *coreTypes.Session) error {
-	/*
-		// if maxRelaysPerSession, overServiced := calculateAppSessionTokens(); overServiced {
-			return fmt.Errorf(""application %s has exceeded its allocated relays %d for the session %d"", meta.ApplicationPublicKey, maxRelaysPerSession)
-		}
-	*/
-	return nil
+func (s *servicer) validateApplication(session *coreTypes.Session, currentHeight int64) error {
+	// IMPROVE: use a function to get current height from the current session
+	servicerAppSessionTokens, err := s.calculateServicerAppSessionTokens(session, currentHeight)
+	if err != nil {
+		return fmt.Errorf(""Error calculating servicer tokens for application: %w"", err)
+	}
+
+	readCtx, err := s.GetBus().GetPersistenceModule().NewReadContext(currentHeight)
+	if err != nil {
+		return fmt.Errorf(""Error getting read context: application %s session number %d: %w"", session.Application.PublicKey, session.SessionNumber, err)
+	}
+
+	usedAppSessionTokens, err := readCtx.GetServicerTokenUsage(session)
+	if err != nil {
+		return fmt.Errorf(""Error getting servicer token usage: application %s session number %d: %w"", session.Application.PublicKey, session.SessionNumber, err)
+	}
+
+	if usedAppSessionTokens == nil || usedAppSessionTokens.Cmp(servicerAppSessionTokens) < 0 {
+		return nil
+	}
+
+	return fmt.Errorf(""application %s has exceeded its allocated relays %s for session %d"",
+		session.Application.PublicKey,
+		servicerAppSessionTokens,
+		session.SessionNumber)
+}
+
+func (s *servicer) cachedAppTokens(session *coreTypes.Session) *sessionTokens {
+	s.rwlock.RLock()
+	defer s.rwlock.RUnlock()
+
+	return s.totalTokens[session.Application.PublicKey]
+}
+
+// calculateServicerAppSessionTokens return the number of tokens the servicer can use for the application in the current session
+func (s *servicer) calculateServicerAppSessionTokens(session *coreTypes.Session, currentHeight int64) (*big.Int, error) {",utility/service/service.go,2023-06-06 23:49:24+00:00,2023-06-06T23:53:55Z,Why not use the `currentHeight` from the session?,,,,,271,RIGHT,234,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1220555132,Olshansk,f37b394454f45c27d058dac20af974a6ed273903,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -177,20 +351,44 @@ func (s servicer) admitRelay(relay *coreTypes.Relay) error {
 
 	// TODO: (REFACTOR) use a loop to run all validators: would also remove the need for passing the session around
 	if err := validateRelayBlockHeight(relay.Meta, session); err != nil {
-		return fmt.Errorf(""%w: %s"", errValidateBlockHeight, err.Error())
+		return fmt.Errorf(""%s: %w"", err.Error(), errValidateBlockHeight)
 	}
 
-	if err := s.validateApplication(relay.Meta, session); err != nil {
-		return fmt.Errorf(""%s: relay failed application validation: %w"", errPrefix, err)
+	if err := s.validateServicer(relay.Meta, session); err != nil {
+		return fmt.Errorf(""%s: %s: %w"", errPrefix, err.Error(), errValidateServicer)
 	}
 
-	if err := s.validateServicer(relay.Meta, session); err != nil {
-		return fmt.Errorf(""%s: relay failed servicer instance validation: %w"", errPrefix, err)
+	if err := s.validateApplication(session, int64(height)); err != nil {
+		return fmt.Errorf(""%s: %s: %w"", errPrefix, err.Error(), errValidateApplication)
 	}
 
 	return nil
 }
 
+// DISCUSS: do we need to export this functionality as part of the utility module?
+// calculateAppSessionTokens determines the number of ""session tokens"" an application gets at the beginning
+// of every session. Each servicer will serve a maximum of (Session Tokens / Number of Servicers in the Session) relays for the application",utility/service/service.go,2023-06-06 23:50:15+00:00,2023-06-06T23:53:56Z,"```suggestion
// of every session. Each servicer will serve a maximum of ~(Session Tokens / Number of Servicers in the Session) relays for the application
```",,,,,370,RIGHT,328,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1220555975,Olshansk,f37b394454f45c27d058dac20af974a6ed273903,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -350,3 +548,44 @@ func (r *relay) GetRelayChain() RelayChain              { return nil }
 func (r *relay) GetGeoZone() GeoZone                    { return nil }
 func (r *relay) GetToken() AAT                          { return nil }
 func (r *relay) GetSignature() string                   { return """" }
+
+// executeHTTPRequest performs the HTTP request that sends the relay to the chain's URL.
+func executeHTTPRequest(cfg *configs.ChainConfig, relay *coreTypes.RelayPayload) (*coreTypes.RelayResponse, error) {",utility/service/service.go,2023-06-06 23:51:13+00:00,2023-06-06T23:53:56Z,"Not much to add here. If we point to the Pocket V1 blochcain & localhost instead of ETH (i.e. 0021) with a fake URL, it might be an even easier way to test things E2E.",,,,,553,RIGHT,359,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1228613985,Olshansk,a98595f48fc016025fce2373b14d8a3829308d2e,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -0,0 +1,29 @@
+package persistence
+
+import (
+	""math/big""
+
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+)
+
+type persistenceLocalContext struct {
+	databasePath string
+}
+
+// INCOMPLETE: implement this",persistence/local.go,2023-06-13 19:40:59+00:00,2023-06-13T23:36:38Z,"NIT: Can you create a ticket to finish this and replace with `INCOMPLETE(#XXX): ...`

Ditto below.",,,,,13,RIGHT,13,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1228616876,Olshansk,a98595f48fc016025fce2373b14d8a3829308d2e,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -6,17 +6,26 @@ option go_package = ""github.com/pokt-network/pocket/shared/core/types"";
 
 // TECHDEBT: These structures were copied as placeholders from v0 and need to be updated to reflect changes in v1",shared/core/types/proto/relay.proto,2023-06-13 19:43:23+00:00,2023-06-13T23:36:38Z,Please remove this TECHDEBT comment given that you've updated it.,,,,,7,RIGHT,2,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1228622031,Olshansk,a98595f48fc016025fce2373b14d8a3829308d2e,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -42,3 +51,8 @@ message Identifiable {
     string id = 1;
     string name = 2;
 }
+
+message RelayReqRes {",shared/core/types/proto/relay.proto,2023-06-13 19:47:27+00:00,2023-06-13T23:36:38Z,Please add a short one line comment on what this is / what its needed.,,,,82.0,55,RIGHT,36,33.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1228622461,Olshansk,a98595f48fc016025fce2373b14d8a3829308d2e,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -6,17 +6,26 @@ option go_package = ""github.com/pokt-network/pocket/shared/core/types"";
 
 // TECHDEBT: These structures were copied as placeholders from v0 and need to be updated to reflect changes in v1
 message Relay {
-    RelayPayload payload = 1;
-    RelayMeta meta = 2;
+    RelayMeta meta = 1;
+    oneof relay_payload {
+        JsonRpcPayload json_rpc_payload = 2;
+        RestPayload rest_payload = 3;
+    }
 }
 
-message RelayPayload {
-    string data = 1;
+// INCOMPLETE: add support for different payloads, e.g. JSON, GRPC, etc.",shared/core/types/proto/relay.proto,2023-06-13 19:47:49+00:00,2023-06-13T23:36:38Z,Is this the right place for this comment or is it meant to be in place of line 13?,,,,,16,RIGHT,15,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1228623403,Olshansk,a98595f48fc016025fce2373b14d8a3829308d2e,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -6,17 +6,26 @@ option go_package = ""github.com/pokt-network/pocket/shared/core/types"";
 
 // TECHDEBT: These structures were copied as placeholders from v0 and need to be updated to reflect changes in v1
 message Relay {
-    RelayPayload payload = 1;
-    RelayMeta meta = 2;
+    RelayMeta meta = 1;
+    oneof relay_payload {
+        JsonRpcPayload json_rpc_payload = 2;
+        RestPayload rest_payload = 3;
+    }
 }
 
-message RelayPayload {
-    string data = 1;
+// INCOMPLETE: add support for different payloads, e.g. JSON, GRPC, etc.
+message JsonRpcPayload {
+    bytes data = 1;",shared/core/types/proto/relay.proto,2023-06-13 19:48:31+00:00,2023-06-13T23:36:38Z,"You mentioned `Every different chain (or even service) has its own custom payload (e.g. HTTP, JSON, GRPC, non-chain services)` in another comment. Where do you think it would be relevant to add this as context for the reader in the file?

Or potentially a github ticket if you create it.",,,,,18,RIGHT,17,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1228625153,Olshansk,a98595f48fc016025fce2373b14d8a3829308d2e,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -7,7 +7,7 @@ and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0
 
 ## [Unreleased]
 
-## [0.0.0.8] - 2023-06-06
+## [0.0.0.8] - 2023-06-12",app/docs/CHANGELOG.md,2023-06-13 19:49:46+00:00,2023-06-13T23:36:38Z,"This is unrelated to your changes, please fix.",,,,,10,RIGHT,5,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1228625255,Olshansk,a98595f48fc016025fce2373b14d8a3829308d2e,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -7,7 +7,7 @@ and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0
 
 ## [Unreleased]
 
-## [0.0.0.46] - 2023-06-06
+## [0.0.0.46] - 2023-06-12",build/docs/CHANGELOG.md,2023-06-13 19:49:51+00:00,2023-06-13T23:36:38Z,"This is unrelated to your changes, please fix.",,,,,10,RIGHT,5,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1228625360,Olshansk,a98595f48fc016025fce2373b14d8a3829308d2e,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -7,7 +7,7 @@ and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0
 
 ## [Unreleased]
 
-## [0.0.0.6] - 2023-06-06
+## [0.0.0.6] - 2023-06-12",charts/CHANGELOG.md,2023-06-13 19:49:56+00:00,2023-06-13T23:36:38Z,"This is unrelated to your changes, please fix.",,,,,10,RIGHT,5,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1228625570,Olshansk,a98595f48fc016025fce2373b14d8a3829308d2e,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -7,7 +7,7 @@ and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0
 
 ## [Unreleased]
 
-## [0.0.0.53] - 2023-06-08
+## [0.0.0.53] - 2023-06-12",consensus/doc/CHANGELOG.md,2023-06-13 19:50:07+00:00,2023-06-13T23:36:38Z,"This is unrelated to your changes, please fix/revert.",,,,,10,RIGHT,5,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1228632184,Olshansk,a98595f48fc016025fce2373b14d8a3829308d2e,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -7,7 +7,7 @@ and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0
 
 ## [Unreleased]
 
-## [0.0.0.14] - 2023-06-06
+## [0.0.0.14] - 2023-06-12",shared/modules/doc/CHANGELOG.md,2023-06-13 19:55:35+00:00,2023-06-13T23:36:38Z,This seems incorrect and there is no comment of the addition of `PersistenceLocalContext`,,,,,10,RIGHT,5,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1228634652,Olshansk,a98595f48fc016025fce2373b14d8a3829308d2e,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -18,6 +20,9 @@ type PersistenceModule interface {
 
 	// Context operations
 	NewRWContext(height int64) (PersistenceRWContext, error)
+	// DISCUSS: removing height from ""NewReadContext"" input and passing it to specific methods seems a better choice.",shared/modules/persistence_module.go,2023-06-13 19:58:24+00:00,2023-06-13T23:36:38Z,"We already have a ticket for it.

```suggestion
	// TODO(#406): removing height from ""NewReadContext"" input and passing it to specific methods seems a better choice.
```

Can you please add a comment on the ticket with the extra details / experience you have? Feel free to just copy paste what you have here.",,,,,23,RIGHT,16,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1228638984,Olshansk,a98595f48fc016025fce2373b14d8a3829308d2e,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -220,3 +232,23 @@ type PersistenceReadContext interface {
 	GetStringFlag(paramName string, height int64) (string, bool, error)
 	GetBytesFlag(paramName string, height int64) ([]byte, bool, error)
 }
+
+// PersistenceLocalContext defines the set of operations specific to local persistence.
+//
+//	This context should be used for node-specific data, e.g. records of served relays.
+//	This is in contrast to PersistenceRWContext which should be used to store on-chain data.
+type PersistenceLocalContext interface {
+	// StoreServiceRelay stores record of a serviced relay and its response in the local context.
+	// The stored service relays will be used to:
+	//	a) check the number of tokens used per session, and
+	//	b) prepare claim/proof messages once the session is over
+	// The ""relayDigest"" and ""relayReqResBytes"" parameters will be used as key and leaf contents in the constructed SMT, respectively.
+	// OPTIMIZE: both the relay and the response can be large structures: we may need to truncate the stored values
+	StoreServiceRelay(session *coreTypes.Session, appAddr string, relayDigest, relayReqResBytes []byte) error",shared/modules/persistence_module.go,2023-06-13 20:03:27+00:00,2023-06-13T23:36:38Z,"Field #7 of `Session` is the application, so we don't need to pass in the `appAddr` separately.",,,,,247,RIGHT,59,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1228639410,Olshansk,a98595f48fc016025fce2373b14d8a3829308d2e,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -220,3 +232,23 @@ type PersistenceReadContext interface {
 	GetStringFlag(paramName string, height int64) (string, bool, error)
 	GetBytesFlag(paramName string, height int64) ([]byte, bool, error)
 }
+
+// PersistenceLocalContext defines the set of operations specific to local persistence.
+//
+//	This context should be used for node-specific data, e.g. records of served relays.
+//	This is in contrast to PersistenceRWContext which should be used to store on-chain data.
+type PersistenceLocalContext interface {
+	// StoreServiceRelay stores record of a serviced relay and its response in the local context.
+	// The stored service relays will be used to:
+	//	a) check the number of tokens used per session, and
+	//	b) prepare claim/proof messages once the session is over
+	// The ""relayDigest"" and ""relayReqResBytes"" parameters will be used as key and leaf contents in the constructed SMT, respectively.
+	// OPTIMIZE: both the relay and the response can be large structures: we may need to truncate the stored values
+	StoreServiceRelay(session *coreTypes.Session, appAddr string, relayDigest, relayReqResBytes []byte) error",shared/modules/persistence_module.go,2023-06-13 20:03:55+00:00,2023-06-13T23:36:38Z,Should this be `StoreServiceRelay` or `StoreServicedRelay`; with emphasis on the `d`?,,,,,247,RIGHT,59,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1228639873,Olshansk,a98595f48fc016025fce2373b14d8a3829308d2e,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -220,3 +232,23 @@ type PersistenceReadContext interface {
 	GetStringFlag(paramName string, height int64) (string, bool, error)
 	GetBytesFlag(paramName string, height int64) ([]byte, bool, error)
 }
+
+// PersistenceLocalContext defines the set of operations specific to local persistence.
+//
+//	This context should be used for node-specific data, e.g. records of served relays.
+//	This is in contrast to PersistenceRWContext which should be used to store on-chain data.
+type PersistenceLocalContext interface {
+	// StoreServiceRelay stores record of a serviced relay and its response in the local context.
+	// The stored service relays will be used to:
+	//	a) check the number of tokens used per session, and
+	//	b) prepare claim/proof messages once the session is over
+	// The ""relayDigest"" and ""relayReqResBytes"" parameters will be used as key and leaf contents in the constructed SMT, respectively.
+	// OPTIMIZE: both the relay and the response can be large structures: we may need to truncate the stored values
+	StoreServiceRelay(session *coreTypes.Session, appAddr string, relayDigest, relayReqResBytes []byte) error
+	// GetSessionTokensUsed returns the number of tokens that have been used for the passed session.",shared/modules/persistence_module.go,2023-06-13 20:04:30+00:00,2023-06-13T23:36:38Z,"```suggestion
	// GetSessionTokensUsed returns the number of tokens that have been used for the provided session.
```",,,,,248,RIGHT,60,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1228643040,Olshansk,a98595f48fc016025fce2373b14d8a3829308d2e,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -220,3 +232,23 @@ type PersistenceReadContext interface {
 	GetStringFlag(paramName string, height int64) (string, bool, error)
 	GetBytesFlag(paramName string, height int64) ([]byte, bool, error)
 }
+
+// PersistenceLocalContext defines the set of operations specific to local persistence.
+//
+//	This context should be used for node-specific data, e.g. records of served relays.
+//	This is in contrast to PersistenceRWContext which should be used to store on-chain data.
+type PersistenceLocalContext interface {
+	// StoreServiceRelay stores record of a serviced relay and its response in the local context.
+	// The stored service relays will be used to:
+	//	a) check the number of tokens used per session, and
+	//	b) prepare claim/proof messages once the session is over
+	// The ""relayDigest"" and ""relayReqResBytes"" parameters will be used as key and leaf contents in the constructed SMT, respectively.
+	// OPTIMIZE: both the relay and the response can be large structures: we may need to truncate the stored values
+	StoreServiceRelay(session *coreTypes.Session, appAddr string, relayDigest, relayReqResBytes []byte) error
+	// GetSessionTokensUsed returns the number of tokens that have been used for the passed session.
+	//    This gets calculated from local storage, so it returns the count of tokens used by the servicer instance",shared/modules/persistence_module.go,2023-06-13 20:08:05+00:00,2023-06-13T23:36:38Z,"Given that this is part of `PersistenceLocalContext`, I don't think we need the extra context.

I'm considering the cognitive load that the reader / future developer would have to take.


```suggestion
	//    It returns the count of tokens used by the servicer instance
```",,,,,249,RIGHT,61,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1228643997,Olshansk,a98595f48fc016025fce2373b14d8a3829308d2e,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -220,3 +232,23 @@ type PersistenceReadContext interface {
 	GetStringFlag(paramName string, height int64) (string, bool, error)
 	GetBytesFlag(paramName string, height int64) ([]byte, bool, error)
 }
+
+// PersistenceLocalContext defines the set of operations specific to local persistence.
+//
+//	This context should be used for node-specific data, e.g. records of served relays.
+//	This is in contrast to PersistenceRWContext which should be used to store on-chain data.
+type PersistenceLocalContext interface {
+	// StoreServiceRelay stores record of a serviced relay and its response in the local context.
+	// The stored service relays will be used to:
+	//	a) check the number of tokens used per session, and
+	//	b) prepare claim/proof messages once the session is over
+	// The ""relayDigest"" and ""relayReqResBytes"" parameters will be used as key and leaf contents in the constructed SMT, respectively.
+	// OPTIMIZE: both the relay and the response can be large structures: we may need to truncate the stored values
+	StoreServiceRelay(session *coreTypes.Session, appAddr string, relayDigest, relayReqResBytes []byte) error
+	// GetSessionTokensUsed returns the number of tokens that have been used for the passed session.
+	//    This gets calculated from local storage, so it returns the count of tokens used by the servicer instance
+	//	for the application associated with the session
+	GetSessionTokensUsed(*coreTypes.Session) (*big.Int, error)
+	// Release the allocated local context.
+	Release() error",shared/modules/persistence_module.go,2023-06-13 20:09:11+00:00,2023-06-13T23:36:38Z,"Open question (not loaded and I do not have a preference): Given that `NewLocalContext` acts as a singleton of sorts, do you still think we want a ""Release"" functionality? I can steelman both ways but just confirming.",,,,,253,RIGHT,65,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1228644915,Olshansk,a98595f48fc016025fce2373b14d8a3829308d2e,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -220,3 +232,23 @@ type PersistenceReadContext interface {
 	GetStringFlag(paramName string, height int64) (string, bool, error)
 	GetBytesFlag(paramName string, height int64) ([]byte, bool, error)
 }
+
+// PersistenceLocalContext defines the set of operations specific to local persistence.
+//
+//	This context should be used for node-specific data, e.g. records of served relays.
+//	This is in contrast to PersistenceRWContext which should be used to store on-chain data.
+type PersistenceLocalContext interface {
+	// StoreServiceRelay stores record of a serviced relay and its response in the local context.
+	// The stored service relays will be used to:
+	//	a) check the number of tokens used per session, and
+	//	b) prepare claim/proof messages once the session is over
+	// The ""relayDigest"" and ""relayReqResBytes"" parameters will be used as key and leaf contents in the constructed SMT, respectively.
+	// OPTIMIZE: both the relay and the response can be large structures: we may need to truncate the stored values",shared/modules/persistence_module.go,2023-06-13 20:10:21+00:00,2023-06-13T23:36:38Z,I think this `OPTIMIZE` should move to the place where we implement the function so the truncating is internal business logic.,,,,,246,RIGHT,58,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1228646093,Olshansk,a98595f48fc016025fce2373b14d8a3829308d2e,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -31,6 +36,11 @@ type PersistenceModule interface {
 
 	// Debugging / development only
 	HandleDebugMessage(*messaging.DebugMessage) error
+
+	// NewLocalContext returns a local persistence context that can be used to store/retrieve node-specific, i.e. off-chain, data
+	// The module can maintain a single local context for both read and write operations: subsequent calls to NewLocalContext return
+	// the same local context.
+	NewLocalContext() (PersistenceLocalContext, error)",shared/modules/persistence_module.go,2023-06-13 20:11:28+00:00,2023-06-13T23:36:38Z,"Given `NewLocalContext returnthe same local context`, do you think we should rename it to `GetLocalContext` given that it kind of acts like a singleton? 

Okay with leaving it as is as well.",,,,,43,RIGHT,30,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1228647356,Olshansk,a98595f48fc016025fce2373b14d8a3829308d2e,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -16,4 +16,5 @@ message PersistenceConfig {
   string max_conn_lifetime = 8; // See pkg.go.dev/time#ParseDuration for reference
   string max_conn_idle_time = 9; // See pkg.go.dev/time#ParseDuration for reference
   string health_check_period = 10; // See pkg.go.dev/time#ParseDuration for reference
+  string local_database_path = 11; // The path used to store local, i.e. off-chain and node-specific, data.",runtime/configs/proto/persistence_config.proto,2023-06-13 20:12:29+00:00,2023-06-13T23:36:38Z,"```suggestion
  // TODO: `local_database_path` may need to be expanded to multiple stores depending on how usage evolves
  string local_database_path = 11; // The path used to store local, i.e. off-chain and node-specific, data.
```",,,,20.0,19,RIGHT,4,5.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1228648089,Olshansk,a98595f48fc016025fce2373b14d8a3829308d2e,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -5,11 +5,33 @@ package configs;
 
 option go_package = ""github.com/pokt-network/pocket/runtime/configs"";
 
+// TODO: Reevalute whether each utility actor should contain address/pubKey configs or if it should be shared
 // ServicerConfig defines the configuration for the node acting as a servicer. Servicers earn rewards for providing Web3 access over a function of volume and quality
 message ServicerConfig {
   // Enabled defines whether or not the node is a servicer.
   bool enabled = 1;
   string public_key = 2;
   string address = 3;
-  repeated string chains = 4;
+  map<string, ServiceConfig> services = 4;
+
+  // relay_mining_volume_accuracy is a parameter used to adjust the calculated number of service tokens for an application.",runtime/configs/proto/servicer_config.proto,2023-06-13 20:13:09+00:00,2023-06-13T23:36:38Z,"Nice, ty!",,,,17.0,17,RIGHT,14,14.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1228651403,Olshansk,a98595f48fc016025fce2373b14d8a3829308d2e,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -5,11 +5,33 @@ package configs;
 
 option go_package = ""github.com/pokt-network/pocket/runtime/configs"";
 
+// TODO: Reevalute whether each utility actor should contain address/pubKey configs or if it should be shared
 // ServicerConfig defines the configuration for the node acting as a servicer. Servicers earn rewards for providing Web3 access over a function of volume and quality
 message ServicerConfig {
   // Enabled defines whether or not the node is a servicer.
   bool enabled = 1;
   string public_key = 2;
   string address = 3;
-  repeated string chains = 4;
+  map<string, ServiceConfig> services = 4;
+
+  // relay_mining_volume_accuracy is a parameter used to adjust the calculated number of service tokens for an application.
+  // It is introduced to minimize the chance of under-utilization of application's tokens, while removing the overhead of
+  // communication between servicers which would be necessary otherwise.
+  // See the following for more details:
+  //	https://arxiv.org/abs/2305.10672
+  double relay_mining_volume_accuracy = 5;
+}
+
+message ServiceConfig {",runtime/configs/proto/servicer_config.proto,2023-06-13 20:16:58+00:00,2023-06-13T23:36:38Z,"Can you add a comment about `ServiceConfig`.

For example:

```
ServiceConfig holds configurations related to where/how the application/client can access the backing RPC service. It is analogous to ""ChainConfig"" in v0 but can support any RPC service.",,,,26.0,25,RIGHT,22,23.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1228671813,Olshansk,a98595f48fc016025fce2373b14d8a3829308d2e,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -1,20 +1,34 @@
 package servicer
 
 import (
+	""bytes""
+	""encoding/hex""
 	""errors""
 	""fmt""
+	""io""
+	""math/big""
+	""net/http""
+	""net/url""
+	""sync""
+	""time""
 
 	""github.com/pokt-network/pocket/logger""
 	""github.com/pokt-network/pocket/runtime/configs""
+	""github.com/pokt-network/pocket/shared/codec""
 	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/crypto""
 	""github.com/pokt-network/pocket/shared/modules""
 	""github.com/pokt-network/pocket/shared/modules/base_modules""
+	""github.com/pokt-network/pocket/shared/utils""
+	typesUtil ""github.com/pokt-network/pocket/utility/types""
 	""golang.org/x/exp/slices""
 )
 
 var (",utility/servicer/module.go,2023-06-13 20:38:02+00:00,2023-06-13T23:36:39Z,"```suggestion
// TECHDEBT(#519): Refactor error handling and consolidate with `shared/core/types/error.go`
var (
```",,,,29.0,27,RIGHT,27,29.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1228673860,Olshansk,a98595f48fc016025fce2373b14d8a3829308d2e,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -23,12 +37,25 @@ const (
 	ServicerModuleName = ""servicer""
 )
 
+// sessionTokens is used to cache the original number of tokens available
+// during a specific session: it is used as the value for a map with keys being applications' public keys",utility/servicer/module.go,2023-06-13 20:39:59+00:00,2023-06-13T23:36:39Z,"`it is used as the value for a map with keys being applications' public keys`

What if we have a servicer managing more than one session from the same app as once? If this is too big of a side tangent, just add a TODO that we may/may not have to resolve this in the future.",,,,43.0,41,RIGHT,40,42.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1228673895,Olshansk,a98595f48fc016025fce2373b14d8a3829308d2e,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -23,12 +37,25 @@ const (
 	ServicerModuleName = ""servicer""
 )
 
+// sessionTokens is used to cache the original number of tokens available
+// during a specific session: it is used as the value for a map with keys being applications' public keys
+type sessionTokens struct {
+	sessionNumber          int64
+	originalCountAvailable *big.Int",utility/servicer/module.go,2023-06-13 20:40:01+00:00,2023-06-13T23:36:39Z,Wdyt of this? `s/originalCountAvailable/startingTokenCountAvailable`,,,,,44,RIGHT,43,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1228679186,Olshansk,a98595f48fc016025fce2373b14d8a3829308d2e,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -23,12 +37,25 @@ const (
 	ServicerModuleName = ""servicer""
 )
 
+// sessionTokens is used to cache the original number of tokens available
+// during a specific session: it is used as the value for a map with keys being applications' public keys
+type sessionTokens struct {
+	sessionNumber          int64
+	originalCountAvailable *big.Int
+}
+
 type servicer struct {
 	base_modules.IntegratableModule
 	base_modules.InterruptableModule
 
 	logger *modules.Logger
 	config *configs.ServicerConfig
+
+	// This lock is needed to allow multiple GO routines update the totalTokens cache as part of serving relays
+	rwlock sync.RWMutex
+	// totalTokens is a mapping from application public keys to session metadata to keep track of session tokens
+	// INVESTIGATE: considering the computational complexity, should we skip caching this value?",utility/servicer/module.go,2023-06-13 20:45:25+00:00,2023-06-13T23:36:39Z,"1. Is it computational complexity or memory complexity?
2. If its the former, what is computationally heavy?",,,,,57,RIGHT,56,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1228679364,Olshansk,a98595f48fc016025fce2373b14d8a3829308d2e,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -23,12 +37,25 @@ const (
 	ServicerModuleName = ""servicer""
 )
 
+// sessionTokens is used to cache the original number of tokens available
+// during a specific session: it is used as the value for a map with keys being applications' public keys
+type sessionTokens struct {
+	sessionNumber          int64
+	originalCountAvailable *big.Int
+}
+
 type servicer struct {
 	base_modules.IntegratableModule
 	base_modules.InterruptableModule
 
 	logger *modules.Logger
 	config *configs.ServicerConfig
+
+	// This lock is needed to allow multiple GO routines update the totalTokens cache as part of serving relays
+	rwlock sync.RWMutex",utility/servicer/module.go,2023-06-13 20:45:40+00:00,2023-06-13T23:36:39Z,Why did you choose to go with a map + mutex instead of `sync.Map`? https://pkg.go.dev/sync#Map,,,,59.0,55,RIGHT,54,58.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1228682351,Olshansk,a98595f48fc016025fce2373b14d8a3829308d2e,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -4,7 +4,10 @@ package configs;
 
 option go_package = ""github.com/pokt-network/pocket/runtime/configs"";
 
+import ""servicer_config.proto"";
+
 message UtilityConfig {
   uint64 max_mempool_transaction_bytes = 1;
   uint32 max_mempool_transactions = 2;
+  ServicerConfig servicer_config = 3;",runtime/configs/proto/utility_config.proto,2023-06-13 20:49:11+00:00,2023-06-13T23:36:39Z,"This doesn't seem like thr right approach anymore given the recent updates


![Screenshot 2023-06-13 at 1 48 44 PM](https://github.com/pokt-network/pocket/assets/1892194/09d4f63a-62f1-4e34-8082-d47b7c0cd369)
",,,,,12,RIGHT,9,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1228685613,Olshansk,a98595f48fc016025fce2373b14d8a3829308d2e,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -0,0 +1,29 @@
+package persistence
+
+import (
+	""math/big""
+
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+)
+",persistence/local.go,2023-06-13 20:53:02+00:00,2023-06-13T23:36:39Z,"Add compile-time casting to make sure we implement the interface

```suggestion

var _ PersistenceLocalContext = &persistenceLocalContext{}

```",,,,,8,RIGHT,8,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1228691687,Olshansk,a98595f48fc016025fce2373b14d8a3829308d2e,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -0,0 +1,29 @@
+package persistence
+
+import (
+	""math/big""
+
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+)
+
+type persistenceLocalContext struct {",persistence/local.go,2023-06-13 21:00:15+00:00,2023-06-13T23:36:39Z,"Do you think this should be treated as a `submodule`? I can see others try to access it via the bus (e.g. might be relevant and useful to the work @h5law is doing), so making it an `IntegratableModule` could help.

There are details in `shared/modules/module.go` and @bryanchriswhite is also working on #810 for added context.",,,,,9,RIGHT,9,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1228699641,Olshansk,a98595f48fc016025fce2373b14d8a3829308d2e,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -0,0 +1,29 @@
+package persistence
+
+import (
+	""math/big""
+
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+)
+
+type persistenceLocalContext struct {
+	databasePath string
+}
+
+// INCOMPLETE: implement this
+// StoreServiceRelay implements the PersistenceLocalContext interface
+func (local *persistenceLocalContext) StoreServiceRelay(session *coreTypes.Session, appAddr string, relayDigest, relayReqResBytes []byte) error {",persistence/local.go,2023-06-13 21:08:18+00:00,2023-06-13T23:36:39Z,"Per my other comment, I think we can get `appAddr` from `session` and do not need it here.",,,,,15,RIGHT,15,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1228700393,Olshansk,a98595f48fc016025fce2373b14d8a3829308d2e,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -0,0 +1,29 @@
+package persistence
+
+import (
+	""math/big""
+
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+)
+
+type persistenceLocalContext struct {
+	databasePath string
+}
+
+// INCOMPLETE: implement this
+// StoreServiceRelay implements the PersistenceLocalContext interface
+func (local *persistenceLocalContext) StoreServiceRelay(session *coreTypes.Session, appAddr string, relayDigest, relayReqResBytes []byte) error {
+	return nil
+}
+
+// INCOMPLETE: implement this",persistence/local.go,2023-06-13 21:09:14+00:00,2023-06-13T23:36:39Z,"Because we have a few `INCOMPLETE` that are related and are a multi-day effort, I think it's worth creating a ticket  an adding it in cracked: `INCOMPLETE(#XXX): ... `",,,,,19,RIGHT,19,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1228704543,Olshansk,a98595f48fc016025fce2373b14d8a3829308d2e,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -86,17 +113,88 @@ func (s *servicer) HandleRelay(relay *coreTypes.Relay) (*coreTypes.RelayResponse
 		return nil, fmt.Errorf(""Error admitting relay: %w"", err)
 	}
 
-	// TODO: implement Persist Relay
-	// TODO: implement execution
-	// TODO: implement state maintenance
-	// TODO: validate the response from the node?
-	// TODO: (QUESTION) Should we persist SignedRPC?
-	return nil, nil
+	response, err := s.executeRelay(relay)
+	if err != nil {
+		return nil, fmt.Errorf(""Error executing relay: %w"", err)
+	}
+
+	// TODO(M6): Look into data integrity checks and response validation.
+
+	relayDigest, relayReqResBytes, shouldStore, err := s.isRelayVolumeApplicable(relay, response)
+	if err != nil {
+		return nil, fmt.Errorf(""Error calculating relay service digest: %w"", err)
+	}
+	if !shouldStore {
+		return response, nil
+	}
+
+	session, err := s.getSession(relay)
+	if err != nil {
+		return nil, err
+	}
+
+	localCtx, err := s.GetBus().GetPersistenceModule().NewLocalContext()
+	if err != nil {
+		return nil, fmt.Errorf(""Error getting a local context to update token usage for application %s: %w"", relay.Meta.ApplicationAddress, err)
+	}
+
+	if err := localCtx.StoreServiceRelay(session, relay.Meta.ApplicationAddress, relayDigest, relayReqResBytes); err != nil {
+		return nil, fmt.Errorf(""Error recording service proof for application %s: %w"", relay.Meta.ApplicationAddress, err)
+	}
+
+	if err := localCtx.Release(); err != nil {",utility/servicer/module.go,2023-06-13 21:14:46+00:00,2023-06-13T23:36:39Z,Is the release like a mutex release (i.e. the context persists)?,,,,,145,RIGHT,100,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1228704706,Olshansk,a98595f48fc016025fce2373b14d8a3829308d2e,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -86,17 +113,88 @@ func (s *servicer) HandleRelay(relay *coreTypes.Relay) (*coreTypes.RelayResponse
 		return nil, fmt.Errorf(""Error admitting relay: %w"", err)
 	}
 
-	// TODO: implement Persist Relay
-	// TODO: implement execution
-	// TODO: implement state maintenance
-	// TODO: validate the response from the node?
-	// TODO: (QUESTION) Should we persist SignedRPC?
-	return nil, nil
+	response, err := s.executeRelay(relay)
+	if err != nil {
+		return nil, fmt.Errorf(""Error executing relay: %w"", err)
+	}
+
+	// TODO(M6): Look into data integrity checks and response validation.
+
+	relayDigest, relayReqResBytes, shouldStore, err := s.isRelayVolumeApplicable(relay, response)
+	if err != nil {
+		return nil, fmt.Errorf(""Error calculating relay service digest: %w"", err)
+	}
+	if !shouldStore {
+		return response, nil
+	}
+
+	session, err := s.getSession(relay)
+	if err != nil {
+		return nil, err
+	}
+
+	localCtx, err := s.GetBus().GetPersistenceModule().NewLocalContext()
+	if err != nil {
+		return nil, fmt.Errorf(""Error getting a local context to update token usage for application %s: %w"", relay.Meta.ApplicationAddress, err)
+	}
+
+	if err := localCtx.StoreServiceRelay(session, relay.Meta.ApplicationAddress, relayDigest, relayReqResBytes); err != nil {
+		return nil, fmt.Errorf(""Error recording service proof for application %s: %w"", relay.Meta.ApplicationAddress, err)
+	}
+
+	if err := localCtx.Release(); err != nil {
+		s.logger.Warn().Err(err).Msg(""failed to release local context"")
+	}
+
+	return response, nil
+}
+
+// isRelayVolumeApplicable returns:
+//  1. The signed digest of a relay/response pair,",utility/servicer/module.go,2023-06-13 21:15:02+00:00,2023-06-13T23:36:39Z,"```suggestion
//  1. The signed digest of a relay/response pair
```",,,,,153,RIGHT,108,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1228705803,Olshansk,a98595f48fc016025fce2373b14d8a3829308d2e,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -86,17 +113,88 @@ func (s *servicer) HandleRelay(relay *coreTypes.Relay) (*coreTypes.RelayResponse
 		return nil, fmt.Errorf(""Error admitting relay: %w"", err)
 	}
 
-	// TODO: implement Persist Relay
-	// TODO: implement execution
-	// TODO: implement state maintenance
-	// TODO: validate the response from the node?
-	// TODO: (QUESTION) Should we persist SignedRPC?
-	return nil, nil
+	response, err := s.executeRelay(relay)
+	if err != nil {
+		return nil, fmt.Errorf(""Error executing relay: %w"", err)
+	}
+
+	// TODO(M6): Look into data integrity checks and response validation.
+
+	relayDigest, relayReqResBytes, shouldStore, err := s.isRelayVolumeApplicable(relay, response)
+	if err != nil {
+		return nil, fmt.Errorf(""Error calculating relay service digest: %w"", err)
+	}
+	if !shouldStore {
+		return response, nil
+	}
+
+	session, err := s.getSession(relay)
+	if err != nil {
+		return nil, err
+	}
+
+	localCtx, err := s.GetBus().GetPersistenceModule().NewLocalContext()
+	if err != nil {
+		return nil, fmt.Errorf(""Error getting a local context to update token usage for application %s: %w"", relay.Meta.ApplicationAddress, err)
+	}
+
+	if err := localCtx.StoreServiceRelay(session, relay.Meta.ApplicationAddress, relayDigest, relayReqResBytes); err != nil {
+		return nil, fmt.Errorf(""Error recording service proof for application %s: %w"", relay.Meta.ApplicationAddress, err)
+	}
+
+	if err := localCtx.Release(); err != nil {
+		s.logger.Warn().Err(err).Msg(""failed to release local context"")
+	}
+
+	return response, nil
+}
+
+// isRelayVolumeApplicable returns:
+//  1. The signed digest of a relay/response pair,
+//  2. Whether there was a collision for the specific chain (i.e. should the service proof be stored for claiming later)",utility/servicer/module.go,2023-06-13 21:16:33+00:00,2023-06-13T23:36:39Z,"This is how I interpreted it. Am I missing anything?
```
2. Whether there was a collision for the specific relay (i.e. has this request already been attempted to be stored for a claim before)
```

",,,,,154,RIGHT,109,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1228706682,Olshansk,a98595f48fc016025fce2373b14d8a3829308d2e,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -86,17 +113,88 @@ func (s *servicer) HandleRelay(relay *coreTypes.Relay) (*coreTypes.RelayResponse
 		return nil, fmt.Errorf(""Error admitting relay: %w"", err)
 	}
 
-	// TODO: implement Persist Relay
-	// TODO: implement execution
-	// TODO: implement state maintenance
-	// TODO: validate the response from the node?
-	// TODO: (QUESTION) Should we persist SignedRPC?
-	return nil, nil
+	response, err := s.executeRelay(relay)
+	if err != nil {
+		return nil, fmt.Errorf(""Error executing relay: %w"", err)
+	}
+
+	// TODO(M6): Look into data integrity checks and response validation.
+
+	relayDigest, relayReqResBytes, shouldStore, err := s.isRelayVolumeApplicable(relay, response)
+	if err != nil {
+		return nil, fmt.Errorf(""Error calculating relay service digest: %w"", err)
+	}
+	if !shouldStore {
+		return response, nil
+	}
+
+	session, err := s.getSession(relay)
+	if err != nil {
+		return nil, err
+	}
+
+	localCtx, err := s.GetBus().GetPersistenceModule().NewLocalContext()
+	if err != nil {
+		return nil, fmt.Errorf(""Error getting a local context to update token usage for application %s: %w"", relay.Meta.ApplicationAddress, err)
+	}
+
+	if err := localCtx.StoreServiceRelay(session, relay.Meta.ApplicationAddress, relayDigest, relayReqResBytes); err != nil {
+		return nil, fmt.Errorf(""Error recording service proof for application %s: %w"", relay.Meta.ApplicationAddress, err)
+	}
+
+	if err := localCtx.Release(); err != nil {
+		s.logger.Warn().Err(err).Msg(""failed to release local context"")
+	}
+
+	return response, nil
+}
+
+// isRelayVolumeApplicable returns:
+//  1. The signed digest of a relay/response pair,
+//  2. Whether there was a collision for the specific chain (i.e. should the service proof be stored for claiming later)
+func (s *servicer) isRelayVolumeApplicable(relay *coreTypes.Relay, response *coreTypes.RelayResponse) (digest, serializedRelayRes []byte, collides bool, err error) {",utility/servicer/module.go,2023-06-13 21:17:44+00:00,2023-06-13T23:36:39Z,Wdyt of renaming `collides` to either `isReplay` or `doesCollide`,,,,,155,RIGHT,110,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1228707329,Olshansk,a98595f48fc016025fce2373b14d8a3829308d2e,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -86,17 +113,88 @@ func (s *servicer) HandleRelay(relay *coreTypes.Relay) (*coreTypes.RelayResponse
 		return nil, fmt.Errorf(""Error admitting relay: %w"", err)
 	}
 
-	// TODO: implement Persist Relay
-	// TODO: implement execution
-	// TODO: implement state maintenance
-	// TODO: validate the response from the node?
-	// TODO: (QUESTION) Should we persist SignedRPC?
-	return nil, nil
+	response, err := s.executeRelay(relay)
+	if err != nil {
+		return nil, fmt.Errorf(""Error executing relay: %w"", err)
+	}
+
+	// TODO(M6): Look into data integrity checks and response validation.
+
+	relayDigest, relayReqResBytes, shouldStore, err := s.isRelayVolumeApplicable(relay, response)
+	if err != nil {
+		return nil, fmt.Errorf(""Error calculating relay service digest: %w"", err)
+	}
+	if !shouldStore {
+		return response, nil
+	}
+
+	session, err := s.getSession(relay)
+	if err != nil {
+		return nil, err
+	}
+
+	localCtx, err := s.GetBus().GetPersistenceModule().NewLocalContext()
+	if err != nil {
+		return nil, fmt.Errorf(""Error getting a local context to update token usage for application %s: %w"", relay.Meta.ApplicationAddress, err)
+	}
+
+	if err := localCtx.StoreServiceRelay(session, relay.Meta.ApplicationAddress, relayDigest, relayReqResBytes); err != nil {
+		return nil, fmt.Errorf(""Error recording service proof for application %s: %w"", relay.Meta.ApplicationAddress, err)
+	}
+
+	if err := localCtx.Release(); err != nil {
+		s.logger.Warn().Err(err).Msg(""failed to release local context"")
+	}
+
+	return response, nil
+}
+
+// isRelayVolumeApplicable returns:
+//  1. The signed digest of a relay/response pair,
+//  2. Whether there was a collision for the specific chain (i.e. should the service proof be stored for claiming later)
+func (s *servicer) isRelayVolumeApplicable(relay *coreTypes.Relay, response *coreTypes.RelayResponse) (digest, serializedRelayRes []byte, collides bool, err error) {
+	relayReqResBytes, err := codec.GetCodec().Marshal(&coreTypes.RelayReqRes{Relay: relay, Response: response})
+	if err != nil {
+		return nil, nil, false, fmt.Errorf(""Error marshalling relay and/or response: %w"", err)
+	}
+
+	relayDigest := crypto.SHA3Hash(relayReqResBytes)
+",utility/servicer/module.go,2023-06-13 21:18:33+00:00,2023-06-13T23:36:39Z,"```suggestion
	relayDigest := crypto.SHA3Hash(relayReqResBytes)
```",,160.0,RIGHT,,162,RIGHT,117,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1228708172,Olshansk,a98595f48fc016025fce2373b14d8a3829308d2e,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -86,17 +113,88 @@ func (s *servicer) HandleRelay(relay *coreTypes.Relay) (*coreTypes.RelayResponse
 		return nil, fmt.Errorf(""Error admitting relay: %w"", err)
 	}
 
-	// TODO: implement Persist Relay
-	// TODO: implement execution
-	// TODO: implement state maintenance
-	// TODO: validate the response from the node?
-	// TODO: (QUESTION) Should we persist SignedRPC?
-	return nil, nil
+	response, err := s.executeRelay(relay)
+	if err != nil {
+		return nil, fmt.Errorf(""Error executing relay: %w"", err)
+	}
+
+	// TODO(M6): Look into data integrity checks and response validation.
+
+	relayDigest, relayReqResBytes, shouldStore, err := s.isRelayVolumeApplicable(relay, response)
+	if err != nil {
+		return nil, fmt.Errorf(""Error calculating relay service digest: %w"", err)
+	}
+	if !shouldStore {
+		return response, nil
+	}
+
+	session, err := s.getSession(relay)
+	if err != nil {
+		return nil, err
+	}
+
+	localCtx, err := s.GetBus().GetPersistenceModule().NewLocalContext()
+	if err != nil {
+		return nil, fmt.Errorf(""Error getting a local context to update token usage for application %s: %w"", relay.Meta.ApplicationAddress, err)
+	}
+
+	if err := localCtx.StoreServiceRelay(session, relay.Meta.ApplicationAddress, relayDigest, relayReqResBytes); err != nil {
+		return nil, fmt.Errorf(""Error recording service proof for application %s: %w"", relay.Meta.ApplicationAddress, err)
+	}
+
+	if err := localCtx.Release(); err != nil {
+		s.logger.Warn().Err(err).Msg(""failed to release local context"")
+	}
+
+	return response, nil
+}
+
+// isRelayVolumeApplicable returns:
+//  1. The signed digest of a relay/response pair,
+//  2. Whether there was a collision for the specific chain (i.e. should the service proof be stored for claiming later)
+func (s *servicer) isRelayVolumeApplicable(relay *coreTypes.Relay, response *coreTypes.RelayResponse) (digest, serializedRelayRes []byte, collides bool, err error) {
+	relayReqResBytes, err := codec.GetCodec().Marshal(&coreTypes.RelayReqRes{Relay: relay, Response: response})
+	if err != nil {
+		return nil, nil, false, fmt.Errorf(""Error marshalling relay and/or response: %w"", err)
+	}
+
+	relayDigest := crypto.SHA3Hash(relayReqResBytes)
+
+	signedDigest := s.sign(relayDigest)
+	response.ServicerSignature = hex.EncodeToString(signedDigest)
+	collision, err := s.isRelayVolumeApplicableOnChain(relayDigest, relay.Meta.RelayChain.Id)",utility/servicer/module.go,2023-06-13 21:19:44+00:00,2023-06-13T23:36:39Z,"Can you add a comment above `RelayChain` in the proto to renaming it to `RPCService` or something alike. 

```go
TODO(M5): Consider renaming `RelayChain` to `RPCService` or something similar
```",,,,,165,RIGHT,120,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1228708745,Olshansk,a98595f48fc016025fce2373b14d8a3829308d2e,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -86,17 +113,88 @@ func (s *servicer) HandleRelay(relay *coreTypes.Relay) (*coreTypes.RelayResponse
 		return nil, fmt.Errorf(""Error admitting relay: %w"", err)
 	}
 
-	// TODO: implement Persist Relay
-	// TODO: implement execution
-	// TODO: implement state maintenance
-	// TODO: validate the response from the node?
-	// TODO: (QUESTION) Should we persist SignedRPC?
-	return nil, nil
+	response, err := s.executeRelay(relay)
+	if err != nil {
+		return nil, fmt.Errorf(""Error executing relay: %w"", err)
+	}
+
+	// TODO(M6): Look into data integrity checks and response validation.
+
+	relayDigest, relayReqResBytes, shouldStore, err := s.isRelayVolumeApplicable(relay, response)
+	if err != nil {
+		return nil, fmt.Errorf(""Error calculating relay service digest: %w"", err)
+	}
+	if !shouldStore {
+		return response, nil
+	}
+
+	session, err := s.getSession(relay)
+	if err != nil {
+		return nil, err
+	}
+
+	localCtx, err := s.GetBus().GetPersistenceModule().NewLocalContext()
+	if err != nil {
+		return nil, fmt.Errorf(""Error getting a local context to update token usage for application %s: %w"", relay.Meta.ApplicationAddress, err)
+	}
+
+	if err := localCtx.StoreServiceRelay(session, relay.Meta.ApplicationAddress, relayDigest, relayReqResBytes); err != nil {
+		return nil, fmt.Errorf(""Error recording service proof for application %s: %w"", relay.Meta.ApplicationAddress, err)
+	}
+
+	if err := localCtx.Release(); err != nil {
+		s.logger.Warn().Err(err).Msg(""failed to release local context"")
+	}
+
+	return response, nil
+}
+
+// isRelayVolumeApplicable returns:
+//  1. The signed digest of a relay/response pair,
+//  2. Whether there was a collision for the specific chain (i.e. should the service proof be stored for claiming later)
+func (s *servicer) isRelayVolumeApplicable(relay *coreTypes.Relay, response *coreTypes.RelayResponse) (digest, serializedRelayRes []byte, collides bool, err error) {
+	relayReqResBytes, err := codec.GetCodec().Marshal(&coreTypes.RelayReqRes{Relay: relay, Response: response})
+	if err != nil {
+		return nil, nil, false, fmt.Errorf(""Error marshalling relay and/or response: %w"", err)
+	}
+
+	relayDigest := crypto.SHA3Hash(relayReqResBytes)
+
+	signedDigest := s.sign(relayDigest)
+	response.ServicerSignature = hex.EncodeToString(signedDigest)
+	collision, err := s.isRelayVolumeApplicableOnChain(relayDigest, relay.Meta.RelayChain.Id)
+	if err != nil {
+		return nil, nil, false, fmt.Errorf(""Error checking collision for chain %s: %w"", relay.Meta.RelayChain.Id, err)",utility/servicer/module.go,2023-06-13 21:20:32+00:00,2023-06-13T23:36:39Z,"```suggestion
		return nil, nil, false, fmt.Errorf(""Error checking for relay reply by app %s for chain %s during session number %d: %w ....
```",,,,,167,RIGHT,122,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1228781737,Olshansk,a98595f48fc016025fce2373b14d8a3829308d2e,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -242,6 +242,14 @@ func (m *persistenceModule) NewWriteContext() modules.PersistenceRWContext {
 	return m.writeContext
 }
 
+// INCOMPLETE: implement this",persistence/module.go,2023-06-13 22:55:01+00:00,2023-06-13T23:36:39Z,"Can you do one of three things:
1.`// INCOMPLETE(@adshmh):  implement this`
2.`// INCOMPLETE(#XXX): Implement <tl;dr description of this>`
3.`// INCOMPLETE: <Full details>`

This way if you had to leave the work tomorrow, it would be self explanatory for someone else to pick it up.

NIT: applicable here and elsewhere.",,,,,245,RIGHT,4,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1228782022,Olshansk,a98595f48fc016025fce2373b14d8a3829308d2e,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -114,8 +114,8 @@ func (s *rpcServer) PostV1ClientRelay(ctx echo.Context) error {
 		Signature:         body.Meta.Signature,
 	}
 
-	payload := &coreTypes.RelayPayload{
-		Data:     body.Payload.Data,
+	payload := &coreTypes.JsonRpcPayload{
+		Data:     []byte(body.Payload.Data),",rpc/handlers.go,2023-06-13 22:55:17+00:00,2023-06-13T23:36:39Z,Why do we need the cast here?,,,,,118,RIGHT,7,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1228782429,Olshansk,a98595f48fc016025fce2373b14d8a3829308d2e,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -112,6 +112,7 @@ func setViperDefaults(cfg *Config) {
 }
 
 func NewDefaultConfig(options ...func(*Config)) *Config {
+",runtime/configs/config.go,2023-06-13 22:55:49+00:00,2023-06-13T23:36:39Z,"```suggestion
```",,,,,115,RIGHT,4,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1228783187,Olshansk,a98595f48fc016025fce2373b14d8a3829308d2e,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -211,3 +213,21 @@ func CreateTempConfig(cfg *Config) (*Config, error) {
 
 	return ParseConfig(tmpfile.Name()), nil
 }
+
+func defaultServicerConfig() *ServicerConfig {
+	return &ServicerConfig{
+		Enabled:                   true,
+		RelayMiningVolumeAccuracy: 0.2,
+		Services: map[string]*ServiceConfig{
+			// DISCUSS: what should the default config be? POKT/ETHM?
+			""POKT-V1"": {",runtime/configs/config.go,2023-06-13 22:56:33+00:00,2023-06-13T23:36:39Z,POKT-LocalNet,,,,,223,RIGHT,27,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1228784521,Olshansk,a98595f48fc016025fce2373b14d8a3829308d2e,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -211,3 +213,21 @@ func CreateTempConfig(cfg *Config) (*Config, error) {
 
 	return ParseConfig(tmpfile.Name()), nil
 }
+
+func defaultServicerConfig() *ServicerConfig {
+	return &ServicerConfig{
+		Enabled:                   true,
+		RelayMiningVolumeAccuracy: 0.2,
+		Services: map[string]*ServiceConfig{
+			// DISCUSS: what should the default config be? POKT/ETHM?",runtime/configs/config.go,2023-06-13 22:57:43+00:00,2023-06-13T23:36:39Z,"```suggestion
			// TODO(#XXX): Design how ChainIDs should be described/define.
```",,,,,222,RIGHT,26,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1228785435,Olshansk,a98595f48fc016025fce2373b14d8a3829308d2e,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -124,6 +125,7 @@ func NewDefaultConfig(options ...func(*Config)) *Config {
 			},
 		},
 		Utility: &UtilityConfig{
+			ServicerConfig:             defaultServicerConfig(),",runtime/configs/config.go,2023-06-13 22:58:29+00:00,2023-06-13T23:36:39Z,"See my other comment about embedding servicerConfig here as well as lines 160-162.

![Screenshot 2023-06-13 at 3 58 09 PM](https://github.com/pokt-network/pocket/assets/1892194/6affbbbe-5bed-4594-98ae-a8d9b6e1e295)
",,,,,128,RIGHT,12,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1228786420,Olshansk,a98595f48fc016025fce2373b14d8a3829308d2e,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -86,17 +113,88 @@ func (s *servicer) HandleRelay(relay *coreTypes.Relay) (*coreTypes.RelayResponse
 		return nil, fmt.Errorf(""Error admitting relay: %w"", err)
 	}
 
-	// TODO: implement Persist Relay
-	// TODO: implement execution
-	// TODO: implement state maintenance
-	// TODO: validate the response from the node?
-	// TODO: (QUESTION) Should we persist SignedRPC?
-	return nil, nil
+	response, err := s.executeRelay(relay)
+	if err != nil {
+		return nil, fmt.Errorf(""Error executing relay: %w"", err)
+	}
+
+	// TODO(M6): Look into data integrity checks and response validation.
+
+	relayDigest, relayReqResBytes, shouldStore, err := s.isRelayVolumeApplicable(relay, response)
+	if err != nil {
+		return nil, fmt.Errorf(""Error calculating relay service digest: %w"", err)
+	}
+	if !shouldStore {
+		return response, nil
+	}
+
+	session, err := s.getSession(relay)
+	if err != nil {
+		return nil, err
+	}
+
+	localCtx, err := s.GetBus().GetPersistenceModule().NewLocalContext()
+	if err != nil {
+		return nil, fmt.Errorf(""Error getting a local context to update token usage for application %s: %w"", relay.Meta.ApplicationAddress, err)
+	}
+
+	if err := localCtx.StoreServiceRelay(session, relay.Meta.ApplicationAddress, relayDigest, relayReqResBytes); err != nil {
+		return nil, fmt.Errorf(""Error recording service proof for application %s: %w"", relay.Meta.ApplicationAddress, err)
+	}
+
+	if err := localCtx.Release(); err != nil {
+		s.logger.Warn().Err(err).Msg(""failed to release local context"")
+	}
+
+	return response, nil
+}
+
+// isRelayVolumeApplicable returns:
+//  1. The signed digest of a relay/response pair,
+//  2. Whether there was a collision for the specific chain (i.e. should the service proof be stored for claiming later)
+func (s *servicer) isRelayVolumeApplicable(relay *coreTypes.Relay, response *coreTypes.RelayResponse) (digest, serializedRelayRes []byte, collides bool, err error) {
+	relayReqResBytes, err := codec.GetCodec().Marshal(&coreTypes.RelayReqRes{Relay: relay, Response: response})
+	if err != nil {
+		return nil, nil, false, fmt.Errorf(""Error marshalling relay and/or response: %w"", err)
+	}
+
+	relayDigest := crypto.SHA3Hash(relayReqResBytes)
+
+	signedDigest := s.sign(relayDigest)
+	response.ServicerSignature = hex.EncodeToString(signedDigest)
+	collision, err := s.isRelayVolumeApplicableOnChain(relayDigest, relay.Meta.RelayChain.Id)
+	if err != nil {
+		return nil, nil, false, fmt.Errorf(""Error checking collision for chain %s: %w"", relay.Meta.RelayChain.Id, err)
+	}
+
+	return signedDigest, relayReqResBytes, collision, nil
+}
+
+// INCOMPLETE: implement this",utility/servicer/module.go,2023-06-13 22:59:31+00:00,2023-06-13T23:36:39Z,See my other comment about `INCOMPLETE` comments,,,,,173,RIGHT,128,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1228786813,Olshansk,a98595f48fc016025fce2373b14d8a3829308d2e,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -86,17 +113,88 @@ func (s *servicer) HandleRelay(relay *coreTypes.Relay) (*coreTypes.RelayResponse
 		return nil, fmt.Errorf(""Error admitting relay: %w"", err)
 	}
 
-	// TODO: implement Persist Relay
-	// TODO: implement execution
-	// TODO: implement state maintenance
-	// TODO: validate the response from the node?
-	// TODO: (QUESTION) Should we persist SignedRPC?
-	return nil, nil
+	response, err := s.executeRelay(relay)
+	if err != nil {
+		return nil, fmt.Errorf(""Error executing relay: %w"", err)
+	}
+
+	// TODO(M6): Look into data integrity checks and response validation.
+
+	relayDigest, relayReqResBytes, shouldStore, err := s.isRelayVolumeApplicable(relay, response)
+	if err != nil {
+		return nil, fmt.Errorf(""Error calculating relay service digest: %w"", err)
+	}
+	if !shouldStore {
+		return response, nil
+	}
+
+	session, err := s.getSession(relay)
+	if err != nil {
+		return nil, err
+	}
+
+	localCtx, err := s.GetBus().GetPersistenceModule().NewLocalContext()
+	if err != nil {
+		return nil, fmt.Errorf(""Error getting a local context to update token usage for application %s: %w"", relay.Meta.ApplicationAddress, err)
+	}
+
+	if err := localCtx.StoreServiceRelay(session, relay.Meta.ApplicationAddress, relayDigest, relayReqResBytes); err != nil {
+		return nil, fmt.Errorf(""Error recording service proof for application %s: %w"", relay.Meta.ApplicationAddress, err)
+	}
+
+	if err := localCtx.Release(); err != nil {
+		s.logger.Warn().Err(err).Msg(""failed to release local context"")
+	}
+
+	return response, nil
+}
+
+// isRelayVolumeApplicable returns:
+//  1. The signed digest of a relay/response pair,
+//  2. Whether there was a collision for the specific chain (i.e. should the service proof be stored for claiming later)
+func (s *servicer) isRelayVolumeApplicable(relay *coreTypes.Relay, response *coreTypes.RelayResponse) (digest, serializedRelayRes []byte, collides bool, err error) {
+	relayReqResBytes, err := codec.GetCodec().Marshal(&coreTypes.RelayReqRes{Relay: relay, Response: response})
+	if err != nil {
+		return nil, nil, false, fmt.Errorf(""Error marshalling relay and/or response: %w"", err)
+	}
+
+	relayDigest := crypto.SHA3Hash(relayReqResBytes)
+
+	signedDigest := s.sign(relayDigest)
+	response.ServicerSignature = hex.EncodeToString(signedDigest)
+	collision, err := s.isRelayVolumeApplicableOnChain(relayDigest, relay.Meta.RelayChain.Id)
+	if err != nil {
+		return nil, nil, false, fmt.Errorf(""Error checking collision for chain %s: %w"", relay.Meta.RelayChain.Id, err)
+	}
+
+	return signedDigest, relayReqResBytes, collision, nil
+}
+
+// INCOMPLETE: implement this
+func (s *servicer) sign(bz []byte) []byte {
+	return bz
+}
+
+// INCOMPLETE: implement this
+func (s *servicer) isRelayVolumeApplicableOnChain(digest []byte, relayChainId string) (bool, error) {",utility/servicer/module.go,2023-06-13 22:59:55+00:00,2023-06-13T23:36:39Z,I believe this will also require a session,,,,,179,RIGHT,134,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1228788603,Olshansk,a98595f48fc016025fce2373b14d8a3829308d2e,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -11,25 +15,53 @@ import (
 	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
 	""github.com/pokt-network/pocket/shared/modules""
 	mockModules ""github.com/pokt-network/pocket/shared/modules/mocks""
+	typesUtil ""github.com/pokt-network/pocket/utility/types""
 )
 
-var testServicer1 = &coreTypes.Actor{
-	ActorType: coreTypes.ActorType_ACTOR_TYPE_SERVICER,
-	Address:   ""a3d9ea9d9ad9c58bb96ec41340f83cb2cabb6496"",
-	PublicKey: ""a6cd0a304c38d76271f74dd3c90325144425d904ef1b9a6fbab9b201d75a998b"",
-	Chains:    []string{""0021""},
-}
+const (",utility/servicer/module_test.go,2023-06-13 23:03:03+00:00,2023-06-13T23:36:39Z,Can you create a ticket to add extensive E2E tests for this. See e2e/tests/root.feature,,,,23.0,21,RIGHT,24,29.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1228789399,Olshansk,a98595f48fc016025fce2373b14d8a3829308d2e,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -138,19 +235,86 @@ func (s servicer) validateRelayChainSupport(relayChain *coreTypes.Identifiable,
 	return nil
 }
 
-// TODO: implement
 // validateApplication makes sure the application has not received more relays than allocated in the current session.
-func (s servicer) validateApplication(meta *coreTypes.RelayMeta, session *coreTypes.Session) error {
-	/*
-		// if maxRelaysPerSession, overServiced := calculateAppSessionTokens(); overServiced {
-			return fmt.Errorf(""application %s has exceeded its allocated relays %d for the session %d"", meta.ApplicationPublicKey, maxRelaysPerSession)
-		}
-	*/
-	return nil
+func (s *servicer) validateApplication(session *coreTypes.Session) error {
+	// IMPROVE: use a function to get current height from the current session",utility/servicer/module.go,2023-06-13 23:04:40+00:00,2023-06-13T23:36:40Z,"1. Can't we just get it directly from `Session`?
2. If not, we should be able to do `s.GetBus().GetConsensusModule().CurrentHeight()`
3. If neither 1 or 2 work, this is `TECHDEBT`, not `IMPROVE` IMO",,,,,240,RIGHT,192,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1228790454,Olshansk,a98595f48fc016025fce2373b14d8a3829308d2e,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -138,19 +235,86 @@ func (s servicer) validateRelayChainSupport(relayChain *coreTypes.Identifiable,
 	return nil
 }
 
-// TODO: implement
 // validateApplication makes sure the application has not received more relays than allocated in the current session.",utility/servicer/module.go,2023-06-13 23:06:49+00:00,2023-06-13T23:36:40Z,"```suggestion
// validateApplication makes sure the application has not received more relays than allocated in the current session.
// returns nil if the servicer should attempt to mine another relay for the session provided
```",,,,,238,RIGHT,183,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1228791088,Olshansk,a98595f48fc016025fce2373b14d8a3829308d2e,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -138,19 +235,86 @@ func (s servicer) validateRelayChainSupport(relayChain *coreTypes.Identifiable,
 	return nil
 }
 
-// TODO: implement
 // validateApplication makes sure the application has not received more relays than allocated in the current session.
-func (s servicer) validateApplication(meta *coreTypes.RelayMeta, session *coreTypes.Session) error {
-	/*
-		// if maxRelaysPerSession, overServiced := calculateAppSessionTokens(); overServiced {
-			return fmt.Errorf(""application %s has exceeded its allocated relays %d for the session %d"", meta.ApplicationPublicKey, maxRelaysPerSession)
-		}
-	*/
-	return nil
+func (s *servicer) validateApplication(session *coreTypes.Session) error {",utility/servicer/module.go,2023-06-13 23:07:29+00:00,2023-06-13T23:36:40Z,I feel like we shold rename `validateApplication` to `sholdMineRelay`. Optionally returning a boolean or just using a nil error to signify `yes`,,,,,239,RIGHT,191,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1228791338,Olshansk,a98595f48fc016025fce2373b14d8a3829308d2e,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -138,19 +235,86 @@ func (s servicer) validateRelayChainSupport(relayChain *coreTypes.Identifiable,
 	return nil
 }
 
-// TODO: implement
 // validateApplication makes sure the application has not received more relays than allocated in the current session.
-func (s servicer) validateApplication(meta *coreTypes.RelayMeta, session *coreTypes.Session) error {
-	/*
-		// if maxRelaysPerSession, overServiced := calculateAppSessionTokens(); overServiced {
-			return fmt.Errorf(""application %s has exceeded its allocated relays %d for the session %d"", meta.ApplicationPublicKey, maxRelaysPerSession)
-		}
-	*/
-	return nil
+func (s *servicer) validateApplication(session *coreTypes.Session) error {
+	// IMPROVE: use a function to get current height from the current session
+	servicerAppSessionTokens, err := s.calculateServicerAppSessionTokens(session)
+	if err != nil {
+		return fmt.Errorf(""Error calculating servicer tokens for application: %w"", err)
+	}
+
+	localCtx, err := s.GetBus().GetPersistenceModule().NewLocalContext()
+	if err != nil {
+		return fmt.Errorf(""Error getting local persistence context: application %s session number %d: %w"", session.Application.PublicKey, session.SessionNumber, err)
+	}
+
+	usedAppSessionTokens, err := localCtx.GetSessionTokensUsed(session)
+	if err != nil {
+		return fmt.Errorf(""Error getting servicer token usage: application %s session number %d: %w"", session.Application.PublicKey, session.SessionNumber, err)
+	}
+
+	if usedAppSessionTokens == nil || usedAppSessionTokens.Cmp(servicerAppSessionTokens) < 0 {
+		return nil",utility/servicer/module.go,2023-06-13 23:07:59+00:00,2023-06-13T23:36:40Z,"```suggestion
		return nil // should attempt to mine a relay
```",,,,,257,RIGHT,209,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1228791684,Olshansk,a98595f48fc016025fce2373b14d8a3829308d2e,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -11,25 +15,53 @@ import (
 	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
 	""github.com/pokt-network/pocket/shared/modules""
 	mockModules ""github.com/pokt-network/pocket/shared/modules/mocks""
+	typesUtil ""github.com/pokt-network/pocket/utility/types""
 )
 
-var testServicer1 = &coreTypes.Actor{
-	ActorType: coreTypes.ActorType_ACTOR_TYPE_SERVICER,
-	Address:   ""a3d9ea9d9ad9c58bb96ec41340f83cb2cabb6496"",
-	PublicKey: ""a6cd0a304c38d76271f74dd3c90325144425d904ef1b9a6fbab9b201d75a998b"",
-	Chains:    []string{""0021""},
-}
+const (
+	testAppsTokensMultiplier = int(2)
+	testCurrentHeight        = int64(9)
+)
+
+var (
+	testServicer1 = &coreTypes.Actor{
+		ActorType: coreTypes.ActorType_ACTOR_TYPE_SERVICER,
+		Address:   ""a3d9ea9d9ad9c58bb96ec41340f83cb2cabb6496"",
+		PublicKey: ""a6cd0a304c38d76271f74dd3c90325144425d904ef1b9a6fbab9b201d75a998b"",
+		Chains:    []string{""0021""},
+	}
+
+	testApp1 = &coreTypes.Actor{
+		Address:      ""98a792b7aca673620132ef01f50e62caa58eca83"",",utility/servicer/module_test.go,2023-06-13 23:08:41+00:00,2023-06-13T23:36:40Z,Why not specify the actor type here?,,,,,35,RIGHT,38,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1228791776,Olshansk,a98595f48fc016025fce2373b14d8a3829308d2e,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -11,25 +15,53 @@ import (
 	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
 	""github.com/pokt-network/pocket/shared/modules""
 	mockModules ""github.com/pokt-network/pocket/shared/modules/mocks""
+	typesUtil ""github.com/pokt-network/pocket/utility/types""
 )
 
-var testServicer1 = &coreTypes.Actor{
-	ActorType: coreTypes.ActorType_ACTOR_TYPE_SERVICER,
-	Address:   ""a3d9ea9d9ad9c58bb96ec41340f83cb2cabb6496"",
-	PublicKey: ""a6cd0a304c38d76271f74dd3c90325144425d904ef1b9a6fbab9b201d75a998b"",
-	Chains:    []string{""0021""},
-}
+const (
+	testAppsTokensMultiplier = int(2)
+	testCurrentHeight        = int64(9)
+)
+
+var (
+	testServicer1 = &coreTypes.Actor{
+		ActorType: coreTypes.ActorType_ACTOR_TYPE_SERVICER,
+		Address:   ""a3d9ea9d9ad9c58bb96ec41340f83cb2cabb6496"",
+		PublicKey: ""a6cd0a304c38d76271f74dd3c90325144425d904ef1b9a6fbab9b201d75a998b"",
+		Chains:    []string{""0021""},",utility/servicer/module_test.go,2023-06-13 23:08:50+00:00,2023-06-13T23:36:40Z,Let's specify the staked amount here ,,,,,31,RIGHT,34,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1228792025,Olshansk,a98595f48fc016025fce2373b14d8a3829308d2e,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -11,25 +15,53 @@ import (
 	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
 	""github.com/pokt-network/pocket/shared/modules""
 	mockModules ""github.com/pokt-network/pocket/shared/modules/mocks""
+	typesUtil ""github.com/pokt-network/pocket/utility/types""
 )
 
-var testServicer1 = &coreTypes.Actor{
-	ActorType: coreTypes.ActorType_ACTOR_TYPE_SERVICER,
-	Address:   ""a3d9ea9d9ad9c58bb96ec41340f83cb2cabb6496"",
-	PublicKey: ""a6cd0a304c38d76271f74dd3c90325144425d904ef1b9a6fbab9b201d75a998b"",
-	Chains:    []string{""0021""},
-}
+const (
+	testAppsTokensMultiplier = int(2)
+	testCurrentHeight        = int64(9)
+)
+
+var (
+	testServicer1 = &coreTypes.Actor{
+		ActorType: coreTypes.ActorType_ACTOR_TYPE_SERVICER,
+		Address:   ""a3d9ea9d9ad9c58bb96ec41340f83cb2cabb6496"",
+		PublicKey: ""a6cd0a304c38d76271f74dd3c90325144425d904ef1b9a6fbab9b201d75a998b"",
+		Chains:    []string{""0021""},",utility/servicer/module_test.go,2023-06-13 23:09:17+00:00,2023-06-13T23:36:40Z,"```suggestion
		Chains:    []string{""POKT-UnitTestNet""},
```",,,,,31,RIGHT,34,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1228792764,Olshansk,a98595f48fc016025fce2373b14d8a3829308d2e,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -11,25 +15,53 @@ import (
 	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
 	""github.com/pokt-network/pocket/shared/modules""
 	mockModules ""github.com/pokt-network/pocket/shared/modules/mocks""
+	typesUtil ""github.com/pokt-network/pocket/utility/types""
 )
 
-var testServicer1 = &coreTypes.Actor{
-	ActorType: coreTypes.ActorType_ACTOR_TYPE_SERVICER,
-	Address:   ""a3d9ea9d9ad9c58bb96ec41340f83cb2cabb6496"",
-	PublicKey: ""a6cd0a304c38d76271f74dd3c90325144425d904ef1b9a6fbab9b201d75a998b"",
-	Chains:    []string{""0021""},
-}
+const (
+	testAppsTokensMultiplier = int(2)
+	testCurrentHeight        = int64(9)
+)
+
+var (
+	testServicer1 = &coreTypes.Actor{
+		ActorType: coreTypes.ActorType_ACTOR_TYPE_SERVICER,
+		Address:   ""a3d9ea9d9ad9c58bb96ec41340f83cb2cabb6496"",
+		PublicKey: ""a6cd0a304c38d76271f74dd3c90325144425d904ef1b9a6fbab9b201d75a998b"",",utility/servicer/module_test.go,2023-06-13 23:10:47+00:00,2023-06-13T23:36:40Z,"How did you generate these?

We have utilities to generate keys that are guaranteed to be compatible.

```go
	operatorKey, err := crypto.GeneratePublicKey()
	if err != nil {
		return nil, err
	}

	outputAddr, err := crypto.GenerateAddress()
	if err != nil {
		return nil, err
	}
```	",,,,,30,RIGHT,33,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1228793199,Olshansk,a98595f48fc016025fce2373b14d8a3829308d2e,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -11,25 +15,53 @@ import (
 	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
 	""github.com/pokt-network/pocket/shared/modules""
 	mockModules ""github.com/pokt-network/pocket/shared/modules/mocks""
+	typesUtil ""github.com/pokt-network/pocket/utility/types""
 )
 
-var testServicer1 = &coreTypes.Actor{
-	ActorType: coreTypes.ActorType_ACTOR_TYPE_SERVICER,
-	Address:   ""a3d9ea9d9ad9c58bb96ec41340f83cb2cabb6496"",
-	PublicKey: ""a6cd0a304c38d76271f74dd3c90325144425d904ef1b9a6fbab9b201d75a998b"",
-	Chains:    []string{""0021""},
-}
+const (
+	testAppsTokensMultiplier = int(2)
+	testCurrentHeight        = int64(9)
+)
+
+var (
+	testServicer1 = &coreTypes.Actor{
+		ActorType: coreTypes.ActorType_ACTOR_TYPE_SERVICER,
+		Address:   ""a3d9ea9d9ad9c58bb96ec41340f83cb2cabb6496"",
+		PublicKey: ""a6cd0a304c38d76271f74dd3c90325144425d904ef1b9a6fbab9b201d75a998b"",
+		Chains:    []string{""0021""},
+	}
+
+	testApp1 = &coreTypes.Actor{
+		Address:      ""98a792b7aca673620132ef01f50e62caa58eca83"",
+		PublicKey:    ""b5cd0a304c38d76271f74dd3c90325144425d904ef1b9a6fbab9b201d86b009c"",
+		StakedAmount: ""1000"",
+	}
+
+	testServiceConfig1 = &configs.ServiceConfig{
+		Url:         ""http://chain-url.pokt.network"",
+		TimeoutMsec: 1234,
+		BasicAuth: &configs.BasicAuth{
+			UserName: ""user1"",
+			Password: ""password1"",
+		},
+	}
+)
 
 func TestAdmitRelay(t *testing.T) {",utility/servicer/module_test.go,2023-06-13 23:11:49+00:00,2023-06-13T23:36:40Z,"```suggestion
func TestRelay_Admit(t *testing.T) {
```",,,,,50,RIGHT,53,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1228793724,Olshansk,a98595f48fc016025fce2373b14d8a3829308d2e,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -43,63 +75,151 @@ func TestAdmitRelay(t *testing.T) {
 		},
 		{
 			name:     ""Relay for unsupported chain is rejected"",
-			relay:    testRelay(""foo"", 8),
+			relay:    testRelay(testRelayChain(""foo"")),
 			expected: errValidateRelayMeta,
 		},
 		{
 			name:     ""Relay with height set in a past session is rejected"",
-			relay:    testRelay(""0021"", 5),
+			relay:    testRelay(testRelayHeight(5)),
 			expected: errValidateBlockHeight,
 		},
 		{
 			name:     ""Relay with height set in a future session is rejected"",
-			relay:    testRelay(""0021"", 9999),
+			relay:    testRelay(testRelayHeight(9999)),
 			expected: errValidateBlockHeight,
 		},
+		{
+			name:     ""Relay not matching the servicer in this session is rejected"",
+			relay:    testRelay(testRelayServicer(""bar"")),
+			expected: errValidateServicer,
+		},
+		{
+			name:              ""Relay for app out of quota is rejected"",
+			relay:             testRelay(),
+			usedSessionTokens: 999999,
+			expected:          errValidateApplication,
+		},
 	}
 
 	for _, testCase := range testCases {
 		t.Run(testCase.name, func(t *testing.T) {
 			config := testServicerConfig()
 			session := testSession(
-				sessionNumber(2),
+				sessionNumber(currentSessionNumber),
 				sessionBlocks(4),
-				sessionHeight(2),
+				sessionHeight(testSessionStartingHeight),
 				sessionServicers(testServicer1),
 			)
-			mockBus := mockBus(t, &config, currentHeight, session)
+			mockBus := mockBus(t, &config, uint64(testCurrentHeight), session, testCase.usedSessionTokens)
 
 			servicerMod, err := CreateServicer(mockBus)
 			require.NoError(t, err)
 
-			err = servicerMod.(*servicer).admitRelay(testCase.relay)
+			servicer, ok := servicerMod.(*servicer)
+			require.True(t, ok)
+
+			err = servicer.admitRelay(testCase.relay)
 			if !errors.Is(err, testCase.expected) {
 				t.Fatalf(""Expected error %v got: %v"", testCase.expected, err)
 			}
 		})
 	}
 }
 
-func testRelay(chain string, height int64) *coreTypes.Relay {
-	return &coreTypes.Relay{
+func TestExecuteRelay(t *testing.T) {",utility/servicer/module_test.go,2023-06-13 23:13:00+00:00,2023-06-13T23:36:40Z,"```suggestion
func TestRelay_Execute(t *testing.T) {
```",,,,,129,RIGHT,140,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1228794129,Olshansk,a98595f48fc016025fce2373b14d8a3829308d2e,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -43,63 +75,151 @@ func TestAdmitRelay(t *testing.T) {
 		},
 		{
 			name:     ""Relay for unsupported chain is rejected"",
-			relay:    testRelay(""foo"", 8),
+			relay:    testRelay(testRelayChain(""foo"")),
 			expected: errValidateRelayMeta,
 		},
 		{
 			name:     ""Relay with height set in a past session is rejected"",
-			relay:    testRelay(""0021"", 5),
+			relay:    testRelay(testRelayHeight(5)),
 			expected: errValidateBlockHeight,
 		},
 		{
 			name:     ""Relay with height set in a future session is rejected"",
-			relay:    testRelay(""0021"", 9999),
+			relay:    testRelay(testRelayHeight(9999)),
 			expected: errValidateBlockHeight,
 		},
+		{
+			name:     ""Relay not matching the servicer in this session is rejected"",
+			relay:    testRelay(testRelayServicer(""bar"")),
+			expected: errValidateServicer,
+		},
+		{
+			name:              ""Relay for app out of quota is rejected"",
+			relay:             testRelay(),
+			usedSessionTokens: 999999,
+			expected:          errValidateApplication,
+		},
 	}
 
 	for _, testCase := range testCases {
 		t.Run(testCase.name, func(t *testing.T) {
 			config := testServicerConfig()
 			session := testSession(
-				sessionNumber(2),
+				sessionNumber(currentSessionNumber),
 				sessionBlocks(4),
-				sessionHeight(2),
+				sessionHeight(testSessionStartingHeight),
 				sessionServicers(testServicer1),
 			)
-			mockBus := mockBus(t, &config, currentHeight, session)
+			mockBus := mockBus(t, &config, uint64(testCurrentHeight), session, testCase.usedSessionTokens)
 
 			servicerMod, err := CreateServicer(mockBus)
 			require.NoError(t, err)
 
-			err = servicerMod.(*servicer).admitRelay(testCase.relay)
+			servicer, ok := servicerMod.(*servicer)
+			require.True(t, ok)
+
+			err = servicer.admitRelay(testCase.relay)
 			if !errors.Is(err, testCase.expected) {
 				t.Fatalf(""Expected error %v got: %v"", testCase.expected, err)
 			}
 		})
 	}
 }
 ",utility/servicer/module_test.go,2023-06-13 23:13:54+00:00,2023-06-13T23:36:40Z,"Can you add a target in the `Makefile` similar to this: https://github.com/pokt-network/pocket/blob/main/Makefile#L370

.PHONY: test_servicer_relay
test_servicer_relay: ## Run all go unit tests related to servicer relays
	go test ${VERBOSE_TEST} -count=1 -tags=test ./utility/servicer -run TestRelay",,,,158.0,128,RIGHT,137,175.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1228794585,Olshansk,a98595f48fc016025fce2373b14d8a3829308d2e,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -138,19 +235,86 @@ func (s servicer) validateRelayChainSupport(relayChain *coreTypes.Identifiable,
 	return nil
 }
 
-// TODO: implement
 // validateApplication makes sure the application has not received more relays than allocated in the current session.
-func (s servicer) validateApplication(meta *coreTypes.RelayMeta, session *coreTypes.Session) error {
-	/*
-		// if maxRelaysPerSession, overServiced := calculateAppSessionTokens(); overServiced {
-			return fmt.Errorf(""application %s has exceeded its allocated relays %d for the session %d"", meta.ApplicationPublicKey, maxRelaysPerSession)
-		}
-	*/
-	return nil
+func (s *servicer) validateApplication(session *coreTypes.Session) error {
+	// IMPROVE: use a function to get current height from the current session
+	servicerAppSessionTokens, err := s.calculateServicerAppSessionTokens(session)
+	if err != nil {
+		return fmt.Errorf(""Error calculating servicer tokens for application: %w"", err)
+	}
+
+	localCtx, err := s.GetBus().GetPersistenceModule().NewLocalContext()
+	if err != nil {
+		return fmt.Errorf(""Error getting local persistence context: application %s session number %d: %w"", session.Application.PublicKey, session.SessionNumber, err)
+	}
+
+	usedAppSessionTokens, err := localCtx.GetSessionTokensUsed(session)
+	if err != nil {
+		return fmt.Errorf(""Error getting servicer token usage: application %s session number %d: %w"", session.Application.PublicKey, session.SessionNumber, err)
+	}
+
+	if usedAppSessionTokens == nil || usedAppSessionTokens.Cmp(servicerAppSessionTokens) < 0 {
+		return nil
+	}
+
+	return fmt.Errorf(""application %s has exceeded its allocated relays %s for session %d"",
+		session.Application.PublicKey,
+		servicerAppSessionTokens,
+		session.SessionNumber)
+}
+
+func (s *servicer) cachedAppTokens(session *coreTypes.Session) *sessionTokens {",utility/servicer/module.go,2023-06-13 23:14:55+00:00,2023-06-13T23:36:40Z,Please add comment,,,,276.0,266,RIGHT,218,238.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1228795330,Olshansk,a98595f48fc016025fce2373b14d8a3829308d2e,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -138,19 +235,86 @@ func (s servicer) validateRelayChainSupport(relayChain *coreTypes.Identifiable,
 	return nil
 }
 
-// TODO: implement
 // validateApplication makes sure the application has not received more relays than allocated in the current session.
-func (s servicer) validateApplication(meta *coreTypes.RelayMeta, session *coreTypes.Session) error {
-	/*
-		// if maxRelaysPerSession, overServiced := calculateAppSessionTokens(); overServiced {
-			return fmt.Errorf(""application %s has exceeded its allocated relays %d for the session %d"", meta.ApplicationPublicKey, maxRelaysPerSession)
-		}
-	*/
-	return nil
+func (s *servicer) validateApplication(session *coreTypes.Session) error {
+	// IMPROVE: use a function to get current height from the current session
+	servicerAppSessionTokens, err := s.calculateServicerAppSessionTokens(session)
+	if err != nil {
+		return fmt.Errorf(""Error calculating servicer tokens for application: %w"", err)
+	}
+
+	localCtx, err := s.GetBus().GetPersistenceModule().NewLocalContext()
+	if err != nil {
+		return fmt.Errorf(""Error getting local persistence context: application %s session number %d: %w"", session.Application.PublicKey, session.SessionNumber, err)
+	}
+
+	usedAppSessionTokens, err := localCtx.GetSessionTokensUsed(session)
+	if err != nil {
+		return fmt.Errorf(""Error getting servicer token usage: application %s session number %d: %w"", session.Application.PublicKey, session.SessionNumber, err)
+	}
+
+	if usedAppSessionTokens == nil || usedAppSessionTokens.Cmp(servicerAppSessionTokens) < 0 {
+		return nil
+	}
+
+	return fmt.Errorf(""application %s has exceeded its allocated relays %s for session %d"",
+		session.Application.PublicKey,
+		servicerAppSessionTokens,
+		session.SessionNumber)
+}
+
+func (s *servicer) cachedAppTokens(session *coreTypes.Session) *sessionTokens {
+	s.rwlock.RLock()
+	defer s.rwlock.RUnlock()
+
+	return s.totalTokens[session.Application.PublicKey]
+}
+
+// calculateServicerAppSessionTokens return the number of tokens the servicer has remaining for the Application in the session provided.
+//
+//	If nothing is cached, the maximum number of session tokens is computed.
+func (s *servicer) calculateServicerAppSessionTokens(session *coreTypes.Session) (*big.Int, error) {
+	tokens := s.cachedAppTokens(session)
+	if tokens != nil && tokens.originalCountAvailable != nil && tokens.sessionNumber == session.SessionNumber {
+		return big.NewInt(1).Set(tokens.originalCountAvailable), nil",utility/servicer/module.go,2023-06-13 23:16:35+00:00,2023-06-13T23:36:40Z,"This returns the original count available but the comment says ""number of tokens remaining"".

Either the comment or business logic is off. Might also be worth updating the function name to what this is intended to do.",,,,,279,RIGHT,231,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1228796039,Olshansk,a98595f48fc016025fce2373b14d8a3829308d2e,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -138,19 +235,86 @@ func (s servicer) validateRelayChainSupport(relayChain *coreTypes.Identifiable,
 	return nil
 }
 
-// TODO: implement
 // validateApplication makes sure the application has not received more relays than allocated in the current session.
-func (s servicer) validateApplication(meta *coreTypes.RelayMeta, session *coreTypes.Session) error {
-	/*
-		// if maxRelaysPerSession, overServiced := calculateAppSessionTokens(); overServiced {
-			return fmt.Errorf(""application %s has exceeded its allocated relays %d for the session %d"", meta.ApplicationPublicKey, maxRelaysPerSession)
-		}
-	*/
-	return nil
+func (s *servicer) validateApplication(session *coreTypes.Session) error {
+	// IMPROVE: use a function to get current height from the current session
+	servicerAppSessionTokens, err := s.calculateServicerAppSessionTokens(session)
+	if err != nil {
+		return fmt.Errorf(""Error calculating servicer tokens for application: %w"", err)
+	}
+
+	localCtx, err := s.GetBus().GetPersistenceModule().NewLocalContext()
+	if err != nil {
+		return fmt.Errorf(""Error getting local persistence context: application %s session number %d: %w"", session.Application.PublicKey, session.SessionNumber, err)
+	}
+
+	usedAppSessionTokens, err := localCtx.GetSessionTokensUsed(session)
+	if err != nil {
+		return fmt.Errorf(""Error getting servicer token usage: application %s session number %d: %w"", session.Application.PublicKey, session.SessionNumber, err)
+	}
+
+	if usedAppSessionTokens == nil || usedAppSessionTokens.Cmp(servicerAppSessionTokens) < 0 {
+		return nil
+	}
+
+	return fmt.Errorf(""application %s has exceeded its allocated relays %s for session %d"",
+		session.Application.PublicKey,
+		servicerAppSessionTokens,
+		session.SessionNumber)
+}
+
+func (s *servicer) cachedAppTokens(session *coreTypes.Session) *sessionTokens {
+	s.rwlock.RLock()
+	defer s.rwlock.RUnlock()
+
+	return s.totalTokens[session.Application.PublicKey]
+}
+
+// calculateServicerAppSessionTokens return the number of tokens the servicer has remaining for the Application in the session provided.
+//
+//	If nothing is cached, the maximum number of session tokens is computed.
+func (s *servicer) calculateServicerAppSessionTokens(session *coreTypes.Session) (*big.Int, error) {
+	tokens := s.cachedAppTokens(session)
+	if tokens != nil && tokens.originalCountAvailable != nil && tokens.sessionNumber == session.SessionNumber {
+		return big.NewInt(1).Set(tokens.originalCountAvailable), nil
+	}
+
+	// Calculate this servicer's limit for the application in the current session.
+	//	This is distributed rate limiting (DRL): no need to know how many requests have
+	//		been performed for this application by other servicers. Instead, simply enforce
+	//		this servicer's share of the application's tokens for this session.
+	appSessionTokens, err := s.calculateAppSessionTokens(session)
+	if err != nil {
+		return nil, fmt.Errorf(""Error calculating application %s total tokens for session %d: %w"", session.Application.PublicKey, session.SessionNumber, err)
+	}
+
+	// type conversion from big.Int to big.Float
+	appTokens := big.NewFloat(1).SetInt(appSessionTokens)
+	servicerTokens := appTokens.Quo(appTokens, big.NewFloat(float64(len(session.Servicers))))
+
+	// This multiplication is performed to minimize the chance of under-utilization of application's tokens,
+	//	while removing the overhead of communication between servicers which would be necessary otherwise.
+	// see https://arxiv.org/abs/2305.10672 for details on application and servicer distributed rate-limiting
+	adjustedTokens := servicerTokens.Mul(servicerTokens, big.NewFloat(1+s.config.RelayMiningVolumeAccuracy))
+	roundedTokens, _ := adjustedTokens.Int(big.NewInt(1))
+
+	s.setAppSessionTokens(session, &sessionTokens{session.SessionNumber, roundedTokens})",utility/servicer/module.go,2023-06-13 23:18:00+00:00,2023-06-13T23:36:40Z,❤️  this!,,,,312.0,301,RIGHT,253,274.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1228796786,Olshansk,a98595f48fc016025fce2373b14d8a3829308d2e,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -138,19 +235,86 @@ func (s servicer) validateRelayChainSupport(relayChain *coreTypes.Identifiable,
 	return nil
 }
 
-// TODO: implement
 // validateApplication makes sure the application has not received more relays than allocated in the current session.
-func (s servicer) validateApplication(meta *coreTypes.RelayMeta, session *coreTypes.Session) error {
-	/*
-		// if maxRelaysPerSession, overServiced := calculateAppSessionTokens(); overServiced {
-			return fmt.Errorf(""application %s has exceeded its allocated relays %d for the session %d"", meta.ApplicationPublicKey, maxRelaysPerSession)
-		}
-	*/
-	return nil
+func (s *servicer) validateApplication(session *coreTypes.Session) error {
+	// IMPROVE: use a function to get current height from the current session
+	servicerAppSessionTokens, err := s.calculateServicerAppSessionTokens(session)
+	if err != nil {
+		return fmt.Errorf(""Error calculating servicer tokens for application: %w"", err)
+	}
+
+	localCtx, err := s.GetBus().GetPersistenceModule().NewLocalContext()
+	if err != nil {
+		return fmt.Errorf(""Error getting local persistence context: application %s session number %d: %w"", session.Application.PublicKey, session.SessionNumber, err)
+	}
+
+	usedAppSessionTokens, err := localCtx.GetSessionTokensUsed(session)
+	if err != nil {
+		return fmt.Errorf(""Error getting servicer token usage: application %s session number %d: %w"", session.Application.PublicKey, session.SessionNumber, err)
+	}
+
+	if usedAppSessionTokens == nil || usedAppSessionTokens.Cmp(servicerAppSessionTokens) < 0 {
+		return nil
+	}
+
+	return fmt.Errorf(""application %s has exceeded its allocated relays %s for session %d"",
+		session.Application.PublicKey,
+		servicerAppSessionTokens,
+		session.SessionNumber)
+}
+
+func (s *servicer) cachedAppTokens(session *coreTypes.Session) *sessionTokens {
+	s.rwlock.RLock()
+	defer s.rwlock.RUnlock()
+
+	return s.totalTokens[session.Application.PublicKey]
+}
+
+// calculateServicerAppSessionTokens return the number of tokens the servicer has remaining for the Application in the session provided.
+//
+//	If nothing is cached, the maximum number of session tokens is computed.
+func (s *servicer) calculateServicerAppSessionTokens(session *coreTypes.Session) (*big.Int, error) {
+	tokens := s.cachedAppTokens(session)
+	if tokens != nil && tokens.originalCountAvailable != nil && tokens.sessionNumber == session.SessionNumber {
+		return big.NewInt(1).Set(tokens.originalCountAvailable), nil
+	}
+
+	// Calculate this servicer's limit for the application in the current session.
+	//	This is distributed rate limiting (DRL): no need to know how many requests have
+	//		been performed for this application by other servicers. Instead, simply enforce
+	//		this servicer's share of the application's tokens for this session.
+	appSessionTokens, err := s.calculateAppSessionTokens(session)
+	if err != nil {
+		return nil, fmt.Errorf(""Error calculating application %s total tokens for session %d: %w"", session.Application.PublicKey, session.SessionNumber, err)
+	}
+
+	// type conversion from big.Int to big.Float
+	appTokens := big.NewFloat(1).SetInt(appSessionTokens)
+	servicerTokens := appTokens.Quo(appTokens, big.NewFloat(float64(len(session.Servicers))))
+
+	// This multiplication is performed to minimize the chance of under-utilization of application's tokens,
+	//	while removing the overhead of communication between servicers which would be necessary otherwise.
+	// see https://arxiv.org/abs/2305.10672 for details on application and servicer distributed rate-limiting
+	adjustedTokens := servicerTokens.Mul(servicerTokens, big.NewFloat(1+s.config.RelayMiningVolumeAccuracy))
+	roundedTokens, _ := adjustedTokens.Int(big.NewInt(1))
+
+	s.setAppSessionTokens(session, &sessionTokens{session.SessionNumber, roundedTokens})
+	return roundedTokens, nil
+}
+
+func (s *servicer) setAppSessionTokens(session *coreTypes.Session, tokens *sessionTokens) {
+	s.rwlock.Lock()
+	defer s.rwlock.Unlock()
+
+	if len(s.totalTokens) == 0 {
+		s.totalTokens = make(map[string]*sessionTokens)",utility/servicer/module.go,2023-06-13 23:19:08+00:00,2023-06-13T23:36:40Z, not do this in `Create` and skip the if altogether?,,,,,310,RIGHT,262,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1228797570,Olshansk,a98595f48fc016025fce2373b14d8a3829308d2e,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -182,31 +356,107 @@ func (s servicer) admitRelay(relay *coreTypes.Relay) error {
 
 	height := s.GetBus().GetConsensusModule().CurrentHeight()
 	if err := s.validateRelayMeta(relay.Meta, int64(height)); err != nil {
-		return fmt.Errorf(""%w: %s"", errValidateRelayMeta, err.Error())
+		return fmt.Errorf(""%s: %w"", err.Error(), errValidateRelayMeta)
 	}
 
 	// TODO: update the CLI to include ApplicationAddress(or Application Public Key) in the RelayMeta",utility/servicer/module.go,2023-06-13 23:20:36+00:00,2023-06-13T23:36:40Z,"Seems like this TODO is no longer relevant? If not, remove.",,,,,362,RIGHT,307,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1228797686,Olshansk,a98595f48fc016025fce2373b14d8a3829308d2e,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -182,31 +356,107 @@ func (s servicer) admitRelay(relay *coreTypes.Relay) error {
 
 	height := s.GetBus().GetConsensusModule().CurrentHeight()
 	if err := s.validateRelayMeta(relay.Meta, int64(height)); err != nil {
-		return fmt.Errorf(""%w: %s"", errValidateRelayMeta, err.Error())
+		return fmt.Errorf(""%s: %w"", err.Error(), errValidateRelayMeta)
 	}
 
 	// TODO: update the CLI to include ApplicationAddress(or Application Public Key) in the RelayMeta
-	session, err := s.GetBus().GetUtilityModule().GetSession(relay.Meta.ApplicationAddress, int64(height), relay.Meta.RelayChain.Id, relay.Meta.GeoZone.Id)
+	session, err := s.getSession(relay)
 	if err != nil {
-		return fmt.Errorf(""%s: failed to get a session for height %d for relay meta %s: %w"", errPrefix, height, relay.Meta, err)
+		return err
 	}
 
 	// TODO: (REFACTOR) use a loop to run all validators: would also remove the need for passing the session around",utility/servicer/module.go,2023-06-13 23:20:48+00:00,2023-06-13T23:36:40Z,"Seems like this TODO is no longer relevant? If not, remove.",,,,,368,RIGHT,315,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1228797884,Olshansk,a98595f48fc016025fce2373b14d8a3829308d2e,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -182,31 +356,107 @@ func (s servicer) admitRelay(relay *coreTypes.Relay) error {
 
 	height := s.GetBus().GetConsensusModule().CurrentHeight()
 	if err := s.validateRelayMeta(relay.Meta, int64(height)); err != nil {
-		return fmt.Errorf(""%w: %s"", errValidateRelayMeta, err.Error())
+		return fmt.Errorf(""%s: %w"", err.Error(), errValidateRelayMeta)
 	}
 
 	// TODO: update the CLI to include ApplicationAddress(or Application Public Key) in the RelayMeta
-	session, err := s.GetBus().GetUtilityModule().GetSession(relay.Meta.ApplicationAddress, int64(height), relay.Meta.RelayChain.Id, relay.Meta.GeoZone.Id)
+	session, err := s.getSession(relay)
 	if err != nil {
-		return fmt.Errorf(""%s: failed to get a session for height %d for relay meta %s: %w"", errPrefix, height, relay.Meta, err)
+		return err
 	}
 
 	// TODO: (REFACTOR) use a loop to run all validators: would also remove the need for passing the session around
 	if err := validateRelayBlockHeight(relay.Meta, session); err != nil {
-		return fmt.Errorf(""%w: %s"", errValidateBlockHeight, err.Error())
+		return fmt.Errorf(""%s: %w"", err.Error(), errValidateBlockHeight)
 	}
 
-	if err := s.validateApplication(relay.Meta, session); err != nil {
-		return fmt.Errorf(""%s: relay failed application validation: %w"", errPrefix, err)
+	if err := s.validateServicer(relay.Meta, session); err != nil {
+		return fmt.Errorf(""%s: %s: %w"", errPrefix, err.Error(), errValidateServicer)
 	}
 
-	if err := s.validateServicer(relay.Meta, session); err != nil {
-		return fmt.Errorf(""%s: relay failed servicer instance validation: %w"", errPrefix, err)
+	if err := s.validateApplication(session); err != nil {
+		return fmt.Errorf(""%s: %s: %w"", errPrefix, err.Error(), errValidateApplication)
 	}
 
 	return nil
 }
 
+// DISCUSS: do we need to export this functionality as part of the utility module?",utility/servicer/module.go,2023-06-13 23:21:13+00:00,2023-06-13T23:36:40Z,"I think we can remove this `DISCUSS` item unless you see a reason for it. 

My answer is no.",,,,,384,RIGHT,336,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1228798776,Olshansk,a98595f48fc016025fce2373b14d8a3829308d2e,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -182,31 +356,107 @@ func (s servicer) admitRelay(relay *coreTypes.Relay) error {
 
 	height := s.GetBus().GetConsensusModule().CurrentHeight()
 	if err := s.validateRelayMeta(relay.Meta, int64(height)); err != nil {
-		return fmt.Errorf(""%w: %s"", errValidateRelayMeta, err.Error())
+		return fmt.Errorf(""%s: %w"", err.Error(), errValidateRelayMeta)
 	}
 
 	// TODO: update the CLI to include ApplicationAddress(or Application Public Key) in the RelayMeta
-	session, err := s.GetBus().GetUtilityModule().GetSession(relay.Meta.ApplicationAddress, int64(height), relay.Meta.RelayChain.Id, relay.Meta.GeoZone.Id)
+	session, err := s.getSession(relay)
 	if err != nil {
-		return fmt.Errorf(""%s: failed to get a session for height %d for relay meta %s: %w"", errPrefix, height, relay.Meta, err)
+		return err
 	}
 
 	// TODO: (REFACTOR) use a loop to run all validators: would also remove the need for passing the session around
 	if err := validateRelayBlockHeight(relay.Meta, session); err != nil {
-		return fmt.Errorf(""%w: %s"", errValidateBlockHeight, err.Error())
+		return fmt.Errorf(""%s: %w"", err.Error(), errValidateBlockHeight)
 	}
 
-	if err := s.validateApplication(relay.Meta, session); err != nil {
-		return fmt.Errorf(""%s: relay failed application validation: %w"", errPrefix, err)
+	if err := s.validateServicer(relay.Meta, session); err != nil {
+		return fmt.Errorf(""%s: %s: %w"", errPrefix, err.Error(), errValidateServicer)
 	}
 
-	if err := s.validateServicer(relay.Meta, session); err != nil {
-		return fmt.Errorf(""%s: relay failed servicer instance validation: %w"", errPrefix, err)
+	if err := s.validateApplication(session); err != nil {
+		return fmt.Errorf(""%s: %s: %w"", errPrefix, err.Error(), errValidateApplication)
 	}
 
 	return nil
 }
 
+// DISCUSS: do we need to export this functionality as part of the utility module?
+// calculateAppSessionTokens determines the number of ""session tokens"" an application gets at the beginning
+// of every session. Each servicer will serve a maximum of ~(Session Tokens / Number of Servicers in the Session) relays for the application
+func (s *servicer) calculateAppSessionTokens(session *coreTypes.Session) (*big.Int, error) {
+	appStake, err := utils.StringToBigInt(session.Application.StakedAmount)
+	if err != nil {
+		return nil, fmt.Errorf(""Error processing application's staked amount %s: %w"", session.Application.StakedAmount, coreTypes.ErrStringToBigInt(err))
+	}
+
+	// DOCUMENT: find the right document to explain the following:",utility/servicer/module.go,2023-06-13 23:22:52+00:00,2023-06-13T23:36:40Z,"```suggestion
	// TODO(M5): find the right document to explain the following:
```",,,,,393,RIGHT,345,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1228799450,Olshansk,a98595f48fc016025fce2373b14d8a3829308d2e,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -182,31 +356,107 @@ func (s servicer) admitRelay(relay *coreTypes.Relay) error {
 
 	height := s.GetBus().GetConsensusModule().CurrentHeight()
 	if err := s.validateRelayMeta(relay.Meta, int64(height)); err != nil {
-		return fmt.Errorf(""%w: %s"", errValidateRelayMeta, err.Error())
+		return fmt.Errorf(""%s: %w"", err.Error(), errValidateRelayMeta)
 	}
 
 	// TODO: update the CLI to include ApplicationAddress(or Application Public Key) in the RelayMeta
-	session, err := s.GetBus().GetUtilityModule().GetSession(relay.Meta.ApplicationAddress, int64(height), relay.Meta.RelayChain.Id, relay.Meta.GeoZone.Id)
+	session, err := s.getSession(relay)
 	if err != nil {
-		return fmt.Errorf(""%s: failed to get a session for height %d for relay meta %s: %w"", errPrefix, height, relay.Meta, err)
+		return err
 	}
 
 	// TODO: (REFACTOR) use a loop to run all validators: would also remove the need for passing the session around
 	if err := validateRelayBlockHeight(relay.Meta, session); err != nil {
-		return fmt.Errorf(""%w: %s"", errValidateBlockHeight, err.Error())
+		return fmt.Errorf(""%s: %w"", err.Error(), errValidateBlockHeight)
 	}
 
-	if err := s.validateApplication(relay.Meta, session); err != nil {
-		return fmt.Errorf(""%s: relay failed application validation: %w"", errPrefix, err)
+	if err := s.validateServicer(relay.Meta, session); err != nil {
+		return fmt.Errorf(""%s: %s: %w"", errPrefix, err.Error(), errValidateServicer)
 	}
 
-	if err := s.validateServicer(relay.Meta, session); err != nil {
-		return fmt.Errorf(""%s: relay failed servicer instance validation: %w"", errPrefix, err)
+	if err := s.validateApplication(session); err != nil {
+		return fmt.Errorf(""%s: %s: %w"", errPrefix, err.Error(), errValidateApplication)
 	}
 
 	return nil
 }
 
+// DISCUSS: do we need to export this functionality as part of the utility module?
+// calculateAppSessionTokens determines the number of ""session tokens"" an application gets at the beginning
+// of every session. Each servicer will serve a maximum of ~(Session Tokens / Number of Servicers in the Session) relays for the application
+func (s *servicer) calculateAppSessionTokens(session *coreTypes.Session) (*big.Int, error) {
+	appStake, err := utils.StringToBigInt(session.Application.StakedAmount)
+	if err != nil {
+		return nil, fmt.Errorf(""Error processing application's staked amount %s: %w"", session.Application.StakedAmount, coreTypes.ErrStringToBigInt(err))
+	}
+
+	// DOCUMENT: find the right document to explain the following:
+	//	We assume that the value of certain parameters only changes/takes effect at the start of a session.
+	//	In this specific case, the `AppSessionTokensMultiplierParamName` parameter is retrieved for the height that
+	//		matches the beginning of the session.
+	readCtx, err := s.GetBus().GetPersistenceModule().NewReadContext(session.SessionHeight)
+	if err != nil {
+		return nil, fmt.Errorf(""error getting persistence context at height %d: %w"", session.SessionHeight, err)
+	}
+	defer readCtx.Release() //nolint:errcheck // We only need to make sure the readCtx is released
+
+	// DISCUSS: using an interface for returning each defined parameter seems less error-prone: also could return e.g. int64 in this case to remove the type cast",utility/servicer/module.go,2023-06-13 23:23:42+00:00,2023-06-13T23:36:40Z,Have you looked at the `GetParameter` function?,,,,,403,RIGHT,355,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1228799963,Olshansk,a98595f48fc016025fce2373b14d8a3829308d2e,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -182,31 +356,107 @@ func (s servicer) admitRelay(relay *coreTypes.Relay) error {
 
 	height := s.GetBus().GetConsensusModule().CurrentHeight()
 	if err := s.validateRelayMeta(relay.Meta, int64(height)); err != nil {
-		return fmt.Errorf(""%w: %s"", errValidateRelayMeta, err.Error())
+		return fmt.Errorf(""%s: %w"", err.Error(), errValidateRelayMeta)
 	}
 
 	// TODO: update the CLI to include ApplicationAddress(or Application Public Key) in the RelayMeta
-	session, err := s.GetBus().GetUtilityModule().GetSession(relay.Meta.ApplicationAddress, int64(height), relay.Meta.RelayChain.Id, relay.Meta.GeoZone.Id)
+	session, err := s.getSession(relay)
 	if err != nil {
-		return fmt.Errorf(""%s: failed to get a session for height %d for relay meta %s: %w"", errPrefix, height, relay.Meta, err)
+		return err
 	}
 
 	// TODO: (REFACTOR) use a loop to run all validators: would also remove the need for passing the session around
 	if err := validateRelayBlockHeight(relay.Meta, session); err != nil {
-		return fmt.Errorf(""%w: %s"", errValidateBlockHeight, err.Error())
+		return fmt.Errorf(""%s: %w"", err.Error(), errValidateBlockHeight)
 	}
 
-	if err := s.validateApplication(relay.Meta, session); err != nil {
-		return fmt.Errorf(""%s: relay failed application validation: %w"", errPrefix, err)
+	if err := s.validateServicer(relay.Meta, session); err != nil {
+		return fmt.Errorf(""%s: %s: %w"", errPrefix, err.Error(), errValidateServicer)
 	}
 
-	if err := s.validateServicer(relay.Meta, session); err != nil {
-		return fmt.Errorf(""%s: relay failed servicer instance validation: %w"", errPrefix, err)
+	if err := s.validateApplication(session); err != nil {
+		return fmt.Errorf(""%s: %s: %w"", errPrefix, err.Error(), errValidateApplication)
 	}
 
 	return nil
 }
 
+// DISCUSS: do we need to export this functionality as part of the utility module?
+// calculateAppSessionTokens determines the number of ""session tokens"" an application gets at the beginning
+// of every session. Each servicer will serve a maximum of ~(Session Tokens / Number of Servicers in the Session) relays for the application
+func (s *servicer) calculateAppSessionTokens(session *coreTypes.Session) (*big.Int, error) {
+	appStake, err := utils.StringToBigInt(session.Application.StakedAmount)
+	if err != nil {
+		return nil, fmt.Errorf(""Error processing application's staked amount %s: %w"", session.Application.StakedAmount, coreTypes.ErrStringToBigInt(err))
+	}
+
+	// DOCUMENT: find the right document to explain the following:
+	//	We assume that the value of certain parameters only changes/takes effect at the start of a session.
+	//	In this specific case, the `AppSessionTokensMultiplierParamName` parameter is retrieved for the height that
+	//		matches the beginning of the session.
+	readCtx, err := s.GetBus().GetPersistenceModule().NewReadContext(session.SessionHeight)
+	if err != nil {
+		return nil, fmt.Errorf(""error getting persistence context at height %d: %w"", session.SessionHeight, err)
+	}
+	defer readCtx.Release() //nolint:errcheck // We only need to make sure the readCtx is released
+
+	// DISCUSS: using an interface for returning each defined parameter seems less error-prone: also could return e.g. int64 in this case to remove the type cast
+	appStakeTokensMultiplier, err := readCtx.GetIntParam(typesUtil.AppSessionTokensMultiplierParamName, session.SessionHeight)
+	if err != nil {
+		return nil, fmt.Errorf(""error reading parameter %s at height %d from persistence: %w"", typesUtil.AppSessionTokensMultiplierParamName, session.SessionHeight, err)
+	}
+
+	return appStake.Mul(appStake, big.NewInt(int64(appStakeTokensMultiplier))), nil
+}
+
+// executeHTTPRequest performs the HTTP request that sends the relay to the chain's URL.",utility/servicer/module.go,2023-06-13 23:24:03+00:00,2023-06-13T23:36:40Z,"```suggestion
// executeHTTPRequest performs the HTTP request that sends the relay to the chain's/service's URL.
```",,,,,412,RIGHT,364,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1228800362,Olshansk,a98595f48fc016025fce2373b14d8a3829308d2e,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -182,31 +356,107 @@ func (s servicer) admitRelay(relay *coreTypes.Relay) error {
 
 	height := s.GetBus().GetConsensusModule().CurrentHeight()
 	if err := s.validateRelayMeta(relay.Meta, int64(height)); err != nil {
-		return fmt.Errorf(""%w: %s"", errValidateRelayMeta, err.Error())
+		return fmt.Errorf(""%s: %w"", err.Error(), errValidateRelayMeta)
 	}
 
 	// TODO: update the CLI to include ApplicationAddress(or Application Public Key) in the RelayMeta
-	session, err := s.GetBus().GetUtilityModule().GetSession(relay.Meta.ApplicationAddress, int64(height), relay.Meta.RelayChain.Id, relay.Meta.GeoZone.Id)
+	session, err := s.getSession(relay)
 	if err != nil {
-		return fmt.Errorf(""%s: failed to get a session for height %d for relay meta %s: %w"", errPrefix, height, relay.Meta, err)
+		return err
 	}
 
 	// TODO: (REFACTOR) use a loop to run all validators: would also remove the need for passing the session around
 	if err := validateRelayBlockHeight(relay.Meta, session); err != nil {
-		return fmt.Errorf(""%w: %s"", errValidateBlockHeight, err.Error())
+		return fmt.Errorf(""%s: %w"", err.Error(), errValidateBlockHeight)
 	}
 
-	if err := s.validateApplication(relay.Meta, session); err != nil {
-		return fmt.Errorf(""%s: relay failed application validation: %w"", errPrefix, err)
+	if err := s.validateServicer(relay.Meta, session); err != nil {
+		return fmt.Errorf(""%s: %s: %w"", errPrefix, err.Error(), errValidateServicer)
 	}
 
-	if err := s.validateServicer(relay.Meta, session); err != nil {
-		return fmt.Errorf(""%s: relay failed servicer instance validation: %w"", errPrefix, err)
+	if err := s.validateApplication(session); err != nil {
+		return fmt.Errorf(""%s: %s: %w"", errPrefix, err.Error(), errValidateApplication)
 	}
 
 	return nil
 }
 
+// DISCUSS: do we need to export this functionality as part of the utility module?
+// calculateAppSessionTokens determines the number of ""session tokens"" an application gets at the beginning
+// of every session. Each servicer will serve a maximum of ~(Session Tokens / Number of Servicers in the Session) relays for the application
+func (s *servicer) calculateAppSessionTokens(session *coreTypes.Session) (*big.Int, error) {",utility/servicer/module.go,2023-06-13 23:24:42+00:00,2023-06-13T23:36:40Z,"```suggestion
// ADDTEST: Need to add more unit tests for the numerical portion of this functionality
func (s *servicer) calculateAppSessionTokens(session *coreTypes.Session) (*big.Int, error) {
```",,,,392.0,387,RIGHT,339,356.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1228800495,Olshansk,a98595f48fc016025fce2373b14d8a3829308d2e,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -138,19 +235,86 @@ func (s servicer) validateRelayChainSupport(relayChain *coreTypes.Identifiable,
 	return nil
 }
 
-// TODO: implement
 // validateApplication makes sure the application has not received more relays than allocated in the current session.
-func (s servicer) validateApplication(meta *coreTypes.RelayMeta, session *coreTypes.Session) error {
-	/*
-		// if maxRelaysPerSession, overServiced := calculateAppSessionTokens(); overServiced {
-			return fmt.Errorf(""application %s has exceeded its allocated relays %d for the session %d"", meta.ApplicationPublicKey, maxRelaysPerSession)
-		}
-	*/
-	return nil
+func (s *servicer) validateApplication(session *coreTypes.Session) error {
+	// IMPROVE: use a function to get current height from the current session
+	servicerAppSessionTokens, err := s.calculateServicerAppSessionTokens(session)
+	if err != nil {
+		return fmt.Errorf(""Error calculating servicer tokens for application: %w"", err)
+	}
+
+	localCtx, err := s.GetBus().GetPersistenceModule().NewLocalContext()
+	if err != nil {
+		return fmt.Errorf(""Error getting local persistence context: application %s session number %d: %w"", session.Application.PublicKey, session.SessionNumber, err)
+	}
+
+	usedAppSessionTokens, err := localCtx.GetSessionTokensUsed(session)
+	if err != nil {
+		return fmt.Errorf(""Error getting servicer token usage: application %s session number %d: %w"", session.Application.PublicKey, session.SessionNumber, err)
+	}
+
+	if usedAppSessionTokens == nil || usedAppSessionTokens.Cmp(servicerAppSessionTokens) < 0 {
+		return nil
+	}
+
+	return fmt.Errorf(""application %s has exceeded its allocated relays %s for session %d"",
+		session.Application.PublicKey,
+		servicerAppSessionTokens,
+		session.SessionNumber)
+}
+
+func (s *servicer) cachedAppTokens(session *coreTypes.Session) *sessionTokens {
+	s.rwlock.RLock()
+	defer s.rwlock.RUnlock()
+
+	return s.totalTokens[session.Application.PublicKey]
+}
+
+// calculateServicerAppSessionTokens return the number of tokens the servicer has remaining for the Application in the session provided.
+//
+//	If nothing is cached, the maximum number of session tokens is computed.
+func (s *servicer) calculateServicerAppSessionTokens(session *coreTypes.Session) (*big.Int, error) {",utility/servicer/module.go,2023-06-13 23:24:55+00:00,2023-06-13T23:36:40Z,"```suggestion
// ADDTEST: Need to add more unit tests for the numerical portion of this functionality
func (s *servicer) calculateServicerAppSessionTokens(session *coreTypes.Session) (*big.Int, error) {
```",,,,,276,RIGHT,228,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1228800755,Olshansk,a98595f48fc016025fce2373b14d8a3829308d2e,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -138,19 +235,86 @@ func (s servicer) validateRelayChainSupport(relayChain *coreTypes.Identifiable,
 	return nil
 }
 
-// TODO: implement
 // validateApplication makes sure the application has not received more relays than allocated in the current session.
-func (s servicer) validateApplication(meta *coreTypes.RelayMeta, session *coreTypes.Session) error {
-	/*
-		// if maxRelaysPerSession, overServiced := calculateAppSessionTokens(); overServiced {
-			return fmt.Errorf(""application %s has exceeded its allocated relays %d for the session %d"", meta.ApplicationPublicKey, maxRelaysPerSession)
-		}
-	*/
-	return nil
+func (s *servicer) validateApplication(session *coreTypes.Session) error {",utility/servicer/module.go,2023-06-13 23:25:32+00:00,2023-06-13T23:36:40Z,"```suggestion
// ADDTEST: Need to add more unit tests to account for potential edge cases
func (s *servicer) validateApplication(session *coreTypes.Session) error {
```",,,,,239,RIGHT,191,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1228800916,Olshansk,a98595f48fc016025fce2373b14d8a3829308d2e,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -182,31 +356,107 @@ func (s servicer) admitRelay(relay *coreTypes.Relay) error {
 
 	height := s.GetBus().GetConsensusModule().CurrentHeight()
 	if err := s.validateRelayMeta(relay.Meta, int64(height)); err != nil {
-		return fmt.Errorf(""%w: %s"", errValidateRelayMeta, err.Error())
+		return fmt.Errorf(""%s: %w"", err.Error(), errValidateRelayMeta)
 	}
 
 	// TODO: update the CLI to include ApplicationAddress(or Application Public Key) in the RelayMeta
-	session, err := s.GetBus().GetUtilityModule().GetSession(relay.Meta.ApplicationAddress, int64(height), relay.Meta.RelayChain.Id, relay.Meta.GeoZone.Id)
+	session, err := s.getSession(relay)
 	if err != nil {
-		return fmt.Errorf(""%s: failed to get a session for height %d for relay meta %s: %w"", errPrefix, height, relay.Meta, err)
+		return err
 	}
 
 	// TODO: (REFACTOR) use a loop to run all validators: would also remove the need for passing the session around
 	if err := validateRelayBlockHeight(relay.Meta, session); err != nil {
-		return fmt.Errorf(""%w: %s"", errValidateBlockHeight, err.Error())
+		return fmt.Errorf(""%s: %w"", err.Error(), errValidateBlockHeight)
 	}
 
-	if err := s.validateApplication(relay.Meta, session); err != nil {
-		return fmt.Errorf(""%s: relay failed application validation: %w"", errPrefix, err)
+	if err := s.validateServicer(relay.Meta, session); err != nil {
+		return fmt.Errorf(""%s: %s: %w"", errPrefix, err.Error(), errValidateServicer)
 	}
 
-	if err := s.validateServicer(relay.Meta, session); err != nil {
-		return fmt.Errorf(""%s: relay failed servicer instance validation: %w"", errPrefix, err)
+	if err := s.validateApplication(session); err != nil {
+		return fmt.Errorf(""%s: %s: %w"", errPrefix, err.Error(), errValidateApplication)
 	}
 
 	return nil
 }
 
+// DISCUSS: do we need to export this functionality as part of the utility module?
+// calculateAppSessionTokens determines the number of ""session tokens"" an application gets at the beginning
+// of every session. Each servicer will serve a maximum of ~(Session Tokens / Number of Servicers in the Session) relays for the application
+func (s *servicer) calculateAppSessionTokens(session *coreTypes.Session) (*big.Int, error) {
+	appStake, err := utils.StringToBigInt(session.Application.StakedAmount)
+	if err != nil {
+		return nil, fmt.Errorf(""Error processing application's staked amount %s: %w"", session.Application.StakedAmount, coreTypes.ErrStringToBigInt(err))
+	}
+
+	// DOCUMENT: find the right document to explain the following:
+	//	We assume that the value of certain parameters only changes/takes effect at the start of a session.
+	//	In this specific case, the `AppSessionTokensMultiplierParamName` parameter is retrieved for the height that
+	//		matches the beginning of the session.
+	readCtx, err := s.GetBus().GetPersistenceModule().NewReadContext(session.SessionHeight)
+	if err != nil {
+		return nil, fmt.Errorf(""error getting persistence context at height %d: %w"", session.SessionHeight, err)
+	}
+	defer readCtx.Release() //nolint:errcheck // We only need to make sure the readCtx is released
+
+	// DISCUSS: using an interface for returning each defined parameter seems less error-prone: also could return e.g. int64 in this case to remove the type cast
+	appStakeTokensMultiplier, err := readCtx.GetIntParam(typesUtil.AppSessionTokensMultiplierParamName, session.SessionHeight)
+	if err != nil {
+		return nil, fmt.Errorf(""error reading parameter %s at height %d from persistence: %w"", typesUtil.AppSessionTokensMultiplierParamName, session.SessionHeight, err)
+	}
+
+	return appStake.Mul(appStake, big.NewInt(int64(appStakeTokensMultiplier))), nil
+}
+
+// executeHTTPRequest performs the HTTP request that sends the relay to the chain's URL.
+func (s *servicer) executeHTTPRelay(meta *coreTypes.RelayMeta, payload *coreTypes.JsonRpcPayload) (*coreTypes.RelayResponse, error) {
+	if meta == nil || meta.RelayChain == nil || meta.RelayChain.Id == """" {
+		return nil, fmt.Errorf(""Relay for application %s does not specify relay chain"", meta.ApplicationAddress)
+	}
+
+	serviceConfig, ok := s.config.Services[meta.RelayChain.Id]
+	if !ok {
+		return nil, fmt.Errorf(""Chain %s not found in servicer configuration: %w"", meta.RelayChain.Id, errValidateRelayMeta)
+	}
+
+	chainUrl, err := url.Parse(serviceConfig.Url)",utility/servicer/module.go,2023-06-13 23:25:55+00:00,2023-06-13T23:36:40Z,"```suggestion
	serviceUrl, err := url.Parse(serviceConfig.Url)
```",,,,,423,RIGHT,375,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1228801636,Olshansk,a98595f48fc016025fce2373b14d8a3829308d2e,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -182,31 +356,107 @@ func (s servicer) admitRelay(relay *coreTypes.Relay) error {
 
 	height := s.GetBus().GetConsensusModule().CurrentHeight()
 	if err := s.validateRelayMeta(relay.Meta, int64(height)); err != nil {
-		return fmt.Errorf(""%w: %s"", errValidateRelayMeta, err.Error())
+		return fmt.Errorf(""%s: %w"", err.Error(), errValidateRelayMeta)
 	}
 
 	// TODO: update the CLI to include ApplicationAddress(or Application Public Key) in the RelayMeta
-	session, err := s.GetBus().GetUtilityModule().GetSession(relay.Meta.ApplicationAddress, int64(height), relay.Meta.RelayChain.Id, relay.Meta.GeoZone.Id)
+	session, err := s.getSession(relay)
 	if err != nil {
-		return fmt.Errorf(""%s: failed to get a session for height %d for relay meta %s: %w"", errPrefix, height, relay.Meta, err)
+		return err
 	}
 
 	// TODO: (REFACTOR) use a loop to run all validators: would also remove the need for passing the session around
 	if err := validateRelayBlockHeight(relay.Meta, session); err != nil {
-		return fmt.Errorf(""%w: %s"", errValidateBlockHeight, err.Error())
+		return fmt.Errorf(""%s: %w"", err.Error(), errValidateBlockHeight)
 	}
 
-	if err := s.validateApplication(relay.Meta, session); err != nil {
-		return fmt.Errorf(""%s: relay failed application validation: %w"", errPrefix, err)
+	if err := s.validateServicer(relay.Meta, session); err != nil {
+		return fmt.Errorf(""%s: %s: %w"", errPrefix, err.Error(), errValidateServicer)
 	}
 
-	if err := s.validateServicer(relay.Meta, session); err != nil {
-		return fmt.Errorf(""%s: relay failed servicer instance validation: %w"", errPrefix, err)
+	if err := s.validateApplication(session); err != nil {
+		return fmt.Errorf(""%s: %s: %w"", errPrefix, err.Error(), errValidateApplication)
 	}
 
 	return nil
 }
 
+// DISCUSS: do we need to export this functionality as part of the utility module?
+// calculateAppSessionTokens determines the number of ""session tokens"" an application gets at the beginning
+// of every session. Each servicer will serve a maximum of ~(Session Tokens / Number of Servicers in the Session) relays for the application
+func (s *servicer) calculateAppSessionTokens(session *coreTypes.Session) (*big.Int, error) {
+	appStake, err := utils.StringToBigInt(session.Application.StakedAmount)
+	if err != nil {
+		return nil, fmt.Errorf(""Error processing application's staked amount %s: %w"", session.Application.StakedAmount, coreTypes.ErrStringToBigInt(err))
+	}
+
+	// DOCUMENT: find the right document to explain the following:
+	//	We assume that the value of certain parameters only changes/takes effect at the start of a session.
+	//	In this specific case, the `AppSessionTokensMultiplierParamName` parameter is retrieved for the height that
+	//		matches the beginning of the session.
+	readCtx, err := s.GetBus().GetPersistenceModule().NewReadContext(session.SessionHeight)
+	if err != nil {
+		return nil, fmt.Errorf(""error getting persistence context at height %d: %w"", session.SessionHeight, err)
+	}
+	defer readCtx.Release() //nolint:errcheck // We only need to make sure the readCtx is released
+
+	// DISCUSS: using an interface for returning each defined parameter seems less error-prone: also could return e.g. int64 in this case to remove the type cast
+	appStakeTokensMultiplier, err := readCtx.GetIntParam(typesUtil.AppSessionTokensMultiplierParamName, session.SessionHeight)
+	if err != nil {
+		return nil, fmt.Errorf(""error reading parameter %s at height %d from persistence: %w"", typesUtil.AppSessionTokensMultiplierParamName, session.SessionHeight, err)
+	}
+
+	return appStake.Mul(appStake, big.NewInt(int64(appStakeTokensMultiplier))), nil
+}
+
+// executeHTTPRequest performs the HTTP request that sends the relay to the chain's URL.
+func (s *servicer) executeHTTPRelay(meta *coreTypes.RelayMeta, payload *coreTypes.JsonRpcPayload) (*coreTypes.RelayResponse, error) {
+	if meta == nil || meta.RelayChain == nil || meta.RelayChain.Id == """" {
+		return nil, fmt.Errorf(""Relay for application %s does not specify relay chain"", meta.ApplicationAddress)
+	}
+
+	serviceConfig, ok := s.config.Services[meta.RelayChain.Id]
+	if !ok {
+		return nil, fmt.Errorf(""Chain %s not found in servicer configuration: %w"", meta.RelayChain.Id, errValidateRelayMeta)
+	}
+
+	chainUrl, err := url.Parse(serviceConfig.Url)
+	if err != nil {
+		return nil, fmt.Errorf(""Error parsing chain URL %s: %w"", serviceConfig.Url, err)
+	}
+	targetUrl := chainUrl.JoinPath(payload.HttpPath)",utility/servicer/module.go,2023-06-13 23:27:17+00:00,2023-06-13T23:36:40Z,Can you add a comment on what this is doing? A small example in the comment above would help,,,,,427,RIGHT,379,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1228802024,Olshansk,a98595f48fc016025fce2373b14d8a3829308d2e,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -182,31 +356,107 @@ func (s servicer) admitRelay(relay *coreTypes.Relay) error {
 
 	height := s.GetBus().GetConsensusModule().CurrentHeight()
 	if err := s.validateRelayMeta(relay.Meta, int64(height)); err != nil {
-		return fmt.Errorf(""%w: %s"", errValidateRelayMeta, err.Error())
+		return fmt.Errorf(""%s: %w"", err.Error(), errValidateRelayMeta)
 	}
 
 	// TODO: update the CLI to include ApplicationAddress(or Application Public Key) in the RelayMeta
-	session, err := s.GetBus().GetUtilityModule().GetSession(relay.Meta.ApplicationAddress, int64(height), relay.Meta.RelayChain.Id, relay.Meta.GeoZone.Id)
+	session, err := s.getSession(relay)
 	if err != nil {
-		return fmt.Errorf(""%s: failed to get a session for height %d for relay meta %s: %w"", errPrefix, height, relay.Meta, err)
+		return err
 	}
 
 	// TODO: (REFACTOR) use a loop to run all validators: would also remove the need for passing the session around
 	if err := validateRelayBlockHeight(relay.Meta, session); err != nil {
-		return fmt.Errorf(""%w: %s"", errValidateBlockHeight, err.Error())
+		return fmt.Errorf(""%s: %w"", err.Error(), errValidateBlockHeight)
 	}
 
-	if err := s.validateApplication(relay.Meta, session); err != nil {
-		return fmt.Errorf(""%s: relay failed application validation: %w"", errPrefix, err)
+	if err := s.validateServicer(relay.Meta, session); err != nil {
+		return fmt.Errorf(""%s: %s: %w"", errPrefix, err.Error(), errValidateServicer)
 	}
 
-	if err := s.validateServicer(relay.Meta, session); err != nil {
-		return fmt.Errorf(""%s: relay failed servicer instance validation: %w"", errPrefix, err)
+	if err := s.validateApplication(session); err != nil {
+		return fmt.Errorf(""%s: %s: %w"", errPrefix, err.Error(), errValidateApplication)
 	}
 
 	return nil
 }
 
+// DISCUSS: do we need to export this functionality as part of the utility module?
+// calculateAppSessionTokens determines the number of ""session tokens"" an application gets at the beginning
+// of every session. Each servicer will serve a maximum of ~(Session Tokens / Number of Servicers in the Session) relays for the application
+func (s *servicer) calculateAppSessionTokens(session *coreTypes.Session) (*big.Int, error) {
+	appStake, err := utils.StringToBigInt(session.Application.StakedAmount)
+	if err != nil {
+		return nil, fmt.Errorf(""Error processing application's staked amount %s: %w"", session.Application.StakedAmount, coreTypes.ErrStringToBigInt(err))
+	}
+
+	// DOCUMENT: find the right document to explain the following:
+	//	We assume that the value of certain parameters only changes/takes effect at the start of a session.
+	//	In this specific case, the `AppSessionTokensMultiplierParamName` parameter is retrieved for the height that
+	//		matches the beginning of the session.
+	readCtx, err := s.GetBus().GetPersistenceModule().NewReadContext(session.SessionHeight)
+	if err != nil {
+		return nil, fmt.Errorf(""error getting persistence context at height %d: %w"", session.SessionHeight, err)
+	}
+	defer readCtx.Release() //nolint:errcheck // We only need to make sure the readCtx is released
+
+	// DISCUSS: using an interface for returning each defined parameter seems less error-prone: also could return e.g. int64 in this case to remove the type cast
+	appStakeTokensMultiplier, err := readCtx.GetIntParam(typesUtil.AppSessionTokensMultiplierParamName, session.SessionHeight)
+	if err != nil {
+		return nil, fmt.Errorf(""error reading parameter %s at height %d from persistence: %w"", typesUtil.AppSessionTokensMultiplierParamName, session.SessionHeight, err)
+	}
+
+	return appStake.Mul(appStake, big.NewInt(int64(appStakeTokensMultiplier))), nil
+}
+
+// executeHTTPRequest performs the HTTP request that sends the relay to the chain's URL.
+func (s *servicer) executeHTTPRelay(meta *coreTypes.RelayMeta, payload *coreTypes.JsonRpcPayload) (*coreTypes.RelayResponse, error) {
+	if meta == nil || meta.RelayChain == nil || meta.RelayChain.Id == """" {
+		return nil, fmt.Errorf(""Relay for application %s does not specify relay chain"", meta.ApplicationAddress)
+	}
+
+	serviceConfig, ok := s.config.Services[meta.RelayChain.Id]
+	if !ok {
+		return nil, fmt.Errorf(""Chain %s not found in servicer configuration: %w"", meta.RelayChain.Id, errValidateRelayMeta)
+	}
+
+	chainUrl, err := url.Parse(serviceConfig.Url)
+	if err != nil {
+		return nil, fmt.Errorf(""Error parsing chain URL %s: %w"", serviceConfig.Url, err)
+	}
+	targetUrl := chainUrl.JoinPath(payload.HttpPath)
+
+	req, err := http.NewRequest(payload.Method, targetUrl.String(), bytes.NewBuffer([]byte(payload.Data)))",utility/servicer/module.go,2023-06-13 23:28:06+00:00,2023-06-13T23:36:41Z,Should we convert `payload.Data` to `[]byte` from `string`? Doesn't have to be in this PR but maybe a TODO,,,,,429,RIGHT,381,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1228802486,Olshansk,a98595f48fc016025fce2373b14d8a3829308d2e,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -182,31 +356,107 @@ func (s servicer) admitRelay(relay *coreTypes.Relay) error {
 
 	height := s.GetBus().GetConsensusModule().CurrentHeight()
 	if err := s.validateRelayMeta(relay.Meta, int64(height)); err != nil {
-		return fmt.Errorf(""%w: %s"", errValidateRelayMeta, err.Error())
+		return fmt.Errorf(""%s: %w"", err.Error(), errValidateRelayMeta)
 	}
 
 	// TODO: update the CLI to include ApplicationAddress(or Application Public Key) in the RelayMeta
-	session, err := s.GetBus().GetUtilityModule().GetSession(relay.Meta.ApplicationAddress, int64(height), relay.Meta.RelayChain.Id, relay.Meta.GeoZone.Id)
+	session, err := s.getSession(relay)
 	if err != nil {
-		return fmt.Errorf(""%s: failed to get a session for height %d for relay meta %s: %w"", errPrefix, height, relay.Meta, err)
+		return err
 	}
 
 	// TODO: (REFACTOR) use a loop to run all validators: would also remove the need for passing the session around
 	if err := validateRelayBlockHeight(relay.Meta, session); err != nil {
-		return fmt.Errorf(""%w: %s"", errValidateBlockHeight, err.Error())
+		return fmt.Errorf(""%s: %w"", err.Error(), errValidateBlockHeight)
 	}
 
-	if err := s.validateApplication(relay.Meta, session); err != nil {
-		return fmt.Errorf(""%s: relay failed application validation: %w"", errPrefix, err)
+	if err := s.validateServicer(relay.Meta, session); err != nil {
+		return fmt.Errorf(""%s: %s: %w"", errPrefix, err.Error(), errValidateServicer)
 	}
 
-	if err := s.validateServicer(relay.Meta, session); err != nil {
-		return fmt.Errorf(""%s: relay failed servicer instance validation: %w"", errPrefix, err)
+	if err := s.validateApplication(session); err != nil {
+		return fmt.Errorf(""%s: %s: %w"", errPrefix, err.Error(), errValidateApplication)
 	}
 
 	return nil
 }
 
+// DISCUSS: do we need to export this functionality as part of the utility module?
+// calculateAppSessionTokens determines the number of ""session tokens"" an application gets at the beginning
+// of every session. Each servicer will serve a maximum of ~(Session Tokens / Number of Servicers in the Session) relays for the application
+func (s *servicer) calculateAppSessionTokens(session *coreTypes.Session) (*big.Int, error) {
+	appStake, err := utils.StringToBigInt(session.Application.StakedAmount)
+	if err != nil {
+		return nil, fmt.Errorf(""Error processing application's staked amount %s: %w"", session.Application.StakedAmount, coreTypes.ErrStringToBigInt(err))
+	}
+
+	// DOCUMENT: find the right document to explain the following:
+	//	We assume that the value of certain parameters only changes/takes effect at the start of a session.
+	//	In this specific case, the `AppSessionTokensMultiplierParamName` parameter is retrieved for the height that
+	//		matches the beginning of the session.
+	readCtx, err := s.GetBus().GetPersistenceModule().NewReadContext(session.SessionHeight)
+	if err != nil {
+		return nil, fmt.Errorf(""error getting persistence context at height %d: %w"", session.SessionHeight, err)
+	}
+	defer readCtx.Release() //nolint:errcheck // We only need to make sure the readCtx is released
+
+	// DISCUSS: using an interface for returning each defined parameter seems less error-prone: also could return e.g. int64 in this case to remove the type cast
+	appStakeTokensMultiplier, err := readCtx.GetIntParam(typesUtil.AppSessionTokensMultiplierParamName, session.SessionHeight)
+	if err != nil {
+		return nil, fmt.Errorf(""error reading parameter %s at height %d from persistence: %w"", typesUtil.AppSessionTokensMultiplierParamName, session.SessionHeight, err)
+	}
+
+	return appStake.Mul(appStake, big.NewInt(int64(appStakeTokensMultiplier))), nil
+}
+
+// executeHTTPRequest performs the HTTP request that sends the relay to the chain's URL.
+func (s *servicer) executeHTTPRelay(meta *coreTypes.RelayMeta, payload *coreTypes.JsonRpcPayload) (*coreTypes.RelayResponse, error) {
+	if meta == nil || meta.RelayChain == nil || meta.RelayChain.Id == """" {
+		return nil, fmt.Errorf(""Relay for application %s does not specify relay chain"", meta.ApplicationAddress)
+	}
+
+	serviceConfig, ok := s.config.Services[meta.RelayChain.Id]
+	if !ok {
+		return nil, fmt.Errorf(""Chain %s not found in servicer configuration: %w"", meta.RelayChain.Id, errValidateRelayMeta)
+	}
+
+	chainUrl, err := url.Parse(serviceConfig.Url)
+	if err != nil {
+		return nil, fmt.Errorf(""Error parsing chain URL %s: %w"", serviceConfig.Url, err)
+	}
+	targetUrl := chainUrl.JoinPath(payload.HttpPath)
+
+	req, err := http.NewRequest(payload.Method, targetUrl.String(), bytes.NewBuffer([]byte(payload.Data)))
+	if err != nil {
+		return nil, err
+	}
+	if serviceConfig.BasicAuth != nil && serviceConfig.BasicAuth.UserName != """" {
+		req.SetBasicAuth(serviceConfig.BasicAuth.UserName, serviceConfig.BasicAuth.Password)
+	}
+
+	// DISCUSS: do we need a default user-agent for HTTP requests?",utility/servicer/module.go,2023-06-13 23:28:52+00:00,2023-06-13T23:36:41Z,"```suggestion
	// INVESTIGATE: do we need a default user-agent for HTTP requests?
```

I don't know yet. If you have any insight/experience, can you add it in the TODO comment?",,,,,437,RIGHT,389,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1228803268,Olshansk,a98595f48fc016025fce2373b14d8a3829308d2e,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -182,31 +356,107 @@ func (s servicer) admitRelay(relay *coreTypes.Relay) error {
 
 	height := s.GetBus().GetConsensusModule().CurrentHeight()
 	if err := s.validateRelayMeta(relay.Meta, int64(height)); err != nil {
-		return fmt.Errorf(""%w: %s"", errValidateRelayMeta, err.Error())
+		return fmt.Errorf(""%s: %w"", err.Error(), errValidateRelayMeta)
 	}
 
 	// TODO: update the CLI to include ApplicationAddress(or Application Public Key) in the RelayMeta
-	session, err := s.GetBus().GetUtilityModule().GetSession(relay.Meta.ApplicationAddress, int64(height), relay.Meta.RelayChain.Id, relay.Meta.GeoZone.Id)
+	session, err := s.getSession(relay)
 	if err != nil {
-		return fmt.Errorf(""%s: failed to get a session for height %d for relay meta %s: %w"", errPrefix, height, relay.Meta, err)
+		return err
 	}
 
 	// TODO: (REFACTOR) use a loop to run all validators: would also remove the need for passing the session around
 	if err := validateRelayBlockHeight(relay.Meta, session); err != nil {
-		return fmt.Errorf(""%w: %s"", errValidateBlockHeight, err.Error())
+		return fmt.Errorf(""%s: %w"", err.Error(), errValidateBlockHeight)
 	}
 
-	if err := s.validateApplication(relay.Meta, session); err != nil {
-		return fmt.Errorf(""%s: relay failed application validation: %w"", errPrefix, err)
+	if err := s.validateServicer(relay.Meta, session); err != nil {
+		return fmt.Errorf(""%s: %s: %w"", errPrefix, err.Error(), errValidateServicer)
 	}
 
-	if err := s.validateServicer(relay.Meta, session); err != nil {
-		return fmt.Errorf(""%s: relay failed servicer instance validation: %w"", errPrefix, err)
+	if err := s.validateApplication(session); err != nil {
+		return fmt.Errorf(""%s: %s: %w"", errPrefix, err.Error(), errValidateApplication)
 	}
 
 	return nil
 }
 
+// DISCUSS: do we need to export this functionality as part of the utility module?
+// calculateAppSessionTokens determines the number of ""session tokens"" an application gets at the beginning
+// of every session. Each servicer will serve a maximum of ~(Session Tokens / Number of Servicers in the Session) relays for the application
+func (s *servicer) calculateAppSessionTokens(session *coreTypes.Session) (*big.Int, error) {
+	appStake, err := utils.StringToBigInt(session.Application.StakedAmount)
+	if err != nil {
+		return nil, fmt.Errorf(""Error processing application's staked amount %s: %w"", session.Application.StakedAmount, coreTypes.ErrStringToBigInt(err))
+	}
+
+	// DOCUMENT: find the right document to explain the following:
+	//	We assume that the value of certain parameters only changes/takes effect at the start of a session.
+	//	In this specific case, the `AppSessionTokensMultiplierParamName` parameter is retrieved for the height that
+	//		matches the beginning of the session.
+	readCtx, err := s.GetBus().GetPersistenceModule().NewReadContext(session.SessionHeight)
+	if err != nil {
+		return nil, fmt.Errorf(""error getting persistence context at height %d: %w"", session.SessionHeight, err)
+	}
+	defer readCtx.Release() //nolint:errcheck // We only need to make sure the readCtx is released
+
+	// DISCUSS: using an interface for returning each defined parameter seems less error-prone: also could return e.g. int64 in this case to remove the type cast
+	appStakeTokensMultiplier, err := readCtx.GetIntParam(typesUtil.AppSessionTokensMultiplierParamName, session.SessionHeight)
+	if err != nil {
+		return nil, fmt.Errorf(""error reading parameter %s at height %d from persistence: %w"", typesUtil.AppSessionTokensMultiplierParamName, session.SessionHeight, err)
+	}
+
+	return appStake.Mul(appStake, big.NewInt(int64(appStakeTokensMultiplier))), nil
+}
+
+// executeHTTPRequest performs the HTTP request that sends the relay to the chain's URL.
+func (s *servicer) executeHTTPRelay(meta *coreTypes.RelayMeta, payload *coreTypes.JsonRpcPayload) (*coreTypes.RelayResponse, error) {
+	if meta == nil || meta.RelayChain == nil || meta.RelayChain.Id == """" {
+		return nil, fmt.Errorf(""Relay for application %s does not specify relay chain"", meta.ApplicationAddress)
+	}
+
+	serviceConfig, ok := s.config.Services[meta.RelayChain.Id]
+	if !ok {
+		return nil, fmt.Errorf(""Chain %s not found in servicer configuration: %w"", meta.RelayChain.Id, errValidateRelayMeta)
+	}
+
+	chainUrl, err := url.Parse(serviceConfig.Url)
+	if err != nil {
+		return nil, fmt.Errorf(""Error parsing chain URL %s: %w"", serviceConfig.Url, err)
+	}
+	targetUrl := chainUrl.JoinPath(payload.HttpPath)
+
+	req, err := http.NewRequest(payload.Method, targetUrl.String(), bytes.NewBuffer([]byte(payload.Data)))
+	if err != nil {
+		return nil, err
+	}
+	if serviceConfig.BasicAuth != nil && serviceConfig.BasicAuth.UserName != """" {
+		req.SetBasicAuth(serviceConfig.BasicAuth.UserName, serviceConfig.BasicAuth.Password)
+	}
+
+	// DISCUSS: do we need a default user-agent for HTTP requests?
+	for k, v := range payload.Headers {
+		req.Header.Set(k, v)
+	}
+	if len(payload.Headers) == 0 {",utility/servicer/module.go,2023-06-13 23:29:41+00:00,2023-06-13T23:36:41Z,"Should this be `if ""Content-Type"" is not a key in `payload.Headers?`",,,,,441,RIGHT,393,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1228803869,Olshansk,a98595f48fc016025fce2373b14d8a3829308d2e,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -182,31 +356,107 @@ func (s servicer) admitRelay(relay *coreTypes.Relay) error {
 
 	height := s.GetBus().GetConsensusModule().CurrentHeight()
 	if err := s.validateRelayMeta(relay.Meta, int64(height)); err != nil {
-		return fmt.Errorf(""%w: %s"", errValidateRelayMeta, err.Error())
+		return fmt.Errorf(""%s: %w"", err.Error(), errValidateRelayMeta)
 	}
 
 	// TODO: update the CLI to include ApplicationAddress(or Application Public Key) in the RelayMeta
-	session, err := s.GetBus().GetUtilityModule().GetSession(relay.Meta.ApplicationAddress, int64(height), relay.Meta.RelayChain.Id, relay.Meta.GeoZone.Id)
+	session, err := s.getSession(relay)
 	if err != nil {
-		return fmt.Errorf(""%s: failed to get a session for height %d for relay meta %s: %w"", errPrefix, height, relay.Meta, err)
+		return err
 	}
 
 	// TODO: (REFACTOR) use a loop to run all validators: would also remove the need for passing the session around
 	if err := validateRelayBlockHeight(relay.Meta, session); err != nil {
-		return fmt.Errorf(""%w: %s"", errValidateBlockHeight, err.Error())
+		return fmt.Errorf(""%s: %w"", err.Error(), errValidateBlockHeight)
 	}
 
-	if err := s.validateApplication(relay.Meta, session); err != nil {
-		return fmt.Errorf(""%s: relay failed application validation: %w"", errPrefix, err)
+	if err := s.validateServicer(relay.Meta, session); err != nil {
+		return fmt.Errorf(""%s: %s: %w"", errPrefix, err.Error(), errValidateServicer)
 	}
 
-	if err := s.validateServicer(relay.Meta, session); err != nil {
-		return fmt.Errorf(""%s: relay failed servicer instance validation: %w"", errPrefix, err)
+	if err := s.validateApplication(session); err != nil {
+		return fmt.Errorf(""%s: %s: %w"", errPrefix, err.Error(), errValidateApplication)
 	}
 
 	return nil
 }
 
+// DISCUSS: do we need to export this functionality as part of the utility module?
+// calculateAppSessionTokens determines the number of ""session tokens"" an application gets at the beginning
+// of every session. Each servicer will serve a maximum of ~(Session Tokens / Number of Servicers in the Session) relays for the application
+func (s *servicer) calculateAppSessionTokens(session *coreTypes.Session) (*big.Int, error) {
+	appStake, err := utils.StringToBigInt(session.Application.StakedAmount)
+	if err != nil {
+		return nil, fmt.Errorf(""Error processing application's staked amount %s: %w"", session.Application.StakedAmount, coreTypes.ErrStringToBigInt(err))
+	}
+
+	// DOCUMENT: find the right document to explain the following:
+	//	We assume that the value of certain parameters only changes/takes effect at the start of a session.
+	//	In this specific case, the `AppSessionTokensMultiplierParamName` parameter is retrieved for the height that
+	//		matches the beginning of the session.
+	readCtx, err := s.GetBus().GetPersistenceModule().NewReadContext(session.SessionHeight)
+	if err != nil {
+		return nil, fmt.Errorf(""error getting persistence context at height %d: %w"", session.SessionHeight, err)
+	}
+	defer readCtx.Release() //nolint:errcheck // We only need to make sure the readCtx is released
+
+	// DISCUSS: using an interface for returning each defined parameter seems less error-prone: also could return e.g. int64 in this case to remove the type cast
+	appStakeTokensMultiplier, err := readCtx.GetIntParam(typesUtil.AppSessionTokensMultiplierParamName, session.SessionHeight)
+	if err != nil {
+		return nil, fmt.Errorf(""error reading parameter %s at height %d from persistence: %w"", typesUtil.AppSessionTokensMultiplierParamName, session.SessionHeight, err)
+	}
+
+	return appStake.Mul(appStake, big.NewInt(int64(appStakeTokensMultiplier))), nil
+}
+
+// executeHTTPRequest performs the HTTP request that sends the relay to the chain's URL.
+func (s *servicer) executeHTTPRelay(meta *coreTypes.RelayMeta, payload *coreTypes.JsonRpcPayload) (*coreTypes.RelayResponse, error) {
+	if meta == nil || meta.RelayChain == nil || meta.RelayChain.Id == """" {
+		return nil, fmt.Errorf(""Relay for application %s does not specify relay chain"", meta.ApplicationAddress)
+	}
+
+	serviceConfig, ok := s.config.Services[meta.RelayChain.Id]
+	if !ok {
+		return nil, fmt.Errorf(""Chain %s not found in servicer configuration: %w"", meta.RelayChain.Id, errValidateRelayMeta)
+	}
+
+	chainUrl, err := url.Parse(serviceConfig.Url)
+	if err != nil {
+		return nil, fmt.Errorf(""Error parsing chain URL %s: %w"", serviceConfig.Url, err)
+	}
+	targetUrl := chainUrl.JoinPath(payload.HttpPath)
+
+	req, err := http.NewRequest(payload.Method, targetUrl.String(), bytes.NewBuffer([]byte(payload.Data)))
+	if err != nil {
+		return nil, err
+	}
+	if serviceConfig.BasicAuth != nil && serviceConfig.BasicAuth.UserName != """" {
+		req.SetBasicAuth(serviceConfig.BasicAuth.UserName, serviceConfig.BasicAuth.Password)
+	}
+
+	// DISCUSS: do we need a default user-agent for HTTP requests?
+	for k, v := range payload.Headers {
+		req.Header.Set(k, v)
+	}
+	if len(payload.Headers) == 0 {
+		req.Header.Set(""Content-Type"", ""application/json"")
+	}
+
+	// DISCUSS: we need to optimize usage of HTTP client, e.g. for connection reuse, considering the expected volume of relays",utility/servicer/module.go,2023-06-13 23:30:19+00:00,2023-06-13T23:36:41Z,"Should this be a TODO instead of a DISCUSS?

Seems like it might validate a whole ticket for this task alone, or make it an M5 thing.",,,,,445,RIGHT,397,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1228805748,Olshansk,a98595f48fc016025fce2373b14d8a3829308d2e,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -43,63 +75,151 @@ func TestAdmitRelay(t *testing.T) {
 		},
 		{
 			name:     ""Relay for unsupported chain is rejected"",
-			relay:    testRelay(""foo"", 8),
+			relay:    testRelay(testRelayChain(""foo"")),
 			expected: errValidateRelayMeta,
 		},
 		{
 			name:     ""Relay with height set in a past session is rejected"",
-			relay:    testRelay(""0021"", 5),
+			relay:    testRelay(testRelayHeight(5)),
 			expected: errValidateBlockHeight,
 		},
 		{
 			name:     ""Relay with height set in a future session is rejected"",
-			relay:    testRelay(""0021"", 9999),
+			relay:    testRelay(testRelayHeight(9999)),
 			expected: errValidateBlockHeight,
 		},
+		{
+			name:     ""Relay not matching the servicer in this session is rejected"",
+			relay:    testRelay(testRelayServicer(""bar"")),
+			expected: errValidateServicer,
+		},
+		{
+			name:              ""Relay for app out of quota is rejected"",
+			relay:             testRelay(),
+			usedSessionTokens: 999999,
+			expected:          errValidateApplication,",utility/servicer/module_test.go,2023-06-13 23:33:46+00:00,2023-06-13T23:36:41Z,I think this should be `errShouldMineRelay` to keep the terminology consistent.,,,,,100,RIGHT,105,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1228806355,Olshansk,a98595f48fc016025fce2373b14d8a3829308d2e,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -43,63 +75,151 @@ func TestAdmitRelay(t *testing.T) {
 		},
 		{
 			name:     ""Relay for unsupported chain is rejected"",
-			relay:    testRelay(""foo"", 8),
+			relay:    testRelay(testRelayChain(""foo"")),
 			expected: errValidateRelayMeta,
 		},
 		{
 			name:     ""Relay with height set in a past session is rejected"",
-			relay:    testRelay(""0021"", 5),
+			relay:    testRelay(testRelayHeight(5)),
 			expected: errValidateBlockHeight,
 		},
 		{
 			name:     ""Relay with height set in a future session is rejected"",
-			relay:    testRelay(""0021"", 9999),
+			relay:    testRelay(testRelayHeight(9999)),
 			expected: errValidateBlockHeight,
 		},
+		{
+			name:     ""Relay not matching the servicer in this session is rejected"",
+			relay:    testRelay(testRelayServicer(""bar"")),
+			expected: errValidateServicer,
+		},
+		{
+			name:              ""Relay for app out of quota is rejected"",
+			relay:             testRelay(),
+			usedSessionTokens: 999999,
+			expected:          errValidateApplication,
+		},
 	}
 
 	for _, testCase := range testCases {
 		t.Run(testCase.name, func(t *testing.T) {
 			config := testServicerConfig()
 			session := testSession(
-				sessionNumber(2),
+				sessionNumber(currentSessionNumber),
 				sessionBlocks(4),
-				sessionHeight(2),
+				sessionHeight(testSessionStartingHeight),
 				sessionServicers(testServicer1),
 			)
-			mockBus := mockBus(t, &config, currentHeight, session)
+			mockBus := mockBus(t, &config, uint64(testCurrentHeight), session, testCase.usedSessionTokens)
 
 			servicerMod, err := CreateServicer(mockBus)
 			require.NoError(t, err)
 
-			err = servicerMod.(*servicer).admitRelay(testCase.relay)
+			servicer, ok := servicerMod.(*servicer)
+			require.True(t, ok)
+
+			err = servicer.admitRelay(testCase.relay)
 			if !errors.Is(err, testCase.expected) {
 				t.Fatalf(""Expected error %v got: %v"", testCase.expected, err)
 			}
 		})
 	}
 }
 
-func testRelay(chain string, height int64) *coreTypes.Relay {
-	return &coreTypes.Relay{
+func TestExecuteRelay(t *testing.T) {
+	testCases := []struct {
+		name        string
+		relay       *coreTypes.Relay
+		expectedErr error
+	}{
+		{
+			name:        ""relay is rejected if chain is not specified in the config"",
+			relay:       testRelay(testRelayChain(""foo"")),
+			expectedErr: errValidateRelayMeta,
+		},
+		{
+			name:  ""Relay for accepted chain is executed"",
+			relay: testRelay(),
+		},
+	}
+
+	for _, testCase := range testCases {
+		t.Run(testCase.name, func(t *testing.T) {
+			ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
+				fmt.Fprintln(w, `{""0x1234""}`)
+			}))
+			defer ts.Close()
+
+			config := testServicerConfig()
+			for ch := range config.Services {
+				config.Services[ch].Url = ts.URL
+			}
+
+			servicer := &servicer{config: &config}
+			_, err := servicer.executeRelay(testCase.relay)
+			if !errors.Is(err, testCase.expectedErr) {
+				t.Fatalf(""Expected error %v got: %v"", testCase.expectedErr, err)
+			}",utility/servicer/module_test.go,2023-06-13 23:35:02+00:00,2023-06-13T23:36:41Z,Why not use: https://pkg.go.dev/github.com/stretchr/testify/assert#ErrorIs,,160.0,RIGHT,,162,RIGHT,173,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1228806491,Olshansk,a98595f48fc016025fce2373b14d8a3829308d2e,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -43,63 +75,151 @@ func TestAdmitRelay(t *testing.T) {
 		},
 		{
 			name:     ""Relay for unsupported chain is rejected"",
-			relay:    testRelay(""foo"", 8),
+			relay:    testRelay(testRelayChain(""foo"")),
 			expected: errValidateRelayMeta,
 		},
 		{
 			name:     ""Relay with height set in a past session is rejected"",
-			relay:    testRelay(""0021"", 5),
+			relay:    testRelay(testRelayHeight(5)),
 			expected: errValidateBlockHeight,
 		},
 		{
 			name:     ""Relay with height set in a future session is rejected"",
-			relay:    testRelay(""0021"", 9999),
+			relay:    testRelay(testRelayHeight(9999)),
 			expected: errValidateBlockHeight,
 		},
+		{
+			name:     ""Relay not matching the servicer in this session is rejected"",
+			relay:    testRelay(testRelayServicer(""bar"")),
+			expected: errValidateServicer,
+		},
+		{
+			name:              ""Relay for app out of quota is rejected"",
+			relay:             testRelay(),
+			usedSessionTokens: 999999,
+			expected:          errValidateApplication,
+		},
 	}
 
 	for _, testCase := range testCases {
 		t.Run(testCase.name, func(t *testing.T) {
 			config := testServicerConfig()
 			session := testSession(
-				sessionNumber(2),
+				sessionNumber(currentSessionNumber),
 				sessionBlocks(4),
-				sessionHeight(2),
+				sessionHeight(testSessionStartingHeight),
 				sessionServicers(testServicer1),
 			)
-			mockBus := mockBus(t, &config, currentHeight, session)
+			mockBus := mockBus(t, &config, uint64(testCurrentHeight), session, testCase.usedSessionTokens)
 
 			servicerMod, err := CreateServicer(mockBus)
 			require.NoError(t, err)
 
-			err = servicerMod.(*servicer).admitRelay(testCase.relay)
+			servicer, ok := servicerMod.(*servicer)
+			require.True(t, ok)
+
+			err = servicer.admitRelay(testCase.relay)
 			if !errors.Is(err, testCase.expected) {
 				t.Fatalf(""Expected error %v got: %v"", testCase.expected, err)
 			}
 		})
 	}
 }
 
-func testRelay(chain string, height int64) *coreTypes.Relay {
-	return &coreTypes.Relay{
+func TestExecuteRelay(t *testing.T) {
+	testCases := []struct {
+		name        string
+		relay       *coreTypes.Relay
+		expectedErr error
+	}{
+		{
+			name:        ""relay is rejected if chain is not specified in the config"",
+			relay:       testRelay(testRelayChain(""foo"")),
+			expectedErr: errValidateRelayMeta,
+		},
+		{
+			name:  ""Relay for accepted chain is executed"",
+			relay: testRelay(),
+		},
+	}
+
+	for _, testCase := range testCases {
+		t.Run(testCase.name, func(t *testing.T) {
+			ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
+				fmt.Fprintln(w, `{""0x1234""}`)
+			}))
+			defer ts.Close()
+
+			config := testServicerConfig()
+			for ch := range config.Services {
+				config.Services[ch].Url = ts.URL
+			}
+
+			servicer := &servicer{config: &config}
+			_, err := servicer.executeRelay(testCase.relay)
+			if !errors.Is(err, testCase.expectedErr) {
+				t.Fatalf(""Expected error %v got: %v"", testCase.expectedErr, err)
+			}
+			// INCOMPLETE: verify HTTP request properties: payload/headers/user-agent/etc.",utility/servicer/module_test.go,2023-06-13 23:35:17+00:00,2023-06-13T23:36:41Z,"```suggestion
			// INCOMPLETE(@adshmh): verify HTTP request properties: payload/headers/user-agent/etc.
```",,,,,163,RIGHT,174,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1235951264,Olshansk,f3bfe1387700a38296d89201c5e7cce3f78a63eb,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -0,0 +1,80 @@
+package local",persistence/local/module.go,2023-06-20 22:13:06+00:00,2023-06-22T21:15:01Z,"For future reference: I think this could have been a separate PR that we merge in first simply titled ""Add Local Persistence Module""",,,,1.0,1,RIGHT,1,1.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1235955158,Olshansk,f3bfe1387700a38296d89201c5e7cce3f78a63eb,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -33,6 +36,11 @@ type PersistenceModule interface {
 
 	// Debugging / development only
 	HandleDebugMessage(*messaging.DebugMessage) error
+
+	// GetLocalContext returns a local persistence context that can be used to store/retrieve node-specific, i.e. off-chain, data
+	// The module can maintain a single local context for both read and write operations: subsequent calls to GetLocalContext return",shared/modules/persistence_module.go,2023-06-20 22:19:08+00:00,2023-06-22T21:15:01Z,"```suggestion
	// The module can maintain a single (i.e. a singleton) local context for both read and write operations: subsequent calls to GetLocalContext return
```",,,,,41,RIGHT,24,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1235980764,Olshansk,f3bfe1387700a38296d89201c5e7cce3f78a63eb,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -191,15 +220,18 @@ func testRelay(editors ...relayEditor) *coreTypes.Relay {
 			ApplicationAddress: testApp1.Address,
 			BlockHeight:        testCurrentHeight,
 			RelayChain: &coreTypes.Identifiable{
-				Id: ""0021"",
+				Id: ""POKT-UnitTestNet"",
 			},
 			GeoZone: &coreTypes.Identifiable{
 				Id: ""geozone"",
 			},
 		},
-		Payload: &coreTypes.RelayPayload{
-			Method: ""POST"",
-			Data:   `{""id"": 1, ""jsonrpc"": ""2.0"", method: ""eth_blockNumber""}`,
+		RelayPayload: &coreTypes.Relay_JsonRpcPayload{",utility/servicer/module_test.go,2023-06-20 22:54:15+00:00,2023-06-22T21:15:01Z,"Should we update the test to getting pocket height? Otherwise, this is confusing of using `POKT-UnitTest` with `eth_blockNumber`.

My suggestion:
1. POKT-UnitTest with REST payload getting `/v1/height`
2. ETH Goerli with `eth_blockNumber` and json RPC",,,,,229,RIGHT,222,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1236007137,Olshansk,f3bfe1387700a38296d89201c5e7cce3f78a63eb,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -0,0 +1,80 @@
+package local
+
+import (
+	""math/big""
+
+	""github.com/pokt-network/pocket/logger""
+	coreTypes ""github.com/pokt-network/pocket/shared/core/types""
+	""github.com/pokt-network/pocket/shared/modules""
+	""github.com/pokt-network/pocket/shared/modules/base_modules""
+)
+
+const (
+	LocalModuleName = ""local""
+)
+
+var _ modules.PersistenceLocalContext = &persistenceLocalContext{}
+
+type persistenceLocalContext struct {
+	base_modules.IntegratableModule
+
+	logger       *modules.Logger
+	databasePath string
+}
+
+func WithLocalContextConfig(databasePath string) modules.ModuleOption {",persistence/local/module.go,2023-06-20 23:37:03+00:00,2023-06-22T21:15:01Z,s/WithLocalContextConfig/WithLocalDatabsePath?,,,,,25,RIGHT,25,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1239027177,Olshansk,c276c99ca68e68a8fd3bdee9d286428534552f5b,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -116,92 +124,78 @@ func (s *servicer) HandleRelay(relay *coreTypes.Relay) (*coreTypes.RelayResponse
 		return nil, fmt.Errorf(""Error executing relay: %w"", err)
 	}
 
-	// DISCUSS: should we validate the response from the node?
-	relayDigest, shouldStore, err := s.hasCollision(relay, response)
+	// TODO(M6): Look into data integrity checks and response validation.
+
+	session, err := s.getSession(relay)
+	if err != nil {
+		return nil, err
+	}
+
+	relayDigest, relayReqResBytes, shouldStore, err := s.isRelayVolumeApplicable(session, relay, response)
 	if err != nil {
 		return nil, fmt.Errorf(""Error calculating relay service digest: %w"", err)
 	}
 	if !shouldStore {
 		return response, nil
 	}
 
-	height := s.GetBus().GetConsensusModule().CurrentHeight()
-	writeCtx, err := s.GetBus().GetPersistenceModule().NewRWContext(int64(height))
+	localCtx, err := s.GetBus().GetPersistenceModule().GetLocalContext()
 	if err != nil {
-		return nil, fmt.Errorf(""Error getting a write context to update token usage for application %s: %w"", relay.Meta.ApplicationAddress, err)
+		return nil, fmt.Errorf(""Error getting a local context to update token usage for application %s: %w"", relay.Meta.ApplicationAddress, err)
 	}
-	defer writeCtx.Release()
 
-	// DISCUSS: should we extend/use UnitOfWork for updating/retrieving token usage?
-	if err := writeCtx.RecordRelayService(relay.Meta.ApplicationAddress, relayDigest, relay, response); err != nil {
+	if err := localCtx.StoreServicedRelay(session, relayDigest, relayReqResBytes); err != nil {
 		return nil, fmt.Errorf(""Error recording service proof for application %s: %w"", relay.Meta.ApplicationAddress, err)
 	}
 
 	return response, nil
 }
 
-// hasCollision returns:
-//  1. The signed digest of a relay/response pair,
-//  2. Whether there was a collision for the specific chain (i.e. should the service proof be stored for claiming later)
-func (s *servicer) hasCollision(relay *coreTypes.Relay, response *coreTypes.RelayResponse) (digest []byte, collides bool, err error) {
-	relayBytes, err := marshal(relay, response)
+// isRelayVolumeApplicable returns:
+//  1. The signed digest of a relay/response pair
+//  2. Whether a legit relay eligible for claiming rewards
+//     Legit means satisfying at-least the following conditions: not-replay and having a proper signature,
+func (s *servicer) isRelayVolumeApplicable(session *coreTypes.Session, relay *coreTypes.Relay, response *coreTypes.RelayResponse) (digest, serializedRelayRes []byte, collides bool, err error) {
+	relayReqResBytes, err := codec.GetCodec().Marshal(&coreTypes.RelayReqRes{Relay: relay, Response: response})
 	if err != nil {
-		return nil, false, fmt.Errorf(""Error marshalling relay and/or response: %w"", err)
+		return nil, nil, false, fmt.Errorf(""Error marshalling relay and/or response: %w"", err)
 	}
 
-	relayDigest := crypto.SHA3Hash(relayBytes)
-
+	relayDigest := crypto.SHA3Hash(relayReqResBytes)
 	signedDigest := s.sign(relayDigest)
 	response.ServicerSignature = hex.EncodeToString(signedDigest)
-	collision, err := s.hasCollisionOnChain(relayDigest, relay.Meta.RelayChain.Id)
+	collision, err := s.isRelayVolumeApplicableOnChain(session, relayDigest)
 	if err != nil {
-		return nil, false, fmt.Errorf(""Error checking collision for chain %s: %w"", relay.Meta.RelayChain.Id, err)
+		return nil, nil, false, fmt.Errorf(""Error checking for relay replay by app %s for chain %s during session number %d: %w"",
+			session.Application.Address, relay.Meta.RelayChain.Id, session.SessionNumber, err)
 	}
 
-	return signedDigest, collision, nil
+	return signedDigest, relayReqResBytes, collision, nil
 }
 
-// INCOMPLETE: implement this
+// INCOMPLETE(#832): provide a private key to the servicer and use it to sign all relays
 func (s *servicer) sign(bz []byte) []byte {
 	return bz
 }
 
-// INCOMPLETE: implement this
-func (s *servicer) hasCollisionOnChain(digest []byte, relayChainId string) (bool, error) {
+// INCOMPLETE: implement this according to the comment below
+// isRelayVolumeApplicableOnChain returns whether the serialized serviced relay and the response, provided as `digest`, is eligible for reward
+//
+//	on the service/chain corresponding to the provided session.
+func (s *servicer) isRelayVolumeApplicableOnChain(session *coreTypes.Session, digest []byte) (bool, error) {
 	return false, nil
 }
 
-func marshal(request *coreTypes.Relay, response *coreTypes.RelayResponse) ([]byte, error) {
-	if request == nil || response == nil {
-		return nil, fmt.Errorf(""error marshalling: got nil value as input"")
-	}
-
-	s := struct {
-		*coreTypes.Relay
-		*coreTypes.RelayResponse
-	}{
-		request,
-		response,
-	}
-	return json.Marshal(s)
-}
-
-// executeRelay performs the passed relay using an HTTP request to the chain-specific target URL
+// executeRelay performs the passed relay using the correct method depending on the relay payload type.
 func (s *servicer) executeRelay(relay *coreTypes.Relay) (*coreTypes.RelayResponse, error) {
-	if relay.Meta == nil || relay.Meta.RelayChain == nil || relay.Meta.RelayChain.Id == """" {
-		return nil, fmt.Errorf(""Relay for application %s does not specify relay chain"", relay.Meta.ApplicationAddress)
-	}
-
-	chainConfig, ok := s.config.Chains[relay.Meta.RelayChain.Id]
-	if !ok {
-		return nil, fmt.Errorf(""Chain %s not found in servicer configuration: %w"", relay.Meta.RelayChain.Id, errValidateRelayMeta)
-	}
-
-	res, err := executeHTTPRequest(chainConfig, relay.Payload)
-	if err != nil {
-		return nil, fmt.Errorf(""Error executing HTTP request for relay on application %s: %w"", relay.Meta.ApplicationAddress, err)
+	switch payload := relay.RelayPayload.(type) {
+	case *coreTypes.Relay_JsonRpcPayload:
+		return s.executeHTTPRelay(relay.Meta, payload.JsonRpcPayload)
+	case *coreTypes.Relay_RestPayload:
+		return nil, fmt.Errorf(""Error executing relay on application %s: REST not supported"", relay.Meta.ApplicationAddress)
+	default:
+		return nil, fmt.Errorf(""Error exeucting relay on application %s: Unsupported type on payload %s"", relay.Meta.ApplicationAddress, payload)",utility/servicer/module.go,2023-06-22 21:00:58+00:00,2023-06-22T21:15:01Z,"```suggestion
		return nil, fmt.Errorf(""Error executing relay on application %s: Unsupported type on payload %s"", relay.Meta.ApplicationAddress, payload)
```",,,,,197,RIGHT,202,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1239032840,Olshansk,c276c99ca68e68a8fd3bdee9d286428534552f5b,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -92,15 +107,60 @@ func ParseConfig(cfgFile string) *Config {
 	return config
 }
 
-// setViperDefaults this is a hacky way to set the default values for Viper so env var overrides work.
+// adjustConfigDefaults performs the necessary adjustments on the default configuration depending on the provided custom configuration.",runtime/configs/config.go,2023-06-22 21:08:22+00:00,2023-06-22T21:15:01Z,"Maybe `hydrateDefaultConfigs` is a better choice of words for this?

Not a blocker, but just thinking out loud",,,,,110,RIGHT,62,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1239034919,Olshansk,c276c99ca68e68a8fd3bdee9d286428534552f5b,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -36,7 +36,10 @@ type Config struct {
 ",runtime/configs/config.go,2023-06-22 21:11:15+00:00,2023-06-22T21:15:01Z,"Lots of config changes here towards the end of the review. It's hard for me to evaluate if there are any issues (configs are always tricky), so I'm going to assume the ordering of things is correct and tested.",,,,,36,RIGHT,1,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1239035137,Olshansk,c276c99ca68e68a8fd3bdee9d286428534552f5b,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -5,11 +5,34 @@ package configs;
 
 option go_package = ""github.com/pokt-network/pocket/runtime/configs"";
 
+// TODO: Reevalute whether each utility actor should contain address/pubKey configs or if it should be shared",runtime/configs/proto/servicer_config.proto,2023-06-22 21:11:35+00:00,2023-06-22T21:15:01Z,"```suggestion
// TODO: Reevaluate whether each utility actor should contain address/pubKey configs or if it should be shared
```",,,,,8,RIGHT,4,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1242893399,Olshansk,b758fef6d3a7c6f14d521d19ce2c2d7c1086d35a,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -248,6 +264,7 @@ func testServicerConfig() configs.ServicerConfig {
 		Address:   testServicer1.Address,
 		Services: map[string]*configs.ServiceConfig{",utility/servicer/module_test.go,2023-06-26 22:53:10+00:00,2023-06-26T22:53:10Z,Thank you for taking the time to update the tests based on all my requests. Goes a long way!,,,,265.0,265,RIGHT,49,288.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1242894357,Olshansk,b758fef6d3a7c6f14d521d19ce2c2d7c1086d35a,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -465,6 +465,15 @@ func (s *servicer) executeHTTPRelay(meta *coreTypes.RelayMeta, payload *coreType
 	return &coreTypes.RelayResponse{Payload: string(body)}, nil
 }
 
+// INCOMPLETE(#860): RESTful service relays: basic checks and execution through HTTP calls
+func (s *servicer) executeRESTRelay(meta *coreTypes.RelayMeta, _ *coreTypes.RESTPayload) (*coreTypes.RelayResponse, error) {
+	_, ok := s.config.Services[meta.RelayChain.Id]
+	if !ok {",utility/servicer/module.go,2023-06-26 22:55:00+00:00,2023-06-26T22:55:00Z,"```suggestion
	if _, ok := s.config.Services[meta.RelayChain.Id]; {
```",,470.0,RIGHT,,471,RIGHT,19,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1242899644,Olshansk,b758fef6d3a7c6f14d521d19ce2c2d7c1086d35a,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -192,9 +192,9 @@ func (s *servicer) executeRelay(relay *coreTypes.Relay) (*coreTypes.RelayRespons
 	case *coreTypes.Relay_JsonRpcPayload:
 		return s.executeHTTPRelay(relay.Meta, payload.JsonRpcPayload)
 	case *coreTypes.Relay_RestPayload:
-		return nil, fmt.Errorf(""Error executing relay on application %s: REST not supported"", relay.Meta.ApplicationAddress)
+		return s.executeRESTRelay(relay.Meta, payload.RestPayload)",utility/servicer/module.go,2023-06-26 23:02:52+00:00,2023-06-26T23:03:37Z,"My last NIT on this PR is just the naming and comments of these functions.

In the switch statement, we have:
`case *coreTypes.Relay_JsonRpcPayload:` -> `s.executeHTTPRelay(`
`case *coreTypes.Relay_RestPayload` -> `s.executeRESTRelay`

The first header is:

```go
// executeHTTPRequest performs the HTTP request that sends the relay to the chain's/service's URL.
func (s *servicer) executeHTTPRelay(meta *coreTypes.RelayMeta, payload *coreTypes.JSONRPCPayload) (*coreTypes.RelayResponse, error) {
```

The second header is:

```go
// INCOMPLETE(#860): RESTful service relays: basic checks and execution through HTTP calls
func (s *servicer) executeRESTRelay(meta *coreTypes.RelayMeta, _ *coreTypes.RESTPayload) (*coreTypes.RelayResponse, error) {
```

My suggestion is this:

```go
// executeJsonRPCRelay performs the relay for JSON-RPC payloads, sending them to the chain's/service's URL.
func (s *servicer) executeJsonRPCRelay(meta *coreTypes.RelayMeta, payload *coreTypes.JSONRPCPayload) (*coreTypes.RelayResponse, error) {
```

```go
// executeRESTRelay performs the relay for REST payloads, sending them to the chain's/service's URL.
// INCOMPLETE(#860): RESTful service relays: basic checks and execution through HTTP calls.
func (s *servicer) executeRESTRelay(meta *coreTypes.RelayMeta, _ *coreTypes.RESTPayload) (*coreTypes.RelayResponse, error) {
```

If the REST (a design pattern) payload needs to use `httpRelay` under the hood, that's fine.
If the JSON RPC (a specific protocol) leverages `httpRelay` under the hood (but could theoretically operate over gRPC or a weboscket if we wanted it to), that's fine.

Wdyt?",,,,195.0,195,RIGHT,5,159.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/pokt-network/pocket/pulls/803,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1246981101,Olshansk,e8021e316655513828bb1c2ee2febbdd69aaf1a2,bc1f3d49b1468f708ef33dbe81c4b8b43d1b100e,"@@ -424,26 +424,43 @@ func (s *servicer) executeHTTPRelay(meta *coreTypes.RelayMeta, payload *coreType
 		return nil, fmt.Errorf(""Chain %s not found in servicer configuration: %w"", meta.RelayChain.Id, errValidateRelayMeta)
 	}
 
-	serviceUrl, err := url.Parse(serviceConfig.Url)
+	relayBytes, err := codec.GetCodec().Marshal(payload)
 	if err != nil {
-		return nil, fmt.Errorf(""Error parsing chain URL %s: %w"", serviceConfig.Url, err)
+		return nil, fmt.Errorf(""Error marshalling payload %s: %w"", payload.String(), err)
 	}
 
-	relayBytes, err := codec.GetCodec().Marshal(payload)
+	return s.executeHTTPRelay(serviceConfig, relayBytes, payload.Headers)
+}
+
+// executeRESTRelay performs the relay for REST payloads, sending them to the chain's/service's URL.
+// INCOMPLETE(#860): RESTful service relays: basic checks and execution through HTTP calls.
+func (s *servicer) executeRESTRelay(meta *coreTypes.RelayMeta, _ *coreTypes.RESTPayload) (*coreTypes.RelayResponse, error) {
+	_, ok := s.config.Services[meta.RelayChain.Id]
+	if !ok {
+		return nil, fmt.Errorf(""Chain %s not found in servicer configuration: %w"", meta.RelayChain.Id, errValidateRelayMeta)
+	}
+	return nil, nil
+}
+
+// executeHTTPRequest performs the HTTP request that sends the relay to the chain's/service's URL.
+func (s *servicer) executeHTTPRelay(serviceConfig *configs.ServiceConfig, payload []byte, headers map[string]string) (*coreTypes.RelayResponse, error) {
+	serviceUrl, err := url.Parse(serviceConfig.Url)
 	if err != nil {
-		return nil, fmt.Errorf(""Error marshalling payload %s: %w"", payload.String(), err)
+		return nil, fmt.Errorf(""Error parsing chain URL %s: %w"", serviceConfig.Url, err)
 	}
 
-	req, err := http.NewRequest(http.MethodPost, serviceUrl.String(), bytes.NewBuffer(relayBytes))
+	req, err := http.NewRequest(http.MethodPost, serviceUrl.String(), bytes.NewBuffer(payload))
 	if err != nil {
 		return nil, err
 	}
-	if serviceConfig.BasicAuth != nil && serviceConfig.BasicAuth.UserName != """" {
-		req.SetBasicAuth(serviceConfig.BasicAuth.UserName, serviceConfig.BasicAuth.Password)
+
+	auth := serviceConfig.BasicAuth
+	if auth != nil && auth.UserName != """" {",utility/servicer/module.go,2023-06-29 18:42:52+00:00,2023-06-29T18:43:17Z,Optional NIT: single line?,,457.0,RIGHT,,458,RIGHT,62,,line,https://api.github.com/repos/pokt-network/pocket/pulls/803,pokt-network/pocket,208ffbb29eee2f2d603aacf373b1a0fa7d8c9daa
https://api.github.com/repos/UnUniFi/chain/pulls/493,https://api.github.com/repos/UnUniFi/chain/pulls/comments/1168298776,jununifi,99df9307867db0e8b4fb464c31875306612d7042,f088ef22c013606d031781f94fa111db425a0bbd,"@@ -62,3 +62,10 @@ func IsValidDepositForPool(deposit sdk.Coin, acceptableAssets []PoolAssetConf) b
 	}
 	return false
 }
+
+// CalcTargetAmountInPool is used to calculate the target amount of the asset in the pool.
+// The target amount is calculated by the formula:
+// targetAmount = poolMarketCap * weight / price
+func CalcTargetAmountInPool(weight, price, poolMarketCap sdk.Dec) sdk.Int {
+	return poolMarketCap.Mul(weight).Quo(price).TruncateInt()",x/derivatives/types/pool.go,2023-04-17 07:36:41+00:00,2023-04-17T07:36:42Z,I think price zero case should be considered,,,,70.0,70,RIGHT,9,9.0,line,https://api.github.com/repos/UnUniFi/chain/pulls/493,UnUniFi/chain,bd7b928e58af47abc818cf3be6b0412a535f65d3
https://api.github.com/repos/UnUniFi/chain/pulls/493,https://api.github.com/repos/UnUniFi/chain/pulls/comments/1168299291,jununifi,99df9307867db0e8b4fb464c31875306612d7042,f088ef22c013606d031781f94fa111db425a0bbd,"@@ -27,19 +27,16 @@ const (
 )
 
 const (
+	// TODO: KeyPrefixDerivativesSubpoolAssets is unused. Remove it if it won't be necesary.
 	// subpool assets
 	KeyPrefixDerivativesSubpoolAssets = ""subpool_assets""
-	// user deposited real assets
-	KeyPrefixDerivativesUserDepositedAssets = ""user_deposited_assets""
-	// User deposits by address
-	KeyPrefixPoolDeposit = ""pool_deposit""
-	//
-	KeyPrefixPosition              = ""position""
-	KeyPrefixUserPosition          = ""user_position""
-	KeyPrefixPerpetualFutures      = ""perpetual_futures""
-	KeyPrefixPerpetualOptions      = ""perpetual_options""
-	KeyPrefixNetPositionAmount     = ""net_position_amount""
-	KeyPrefixLastPositionId        = ""last_position_id""
+	KeyPrefixPosition                 = ""position""
+	KeyPrefixUserPosition             = ""user_position""
+	KeyPrefixPerpetualFutures         = ""perpetual_futures""
+	KeyPrefixPerpetualOptions         = ""perpetual_options""
+	KeyPrefixNetPositionAmount        = ""net_position_amount""
+	KeyPrefixLastPositionId           = ""last_position_id""
+	// TODO: KeyPrefixAccumulatedFee is unused. Remove it if it won't be necesary.
 	KeyPrefixAccumulatedFee        = ""accumulated_fee""",x/derivatives/types/keys.go,2023-04-17 07:37:17+00:00,2023-04-17T07:37:17Z,@KimuraYu45z this item will need to be removed?,,,,40.0,40,RIGHT,25,25.0,line,https://api.github.com/repos/UnUniFi/chain/pulls/493,UnUniFi/chain,bd7b928e58af47abc818cf3be6b0412a535f65d3
https://api.github.com/repos/UnUniFi/chain/pulls/493,https://api.github.com/repos/UnUniFi/chain/pulls/comments/1168300350,jununifi,99df9307867db0e8b4fb464c31875306612d7042,f088ef22c013606d031781f94fa111db425a0bbd,"@@ -37,28 +37,13 @@ func (k Keeper) IsAssetAcceptable(ctx sdk.Context, denom string) bool {
 	return false
 }
 
-// TODO: delete below fn and replace it with the bank query for the specific module account balance of the liquidity pool
-// TODO: The name GetAssetBalance is weird. We need to change the name like ""GetAssetAmountInPool""
-// TODO: Furthermore, is this really needed? Can we just use the bankKeeper function of getBalance for pool module account?
-func (k Keeper) GetAssetBalance(ctx sdk.Context, denom string) sdk.Coin {
-	store := ctx.KVStore(k.storeKey)
-	bz := store.Get(types.AssetDepositKeyPrefix(denom))
-	if bz == nil {
-		return sdk.NewCoin(denom, sdk.ZeroInt())
-	}
-
-	coin := sdk.Coin{}
-	k.cdc.MustUnmarshal(bz, &coin)
-
-	return coin
-}
-
-func (k Keeper) SetAssetBalance(ctx sdk.Context, coin sdk.Coin) {
-	store := ctx.KVStore(k.storeKey)
-	bz := k.cdc.MustMarshal(&coin)
-	store.Set(types.AssetDepositKeyPrefix(coin.Denom), bz)
+// GetAssetBalanceInPoolByDenom is used to get token balance of ""derivatives"" module account which is the liquidity pool.
+func (k Keeper) GetAssetBalanceInPoolByDenom(ctx sdk.Context, denom string) sdk.Coin {
+	derivModAddr := k.accountKeeper.GetModuleAddress(types.ModuleName)",x/derivatives/keeper/pool.go,2023-04-17 07:38:21+00:00,2023-04-17T07:38:21Z,"Module address can be fetched without account keeper.
Same result can be fetched with `authtypes.NewModuleAddress(types.ModuleName)`",,,,,42,RIGHT,26,,line,https://api.github.com/repos/UnUniFi/chain/pulls/493,UnUniFi/chain,bd7b928e58af47abc818cf3be6b0412a535f65d3
https://api.github.com/repos/UnUniFi/chain/pulls/493,https://api.github.com/repos/UnUniFi/chain/pulls/comments/1168301443,jununifi,99df9307867db0e8b4fb464c31875306612d7042,f088ef22c013606d031781f94fa111db425a0bbd,"@@ -29,3 +30,8 @@ type PricefeedKeeper interface {
 	// These are used for testing TODO replace mockApp with keeper in tests to remove these
 	SetParams(sdk.Context, pftypes.Params)
 }
+
+type AccountKeeper interface {",x/derivatives/types/expected_keepers.go,2023-04-17 07:39:25+00:00,2023-04-17T07:39:26Z,I think account keeper is not used other than GetModuleAddress and this could be removed if there's no further use case since GetModuleAddress can be replaced with authtypes.NewModuleAddress,,,,,34,RIGHT,13,,line,https://api.github.com/repos/UnUniFi/chain/pulls/493,UnUniFi/chain,bd7b928e58af47abc818cf3be6b0412a535f65d3
https://api.github.com/repos/QuickSwap/interface-v2/pulls/969,https://api.github.com/repos/QuickSwap/interface-v2/pulls/comments/1305406610,sameepsi,605849129767dc1c1a27af42f002ba2525e1d4a0,048ae163df131c52a32b9d8d7d505f3664d94fc5,"@@ -17,6 +17,7 @@
     ""bestTrade"": true,
     ""proMode"": true,
     ""limitOrder"": true,
+    ""liquidityHub"": true,",src/config/polygon.json,2023-08-25 09:11:26+00:00,2023-08-25T09:11:42Z,Please set this variable as false in other networks config files.,,,,20.0,20,RIGHT,4,4.0,line,https://api.github.com/repos/QuickSwap/interface-v2/pulls/969,QuickSwap/interface-v2,b95a24a0434cb5153df2b6f2103f1bf3d7624a91
https://api.github.com/repos/pokt-network/pocket/pulls/804,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1218418707,dylanlott,094a95e15311c61707e1e16a9311ac44deae6faa,2e4d60de826d651aa7d182e913300f4c16a09871,"@@ -0,0 +1,72 @@
+package persistence
+
+import (
+	""fmt""
+
+	""github.com/pokt-network/pocket/p2p/providers/peerstore_provider""
+	typesP2P ""github.com/pokt-network/pocket/p2p/types""
+	""github.com/pokt-network/pocket/shared/modules""
+	""github.com/pokt-network/pocket/shared/modules/base_modules""
+)
+
+var (
+	_ peerstore_provider.PeerstoreProvider = &p2pPeerstoreProvider{}
+	_ p2pPStoreProviderFactory             = &p2pPeerstoreProvider{}
+)
+
+// unstakedPeerstoreProvider is an interface which the p2p module supports in
+// order to allow access to the unstaked-actor-router's peerstore
+//
+// TECHDEBT(#xxx): will become unnecessary after `modules.P2PModule#GetUnstakedPeerstore` is added.`
+// CONSIDERATION: split `PeerstoreProvider` into `StakedPeerstoreProvider` and `UnstakedPeerstoreProvider`.
+// (see: https://github.com/pokt-network/pocket/pull/804#issuecomment-1576531916)
+type unstakedPeerstoreProvider interface {
+	GetUnstakedPeerstore() (typesP2P.Peerstore, error)
+}
+
+type p2pPStoreProviderFactory = modules.Factory[peerstore_provider.PeerstoreProvider]
+
+type p2pPeerstoreProvider struct {
+	base_modules.IntegratableModule
+	persistencePeerstoreProvider
+
+	p2pModule modules.P2PModule
+}
+
+func NewP2PPeerstoreProvider(
+	bus modules.Bus,
+) (peerstore_provider.PeerstoreProvider, error) {
+	return new(p2pPeerstoreProvider).Create(bus)
+}
+
+func (*p2pPeerstoreProvider) Create(
+	bus modules.Bus,
+) (peerstore_provider.PeerstoreProvider, error) {
+	if bus == nil {
+		return nil, fmt.Errorf(""bus is required"")
+	}
+
+	p2pModule := bus.GetP2PModule()
+	if p2pModule == nil {
+		return nil, fmt.Errorf(""p2p module is not registered to bus and is required"")",p2p/providers/peerstore_provider/persistence/p2p.go,2023-06-05 18:05:04+00:00,2023-06-05T18:12:15Z,Nit: consider passing the bus to the Errrof for debugging purposes. ,,,,,51,RIGHT,51,,line,https://api.github.com/repos/pokt-network/pocket/pulls/804,pokt-network/pocket,9cb0ee93d1dc34449b90a9c8487366a3a2abbe38
https://api.github.com/repos/pokt-network/pocket/pulls/804,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1218420373,dylanlott,094a95e15311c61707e1e16a9311ac44deae6faa,2e4d60de826d651aa7d182e913300f4c16a09871,"@@ -4,23 +4,29 @@ package modules
 // a variadic `ModuleOption` argument(s) and returns a `Module`and an error.
 type ModuleFactoryWithOptions FactoryWithOptions[Module, ModuleOption]
 
-// FactoryWithConfig implements a `#Create()` factory method which takes a
-// required ""config"" argument of type K and returns a value of type T and an error.
+// Factory implements a `#Create()` factory method which takes a bus and returns
+// a value of type T and an error.
+type Factory[T interface{}] interface {
+	Create(bus Bus) (T, error)
+}
+
+// FactoryWithConfig implements a `#Create()` factory method which takes a bus and
+// a required ""config"" argument of type K and returns a value of type T and an error.
 // TECHDEBT: apply enforcement across applicable ""sub-modules"" (see: `p2p/raintree/router.go`: `raintTreeFactory`)
 type FactoryWithConfig[T interface{}, K interface{}] interface {
 	Create(bus Bus, cfg K) (T, error)
 }
 
-// FactoryWithOptions implements a `#Create()` factory method which takes a
-// variadic ""optional"" argument(s) of type O and returns a value of type T
+// FactoryWithOptions implements a `#Create()` factory method which takes a bus
+// and a variadic ""optional"" argument(s) of type O and returns a value of type T
 // and an error.
 // TECHDEBT: apply enforcement across applicable ""sub-modules""
 type FactoryWithOptions[T interface{}, O interface{}] interface {
 	Create(bus Bus, opts ...O) (T, error)
 }
 
-// FactoryWithConfigAndOptions implements a `#Create()` factory method which
-// takes both a required ""config"" argument of type K and a variadic ""optional""
+// FactoryWithConfigAndOptions implements a `#Create()` factory method which takes
+// a bus and both a required ""config"" argument of type K and a variadic ""optional""",shared/modules/factory.go,2023-06-05 18:07:03+00:00,2023-06-05T18:12:15Z,"Nit: I think this should read as `a bus, a required ""config"", and a variadic ""optional""`",,,,,29,RIGHT,32,,line,https://api.github.com/repos/pokt-network/pocket/pulls/804,pokt-network/pocket,9cb0ee93d1dc34449b90a9c8487366a3a2abbe38
https://api.github.com/repos/pokt-network/pocket/pulls/804,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1218421884,dylanlott,094a95e15311c61707e1e16a9311ac44deae6faa,2e4d60de826d651aa7d182e913300f4c16a09871,"@@ -7,6 +7,11 @@ and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0
 
 ## [Unreleased]
 
+## [0.0.0.60] - 2023-06-05
+
+- Added `Factory` generic type",shared/CHANGELOG.md,2023-06-05 18:08:32+00:00,2023-06-05T18:12:15Z,💯 Great spot for a good generic 🚀,,,,12.0,12,RIGHT,6,6.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/804,pokt-network/pocket,9cb0ee93d1dc34449b90a9c8487366a3a2abbe38
https://api.github.com/repos/pokt-network/pocket/pulls/804,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1218424440,dylanlott,094a95e15311c61707e1e16a9311ac44deae6faa,2e4d60de826d651aa7d182e913300f4c16a09871,"@@ -4,23 +4,29 @@ package modules
 // a variadic `ModuleOption` argument(s) and returns a `Module`and an error.
 type ModuleFactoryWithOptions FactoryWithOptions[Module, ModuleOption]
 
-// FactoryWithConfig implements a `#Create()` factory method which takes a
-// required ""config"" argument of type K and returns a value of type T and an error.
+// Factory implements a `#Create()` factory method which takes a bus and returns
+// a value of type T and an error.
+type Factory[T interface{}] interface {",shared/modules/factory.go,2023-06-05 18:11:13+00:00,2023-06-05T18:12:15Z,"Would this be better declared as an any instead of an interface? I think they're functionally identical, but any seems more appropriate in the context of generics.",,,,,9,RIGHT,8,,line,https://api.github.com/repos/pokt-network/pocket/pulls/804,pokt-network/pocket,9cb0ee93d1dc34449b90a9c8487366a3a2abbe38
https://api.github.com/repos/pokt-network/pocket/pulls/804,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1218651942,Olshansk,094a95e15311c61707e1e16a9311ac44deae6faa,2e4d60de826d651aa7d182e913300f4c16a09871,"@@ -16,10 +15,10 @@ const ModuleName = ""peerstore_provider""
 
 // PeerstoreProvider is an interface that provides Peerstore accessors
 type PeerstoreProvider interface {
-	modules.Module
+	modules.IntegratableModule
 
 	GetStakedPeerstoreAtHeight(height uint64) (typesP2P.Peerstore, error)
-	GetP2PConfig() *configs.P2PConfig
+	GetUnstakedPeerstore() (typesP2P.Peerstore, error)",p2p/providers/peerstore_provider/peerstore_provider.go,2023-06-05 22:20:08+00:00,2023-06-06T20:47:28Z,Can you add a few comments to these functions?,,,,26.0,21,RIGHT,17,22.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/804,pokt-network/pocket,9cb0ee93d1dc34449b90a9c8487366a3a2abbe38
https://api.github.com/repos/pokt-network/pocket/pulls/804,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1218653938,Olshansk,094a95e15311c61707e1e16a9311ac44deae6faa,2e4d60de826d651aa7d182e913300f4c16a09871,"@@ -15,6 +17,7 @@ type persistencePeerstoreProvider struct {
 	base_modules.InterruptableModule
 }
 
+// TECHDEBT: refactor",p2p/providers/peerstore_provider/persistence/persistence.go,2023-06-05 22:21:50+00:00,2023-06-06T20:47:28Z,Please add a couple of details on what kind of refactor you had in mind.,,,,,20,RIGHT,13,,line,https://api.github.com/repos/pokt-network/pocket/pulls/804,pokt-network/pocket,9cb0ee93d1dc34449b90a9c8487366a3a2abbe38
https://api.github.com/repos/pokt-network/pocket/pulls/804,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1218655296,Olshansk,094a95e15311c61707e1e16a9311ac44deae6faa,2e4d60de826d651aa7d182e913300f4c16a09871,"@@ -56,3 +61,7 @@ func (pabp *persistencePeerstoreProvider) GetStakedPeerstoreAtHeight(height uint
 func (pabp *persistencePeerstoreProvider) GetP2PConfig() *configs.P2PConfig {
 	return pabp.GetBus().GetRuntimeMgr().GetConfig().P2P
 }
+
+func (pabp *persistencePeerstoreProvider) GetUnstakedPeerstore() (typesP2P.Peerstore, error) {
+	return nil, fmt.Errorf(""persistence peerstore provider does not support unstaked peerstore"")",p2p/providers/peerstore_provider/persistence/persistence.go,2023-06-05 22:22:53+00:00,2023-06-06T20:47:28Z,Please add a comment as to why,,,,,66,RIGHT,36,,line,https://api.github.com/repos/pokt-network/pocket/pulls/804,pokt-network/pocket,9cb0ee93d1dc34449b90a9c8487366a3a2abbe38
https://api.github.com/repos/pokt-network/pocket/pulls/804,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1220300730,Olshansk,8d1f62a44eb25be452aea76ea5ca5bfcbff5a21c,2e4d60de826d651aa7d182e913300f4c16a09871,"@@ -0,0 +1,72 @@
+package persistence
+
+import (
+	""fmt""
+
+	""github.com/pokt-network/pocket/p2p/providers/peerstore_provider""
+	typesP2P ""github.com/pokt-network/pocket/p2p/types""
+	""github.com/pokt-network/pocket/shared/modules""
+	""github.com/pokt-network/pocket/shared/modules/base_modules""
+)
+
+var (
+	_ peerstore_provider.PeerstoreProvider = &p2pPeerstoreProvider{}
+	_ p2pPStoreProviderFactory             = &p2pPeerstoreProvider{}
+)
+
+// unstakedPeerstoreProvider is an interface which the p2p module supports in
+// order to allow access to the unstaked-actor-router's peerstore",p2p/providers/peerstore_provider/persistence/p2p.go,2023-06-06 20:34:50+00:00,2023-06-06T20:47:28Z,"```suggestion
// order to allow access to the unstaked-actor-router's (i.e. actors, full and light nodes) peerstore
```",,,,,18,RIGHT,18,,line,https://api.github.com/repos/pokt-network/pocket/pulls/804,pokt-network/pocket,9cb0ee93d1dc34449b90a9c8487366a3a2abbe38
https://api.github.com/repos/pokt-network/pocket/pulls/804,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1220310968,Olshansk,8d1f62a44eb25be452aea76ea5ca5bfcbff5a21c,2e4d60de826d651aa7d182e913300f4c16a09871,"@@ -14,6 +14,8 @@ type P2PModule interface {
 
 	// Returns the public P2P address of this node
 	GetAddress() (cryptoPocket.Address, error)
+	// TECHDEBT(#xxx): uncomment after moving `typesP2P.Peerstore` interface to a shared package",shared/modules/p2p_module.go,2023-06-06 20:37:49+00:00,2023-06-06T20:47:28Z,Can you create a ticket to track this and update all the #xxx?,,,,,17,RIGHT,4,,line,https://api.github.com/repos/pokt-network/pocket/pulls/804,pokt-network/pocket,9cb0ee93d1dc34449b90a9c8487366a3a2abbe38
https://api.github.com/repos/pokt-network/pocket/pulls/804,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1220318622,Olshansk,8d1f62a44eb25be452aea76ea5ca5bfcbff5a21c,2e4d60de826d651aa7d182e913300f4c16a09871,"@@ -4,25 +4,31 @@ package modules
 // a variadic `ModuleOption` argument(s) and returns a `Module`and an error.
 type ModuleFactoryWithOptions FactoryWithOptions[Module, ModuleOption]
 
-// FactoryWithConfig implements a `#Create()` factory method which takes a
-// required ""config"" argument of type K and returns a value of type T and an error.
+// Factory implements a `#Create()` factory method which takes a bus and returns
+// a value of type T and an error.
+type Factory[T any] interface {
+	Create(bus Bus) (T, error)
+}
+
+// FactoryWithConfig implements a `#Create()` factory method which takes a bus and",shared/modules/factory.go,2023-06-06 20:40:18+00:00,2023-06-06T20:47:29Z,NIT: Thoughts on `s/T/M/g` and `s/K/C/g/` to represent `M`odule and `C`onfig respectively,,,,13.0,13,RIGHT,12,12.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/804,pokt-network/pocket,9cb0ee93d1dc34449b90a9c8487366a3a2abbe38
https://api.github.com/repos/pokt-network/pocket/pulls/804,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1220322441,Olshansk,8d1f62a44eb25be452aea76ea5ca5bfcbff5a21c,2e4d60de826d651aa7d182e913300f4c16a09871,"@@ -4,25 +4,31 @@ package modules
 // a variadic `ModuleOption` argument(s) and returns a `Module`and an error.
 type ModuleFactoryWithOptions FactoryWithOptions[Module, ModuleOption]",shared/modules/factory.go,2023-06-06 20:41:36+00:00,2023-06-06T20:47:29Z,Should we add other types like `type ModuleFactory Factory[Module]` as well?,,,,5.0,5,RIGHT,2,2.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/804,pokt-network/pocket,9cb0ee93d1dc34449b90a9c8487366a3a2abbe38
https://api.github.com/repos/pokt-network/pocket/pulls/804,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1220328623,Olshansk,8d1f62a44eb25be452aea76ea5ca5bfcbff5a21c,2e4d60de826d651aa7d182e913300f4c16a09871,"@@ -0,0 +1,72 @@
+package persistence
+
+import (
+	""fmt""
+
+	""github.com/pokt-network/pocket/p2p/providers/peerstore_provider""
+	typesP2P ""github.com/pokt-network/pocket/p2p/types""
+	""github.com/pokt-network/pocket/shared/modules""
+	""github.com/pokt-network/pocket/shared/modules/base_modules""
+)
+
+var (
+	_ peerstore_provider.PeerstoreProvider = &p2pPeerstoreProvider{}
+	_ p2pPStoreProviderFactory             = &p2pPeerstoreProvider{}
+)
+
+// unstakedPeerstoreProvider is an interface which the p2p module supports in
+// order to allow access to the unstaked-actor-router's peerstore
+//
+// TECHDEBT(#xxx): will become unnecessary after `modules.P2PModule#GetUnstakedPeerstore` is added.`
+// CONSIDERATION: split `PeerstoreProvider` into `StakedPeerstoreProvider` and `UnstakedPeerstoreProvider`.",p2p/providers/peerstore_provider/persistence/p2p.go,2023-06-06 20:44:15+00:00,2023-06-06T20:47:29Z,"I didn't have time to dive into your mind map (too many other reviews right now) but at a high-level, getting access to staked & unstaked peers should not be debug-only IMO.",,,,,21,RIGHT,21,,line,https://api.github.com/repos/pokt-network/pocket/pulls/804,pokt-network/pocket,9cb0ee93d1dc34449b90a9c8487366a3a2abbe38
https://api.github.com/repos/pokt-network/pocket/pulls/804,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1220329502,Olshansk,8d1f62a44eb25be452aea76ea5ca5bfcbff5a21c,2e4d60de826d651aa7d182e913300f4c16a09871,"@@ -0,0 +1,72 @@
+package persistence
+
+import (
+	""fmt""
+
+	""github.com/pokt-network/pocket/p2p/providers/peerstore_provider""
+	typesP2P ""github.com/pokt-network/pocket/p2p/types""
+	""github.com/pokt-network/pocket/shared/modules""
+	""github.com/pokt-network/pocket/shared/modules/base_modules""
+)
+
+var (
+	_ peerstore_provider.PeerstoreProvider = &p2pPeerstoreProvider{}
+	_ p2pPStoreProviderFactory             = &p2pPeerstoreProvider{}
+)
+
+// unstakedPeerstoreProvider is an interface which the p2p module supports in
+// order to allow access to the unstaked-actor-router's peerstore
+//
+// TECHDEBT(#xxx): will become unnecessary after `modules.P2PModule#GetUnstakedPeerstore` is added.`
+// CONSIDERATION: split `PeerstoreProvider` into `StakedPeerstoreProvider` and `UnstakedPeerstoreProvider`.
+// (see: https://github.com/pokt-network/pocket/pull/804#issuecomment-1576531916)
+type unstakedPeerstoreProvider interface {
+	GetUnstakedPeerstore() (typesP2P.Peerstore, error)
+}
+
+type p2pPStoreProviderFactory = modules.Factory[peerstore_provider.PeerstoreProvider]
+
+type p2pPeerstoreProvider struct {
+	base_modules.IntegratableModule
+	persistencePeerstoreProvider
+
+	p2pModule modules.P2PModule",p2p/providers/peerstore_provider/persistence/p2p.go,2023-06-06 20:44:58+00:00,2023-06-06T20:47:29Z,Storing a reference to `p2pModule` feels like an antipattern. You should always be able to access it via the bus and everyone stores a reference to the bus.,,,,,33,RIGHT,33,,line,https://api.github.com/repos/pokt-network/pocket/pulls/804,pokt-network/pocket,9cb0ee93d1dc34449b90a9c8487366a3a2abbe38
https://api.github.com/repos/pokt-network/pocket/pulls/804,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1220330923,Olshansk,8d1f62a44eb25be452aea76ea5ca5bfcbff5a21c,2e4d60de826d651aa7d182e913300f4c16a09871,"@@ -0,0 +1,72 @@
+package persistence
+
+import (
+	""fmt""
+
+	""github.com/pokt-network/pocket/p2p/providers/peerstore_provider""
+	typesP2P ""github.com/pokt-network/pocket/p2p/types""
+	""github.com/pokt-network/pocket/shared/modules""
+	""github.com/pokt-network/pocket/shared/modules/base_modules""
+)
+
+var (
+	_ peerstore_provider.PeerstoreProvider = &p2pPeerstoreProvider{}
+	_ p2pPStoreProviderFactory             = &p2pPeerstoreProvider{}
+)
+
+// unstakedPeerstoreProvider is an interface which the p2p module supports in
+// order to allow access to the unstaked-actor-router's peerstore
+//
+// TECHDEBT(#xxx): will become unnecessary after `modules.P2PModule#GetUnstakedPeerstore` is added.`
+// CONSIDERATION: split `PeerstoreProvider` into `StakedPeerstoreProvider` and `UnstakedPeerstoreProvider`.
+// (see: https://github.com/pokt-network/pocket/pull/804#issuecomment-1576531916)
+type unstakedPeerstoreProvider interface {
+	GetUnstakedPeerstore() (typesP2P.Peerstore, error)
+}
+
+type p2pPStoreProviderFactory = modules.Factory[peerstore_provider.PeerstoreProvider]",p2p/providers/peerstore_provider/persistence/p2p.go,2023-06-06 20:46:07+00:00,2023-06-06T20:47:29Z,Why not embed this in the struct as well?,,,,,27,RIGHT,27,,line,https://api.github.com/repos/pokt-network/pocket/pulls/804,pokt-network/pocket,9cb0ee93d1dc34449b90a9c8487366a3a2abbe38
https://api.github.com/repos/pokt-network/pocket/pulls/804,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1220331980,Olshansk,8d1f62a44eb25be452aea76ea5ca5bfcbff5a21c,2e4d60de826d651aa7d182e913300f4c16a09871,"@@ -0,0 +1,72 @@
+package persistence
+
+import (
+	""fmt""
+
+	""github.com/pokt-network/pocket/p2p/providers/peerstore_provider""
+	typesP2P ""github.com/pokt-network/pocket/p2p/types""
+	""github.com/pokt-network/pocket/shared/modules""
+	""github.com/pokt-network/pocket/shared/modules/base_modules""
+)
+
+var (
+	_ peerstore_provider.PeerstoreProvider = &p2pPeerstoreProvider{}
+	_ p2pPStoreProviderFactory             = &p2pPeerstoreProvider{}
+)
+
+// unstakedPeerstoreProvider is an interface which the p2p module supports in
+// order to allow access to the unstaked-actor-router's peerstore
+//
+// TECHDEBT(#xxx): will become unnecessary after `modules.P2PModule#GetUnstakedPeerstore` is added.`
+// CONSIDERATION: split `PeerstoreProvider` into `StakedPeerstoreProvider` and `UnstakedPeerstoreProvider`.
+// (see: https://github.com/pokt-network/pocket/pull/804#issuecomment-1576531916)
+type unstakedPeerstoreProvider interface {
+	GetUnstakedPeerstore() (typesP2P.Peerstore, error)
+}
+
+type p2pPStoreProviderFactory = modules.Factory[peerstore_provider.PeerstoreProvider]
+
+type p2pPeerstoreProvider struct {
+	base_modules.IntegratableModule
+	persistencePeerstoreProvider
+
+	p2pModule modules.P2PModule
+}
+
+func NewP2PPeerstoreProvider(",p2p/providers/peerstore_provider/persistence/p2p.go,2023-06-06 20:46:57+00:00,2023-06-06T20:47:29Z,"Optional NIT: Personally, I think the multilined method header here makes it harder to read (given only one parameter), but it's such a subjective preference feel free to ignore.",,,,,36,RIGHT,36,,line,https://api.github.com/repos/pokt-network/pocket/pulls/804,pokt-network/pocket,9cb0ee93d1dc34449b90a9c8487366a3a2abbe38
https://api.github.com/repos/pokt-network/pocket/pulls/804,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1220332470,Olshansk,8d1f62a44eb25be452aea76ea5ca5bfcbff5a21c,2e4d60de826d651aa7d182e913300f4c16a09871,"@@ -0,0 +1,72 @@
+package persistence
+
+import (
+	""fmt""
+
+	""github.com/pokt-network/pocket/p2p/providers/peerstore_provider""
+	typesP2P ""github.com/pokt-network/pocket/p2p/types""
+	""github.com/pokt-network/pocket/shared/modules""
+	""github.com/pokt-network/pocket/shared/modules/base_modules""
+)
+
+var (
+	_ peerstore_provider.PeerstoreProvider = &p2pPeerstoreProvider{}
+	_ p2pPStoreProviderFactory             = &p2pPeerstoreProvider{}
+)
+
+// unstakedPeerstoreProvider is an interface which the p2p module supports in
+// order to allow access to the unstaked-actor-router's peerstore
+//
+// TECHDEBT(#xxx): will become unnecessary after `modules.P2PModule#GetUnstakedPeerstore` is added.`
+// CONSIDERATION: split `PeerstoreProvider` into `StakedPeerstoreProvider` and `UnstakedPeerstoreProvider`.
+// (see: https://github.com/pokt-network/pocket/pull/804#issuecomment-1576531916)
+type unstakedPeerstoreProvider interface {
+	GetUnstakedPeerstore() (typesP2P.Peerstore, error)
+}
+
+type p2pPStoreProviderFactory = modules.Factory[peerstore_provider.PeerstoreProvider]
+
+type p2pPeerstoreProvider struct {
+	base_modules.IntegratableModule
+	persistencePeerstoreProvider
+
+	p2pModule modules.P2PModule
+}
+
+func NewP2PPeerstoreProvider(
+	bus modules.Bus,
+) (peerstore_provider.PeerstoreProvider, error) {
+	return new(p2pPeerstoreProvider).Create(bus)
+}
+
+func (*p2pPeerstoreProvider) Create(
+	bus modules.Bus,
+) (peerstore_provider.PeerstoreProvider, error) {
+	if bus == nil {
+		return nil, fmt.Errorf(""bus is required"")
+	}
+
+	p2pModule := bus.GetP2PModule()
+	if p2pModule == nil {
+		return nil, fmt.Errorf(""p2p module is not registered to bus and is required"")
+	}
+
+	p2pPSP := &p2pPeerstoreProvider{
+		IntegratableModule: *base_modules.NewIntegratableModule(bus),
+		p2pModule:          p2pModule,",p2p/providers/peerstore_provider/persistence/p2p.go,2023-06-06 20:47:22+00:00,2023-06-06T20:47:29Z,Note above: I don't think we should be doing this.,,,,,56,RIGHT,56,,line,https://api.github.com/repos/pokt-network/pocket/pulls/804,pokt-network/pocket,9cb0ee93d1dc34449b90a9c8487366a3a2abbe38
https://api.github.com/repos/pokt-network/pocket/pulls/804,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1223398685,Olshansk,2489b92e15c0544d21f2b89b8745f85e6cb60c8d,2e4d60de826d651aa7d182e913300f4c16a09871,"@@ -37,6 +38,8 @@ type rpcPeerstoreProvider struct {
 	rpcClient *rpc.ClientWithResponses
 }
 
+// TECHDEBT(#810): refactor to be consistent with `persistencePeerstoreProvider`
+// (i.e. `NewRPCPeerstoreProvider` calls `rpcPeerstoreProvider#Create()`.",p2p/providers/peerstore_provider/rpc/provider.go,2023-06-08 18:16:07+00:00,2023-06-08T18:27:18Z,"Given that we have `func Create` in our factory functions, I think all `func New` should be deprecated & removed.",,,,,42,RIGHT,13,,line,https://api.github.com/repos/pokt-network/pocket/pulls/804,pokt-network/pocket,9cb0ee93d1dc34449b90a9c8487366a3a2abbe38
https://api.github.com/repos/pokt-network/pocket/pulls/804,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1223400571,Olshansk,2489b92e15c0544d21f2b89b8745f85e6cb60c8d,2e4d60de826d651aa7d182e913300f4c16a09871,"@@ -0,0 +1,59 @@
+package persistence",p2p/providers/peerstore_provider/persistence/provider.go,2023-06-08 18:17:33+00:00,2023-06-08T18:27:18Z,Please try to do `mv` in the future when possible. Seeing a file deleted and a new file created requires the reviewer to identify what the diff was or simply review all the business logic from scratch which takes a non-trivial amount of effort.,,,,,1,RIGHT,1,,line,https://api.github.com/repos/pokt-network/pocket/pulls/804,pokt-network/pocket,9cb0ee93d1dc34449b90a9c8487366a3a2abbe38
https://api.github.com/repos/pokt-network/pocket/pulls/804,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1223400826,Olshansk,2489b92e15c0544d21f2b89b8745f85e6cb60c8d,2e4d60de826d651aa7d182e913300f4c16a09871,"@@ -0,0 +1,59 @@
+package persistence
+
+import (
+	""github.com/pokt-network/pocket/p2p/providers/peerstore_provider""
+	typesP2P ""github.com/pokt-network/pocket/p2p/types""
+	""github.com/pokt-network/pocket/shared/modules""
+	""github.com/pokt-network/pocket/shared/modules/base_modules""
+)
+
+var (
+	_ peerstore_provider.PeerstoreProvider = &persistencePeerstoreProvider{}
+	_ persistencePStoreProviderFactory     = &persistencePeerstoreProvider{}
+)
+
+type persistencePStoreProviderOption func(*persistencePeerstoreProvider)
+type persistencePStoreProviderFactory = modules.FactoryWithOptions[peerstore_provider.PeerstoreProvider, persistencePStoreProviderOption]
+type persistencePeerstoreProvider struct {
+	base_modules.IntegratableModule
+}
+
+func NewPersistencePeerstoreProvider(bus modules.Bus, options ...persistencePStoreProviderOption) (peerstore_provider.PeerstoreProvider, error) {",p2p/providers/peerstore_provider/persistence/provider.go,2023-06-08 18:17:54+00:00,2023-06-08T18:27:18Z,Add a TECHDEBT comment to refactor/simplify this linking to the new github issue,,,,,21,RIGHT,21,,line,https://api.github.com/repos/pokt-network/pocket/pulls/804,pokt-network/pocket,9cb0ee93d1dc34449b90a9c8487366a3a2abbe38
https://api.github.com/repos/pokt-network/pocket/pulls/804,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1223401547,Olshansk,2489b92e15c0544d21f2b89b8745f85e6cb60c8d,2e4d60de826d651aa7d182e913300f4c16a09871,"@@ -0,0 +1,59 @@
+package persistence
+
+import (
+	""github.com/pokt-network/pocket/p2p/providers/peerstore_provider""
+	typesP2P ""github.com/pokt-network/pocket/p2p/types""
+	""github.com/pokt-network/pocket/shared/modules""
+	""github.com/pokt-network/pocket/shared/modules/base_modules""
+)
+
+var (
+	_ peerstore_provider.PeerstoreProvider = &persistencePeerstoreProvider{}
+	_ persistencePStoreProviderFactory     = &persistencePeerstoreProvider{}
+)
+
+type persistencePStoreProviderOption func(*persistencePeerstoreProvider)
+type persistencePStoreProviderFactory = modules.FactoryWithOptions[peerstore_provider.PeerstoreProvider, persistencePStoreProviderOption]
+type persistencePeerstoreProvider struct {
+	base_modules.IntegratableModule
+}
+
+func NewPersistencePeerstoreProvider(bus modules.Bus, options ...persistencePStoreProviderOption) (peerstore_provider.PeerstoreProvider, error) {
+	return new(persistencePeerstoreProvider).Create(bus, options...)
+}
+
+func (*persistencePeerstoreProvider) Create(bus modules.Bus, options ...persistencePStoreProviderOption) (peerstore_provider.PeerstoreProvider, error) {
+	pabp := &persistencePeerstoreProvider{
+		IntegratableModule: *base_modules.NewIntegratableModule(bus),
+	}
+
+	for _, o := range options {
+		o(pabp)
+	}
+
+	return pabp, nil
+}
+
+func (*persistencePeerstoreProvider) GetModuleName() string {
+	return peerstore_provider.ModuleName
+}
+
+// GetStakedPeerstoreAtHeight implements the respective `PeerstoreProvider` interface method.
+func (persistencePSP *persistencePeerstoreProvider) GetStakedPeerstoreAtHeight(height uint64) (typesP2P.Peerstore, error) {
+	readCtx, err := persistencePSP.GetBus().GetPersistenceModule().NewReadContext(int64(height))
+	if err != nil {
+		return nil, err
+	}
+	defer readCtx.Release()
+
+	validators, err := readCtx.GetAllValidators(int64(height))",p2p/providers/peerstore_provider/persistence/provider.go,2023-06-08 18:18:42+00:00,2023-06-08T18:27:18Z,"Add a TODO that this should extend to more than just validators to all staked actors.

We might even be able to do it now given all the recent changes?",,,,52.0,49,RIGHT,49,64.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/804,pokt-network/pocket,9cb0ee93d1dc34449b90a9c8487366a3a2abbe38
https://api.github.com/repos/pokt-network/pocket/pulls/804,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1223402155,Olshansk,2489b92e15c0544d21f2b89b8745f85e6cb60c8d,2e4d60de826d651aa7d182e913300f4c16a09871,"@@ -51,10 +54,13 @@ func NewRPCPeerstoreProvider(options ...modules.ModuleOption) *rpcPeerstoreProvi
 	return rabp
 }
 
+// TECHDEBT(#810): remove as it should no longer be needed.",p2p/providers/peerstore_provider/rpc/provider.go,2023-06-08 18:19:24+00:00,2023-06-08T18:27:18Z,See my comment above. Let's keep it one thread so won't leave any more comments on this topic.,,,,,57,RIGHT,21,,line,https://api.github.com/repos/pokt-network/pocket/pulls/804,pokt-network/pocket,9cb0ee93d1dc34449b90a9c8487366a3a2abbe38
https://api.github.com/repos/pokt-network/pocket/pulls/804,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1227053392,Olshansk,22ff0fd95050cedcd9fa72101dceb73633ab651f,2e4d60de826d651aa7d182e913300f4c16a09871,"@@ -0,0 +1,12 @@
+package testutil
+
+// Concatenate appends the contents of multiple slices of any type (T) into a
+// single slice of type T.
+func Concatenate[T any](tt ...[]T) []T {
+	var result []T",internal/testutil/slice.go,2023-06-12 18:02:22+00:00,2023-06-12T18:02:22Z,Optional NIT: Could just use a named return value here but I don't think we really ever settled on a pattern - it would just save a single line of code.,,,,,6,RIGHT,6,,line,https://api.github.com/repos/pokt-network/pocket/pulls/804,pokt-network/pocket,9cb0ee93d1dc34449b90a9c8487366a3a2abbe38
https://api.github.com/repos/pokt-network/pocket/pulls/804,https://api.github.com/repos/pokt-network/pocket/pulls/comments/1227056449,Olshansk,22ff0fd95050cedcd9fa72101dceb73633ab651f,2e4d60de826d651aa7d182e913300f4c16a09871,"@@ -3,19 +3,28 @@ package persistence
 import (
 	""github.com/pokt-network/pocket/p2p/providers/peerstore_provider""
 	typesP2P ""github.com/pokt-network/pocket/p2p/types""
-	""github.com/pokt-network/pocket/runtime/configs""
 	""github.com/pokt-network/pocket/shared/modules""
 	""github.com/pokt-network/pocket/shared/modules/base_modules""
 )
 
-var _ peerstore_provider.PeerstoreProvider = &persistencePeerstoreProvider{}
+var (
+	_ peerstore_provider.PeerstoreProvider = &persistencePeerstoreProvider{}
+	_ persistencePStoreProviderFactory     = &persistencePeerstoreProvider{}
+)
+
+type persistencePStoreProviderOption func(*persistencePeerstoreProvider)",p2p/providers/peerstore_provider/persistence/provider.go,2023-06-12 18:05:57+00:00,2023-06-12T18:05:58Z,"On the topic of ""not being afraid to change everything"", take into consideration that maybe ""providers"" aren't the best approach with our bus based system.

Not making a comment on removing/extending them, but just sharing that it is not set in stone so don't feel constrained.",,,,15.0,15,RIGHT,15,15.0,line,https://api.github.com/repos/pokt-network/pocket/pulls/804,pokt-network/pocket,9cb0ee93d1dc34449b90a9c8487366a3a2abbe38
